def _get_child_candidates(self, distance, min_dist, max_dist): if self._leftchild and distance - max_dist < self._median: yield self._leftchild if self._rightchild and distance + max_dist >= self._median: yield self._rightchild
result, candidates = [], [self] while candidates: node = candidates.pop() distance = node._get_dist(obj) if distance <= max_dist and distance >= min_dist: result.extend(node._values) candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) return result
>>> mylist = [1, 2, 3] >>> for i in mylist: ... print(i) 1 2 3
>>> mylist = [x*x for x in range(3)] >>> for i in mylist: ... print(i) 0 1 4
>>> mygenerator = (x*x for x in range(3)) >>> for i in mygenerator: ... print(i) 0 1 4
>>> def createGenerator(): ... mylist = range(3) ... for i in mylist: ... yield i*i ... >>> mygenerator = createGenerator() >>> print(mygenerator) <generator object createGenerator at 0xb7555c34> >>> for i in mygenerator: ... print(i) 0 1 4
def _get_child_candidates(self, distance, min_dist, max_dist): if self._leftchild and distance - max_dist < self._median: yield self._leftchild if self._rightchild and distance + max_dist >= self._median: yield self._rightchild
result, candidates = list(), [self] while candidates: node = candidates.pop() distance = node._get_dist(obj) if distance <= max_dist and distance >= min_dist: result.extend(node._values) candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) return result
>>> a = [1, 2] >>> b = [3, 4] >>> a.extend(b) >>> print(a) [1, 2, 3, 4]
>>> class Bank(): ... crisis = False ... def create_atm(self): ... while not self.crisis: ... yield "$100" >>> hsbc = Bank() >>> corner_street_atm = hsbc.create_atm() >>> print(corner_street_atm.next()) $100 >>> print(corner_street_atm.next()) $100 >>> print([corner_street_atm.next() for cash in range(5)]) [ >>> hsbc.crisis = True >>> print(corner_street_atm.next()) <type >>> wall_street_atm = hsbc.create_atm() >>> print(wall_street_atm.next()) <type >>> hsbc.crisis = False >>> print(corner_street_atm.next()) <type >>> brand_new_atm = hsbc.create_atm() >>> for cash in brand_new_atm: ... print cash $100 $100 $100 $100 $100 $100 $100 $100 $100 ...
>>> horses = [1, 2, 3, 4] >>> races = itertools.permutations(horses) >>> print(races) <itertools.permutations object at 0xb754f1dc> >>> print(list(itertools.permutations(horses))) [(1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), (1, 3, 4, 2), (1, 4, 2, 3), (1, 4, 3, 2), (2, 1, 3, 4), (2, 1, 4, 3), (2, 3, 1, 4), (2, 3, 4, 1), (2, 4, 1, 3), (2, 4, 3, 1), (3, 1, 2, 4), (3, 1, 4, 2), (3, 2, 1, 4), (3, 2, 4, 1), (3, 4, 1, 2), (3, 4, 2, 1), (4, 1, 2, 3), (4, 1, 3, 2), (4, 2, 1, 3), (4, 2, 3, 1), (4, 3, 1, 2), (4, 3, 2, 1)]
def f123(): yield 1 yield 2 yield 3 for item in f123(): print item
def some_function(): for i in xrange(4): yield i for i in some_function(): print i
class it: def __init__(self): self.count = -1 def __iter__(self): return self def next(self): self.count += 1 if self.count < 4: return self.count else: raise StopIteration def some_func(): return it() for i in some_func(): print i
iterator = some_func() try: while 1: print iterator.next() except StopIteration: pass
generator = myYieldingFunction(...) x = list(generator) generator v [x[0], ..., ???] generator v [x[0], x[1], ..., ???] generator v [x[0], x[1], x[2], ..., ???] StopIteration exception [x[0], x[1], x[2]] done list==[x[0], x[1], x[2]]
def makeRange(n): i = 0 while i < n: yield i i += 1 >>> makeRange(5) <generator object makeRange at 0x19e4aa0>
def makeRange(n): TO_RETURN = [] i = 0 while i < n: TO_RETURN += [i] i += 1 return TO_RETURN >>> makeRange(5) [0, 1, 2, 3, 4]
>>> [x+10 for x in makeRange(5)] [10, 11, 12, 13, 14]
>>> x=iter(range(5)) >>> next(x) 0 >>> next(x) 1 >>> next(x) 2 >>> next(x) 3 >>> next(x) 4 >>> next(x) Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration
> x = myRange(5) > list(x) [0, 1, 2, 3, 4] > list(x) []
>>> def func(): ... yield ... yield ... >>> type(func) <type >>> gen = func() >>> type(gen) <type >>> hasattr(gen, True >>> hasattr(gen, True
>>> import collections, types >>> issubclass(types.GeneratorType, collections.Iterator) True
>>> isinstance(gen, types.GeneratorType) True >>> isinstance(gen, collections.Iterator) True
def func(an_iterable): for item in an_iterable: yield item
def bank_account(deposited, interest_rate): while True: calculated_interest = interest_rate * deposited received = yield calculated_interest if received: deposited += received >>> my_account = bank_account(1000, .05)
>>> first_year_interest = next(my_account) >>> first_year_interest 50.0
>>> next_year_interest = my_account.send(first_year_interest + 1000) >>> next_year_interest 102.5
def money_manager(expected_rate): under_management = yield while True: try: additional_investment = yield expected_rate * under_management if additional_investment: under_management += additional_investment except GeneratorExit: finally: def investment_account(deposited, manager): next(manager) manager.send(deposited) while True: try: yield from manager except GeneratorExit: return manager.close()
>>> my_manager = money_manager(.06) >>> my_account = investment_account(1000, my_manager) >>> first_year_return = next(my_account) >>> first_year_return 60.0 >>> next_year_return = my_account.send(first_year_return + 1000) >>> next_year_return 123.6
>>> import sys >>> try: ... raise ValueError ... except: ... my_manager.throw(*sys.exc_info()) ... Traceback (most recent call last): File "<stdin>", line 4, in <module> File "<stdin>", line 2, in <module> ValueError
expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) | ( ... yield_expr: yield_arg:
def fib(): last, cur = 0, 1 while True: yield cur last, cur = cur, last + cur
for f in fib(): if some_condition: break coolfuncs(f);
>>> def f(): ... yield 1 ... yield 2 ... yield 3 ... >>> g = f() >>> for i in g: ... print i ... 1 2 3 >>> for i in g: ... print i ... >>>
def square_list(n): the_list = [] for x in range(n): y = x * x the_list.append(y) return the_list
def square_yield(n): for x in range(n): y = x * x yield y
>>> for square in square_list(4): ... print(square) ... 0 1 4 9 >>> for square in square_yield(4): ... print(square) ... 0 1 4 9
>>> def squares_all_of_them(): ... x = 0 ... while True: ... yield x * x ... x += 1 ... >>> squares = squares_all_of_them() >>> for _ in range(4): ... print(next(squares)) ... 0 1 4 9
def get_odd_numbers(i): return range(1, i, 2) def yield_odd_numbers(i): for x in range(1, i, 2): yield x foo = get_odd_numbers(10) bar = yield_odd_numbers(10) foo [1, 3, 5, 7, 9] bar <generator object yield_odd_numbers at 0x1029c6f50> bar.next() 1 bar.next() 3 bar.next() 5
def save_file(filename): def write_file_continuation(): write_stuff_to_file(filename) check_if_file_exists_and_user_wants_to_overwrite(write_file_continuation)
class Generator(): def __init__(self,iterable,generatorfun): self.next_continuation = lambda:generatorfun(iterable) def next(self): value, next_continuation = self.next_continuation() self.next_continuation = next_continuation return value
def generatorfun(iterable): if len(iterable) == 0: raise StopIteration else: return (iterable[0], lambda:generatorfun(iterable[1:]))
>>> def coroutine(): ... i = -1 ... while True: ... i += 1 ... val = (yield i) ... print("Received %s" % val) ... >>> sequence = coroutine() >>> sequence.next() 0 >>> sequence.next() Received None 1 >>> sequence.send( Received hello 2 >>> sequence.close()
async def new_coroutine(data): ... await blocking_action()
from itertools import islice def fib_gen(): a, b = 1, 1 while True: yield a a, b = b, a + b assert [1, 1, 2, 3, 5] == list(islice(fib_gen(), 5))
def ftake(fnext, last): return [fnext() for _ in xrange(last)] def fib_gen2(): def _(): _.a, _.b = _.b, _.a + _.b return _.a _.a, _.b = 0, 1 return _ assert [1,1,2,3,5] == ftake(fib_gen2(), 5)
class fib_gen3: def __init__(self): self.a, self.b = 1, 1 def __call__(self): r = self.a self.a, self.b = self.b, self.a + self.b return r assert [1,1,2,3,5] == ftake(fib_gen3(), 5)
In [10]: def num_list(n): ...: for i in range(n): ...: yield i ...: In [11]: num_list(3) Out[11]: <generator object num_list at 0x10327c990> In [12]: list(num_list(3)) Out[12]: [0, 1, 2]
In [15]: def num_list(n): ...: result = [] ...: for i in range(n): ...: result.append(i) ...: return result In [16]: num_list(3) Out[16]: [0, 1, 2]
Welcome to Racket v6.5.0.3. -> (define gen (lambda (l) (define yield (lambda () (if (null? l) (let ((v (car l))) (set! l (cdr l)) v)))) (lambda(m) (case m ( ( (set! l data) -> (define stream (gen -> (stream 1 -> (stream 2 -> (stream 3 -> (stream -> ((stream -> (stream -> (stream -> (stream -> (stream ->
def isPrimeNumber(n): print "isPrimeNumber({}) call".format(n) if n==1: return False for x in range(2,n): if n % x == 0: return False return True def primes (n=1): while(True): print "loop step ---------------- {}".format(n) if isPrimeNumber(n): yield n n += 1 for n in primes(): if n> 10:break print "wiriting result {}".format(n)
loop step ---------------- 1 isPrimeNumber(1) call loop step ---------------- 2 isPrimeNumber(2) call loop step ---------------- 3 isPrimeNumber(3) call wiriting result 3 loop step ---------------- 4 isPrimeNumber(4) call loop step ---------------- 5 isPrimeNumber(5) call wiriting result 5 loop step ---------------- 6 isPrimeNumber(6) call loop step ---------------- 7 isPrimeNumber(7) call wiriting result 7 loop step ---------------- 8 isPrimeNumber(8) call loop step ---------------- 9 isPrimeNumber(9) call loop step ---------------- 10 isPrimeNumber(10) call loop step ---------------- 11 isPrimeNumber(11) call
def normalFunction(): return if False: pass def yielderFunction(): return if False: yield 12
>>> yielderFunction() <generator object yielderFunction at 0x07742D28>
def getNextLines(): while con.isOpen(): yield con.read()
def simpleYield(): yield "first time" yield "second time" yield "third time" yield "Now some useful value {}".format(12) for i in simpleYield(): print i
"first time" "second time" "third time" "Now some useful value 12"
def simple_generator(): yield yield yield for i in simple_generator(): print i
def myRangeNaive(i): n = 0 range = [] while n < i: range.append(n) n = n + 1 return range
def myRangeSmart(i): n = 0 while n < i: yield n n = n + 1 return for i in myRangeSmart(10): print i
import random def return_dates(): dates = [] for i in range(5): date = random.choice(["1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th"]) dates.append(date) return dates
def yield_dates(): for i in range(5): date = random.choice(["1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th"]) yield date
dates_list = return_dates() print(dates_list) for i in dates_list: print(i) dates_generator = yield_dates() print(dates_generator) for i in dates_generator: print(i)
def fib(limit=50): a, b = 0, 1 for i in range(limit): yield b a, b = b, a+b
>>> g = fib() >>> next(g) 1 >>> next(g) 1 >>> next(g) 2 >>> next(g) 3 >>> next(g) 5
results = [] for i in fib(30): results.append(i) results = list(fib(30))
def yielder(value): while 1: print("I print("Then I yield value print("Let
def f123(): for _ in range(4): yield 1 yield 2 for i in f123(): print i
def make_hook(f): f.is_hook = 1 return f class MyType(type): def __new__(mcls, name, bases, attrs): if name.startswith( return None newattrs = {} for attrname, attrvalue in attrs.iteritems(): if getattr(attrvalue, newattrs[ else: newattrs[attrname] = attrvalue return super(MyType, mcls).__new__(mcls, name, bases, newattrs) def __init__(self, name, bases, attrs): super(MyType, self).__init__(name, bases, attrs) print "Would register class %s now." % self def __add__(self, other): class AutoClass(self, other): pass return AutoClass def unregister(self): print "Would unregister class %s now." % self class MyObject: __metaclass__ = MyType class NoneSample(MyObject): pass print type(NoneSample), repr(NoneSample) class Example(MyObject): def __init__(self, value): self.value = value @make_hook def add(self, other): return self.__class__(self.value + other.value) Example.unregister() inst = Example(10) print inst + inst class Sibling(MyObject): pass ExampleSibling = Example + Sibling print ExampleSibling print ExampleSibling.__mro__
>>> class ObjectCreator(object): ... pass ... >>> my_object = ObjectCreator() >>> print(my_object) <__main__.ObjectCreator object at 0x8974f2c>
>>> print(ObjectCreator) <class >>> def echo(o): ... print(o) ... >>> echo(ObjectCreator) <class >>> print(hasattr(ObjectCreator, False >>> ObjectCreator.new_attribute = >>> print(hasattr(ObjectCreator, True >>> print(ObjectCreator.new_attribute) foo >>> ObjectCreatorMirror = ObjectCreator >>> print(ObjectCreatorMirror.new_attribute) foo >>> print(ObjectCreatorMirror()) <__main__.ObjectCreator object at 0x8997b4c>
>>> def choose_class(name): ... if name == ... class Foo(object): ... pass ... return Foo ... else: ... class Bar(object): ... pass ... return Bar ... >>> MyClass = choose_class( >>> print(MyClass) <class >>> print(MyClass()) <__main__.Foo object at 0x89c6d4c>
>>> print(type(1)) <type >>> print(type("1")) <type >>> print(type(ObjectCreator)) <type >>> print(type(ObjectCreator())) <class
type(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values)
>>> MyShinyClass = type( >>> print(MyShinyClass) <class >>> print(MyShinyClass()) <__main__.MyShinyClass object at 0x8997cec>
>>> print(Foo) <class >>> print(Foo.bar) True >>> f = Foo() >>> print(f) <__main__.Foo object at 0x8a9b84c> >>> print(f.bar) True
>>> FooChild = type( >>> print(FooChild) <class >>> print(FooChild.bar) True
>>> def echo_bar(self): ... print(self.bar) ... >>> FooChild = type( >>> hasattr(Foo, False >>> hasattr(FooChild, True >>> my_foo = FooChild() >>> my_foo.echo_bar() True
>>> def echo_bar_more(self): ... print( ... >>> FooChild.echo_bar_more = echo_bar_more >>> hasattr(FooChild, True
>>> age = 35 >>> age.__class__ <type >>> name = >>> name.__class__ <type >>> def foo(): pass >>> foo.__class__ <type >>> class Bar(object): pass >>> b = Bar() >>> b.__class__ <class
>>> age.__class__.__class__ <type >>> name.__class__.__class__ <type >>> foo.__class__.__class__ <type >>> b.__class__.__class__ <type
class Foo(object): __metaclass__ = something... [...]
class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2): ...
def upper_attr(future_class_name, future_class_parents, future_class_attr): uppercase_attr = {} for name, val in future_class_attr.items(): if not name.startswith( uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type(future_class_name, future_class_parents, uppercase_attr) __metaclass__ = upper_attr class Foo(): bar = print(hasattr(Foo, print(hasattr(Foo, f = Foo() print(f.BAR)
class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = {} for name, val in future_class_attr.items(): if not name.startswith( uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type(future_class_name, future_class_parents, uppercase_attr)
class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = {} for name, val in future_class_attr.items(): if not name.startswith( uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)
class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = {} for name, val in dct.items(): if not name.startswith( uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type.__new__(cls, clsname, bases, uppercase_attr)
class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = {} for name, val in dct.items(): if not name.startswith( uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr)
class Foo(object, metaclass=Thing, kwarg1=value1): ...
class Thing(type): def __new__(class, clsname, bases, dct, kwargs1=default): ...
class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField()
class ThisIsTheName(Bases, Are, Here): All_the_code_here def doesIs(create, a): dict
def test_metaclass(name, bases, dict): print print print return "yellow" class TestName(object, None, int, 1): __metaclass__ = test_metaclass foo = 1 def baz(self, arr): pass print The Class Name is TestName The Class Bases are (<type The dict has 4 elems, the keys are [ TestName =
def init_attributes(name, bases, dict): if for attr in dict[ dict[attr] = None return type(name, bases, dict) class Initialised(object): __metaclass__ = init_attributes attributes = [ print foo => None
class MetaSingleton(type): instance = None def __call__(cls, *args, **kw): if cls.instance is None: cls.instance = super(MetaSingleton, cls).__call__(*args, **kw) return cls.instance class Foo(object): __metaclass__ = MetaSingleton a = Foo() b = Foo() assert a is b
class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30)
class MyMeta(type): counter = 0 def __init__(cls, name, bases, dic): type.__init__(cls, name, bases, dic) cls._order = MyMeta.counter MyMeta.counter += 1 class MyType(object): __metaclass__ = MyMeta class MyType(metaclass=MyMeta): pass
>>> type(object) == type True >>> object.__class__ <class
>>> Foo <class >>> isinstance(Foo, type), isinstance(Foo, object) (True, True)
name = bases = (object,) namespace = { Foo = type(name, bases, namespace)
class Type(type): def __repr__(cls): """ >>> Baz Type( >>> eval(repr(Baz)) Type( """ metaname = type(cls).__name__ name = cls.__name__ parents = if parents: parents += namespace = (repr(k), repr(v) if not isinstance(v, type) else v.__name__)) for k, v in cls.__dict__.items()) return def __eq__(cls, other): """ >>> Baz == eval(repr(Baz)) True """ return (cls.__name__, cls.__bases__, cls.__dict__) == ( other.__name__, other.__bases__, other.__dict__)
>>> class Bar(object): pass >>> Baz = Type( >>> Baz Type(
from collections import OrderedDict class OrderedType(Type): @classmethod def __prepare__(metacls, name, bases, **kwargs): return OrderedDict() def __new__(cls, name, bases, namespace, **kwargs): result = Type.__new__(cls, name, bases, dict(namespace)) result.members = tuple(namespace) return result
class OrderedMethodsObject(object, metaclass=OrderedType): def method1(self): pass def method2(self): pass def method3(self): pass def method4(self): pass
>>> OrderedMethodsObject OrderedType( hodsObject.method3 at 0x0000000002DB02F0>, ict__
class Meta(type): def __prepare__(metaclass, cls, bases): return dict() def __new__(metacls, cls, bases, clsdict): return super().__new__(metacls, cls, bases, clsdict)
class Person: weight = ValidateType( age = ValidateType( name = ValidateType(
class Person(metaclass=Validator): weight = ValidateType(int) age = ValidateType(int) name = ValidateType(str)
class Validator(type): def __new__(metacls, cls, bases, clsdict): for name, attr in clsdict.items(): if isinstance(attr, ValidateType): attr.name = name attr.attr = return super().__new__(metacls, cls, bases, clsdict)
p = Person() p.weight = 9 print(p.weight) p.weight =
9 Traceback (most recent call last): File "simple_meta.py", line 36, in <module> p.weight = File "simple_meta.py", line 24, in __set__ (self.name, self.type, value)) TypeError: weight must be of type(s) <class
class ValidateType: def __init__(self, type): self.name = None self.attr = None self.type = type def __get__(self, inst, cls): if inst is None: return self else: return inst.__dict__[self.attr] def __set__(self, inst, value): if not isinstance(value, self.type): raise TypeError( (self.name, self.type, value)) else: inst.__dict__[self.attr] = value
class SomeClass(object): instance = SomeClass() result = instance(
class SomeClass(object): def __call__(self, foo, bar): return bar + foo
class Meta_1(type): def __call__(cls): print "Meta_1.__call__() before creating an instance of ", cls instance = super(Meta_1, cls).__call__() print "Meta_1.__call__() about to return instance." return instance
class Class_1(object): __metaclass__ = Meta_1 def __new__(cls): print "Class_1.__new__() before creating an instance." instance = super(Class_1, cls).__new__(cls) print "Class_1.__new__() about to return instance." return instance def __init__(self): print "entering Class_1.__init__() for instance initialization." super(Class_1,self).__init__() print "exiting Class_1.__init__()."
class type: def __call__(cls, *args, **kwarg): instance = cls.__new__(cls, *args, **kwargs) instance.__init__(*args, **kwargs) return instance
class Meta_2(type): singletons = {} def __call__(cls, *args, **kwargs): if cls in Meta_2.singletons: print ("{} singleton returning from Meta_2.__call__(), " "skipping creation of new instance.".format(cls)) return Meta_2.singletons[cls] print "Meta_2.__call__() before creating an instance." instance = super(Meta_2, cls).__call__(*args, **kwargs) Meta_2.singletons[cls] = instance print "Meta_2.__call__() returning new instance." return instance class Class_2(object): __metaclass__ = Meta_2 def __new__(cls, *args, **kwargs): print "Class_2.__new__() before creating instance." instance = super(Class_2, cls).__new__(cls) print "Class_2.__new__() returning instance." return instance def __init__(self, *args, **kwargs): print "entering Class_2.__init__() for initialization." super(Class_2, self).__init__() print "exiting Class_2.__init__()."
a = Class_2() b = Class_2() c = Class_2() a is b is c
# # # # # # # def GetGsyncOptionsType(): class GsyncListOptions(object): __initialised = False class GsyncOptionsType(type): def __initialiseClass(cls): if GsyncListOptions._GsyncListOptions__initialised: return from docopt import docopt from libgsync.options import doc from libgsync import __version__ options = docopt( doc.__doc__ % __version__, version = __version__, options_first = True ) paths = options.pop( setattr(cls, "destination_path", paths.pop() if paths else None) setattr(cls, "source_paths", paths) setattr(cls, "options", options) for k, v in options.iteritems(): setattr(cls, k, v) GsyncListOptions._GsyncListOptions__initialised = True def list(cls): return GsyncListOptions def __getattr__(cls, name): cls.__initialiseClass() return getattr(GsyncListOptions, name)[-1] def __setattr__(cls, name, value): import re name = re.sub(r listvalue = [] if isinstance(value, list): if value: listvalue = [] + value else: listvalue = [ None ] else: listvalue = [ value ] type.__setattr__(GsyncListOptions, name, listvalue) import sys module = sys.modules[__name__] del module.__dict__[ return GsyncOptionsType class GsyncOptions(object): __metaclass__ = GetGsyncOptionsType()
>>> class MetaClass(type): ... def __init__(cls, name, bases, attrs): ... print ( ... print ( ... print( ... print( ... for (name, value) in attrs.items(): ... print ( ... >>> class NewClass(object, metaclass=MetaClass): ... get_choch= ... class name: NewClass Bases <class Defining class <class get_choch : __module__ : __qualname__ :
class somemeta(type): __new__(mcs, name, bases, clsdict): """ mcs: is the base metaclass, in this case type. name: name of the new class, as provided by the user. bases: tuple of base classes clsdict: a dictionary containing all methods and attributes defined on class you must return a class object by invoking the __new__ constructor on the base metaclass. ie: return type.__call__(mcs, name, bases, clsdict). in the following case: class foo(baseclass): __metaclass__ = somemeta an_attr = 12 def bar(self): ... @classmethod def foo(cls): ... arguments would be : ( somemeta, "foo", (baseclass, baseofbase,..., object), {"an_attr":12, "bar": <function>, "foo": <bound class method>} you can modify any of these values before passing on to type """ return type.__call__(mcs, name, bases, clsdict) def __init__(self, name, bases, clsdict): """ called after type has been created. unlike in standard classes, __init__ method cannot modify the instance (cls) - and should be used for class validaton. """ pass def __prepare__(): return dict() def mymethod(cls): pass
def func(self, name= print( Hi = type( h = Hi() h.hi() Hi, mike. type(Hi) type type(h) __main__.Hi
class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs[ return type.__new__(cls, name, bases, attrs) class CustomList(list, metaclass=ListMetaclass): pass lst = CustomList() lst.add( lst.add( lst [
class MyClass: __metaclass__ = type print(MyClass.__metaclass__)
class MyMetaClass(type): __metaclass__ = type class MyTestClass: __metaclass__ = MyMetaClass Obj = MyTestClass() print(Obj.__metaclass__) print(MyMetaClass.__metaclass__)
>>> pass if False else x = 3 File "<stdin>", line 1 pass if False else x = 3 ^ SyntaxError: invalid syntax
>>> a = 1 >>> b = 2 >>> 1 if a > b else -1 -1 >>> 1 if a > b else -1 if a < b else 0 -1
def q(cond, on_true, on_false) return {True: on_true, False: on_false}[cond is True]
>>> x = 0 >>> print x == 0 and 0 or 1 1 >>> x = 1 >>> print x == 0 and 0 or 1 1
>>> x = 0 >>> print 0 if x == 0 else 1 0 >>> x = 1 >>> print 0 if x == 0 else 1 1
general syntax : first_expression if bool_expression_is_true else second_expression Example: x= 3 if 3 > 2 else 4
expression1 if expression2 else expression3 if expression4 else expression5
[expression1 if expression2 for element in iterable]
[expression1 for element in iterable if expression2]
a, b, x, y = 1, 2, result = (lambda:y, lambda:x)[a > b]()
a, b = 10, 20 print( (b, a) [a < b] ) print({True: a, False: b} [a < b]) print((lambda: b, lambda: a)[a < b]())
a, b = 10, 20 print ("Both a and b are equal" if a == b else "a is greater than b" if a > b else "b is greater than a")
a, b = 10, 20 if a != b: if a > b: print("a is greater than b") else: print("b is greater than a") else: print("Both a and b are equal")
In [1]: a = 1 if False else 0 In [2]: a Out[2]: 0 In [3]: b = 1 if True else 0 In [4]: b Out[4]: 1
is_fat = True state = "fat" if is_fat else "not fat"
a= input("Enter the First Number ") b= input("Enter the Second Number ") print("A is Bigger") if a>b else print("B is Bigger")
>>> b = (True if 5 > 4 else False) >>> print b True
pressure = 5 if pressure < 20: if pressure < 10: print( else: print( else: print(
def test(myvar=None): print myvar or "no Input" test() test([]) test(False) test( test([ test(True)
from pathlib import Path my_file = Path("/path/to/file") if my_file.is_file():
try: my_abs_path = my_file.resolve(strict=True) except FileNotFoundError: else:
>>> print os.path.isfile("/etc/password.txt") True >>> print os.path.isfile("/etc") False >>> print os.path.isfile("/does/not/exist") False >>> print os.path.exists("/etc/password.txt") True >>> print os.path.exists("/etc") True >>> print os.path.exists("/does/not/exist") False
import os import os.path PATH= if os.path.isfile(PATH) and os.access(PATH, os.R_OK): print "File exists and is readable" else: print "Either the file is missing or not readable"
import os os.path.exists(path) os.path.isfile(path)
def exists(path): try: st = os.stat(path) except os.error: return False return True
def is_file(self): """ Whether this path is a regular file (also True for symlinks pointing to regular files). """ try: return S_ISREG(self.stat().st_mode) except OSError as e: if e.errno not in (ENOENT, ENOTDIR): raise return False
class Swallow: swallowed_exceptions = (FileNotFoundError,) def __enter__(self): print("Entering...") def __exit__(self, exc_type, exc_value, exc_traceback): print("Exiting:", exc_type, exc_value, exc_traceback) return exc_type in Swallow.swallowed_exceptions
import os import stat def isfile_seaman(path): result = False with Swallow(): result = stat.S_ISREG(os.stat(path).st_mode) return result
Python 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32 Type "help", "copyright", "credits" or "license" for more information. >>> import os, ctypes >>> ctypes.CDLL("msvcrt")._waccess(u"C:\\Windows\\System32\\cmd.exe", os.F_OK) 0 >>> ctypes.CDLL("msvcrt")._waccess(u"C:\\Windows\\System32\\___cmd.exe", os.F_OK) -1
Python 3.5.2 (default, Nov 17 2016, 17:05:23) [GCC 5.4.0 20160609] on linux Type "help", "copyright", "credits" or "license" for more information. >>> import os, ctypes >>> ctypes.CDLL("/lib/x86_64-linux-gnu/libc.so.6").access(b"/tmp", os.F_OK) 0 >>> ctypes.CDLL("/lib/x86_64-linux-gnu/libc.so.6").access(b"/tmp1", os.F_OK) -1
(py35x64_test) e:\Work\Dev\StackOverflow\q000082831>"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" -c "import os; print(os.system( 0 (py35x64_test) e:\Work\Dev\StackOverflow\q000082831>"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" -c "import os; print(os.system( 1
[cfati@cfati-ubtu16x64-0:~]> python3 -c "import os; print(os.system( 0 [cfati@cfati-ubtu16x64-0:~]> python3 -c "import os; print(os.system( 512
import os fname = "foo.txt" if os.path.isfile(fname): print("file does exist at this time") else: print("no such file exists at this time")
>>> from pathlib import Path >>> Path( False >>> Path( True >>> Path( False
>>> import os >>> os.path.isfile( False >>> os.path.isfile( True >>> os.path.isfile( False
>>> from pathlib import Path >>> root = Path( >>> root.exists() True
is_file(self) Whether this path is a regular file (also True for symlinks pointing to regular files).
>>> import tempfile >>> file = tempfile.NamedTemporaryFile() >>> filepathobj = Path(file.name) >>> filepathobj.is_file() True >>> filepathobj.exists() True
>>> del file >>> filepathobj.exists() False >>> filepathobj.is_file() False
def is_file(self): """ Whether this path is a regular file (also True for symlinks pointing to regular files). """ try: return S_ISREG(self.stat().st_mode) except OSError as e: if e.errno not in (ENOENT, ENOTDIR): raise return False
from contextlib import suppress from pathlib import Path
>>> with suppress(OSError), Path( ... for line in f: ... print(line) ... >>> >>> with suppress(OSError): ... Path( ... >>>
class suppress(object): def __init__(self, *exceptions): self.exceptions = exceptions def __enter__(self): return self def __exit__(self, exc_type, exc_value, traceback): if exc_type is not None: return issubclass(exc_type, self.exceptions)
from contextlib import contextmanager @contextmanager def suppress(*exceptions): try: yield except exceptions: pass
def isfile(path): try: st = os.stat(path) except os.error: return False return stat.S_ISREG(st.st_mode)
try: with open(path) as f: f.read() except OSError: pass
if os.access("myfile", os.R_OK): with open("myfile") as fp: return fp.read() return "some default data"
try: fp = open("myfile") except IOError as e: if e.errno == errno.EACCES: return "some default data" raise else: with fp: return fp.read()
import os if os.path.exists("C:\..."): print "File found!" else: print "File not found!"
>>> import os >>> path = "path to a word document" >>> os.path.isfile(path) True >>> os.path.splitext(path)[1] == ".docx" True
import pathlib path = pathlib.Path( if path.is_file(): ...
if os.path.isfile(filepath): os.rename(filepath, filepath +
if not os.path.isfile(filepath): f = open(filepath, try: f = open(filepath, except IOError: print
try: with open( except IOError as e: print("({})".format(e))
def File_Existence(filepath): f = open(filepath) return True
def File_Existence(filepath): try: f = open(filepath) except IOError, OSError: return False return True
import os.path >>> os.path.exists("this/is/a/directory") True >>> os.path.exists("this/is/a/file.txt") True >>> os.path.exists("not/a/directory") False
>>> import os >>> os.access("/is/a/file.txt", os.F_OK) True
import pathlib path = pathlib.Path( if path.is_file():
if os.access("myfile", os.R_OK): with open("myfile") as fp: return fp.read()
>>> with open( ... f.write( >>> if not os.path.exists( ... with open( ... f.write("Hello\n") ... else: ... print(
import os os.path.isfile( os.path.isdir( os.path.exists(
if os.path.isfile(path_to_file): try: open(path_to_file) pass except IOError as e: print "Unable to open file"
from contextlib import suppress with suppress(IOError), open( process()
from contextlib import contextmanager @contextmanager def suppress(*exceptions): try: yield except exceptions: pass
import numpy as np np.DataSource().exists("path/to/your/file")
import os.path os.path.isfile(filename) os.path.isfile(dirname)
import os.path os.path.exists(filename) os.path.exists(dirname)
def file_exists(file_path): if not file_path: return False elif not os.path.isfile(file_path): return False else: return True
def file_exists(file_path): if not file_path: return False else: return os.path.isfile(file_path)
def file_exists(file_path): return file_path and os.path.isfile(file_path):
>>> print pox.find.__doc__ find(patterns[,root,recurse,type]); Get path to a file or directory patterns: name or partial name string of items to search for root: path string of top-level directory to search recurse: if True, recurse down from root directory type: item filter; one of {None, file, dir, link, socket, block, char} verbose: if True, be a little verbose about the search On some OS, recursion can be specified by recursion depth (an integer). patterns can be specified with basic pattern matching. Additionally, multiple patterns can be specified by splitting patterns with a For example: >>> find( [ >>> find( [ >>>
>>> import os >>> os.path.exists("C:\\Users\\ True >>> os.path.exists("C:\\Users\\ False
import time, thread def myfunction(string, sleeptime, lock, *args): while True: lock.acquire() time.sleep(sleeptime) lock.release() time.sleep(sleeptime) if __name__ == "__main__": lock = thread.allocate_lock() thread.start_new_thread(myfunction, ("Thread thread.start_new_thread(myfunction, ("Thread
print("before import") import math print("before functionA") def functionA(): print("Function A") print("before functionB") def functionB(): print("Function B {}".format(math.sqrt(100))) print("before __name__ guard") if __name__ == functionA() functionB() print("after __name__ guard")
def functionA(): print("a1") from foo2 import functionB print("a2") functionB() print("a3") def functionB(): print("b") print("t1") if __name__ == "__main__": print("m1") functionA() print("m2") print("t2")
def functionA(): print("a1") from foo3 import functionB print("a2") functionB() print("a3") def functionB(): print("b") print("t1") print("m1") functionA() print("m2") print("t2")
__name__ = "__main__" def bar(): print("bar") print("before __name__ guard") if __name__ == "__main__": bar() print("before __name__ guard")
def func(): print("func() in one.py") print("top-level in one.py") if __name__ == "__main__": print("one.py is being run directly") else: print("one.py is being imported into another module")
import one print("top-level in two.py") one.func() if __name__ == "__main__": print("two.py is being run directly") else: print("two.py is being imported into another module")
top-level in one.py one.py is being imported into another module top-level in two.py func() in one.py two.py is being run directly
print "Hello World from %s!" % __name__ if __name__ == print "Hello World again from %s!" % __name__
$ python b.py Hello World from __main__! Hello World again from __main__!
def main(): setup() foo = do_important() bar = do_even_more_important(foo) for baz in bar: do_super_important(baz) teardown() if __name__ == main()
import ab def main(): print( def x(): print ( x() if __name__ == "__main__": main()
>>> __name__ = >>> if __name__ == ... >>> else: print( ... Horrify >>>
def some_function_for_instance_main(): dosomething() __name__ ==
if __name__ == "__main__": lock = thread.allocate_lock() thread.start_new_thread(myfunction, ("Thread thread.start_new_thread(myfunction, ("Thread
lock = thread.allocate_lock() thread.start_new_thread(myfunction, ("Thread thread.start_new_thread(myfunction, ("Thread
def fib(n): a, b = 0, 1 while b < n: print(b, end= a, b = b, a+b print() if __name__ == "__main__": import sys fib(int(sys.argv[1]))
>>> x = { >>> y = { >>> z = x.update(y) >>> print(z) None >>> x {
def merge_two_dicts(x, y): z = x.copy() z.update(y) return z
def merge_two_dicts(x, y): z = x.copy() z.update(y) return z
def merge_dicts(*dict_args): result = {} for dictionary in dict_args: result.update(dictionary) return result
>>> c = dict(a.items() + b.items()) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unsupported operand type(s) for +:
>>> x = { >>> y = { >>> dict(x.items() | y.items()) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unhashable type:
>>> x = { >>> y = { >>> dict(x.items() | y.items()) {
>>> c = dict(a, **b) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: keyword arguments must be strings
>>> foo(**{( Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: foo() keywords must be strings >>> dict(**{( {(
from copy import deepcopy def dict_of_dicts_merge(x, y): z = {} overlapping_keys = x.keys() & y.keys() for key in overlapping_keys: z[key] = dict_of_dicts_merge(x[key], y[key]) for key in x.keys() - overlapping_keys: z[key] = deepcopy(x[key]) for key in y.keys() - overlapping_keys: z[key] = deepcopy(y[key]) return z
>>> x = { >>> y = { >>> dict_of_dicts_merge(x, y) {
import itertools z = dict(itertools.chain(x.iteritems(), y.iteritems()))
>>> min(timeit.repeat(lambda: merge_two_dicts(x, y))) 0.5726828575134277 >>> min(timeit.repeat(lambda: {k: v for d in (x, y) for k, v in d.items()} )) 1.163769006729126 >>> min(timeit.repeat(lambda: dict(itertools.chain(x.iteritems(), y.iteritems())))) 1.1614501476287842 >>> min(timeit.repeat(lambda: dict((k, v) for d in (x, y) for k, v in d.items()))) 2.2345519065856934
>>> min(timeit.repeat(lambda: {**x, **y})) 0.4094954460160807 >>> min(timeit.repeat(lambda: merge_two_dicts(x, y))) 0.7881555100320838 >>> min(timeit.repeat(lambda: {k: v for d in (x, y) for k, v in d.items()} )) 1.4525277839857154 >>> min(timeit.repeat(lambda: dict(itertools.chain(x.items(), y.items())))) 2.3143140770262107 >>> min(timeit.repeat(lambda: dict((k, v) for d in (x, y) for k, v in d.items()))) 3.2069112799945287
>>> x = { >>> y = { >>> z = dict(x.items() + y.items()) >>> z {
>>> z = dict(list(x.items()) + list(y.items())) >>> z {
>>> timeit.Timer("dict(x, **y)", "x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))").timeit(100000) 15.52571702003479 >>> timeit.Timer("temp = x.copy()\ntemp.update(y)", "x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))").timeit(100000) 15.694622993469238 >>> timeit.Timer("dict(x.items() + y.items())", "x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))").timeit(100000) 41.484580039978027
% python -m timeit -s 100000 loops, best of 3: 5.67 usec per loop % python -m timeit -s 100000 loops, best of 3: 1.53 usec per loop
% python -m timeit -s 1000 loops, best of 3: 260 usec per loop % python -m timeit -s 10000 loops, best of 3: 26.9 usec per loop
from itertools import chain z3 = dict(chain(x.iteritems(), y.iteritems()))
% python -m timeit -s 10000 loops, best of 3: 66 usec per loop
% python -m timeit -s 10000 loops, best of 3: 26.9 usec per loop
def merge(d1, d2, merge_fn=lambda x,y:y): """ Merges two dictionaries, non-destructively, combining values on duplicate keys as defined by the optional merge function. The default behavior replaces the values in d1 with corresponding values in d2. (There is no other generally applicable merge strategy, but often you types in your dicts, so specifying a merge technique can be valuable.) Examples: >>> d1 { >>> merge(d1, d1) { >>> merge(d1, d1, lambda x,y: x+y) { """ result = dict(d1) for k,v in d2.iteritems(): if k in result: result[k] = merge_fn(result[k], v) else: result[k] = v return result
>>> from collections import ChainMap >>> x = { >>> y = { >>> z = ChainMap({}, y, x) >>> for k, v in z.items(): print(k, a --> 1 b --> 10 c --> 11
def deepupdate(original, update): for key, value in original.iteritems(): if key not in update: update[key] = value elif isinstance(value, dict): deepupdate(value, update[key]) return update
pluto_original = { } } pluto_update = { } } print deepupdate(pluto_original, pluto_update)
from itertools import chain x = { y = { dict(chain(x.iteritems(), y.iteritems()))
x = { y = { z = dict(x.items() + y.items()) print z
def dict_merge(a, b): c = a.copy() c.update(b) return c new = dict_merge(old, extras)
x = { y = { z = (lambda a, b: (lambda a_copy: a_copy.update(b) or a_copy)(a.copy()))(x, y) print z { print x {
In [1]: from collections import ChainMap In [2]: from string import ascii_uppercase as up, ascii_lowercase as lo; x = dict(zip(lo, up)); y = dict(zip(up, lo)) In [3]: chainmap_dict = ChainMap(y, x) In [4]: union_dict = dict(x.items() | y.items()) In [5]: timeit for k in union_dict: union_dict[k] 100000 loops, best of 3: 2.15 µs per loop In [6]: timeit for k in chainmap_dict: chainmap_dict[k] 10000 loops, best of 3: 27.1 µs per loop
>>> x = { >>> y = { >>> z = (lambda f=x.copy(): (f.update(y), f)[1])() >>> z {
>>> x = { >>> y = { >>> z = (x.update(y), x)[1] >>> z {
import itertools as it merge = lambda *args: dict(it.chain.from_iterable(it.imap(dict.iteritems, args)))
>>> x = { >>> y = { >>> merge(x, y) { >>> z = { >>> merge(x, y, z) {
def union2(dict1, dict2): return dict(list(dict1.items()) + list(dict2.items()))
def union(*dicts): return dict(itertools.chain.from_iterable(dct.items() for dct in dicts))
import collections a = {1: 1, 2: 2} b = {2: 3, 3: 4} c = {3: 5} r = dict(collections.ChainMap(a, b, c)) print(r)
from itertools import chain print dict(chain(a.iteritems(), b.iteritems()))
def merge(*dicts, **kv): return { k:v for d in list(dicts) + [kv] for k,v in d.items() }
assert (merge({1:11, {1: 99, assert (merge(foo= assert (merge({1:11},{1:99},foo= {1: 99, assert (merge({1:11},{1:99})=={1: 99})
from collections import Counter dict1 = { dict2 = { result = dict(Counter(dict1) + Counter(dict2))
dict1 = { dict2 = { new_dict = {**dict1, **dict2} >>>new_dict {
>>> x = { >>> y = { >>> x, z = dict(x), x.update(y) or x >>> x { >>> y { >>> z {
import timeit n=100000 su = """ x = { y = { """ def timeMerge(f,su,niter): print "{:4f} sec for: {:30s}".format(timeit.Timer(f,setup=su).timeit(n),f) timeMerge("dict(x, **y)",su,n) timeMerge("x.update(y)",su,n) timeMerge("dict(x.items() + y.items())",su,n) timeMerge("for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] ",su,n) x = { y = { for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] print "confirm b elements are added:",x
0.049465 sec for: dict(x, **y) 0.033729 sec for: x.update(y) 0.150380 sec for: dict(x.items() + y.items()) 0.083120 sec for: for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] confirm b elements are added: {
>>> x = { >>> y = { >>> { key: y[key] if key in y else x[key] for key in set(x) + set(y) }
from functools import reduce def merge_dicts(*dicts): return reduce(lambda a, d: a.update(d) or a, dicts, {})
import os file_path = "/my/directory/filename.txt" directory = os.path.dirname(file_path) try: os.stat(directory) except: os.mkdir(directory) f = file(filename)
def ensure_dir(file_path): directory = os.path.dirname(file_path) if not os.path.exists(directory): os.makedirs(directory)
import os if not os.path.exists(directory): os.makedirs(directory)
import os, errno try: os.makedirs(directory) except OSError as e: if e.errno != errno.EEXIST: raise
import os try: os.makedirs(path) except OSError: if not os.path.isdir(path): raise
import distutils.dir_util distutils.dir_util.mkpath(path)
import os import errno def make_sure_path_exists(path): try: os.makedirs(path) except OSError as exception: if exception.errno != errno.EEXIST: raise
>>> os.path.exists( True >>> os.path.exists( True >>> os.path.isdir( False >>> os.path.isdir( False
from pathlib import Path path = Path( path.parent.mkdir(parents=True, exist_ok=True)
filename = "/my/directory/filename.txt" dir = os.path.dirname(filename)
import os filepath = directory = os.path.dirname(filepath)
if not os.path.exists(directory): os.makedirs(directory) f = file(filename)
import errno try: with open(filepath) as my_file: do_stuff(my_file) except IOError as error: if error.errno == errno.ENOENT: print else: raise
import os if not os.path.exists(directory): os.makedirs(directory) with open(filepath, do_stuff(my_file)
import os import errno if not os.path.exists(directory): try: os.makedirs(directory) except OSError as error: if error.errno != errno.EEXIST: raise with open(filepath, do_stuff(my_file)
import os dirname = try: os.makedirs(dirname) except OSError: if os.path.exists(dirname): pass else: raise
import errno try: os.makedirs(d) except OSError as exception: if exception.errno != errno.EEXIST: raise
mkdtemp(suffix= User-callable function to create and return a unique temporary directory. The return value is the pathname of the directory. The directory is readable, writable, and searchable only by the creating user. Caller is responsible for deleting the directory when done with it.
todays_file = directory / str(datetime.datetime.utcnow().date()) if todays_file.exists(): logger.info("todays_file exists: " + str(todays_file)) df = pd.read_json(str(todays_file))
from pathlib import Path path = Path("/my/directory/filename.txt") try: if not path.parent.exists(): path.parent.mkdir(parents=True) except OSError:
try: os.makedirs(path) except OSError as exception: if exception.errno != errno.EEXIST: raise else: print "\nBE CAREFUL! Directory %s already exists." % path
if not os.path.exists(path): os.makedirs(path) else: print "\nBE CAREFUL! Directory %s already exists." % path
from distutils.dir_util import mkpath mkpath("test")
import os import errno def make_sure_path_exists(path): try: os.makedirs(path) except OSError as exception: if exception.errno != errno.EEXIST: raise
from IPython.utils.path import ensure_dir_exists ensure_dir_exists(dir)
import pathlib """ Notes: 1. Include a trailing slash at the end of the directory path ("Method 1," below). 2. If a subdirectory in your intended path matches an existing file with same name, you will get the following error: "NotADirectoryError: [Errno 20] Not a directory:" ... """
import os import errno def make_sure_path_exists(path): try: os.makedirs(path) except OSError as exception: if exception.errno != errno.EEXIST or not os.path.isdir(path): raise
try: os.makedirs(dir_path) except OSError as e: if e.errno != errno.EEXIS: raise
import os def create_dir(directory): if not os.path.exists(directory): print( os.makedirs(directory) create_dir(
if not os.path.isdir(test_img_dir): os.mkdir(str("./"+test_img_dir))
import os if os.path.isfile(filename): print "file exists" else: "Your code here"
s = "This be a string" if s.find("is") == -1: print "No else: print "Found
>>> "King" in "King True >>> "Jon Snow" in "King False
>>> some_string = "valar morghulis" >>> some_string.find("morghulis") 6 >>> some_string.find("dohaeris") -1
class NoisyString(str): def __contains__(self, other): print( return super(NoisyString, self).__contains__(other) ns = NoisyString(
>>> testing if "substring" in "a string with a substring inside" True
>>> 2 >>> 2 >>> -1 >>> Traceback (most recent call last): File "<pyshell ValueError: substring not found
import timeit def in_(s, other): return other in s def contains(s, other): return s.__contains__(other) def find(s, other): return s.find(other) != -1 def index(s, other): try: s.index(other) except ValueError: return False else: return True perf_dict = { }
import commands (st, output) = commands.getstatusoutput( print [f for f in output.split(
"foo" in "foobar" True "foo" in "Foobar" False "foo" in "Foobar".lower() True "foo".capitalize() in "Foobar" True "foo" in ["bar", "foo", "foobar"] True "foo" in ["fo", "o", "foobar"] False
str1 = "This be a string" find_this = "tr" if find_this in str1: print find_this, " is been found in ", str1 else: print find_this, " is not found in ", str1
import operator if not operator.contains(somestring, "blah"): continue
example_string = "This is an example string" substring = "example" print(substring in example_string)
if example_string.find(substring) != -1: print( else: print(
if "insert_char_or_string_here" in "insert_string_to_search_here":
if not "insert_char_or_string_here" in "insert_string_to_search_here":
if "insert_char_or_string_here" not in "insert_string_to_search_here":
import string s = if for split_char in string.punctuation + string.whitespace for word in s.split(split_char)):
"test" in "testtext" True "abc" in "abcdefg" True "abc" in "Abc" False "ABC" in "abc" False "abc" in "def" False "abc" in ["abc", "def", "ghi"] True
"xxabcxx".find("abc") 2 "xxabcxx".find("cde") -1 "xxabcxx".index("abc") 2 "xxabcxx".index("cde") ValueError: substring not found
someString = "Polly is drinking Coca-Cola." "Coca-Cola" in someString "Pepsi" in someString
someString = "Polly is drinking Coca-Cola." someString.find("is") someString.find("Pepsi") someString.find("Polly")
someString = "Polly is drinking Coca-Cola." someString.find("is", 5, 10) someString.find("Polly", 15, 20)
someString = "Polly is drinking Coca-Cola." substring = "drinking" if someString.find(substring) is not -1: print("Cool! Python found the desired substring!") else: print("Python didn
someString = "Polly is drinking Coca-Cola." x = someString.index("drinking") print(x)
>>> to_search_in = "String to search in" >>> to_search = "search" >>> print(to_search in to_search_in) True >>> print(to_search_in.find(to_search)) 10
import operator x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_x = sorted(x.items(), key=operator.itemgetter(1))
import operator x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_x = sorted(x.items(), key=operator.itemgetter(0))
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_by_value = sorted(x.items(), key=lambda kv: kv[1])
from collections import defaultdict d = defaultdict(int) for w in text.split(): d[w] += 1
for w in sorted(d, key=d.get, reverse=True): print w, d[w]
from operator import itemgetter sorted(d.items(), key=itemgetter(1))
>>> d = {"third": 3, "first": 1, "fourth": 4, "second": 2} >>> for k, v in d.items(): ... print "%s: %s" % (k, v) ... second: 2 fourth: 4 third: 3 first: 1 >>> d {
>>> from collections import OrderedDict >>> d_sorted_by_value = OrderedDict(sorted(d.items(), key=lambda x: x[1]))
>>> for k, v in d_sorted_by_value.items(): ... print "%s: %s" % (k, v) ... first: 1 second: 2 third: 3 fourth: 4 >>> d_sorted_by_value OrderedDict([(
from operator import itemgetter from collections import OrderedDict x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_x = OrderedDict(sorted(x.items(), key=itemgetter(1)))
d = { OrderedDict(sorted(d.items(), key=lambda t: t[1]))
import collections Player = collections.namedtuple( d = {
best = sorted([Player(v,k) for (k,v) in d.items()], reverse=True)
SELECT a_key, a_value FROM a_table ORDER BY a_value;
k_seq = ( v_seq = (0, 1, 42) ordered_map = dict(zip(k_seq, v_seq))
sred = sorted(e.items(), key=lambda value: value[1])
WantedOutput = sorted(MyDict, key=lambda x : MyDict[x])
from collections import OrderedDict d = { OrderedDict(sorted(d.items(), key=lambda t: t[0])) OrderedDict([( OrderedDict(sorted(d.items(), key=lambda t: t[1])) OrderedDict([(
import operator origin_list = [ {"name": "foo", "rank": 0, "rofl": 20000}, {"name": "Silly", "rank": 15, "rofl": 1000}, {"name": "Baa", "rank": 300, "rofl": 20}, {"name": "Zoo", "rank": 10, "rofl": 200}, {"name": "Penguin", "rank": -1, "rofl": 10000} ] print ">> Original >>" for foo in origin_list: print foo print "\n>> Rofl sort >>" for foo in sorted(origin_list, key=operator.itemgetter("rofl")): print foo print "\n>> Rank sort >>" for foo in sorted(origin_list, key=operator.itemgetter("rank")): print foo
from collections import Counter x={ c=Counter(x) print c.most_common() >> [(
>>> x = {1: 2, 3: 4, 4:3, 2:1, 0:0} >>> from collections import Counter >>> >>> Counter(x).most_common() [(3, 4), (4, 3), (1, 2), (2, 1), (0, 0)] >>> >>> Counter(x).most_common()[::-1] [(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)] >>> >>> from collections import OrderedDict >>> OrderedDict(Counter(x).most_common()[::-1]) OrderedDict([(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)])
for key in sorted(mydict.iterkeys()): print "%s: %s" % (key, mydict[key])
for key, value in sorted(mydict.iteritems(), key=lambda (k,v): (v,k)): print "%s: %s" % (key, value)
from collections import defaultdict inverse= defaultdict( list ) for k, v in originalDict.items(): inverse[v].append( k )
sorted(d.items(), key=lambda x: x[1], reverse=True)
>>> data = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} >>> SkipDict(data) {0: 0.0, 2: 1.0, 1: 2.0, 4: 3.0, 3: 4.0}
from django.utils.datastructures import SortedDict def sortedDictByKey(self,data): sortedDict = SortedDict() if data: if isinstance(data, dict): sortedKey = sorted(data.keys()) for k in sortedKey: sortedDict[k] = data[k] return sortedDict
def dict_val(x): return x[1] x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_x = sorted(x.items(), key=dict_val)
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0} sorted_x = sorted(x.items(), key=lambda t: t[1])
d = { d_sorted = sorted(zip(d.values(), d.keys())) print d_sorted
def sort_iterable(iterable, sort_on=None, reverse=False, num_as_num=False): def _sort(i): try: if num_as_num: if i is None: _sorted = sorted(iterable, key=lambda v: float(v), reverse=reverse) else: _sorted = dict(sorted(iterable.items(), key=lambda v: float(v[i]), reverse=reverse)) else: raise TypeError except (TypeError, ValueError): if i is None: _sorted = sorted(iterable, key=lambda v: str(v), reverse=reverse) else: _sorted = dict(sorted(iterable.items(), key=lambda v: str(v[i]), reverse=reverse)) return _sorted if isinstance(iterable, list): sorted_list = _sort(None) return sorted_list elif isinstance(iterable, tuple): sorted_list = tuple(_sort(None)) return sorted_list elif isinstance(iterable, dict): if sort_on == sorted_dict = _sort(0) return sorted_dict elif sort_on == sorted_dict = _sort(1) return sorted_dict elif sort_on is not None: raise ValueError(f"Unexpected value {sort_on} for sort_on. When sorting a dict, use key or values") else: raise TypeError(f"Unexpected type {type(iterable)} for iterable. Expected a list, tuple, or dict")
from dicts.sorteddict import ValueSortedDict d = {1: 2, 3: 4, 4:3, 2:1, 0:0} sorted_dict = ValueSortedDict(d) print sorted_dict.items() [(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]
>>> words = {"python": 2, "blah": 4, "alice": 3} >>> dict(sorted(words.items(), key=lambda x: x[1])) {
$ python --version Python 3.2.2 $ cat sort_dict_by_val_desc.py dictionary = dict(siis = 1, sana = 2, joka = 3, tuli = 4, aina = 5) for word in sorted(dictionary, key=dictionary.get, reverse=True): print(word, dictionary[word]) $ python sort_dict_by_val_desc.py aina 5 tuli 4 joka 3 sana 2 siis 1
import operator x = {1: 2, 3: 4, 4:3, 2:1, 0:0} sorted_x = {k[0]:k[1] for k in sorted(x.items(), key=operator.itemgetter(1))}
x = {1: 2, 3: 4, 4:3, 2:1, 0:0} from collections import OrderedDict od1 = OrderedDict(sorted(x.items(), key=lambda t: t[1]))
from os import listdir from os.path import isfile, join onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
from os import walk f = [] for (dirpath, dirnames, filenames) in walk(mypath): f.extend(filenames) break
>>> q = [1, 2, 3] >>> w = [4, 5, 6] >>> q = q + w >>> q [1, 2, 3, 4, 5, 6]
import glob txtfiles = [] for file in glob.glob("*.txt"): txtfiles.append(file)
import glob mylist = [f for f in glob.glob("*.txt")]
>>> import os >>> files_path = [os.path.abspath(x) for x in os.listdir()] >>> files_path [
import os thisdir = os.getcwd() for r, d, f in os.walk(thisdir): for file in f: if ".docx" in file: print(os.path.join(r, file))
>>> import os >>> arr = [] >>> for d,r,f in next(os.walk("F:\_python")): >>> for file in f: >>> arr.append(os.path.join(r,file)) ... >>> for f in arr: >>> print(files) >output F:\\_python\\dict_class.py F:\\_python\\programmi.txt
>>> [os.path.join(r,file) for r,d,f in next(os.walk("F:\\_python")) for file in f] [
x = [os.path.join(r,file) for r,d,f in os.walk("F:\\_python") for file in f] >>>x [
>>> arr_txt = [x for x in os.listdir() if x.endswith(".txt")] >>> print(arr_txt) [
>>> from path import path >>> from glob import glob >>> x = [path(f).abspath() for f in glob("F:\*.txt")] >>> for f in x: ... print(f) ... F:\acquistionline.txt F:\acquisti_2018.txt F:\bootstrap_jquery_ecc.txt
import os.path listOfFiles = [f for f in os.listdir() if os.path.isfile(f)] print(listOfFiles) > output [
import pathlib >>> flist = [] >>> for p in pathlib.Path( ... if p.is_file(): ... print(p) ... flist.append(p) ... error.PNG exemaker.bat guiprova.mp3 setup.py speak_gui2.py thumb.PNG
import pathlib py = pathlib.Path().glob("*.py") for file in py: print(file)
stack_overflow_list.py stack_overflow_list_tkinter.py
import os x = [i[2] for i in os.walk( y=[] for t in x: for f in t: y.append(f) >>> y [
>>> for r,d,f in os.walk("F:\_python"): ... for dirs in d: ... print(dirs) ... .vscode pyexcel pyschool.py subtitles _metaprogramming .ipynb_checkpoints
>>> import os >>> x = [f.name for f in os.scandir() if f.is_file()] >>> x [ >>> import os >>> with os.scandir() as i: ... for entry in i: ... if entry.is_file(): ... print(entry.name) ... ebookmaker.py error.PNG exemaker.bat guiprova.mp3 setup.py speakgui4.py speak_gui2.py speak_gui3.py thumb.PNG >>>
import os def count(dir, counter=0): "returns number of files in dir and subdirs" for pack in os.walk(dir): for f in pack[2]: counter += 1 return dir + " : " + str(counter) + "files" print(count("F:\\python")) > output >
import os import shutil from path import path destination = "F:\\file_copied" def copyfile(dir, filetype= "Searches for pptx (or other - pptx is the default) files and copies them" for pack in os.walk(dir): for f in pack[2]: if f.endswith(filetype): fullpath = pack[0] + "\\" + f print(fullpath) shutil.copy(fullpath, destination) counter += 1 if counter > 0: print("------------------------") print("\t==> Found in: `" + dir + "` : " + str(counter) + " files\n") for dir in os.listdir(): "searches for folders that starts with `_`" if dir[0] == copyfile(dir, filetype= > Output _compiti18\Compito Contabilità 1\conti.txt _compiti18\Compito Contabilità 1\modula4.txt _compiti18\Compito Contabilità 1\moduloa4.txt ------------------------ ==> Found in: `_compiti18` : 3 files
import os mylist = "" with open("filelist.txt", "w", encoding="utf-8") as file: for eachfile in os.listdir(): mylist += eachfile + "\n" file.write(mylist)
"""We are going to save a txt file with all the files in your directory. We will use the function walk() """ import os listafile = [] percorso = [] with open("lista_file.txt", "w", encoding= for root, dirs, files in os.walk("D:\\"): for file in files: listafile.append(file) percorso.append(root + "\\" + file) testo.write(file + "\n") listafile.sort() print("N. of files", len(listafile)) with open("lista_file_ordinata.txt", "w", encoding="utf-8") as testo_ordinato: for file in listafile: testo_ordinato.write(file + "\n") with open("percorso.txt", "w", encoding="utf-8") as file_percorso: for file in percorso: file_percorso.write(file + "\n") os.system("lista_file.txt") os.system("lista_file_ordinata.txt") os.system("percorso.txt")
import os with open("file.txt", "w", encoding="utf-8") as filewrite: for r, d, f in os.walk("C:\\"): for file in f: filewrite.write(f"{r + file}\n")
def searchfiles(extension= "Create a txt file with all the file of a type" with open("file.txt", "w", encoding="utf-8") as filewrite: for r, d, f in os.walk("C:\\"): for file in f: if file.endswith(extension): filewrite.write(f"{r + file}\n") searchfiles(
paths = [os.path.join(path,fn) for fn in next(os.walk(path))[2]]
import os def get_filepaths(directory): """ This function will generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple (dirpath, dirnames, filenames). """ file_paths = [] for root, directories, files in os.walk(directory): for filename in files: filepath = os.path.join(root, filename) file_paths.append(filepath) return file_paths full_file_paths = get_filepaths("/Users/johnny/Desktop/TEST")
for f in full_file_paths: if f.endswith(".dat"): print f
from glob import glob from os.path import join glob(join(
from glob import glob from os.path import expanduser, join glob(join(expanduser(
from glob import glob from os import getcwd from os.path import join glob(join(getcwd(),
>>> import sys >>> sys.version >>> m = map(lambda x: x, [1, 2, 3]) >>> m, type(m) ([1, 2, 3], <type >>> len(m) 3
>>> import sys >>> sys.version >>> m = map(lambda x: x, [1, 2, 3]) >>> m, type(m) (<map object at 0x000001B4257342B0>, <class >>> len(m) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: object of type >>> lm0 = list(m) >>> lm0, type(lm0) ([1, 2, 3], <class >>> >>> lm1 = list(m) >>> lm1, type(lm1) ([], <class
E:\Work\Dev\StackOverflow\q003207219>tree /f "root_dir" Folder PATH listing for volume Work Volume serial number is 00000029 3655:6FED E:\WORK\DEV\STACKOVERFLOW\Q003207219\ROOT_DIR ¦ file0 ¦ file1 ¦ +---dir0 ¦ +---dir00 ¦ ¦ ¦ file000 ¦ ¦ ¦ ¦ ¦ +---dir000 ¦ ¦ file0000 ¦ ¦ ¦ +---dir01 ¦ ¦ file010 ¦ ¦ file011 ¦ ¦ ¦ +---dir02 ¦ +---dir020 ¦ +---dir0200 +---dir1 ¦ file10 ¦ file11 ¦ file12 ¦ +---dir2 ¦ ¦ file20 ¦ ¦ ¦ +---dir20 ¦ file200 ¦ +---dir3
>>> import os >>> root_dir = "root_dir" >>> >>> os.listdir(root_dir) [ >>> >>> [item for item in os.listdir(root_dir) if os.path.isfile(os.path.join(root_dir, item))] [
import os from pprint import pformat def _get_dir_content(path, include_folders, recursive): entries = os.listdir(path) for entry in entries: entry_with_path = os.path.join(path, entry) if os.path.isdir(entry_with_path): if include_folders: yield entry_with_path if recursive: for sub_entry in _get_dir_content(entry_with_path, include_folders, recursive): yield sub_entry else: yield entry_with_path def get_dir_content(path, include_folders=True, recursive=True, prepend_folder_name=True): path_len = len(path) + len(os.path.sep) for item in _get_dir_content(path, include_folders, recursive): yield item if prepend_folder_name else item[path_len:] def _get_dir_content_old(path, include_folders, recursive): entries = os.listdir(path) ret = list() for entry in entries: entry_with_path = os.path.join(path, entry) if os.path.isdir(entry_with_path): if include_folders: ret.append(entry_with_path) if recursive: ret.extend(_get_dir_content_old(entry_with_path, include_folders, recursive)) else: ret.append(entry_with_path) return ret def get_dir_content_old(path, include_folders=True, recursive=True, prepend_folder_name=True): path_len = len(path) + len(os.path.sep) return [item if prepend_folder_name else item[path_len:] for item in _get_dir_content_old(path, include_folders, recursive)] def main(): root_dir = "root_dir" ret0 = get_dir_content(root_dir, include_folders=True, recursive=True, prepend_folder_name=True) lret0 = list(ret0) print(ret0, len(lret0), pformat(lret0)) ret1 = get_dir_content_old(root_dir, include_folders=False, recursive=True, prepend_folder_name=False) print(len(ret1), pformat(ret1)) if __name__ == "__main__": main()
(py35x64_test) E:\Work\Dev\StackOverflow\q003207219>"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" "code_os_listdir.py" <generator object get_dir_content at 0x000001BDDBB3DF10> 22 [ 11 [
>>> import os >>> root_dir = os.path.join(".", "root_dir") >>> root_dir >>> >>> scandir_iterator = os.scandir(root_dir) >>> scandir_iterator <nt.ScandirIterator object at 0x00000268CF4BC140> >>> [item.path for item in scandir_iterator] [ >>> >>> [item.path for item in scandir_iterator] [] >>> >>> scandir_iterator = os.scandir(root_dir) >>> for item in scandir_iterator : ... if os.path.isfile(item.path): ... print(item.name) ... file0 file1
>>> import os >>> root_dir = os.path.join(os.getcwd(), "root_dir") >>> root_dir >>> >>> walk_generator = os.walk(root_dir) >>> root_dir_entry = next(walk_generator) >>> root_dir_entry ( >>> >>> root_dir_entry[1] + root_dir_entry[2] [ >>> >>> [os.path.join(root_dir_entry[0], item) for item in root_dir_entry[1] + root_dir_entry[2]] [ >>> >>> for entry in walk_generator: ... print(entry) ... ( ( ( ( ( ( ( ( ( ( (
>>> import glob, os >>> wildcard_pattern = "*" >>> root_dir = os.path.join("root_dir", wildcard_pattern) >>> root_dir >>> >>> glob_list = glob.glob(root_dir) >>> glob_list [ >>> >>> [item.replace("root_dir" + os.path.sep, "") for item in glob_list] [ >>> >>> for entry in glob.iglob(root_dir + "*", recursive=True): ... print(entry) ... root_dir\ root_dir\dir0 root_dir\dir0\dir00 root_dir\dir0\dir00\dir000 root_dir\dir0\dir00\dir000\file0000 root_dir\dir0\dir00\file000 root_dir\dir0\dir01 root_dir\dir0\dir01\file010 root_dir\dir0\dir01\file011 root_dir\dir0\dir02 root_dir\dir0\dir02\dir020 root_dir\dir0\dir02\dir020\dir0200 root_dir\dir1 root_dir\dir1\file10 root_dir\dir1\file11 root_dir\dir1\file12 root_dir\dir2 root_dir\dir2\dir20 root_dir\dir2\dir20\file200 root_dir\dir2\file20 root_dir\dir3 root_dir\file0 root_dir\file1
>>> import pathlib >>> root_dir = "root_dir" >>> root_dir_instance = pathlib.Path(root_dir) >>> root_dir_instance WindowsPath( >>> root_dir_instance.name >>> root_dir_instance.is_dir() True >>> >>> [item.name for item in root_dir_instance.glob("*")] [ >>> >>> [os.path.join(item.parent.name, item.name) for item in root_dir_instance.glob("*") if not item.is_dir()] [
def listdir(path): try: cached_mtime, list = cache[path] del cache[path] except KeyError: cached_mtime, list = -1, [] mtime = os.stat(path).st_mtime if mtime != cached_mtime: list = os.listdir(path) list.sort() cache[path] = mtime, list return list
import sys from ctypes import Structure, \ c_ulonglong, c_longlong, c_ushort, c_ubyte, c_char, c_int, \ CDLL, POINTER, \ create_string_buffer, get_errno, set_errno, cast DT_DIR = 4 DT_REG = 8 char256 = c_char * 256 class LinuxDirent64(Structure): _fields_ = [ ("d_ino", c_ulonglong), ("d_off", c_longlong), ("d_reclen", c_ushort), ("d_type", c_ubyte), ("d_name", char256), ] LinuxDirent64Ptr = POINTER(LinuxDirent64) libc_dll = this_process = CDLL(None, use_errno=True) opendir = libc_dll.opendir readdir = libc_dll.readdir closedir = libc_dll.closedir def get_dir_content(path): ret = [path, list(), list()] dir_stream = opendir(create_string_buffer(path.encode())) if (dir_stream == 0): print("opendir returned NULL (errno: {:d})".format(get_errno())) return ret set_errno(0) dirent_addr = readdir(dir_stream) while dirent_addr: dirent_ptr = cast(dirent_addr, LinuxDirent64Ptr) dirent = dirent_ptr.contents name = dirent.d_name.decode() if dirent.d_type & DT_DIR: if name not in (".", ".."): ret[1].append(name) elif dirent.d_type & DT_REG: ret[2].append(name) dirent_addr = readdir(dir_stream) if get_errno(): print("readdir returned NULL (errno: {:d})".format(get_errno())) closedir(dir_stream) return ret def main(): print("{:s} on {:s}\n".format(sys.version, sys.platform)) root_dir = "root_dir" entries = get_dir_content(root_dir) print(entries) if __name__ == "__main__": main()
[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q003207219]> ./code_ctypes.py 3.5.2 (default, Nov 12 2018, 13:43:14) [GCC 5.4.0 20160609] on linux [
>>> import os, win32file, win32con >>> root_dir = "root_dir" >>> wildcard = "*" >>> root_dir_wildcard = os.path.join(root_dir, wildcard) >>> entry_list = win32file.FindFilesW(root_dir_wildcard) >>> len(entry_list) 8 >>> [entry[-2] for entry in entry_list] [ >>> >>> [entry[-2] for entry in entry_list if entry[0] & win32con.FILE_ATTRIBUTE_DIRECTORY and entry[-2] not in (".", "..")] [ >>> >>> [os.path.join(root_dir, entry[-2]) for entry in entry_list if entry[0] & (win32con.FILE_ATTRIBUTE_NORMAL | win32con.FILE_ATTRIBUTE_ARCHIVE)] [
(py35x64_test) E:\Work\Dev\StackOverflow\q003207219>"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" -c "import os;os.system(\"dir /b root_dir\")" dir0 dir1 dir2 dir3 file0 file1
def list_files(path): files = [] for name in os.listdir(path): if os.path.isfile(os.path.join(path, name)): files.append(name) return files
from findtools.find_files import (find_files, Match) sh_files_pattern = Match(filetype= found_files = find_files(path= for found_file in found_files: print found_file
L = [os.path.join(os.getcwd(),f) for f in os.listdir(
import os import os.path def get_files(target_dir): item_list = os.listdir(target_dir) file_list = list() for item in item_list: item_dir = os.path.join(target_dir,item) if os.path.isdir(item_dir): file_list += get_files(item_dir) else: file_list.append(item_dir) return file_list
import os import traceback print def start(): address = "/home/ubuntu/Desktop" try: Folders = [] Id = 1 for item in os.listdir(address): endaddress = address + "/" + item Folders.append({ Id += 1 state = 0 for item2 in os.listdir(endaddress): state = 1 if state == 1: Id = FolderToList(endaddress, Id, Id - 1, Folders) return Folders except: print "___________________________ ERROR ___________________________\n" + traceback.format_exc() def FolderToList(address, Id, TopId, Folders): for item in os.listdir(address): endaddress = address + "/" + item Folders.append({ Id += 1 state = 0 for item in os.listdir(endaddress): state = 1 if state == 1: Id = FolderToList(endaddress, Id, Id - 1, Folders) return Id print start()
import os def get_files(search_path): for (dirpath, _, filenames) in os.walk(search_path): for filename in filenames: yield os.path.join(dirpath, filename) list_files = get_files( for filename in list_files: print(filename)
import dircache list = dircache.listdir(pathname) i = 0 check = len(list[0]) temp = [] count = len(list) while count != 0: if len(list[i]) != check: temp.append(list[i-1]) check = len(list[i]) else: i = i + 1 count = count - 1 print temp
import os def createList(foldername, fulldir = True, suffix=".jpg"): file_list_tmp = os.listdir(foldername) file_list = [] if fulldir: for item in file_list_tmp: if item.endswith(suffix): file_list.append(os.path.join(foldername, item)) else: for item in file_list_tmp: if item.endswith(suffix): file_list.append(item) return file_list
from pathlib import Path folder = [f for f in Path(folder).glob(
import os def files(path): for file in os.listdir(path): if os.path.isfile(os.path.join(path, file)): yield file for file in files("."): print (file)
import os import fnmatch def list_paths(folder= match = fnmatch.fnmatchcase if case_sensitive else fnmatch.fnmatch walked = os.walk(folder) if subfolders else [next(os.walk(folder))] return [os.path.join(root, f) for root, dirnames, filenames in walked for f in filenames if match(f, pattern)]
import rglob file_list=rglob.rglob("/home/base/dir/", "*") print file_list
Yes: if not seq: if seq: No: if len(seq): if not len(seq):
>>> x = numpy.array([0,1]) >>> if x: print("x") ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
>>> x = numpy.array([0,]) >>> if x: print("x") ... else: print("No x") No x
>>> x = numpy.array([0,1]) >>> if x.size: print("x") x >>> x = numpy.array([0,]) >>> if x.size: print("x") ... else: print("No x") x >>> x = numpy.zeros((1,0)) >>> if x.size: print("x") ... else: print("No x") No x
Yes: if not seq: if seq: No: if len(seq): if not len(seq):
>>> import timeit >>> min(timeit.repeat(lambda: len([]) == 0, repeat=100)) 0.13775854044661884 >>> min(timeit.repeat(lambda: [] == [], repeat=100)) 0.0984637276455409 >>> min(timeit.repeat(lambda: not [], repeat=100)) 0.07878462291455435
>>> min(timeit.repeat(lambda: [], repeat=100)) 0.07074015751817342
>>> import dis >>> dis.dis(lambda: len([]) == 0) 1 0 LOAD_GLOBAL 0 (len) 2 BUILD_LIST 0 4 CALL_FUNCTION 1 6 LOAD_CONST 1 (0) 8 COMPARE_OP 2 (==) 10 RETURN_VALUE
>>> dis.dis(lambda: [] == []) 1 0 BUILD_LIST 0 2 BUILD_LIST 0 4 COMPARE_OP 2 (==) 6 RETURN_VALUE
>>> dis.dis(lambda: not []) 1 0 BUILD_LIST 0 2 UNARY_NOT 4 RETURN_VALUE
typedef struct { PyObject_VAR_HEAD PyObject **ob_item; /* ob_item contains space for * currently in use is ob_size. * Invariants: * 0 <= ob_size <= allocated * len(list) == ob_size
a = [] for item in a: <do something with item> <rest of code>
if isinstance(a, (list, some, other, types, i, accept)) and not a: do_stuff
if isinstance(a, numpy.ndarray) and not a.size: do_stuff elif isinstance(a, collections.Sized) and not a: do_stuff
a = [] . . . if a: print("List is not empty.") else: print("List is empty.")
if not a: print "list is empty" if len(a) == 0: print "list is empty"
try: next(iter(a)) except StopIteration: print("Error: a is empty")
def list_test (L): if L is None : print elif not L : print else: print list_test(None) list_test([]) list_test([1,2,3])
def list_test2 (L): if not L : print else: print list_test2(None) list_test2([]) list_test2([1,2,3])
a = [] if len(a) == 0: print("Empty") else: print(" Not empty")
import collections def is_empty(a): return not a and isinstance(a, collections.Iterable)
>>> is_empty( False >>> is_empty(555) False >>> is_empty(0) False >>> is_empty( True >>> is_empty([3]) False >>> is_empty([]) True >>> is_empty({}) True >>> is_empty(()) True
if isinstance(a, list) and len(a)==0: print("Received an empty list")
list=[] if len(list)==0: print ("list is empty") else: print ("list is not empty")
def is_empty(any_structure): if any_structure: print( return True else: print( return False
def empty_list(lst): if len(lst) ==0: return false else: return all(bool(x) for x in l)
def Enquiry(list1): if len(list1) == 0: return 0 else: return 1 list1 = [] if Enquiry(list1): print ("The list isn else: print("The list is Empty")
def Enquiry(list1): if not list1: return 1 else: return 0 list1 = [] if Enquiry(list1): print ("The list is Empty") else: print ("The list isn
>>> li = [ >>> li [ >>> li.append("new") >>> li [ >>> li.append(["new", 2]) >>> li [ >>> li.insert(2, "new") >>> li [ >>> li.extend(["two", "elements"]) >>> li [
>>> another_list = [1, 2, 3] >>> my_list.append(another_list) >>> my_list [
>>> my_list [ >>> another_list = [1, 2, 3] >>> my_list.extend(another_list) >>> my_list [
def append(alist, iterable): for item in iterable: alist.append(item) def extend(alist, iterable): alist.extend(iterable)
import timeit >>> min(timeit.repeat(lambda: append([], "abcdefghijklmnopqrstuvwxyz"))) 2.867846965789795 >>> min(timeit.repeat(lambda: extend([], "abcdefghijklmnopqrstuvwxyz"))) 0.8060121536254883
def append_one(a_list, element): a_list.append(element) def extend_one(a_list, element): a_list.extend([element]) import timeit
>>> min(timeit.repeat(lambda: append_one([], 0))) 0.2082819009956438 >>> min(timeit.repeat(lambda: extend_one([], 0))) 0.2397019260097295
>>> a = [1, 2, 3] >>> a.append([4, 5, 6]) >>> a [1, 2, 3, [4, 5, 6]]
x = [1, 2, 3] x.append([4, 5]) x.append( print(x) [1, 2, 3, [4, 5],
x = [1, 2, 3] x.extend([4, 5]) x.extend( print(x) [1, 2, 3, 4, 5,
l1=range(10) l1+[11] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11] l2=range(10,1,-1) l1+l2 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2]
>>> x = [1,2] >>> x.append([3,4]) >>> x [1,2,[3,4]]
x = [20] x.append([21, 22, 23]) print(x) --> [20, [21, 22, 23]]
x = [20] x.extend([21, 22, 23]) print(x) [20, 21, 22, 23]
def from_iterable(iterables): for it in iterables: for element in it: yield element
import itertools list2d = [[1,2,3],[4,5,6], [7], [8,9]] merged = list(itertools.chain.from_iterable(list2d))
merged = [] merged.extend(itertools.chain.from_iterable(list2d)) print(merged) >>> [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> x = [1,2,3] >>> x [1, 2, 3] >>> x = x + [4,5,6] >>> x [1, 2, 3, 4, 5, 6] >>> x = x + [[7,8]] >>> x [1, 2, 3, 4, 5, 6, [7, 8]]
>> a = [1, 2, 3, 4] >> a.append(5) >> print(a) >> a = [1, 2, 3, 4, 5]
>> a = [1, 2, 3, 4] >> a.append([5, 6]) >> print(a) >> a = [1, 2, 3, 4, [5, 6]]
>> a = [1, 2, 3, 4] >> b = [5, 6, 7, 8] >> a.extend(b) >> print(a) >> a = [1, 2, 3, 4, 5, 6, 7, 8]
>> a = [1, 2, 3, 4] >> a.extend([5, 6]) >> print(a) >> a = [1, 2, 3, 4, 5, 6]
lis = [1, 2, 3] lis = lis + list(iterable) lis.append(object)
>>>def foo(): dic = {1: newdic = {5: for i in dic.keys(): if not newdic.has_key(dic[i]): newdic[i] = dic[i] print "Appended one:", newdic >>>foo() Appended one: {1:
a = [[1,2,3],[4,5,6]] print(a) >>> [[1, 2, 3], [4, 5, 6]] a.append([6,7,8]) print(a) >>> [[1, 2, 3], [4, 5, 6], [6, 7, 8]] a.extend([0,1,2]) print(a) >>> [[1, 2, 3], [4, 5, 6], [6, 7, 8], 0, 1, 2] a=a+[8,9,10] print(a) >>> [[1, 2, 3], [4, 5, 6], [6, 7, 8], 0, 1, 2, 8, 9, 10]
list1 = [1,2,3,4,5] list2 = [6,7,8] list1.append(list2) print(list1) list1.extend(list2) print(list1)
>>> a [1, 2, 3] a.extend([4) >>>a [1, 2, 3, 4] a =[1,2,3] >>> a [1, 2, 3] >>> a[len(a):] = [4] >>> a [1, 2, 3, 4]
def append_o(a_list, element): a_list.append(element) print( for item in a_list: print(item, end = print() def extend_o(a_list, element): a_list.extend(element) print( for item in a_list: print(item, end = print() append_o([ extend_o([ append_o([ extend_o([ append_o([ extend_o([
append: ab,cd, extend: ab,c,d, append: ab,[ extend: ab,cd,ef, append: ab,[ extend: ab,cd,
Example: my_list = [1,2,3,4] my_list[4, my_list [1,2,3,4,
a = [1] b = [2] c = [3] a.extend(b+c) print (a) [1,2,3]
class A(object): def foo(self,x): print "executing foo(%s,%s)"%(self,x) @classmethod def class_foo(cls,x): print "executing class_foo(%s,%s)"%(cls,x) @staticmethod def static_foo(x): print "executing static_foo(%s)"%x a=A()
>>> class DictSubclass(dict): ... def __repr__(self): ... return "DictSubclass" ... >>> dict.fromkeys("abc") { >>> DictSubclass.fromkeys("abc") DictSubclass >>>
class C: @classmethod def f(cls, arg1, arg2, ...): ...
class Apple: _counter = 0 @staticmethod def about_apple(): print( # # @classmethod def make_apple_juice(cls, number_of_apples): print( for i in range(number_of_apples): cls._juice_this(i) @classmethod def _juice_this(cls, apple): print( cls._counter += 1
class Foo(object): def a_normal_instance_method(self, arg_1, kwarg_2=None): Return a value that is a function of the instance with its attributes, and other arguments such as arg_1 and kwarg2 @staticmethod def a_static_method(arg_0): Return a value that is a function of arg_0. It does not know the instance or class it is called from. @classmethod def a_class_method(cls, arg1): Return a value that is a function of the class and other arguments. respects subclassing, it is called with the class it is called from.
>>> {65: 97, 66: 98, 67: 99} >>> str.maketrans( {65: 97, 66: 98, 67: 99}
>>> class MyDict(dict): >>> md = MyDict.fromkeys([ >>> md { >>> type(md) <class
class Cluster(object): def _is_cluster_for(cls, name): return cls.__name__ == name _is_cluster_for = classmethod(_is_cluster_for) def getCluster(name): for cls in Cluster.__subclasses__(): if cls._is_cluster_for(name): return cls() getCluster = staticmethod(getCluster)
@staticmethod def some_static_method(*args, **kwds): pass
@classmethod def some_class_method(cls, *args, **kwds): pass
>>> class C(object): ... pass ... >>> def f(): ... pass ... >>> staticmethod(f).__get__(None, C) <function f at 0x5c1cf0> >>> classmethod(f).__get__(None, C) <bound method type.f of <class
>>> class CMeta(type): ... def foo(cls): ... print cls ... >>> class C(object): ... __metaclass__ = CMeta ... >>> C.foo() <class
class Person(object): def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name
class Person(object): def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def __init__(self, first_name): self.first_name = first_name
class Person(object): def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name @classmethod def get_person(cls, first_name): return cls(first_name, "")
@staticmethod def validate_name(name): return len(name) <= 20
class Foo(object): @staticmethod def bar(): return "In Foo"
class Foo2(Foo): @staticmethod def bar(): return "In Foo2"
class Foo2(Foo): @staticmethod def bar(): return "In Foo2" @staticmethod def magic(): return "Something useful you
class Foo(object): @classmethod def bar(cls): return "In Foo" class Foo2(Foo): @classmethod def bar(cls): return "In Foo2 " + cls.magic() @classmethod def magic(cls): return "MAGIC" print Foo2().bar()
>>> class Klaus: @classmethod def classmthd(*args): return args @staticmethod def staticmthd(*args): return args >>> Klaus.classmthd() (__main__.Klaus,) >>> Klaus.classmthd( (__main__.Klaus, >>> Klaus.staticmthd() () >>> Klaus.staticmthd( (
class A(object): x = 0 def say_hi(self): pass @staticmethod def say_hi_static(): pass @classmethod def say_hi_class(cls): pass def run_self(self): self.x += 1 print self.x self.say_hi() self.say_hi_static() self.say_hi_class() @staticmethod def run_static(): print A.x A.say_hi_static() A.say_hi_class() @classmethod def run_class(cls): print cls.x cls.say_hi_static() cls.say_hi_class()
from os import system system( class DemoClass(object): def instance_method_1(self): return def instance_method_2(self): return self.static_method() + @classmethod def class_method(cls): return @staticmethod def static_method(): return print(DemoClass.class_method() + print(DemoClass.static_method() + democlassObj = DemoClass() print(democlassObj.instance_method_1() + print(democlassObj.instance_method_2() + print(democlassObj.class_method() + print(democlassObj.static_method()) """ print(DemoClass.instance_method_1() + TypeError: TypeError: unbound method instancemethod() must be called with DemoClass instance as first argument (got nothing instead) """
class A(object): m=54 @classmethod def class_method(cls): print "m is %d" % cls.m
class X(object): m=54 @staticmethod def static_method(): print "Referencing/calling a variable or function outside this class. E.g. Some global variable/function."
class Demo(object): def __init__(self,x): self.x = x @classmethod def addone(self, x): return x+1 @staticmethod def addtwo(x): return x+2 def addthree(self, x): return x+3 def main(): print Demo.addone(2) print Demo.addtwo(2) demo = Demo(2) print demo.addthree(2) if __name__ == main()
for index, item in enumerate(items): print(index, item)
for count, item in enumerate(items, start=1): print(count, item)
index = 0 for item in items: print(index, item) index += 1
index = 0 while index < len(items): print(index, items[index]) index += 1
for index in range(len(items)): print(index, items[index])
for index, item in enumerate(items, start=0): print(index, item)
for count, item in enumerate(items, start=1): print(item) print(
iteration = next(enumerate_object) print(iteration)
for index, item in enumerate(items, start=0): print(index, item)
for index, item in enumerate(iterable, start=1): print index, item
[ (ix, ints[ix]) for ix in range(len(ints))] >>> ints [1, 2, 3, 4, 5] >>> for ix in range(len(ints)): print ints[ix] ... 1 2 3 4 5 >>> [ (ix, ints[ix]) for ix in range(len(ints))] [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)] >>> lc = [ (ix, ints[ix]) for ix in range(len(ints))] >>> for tup in lc: ... print tup ... (0, 1) (1, 2) (2, 3) (3, 4) (4, 5) >>>
from timeit import timeit def range_loop(iterable): for i in range(len(iterable)): 1 + iterable[i] def xrange_loop(iterable): for i in xrange(len(iterable)): 1 + iterable[i] def enumerate_loop(iterable): for i, val in enumerate(iterable): 1 + val def manual_indexing_loop(iterable): index = 0 for item in iterable: 1 + item index += 1
from timeit import timeit def measure(l, number=10000): print "Measure speed for list with %d items" % len(l) print "xrange: ", timeit(lambda :xrange_loop(l), number=number) print "range: ", timeit(lambda :range_loop(l), number=number) print "enumerate: ", timeit(lambda :enumerate_loop(l), number=number) print "manual_indexing: ", timeit(lambda :manual_indexing_loop(l), number=number) measure(range(1000)) measure(range(10000)) measure(range(10000000), number=100)
int_list = [8, 23, 45, 12, 78] for index, value in enumerate(int_list): print(index, value)
ints = [9, 23, 45, 12, 78] ints.extend([1,2,3,4,5,6,7,8]) for idx, val in enumerate(ints): print(idx,val)
ints = [9, 23, 45, 12, 78] ints.append([1]) for idx, val in enumerate(ints): print(idx,val)
ints = [8, 23, 45, 12, 78] index = 0 for value in (ints): index +=1 print index, value
ints = [8, 23, 45, 12, 78] index = 0 for value in (ints): index +=1 print index, value if index >= len(ints)-1: index = 0
In [1]: ints = [8, 23, 45, 12, 78] In [2]: for idx, val in enumerate(ints): ...: print(idx, val) ...: (0, 8) (1, 23) (2, 45) (3, 12) (4, 78)
for counter, value in enumerate(ints): print(counter, value)
for counter in range(len(ints)): print(counter, ints[counter])
data = [ x = [] for (i, item) in enumerate(data): a = (i, str(item).split( x.append(a) for index, value in x: print(index, value)
alist = [ 1, 2, 3, 4, 5 ] for n,a in enumerate(alist): print( "%d %d"%(n,a) )
for n,a in enumerate(alist[1:-1]): print( "%d %d"%(n,a) )
for n,a in enumerate(alist,start=1): print( "%d %d"%(n,a) )
ints = [8, 23, 45, 12, 78] inds = [ints.index(i) for i in ints]
ints = [8, 8, 8, 23, 45, 12, 78] inds = [tup[0] for tup in enumerate(ints)]
ints = [8, 8, 8, 23, 45, 12, 78] inds = [tup for tup in enumerate(ints)]
for i, num in enumerate(nums, start = 1): print(i, num)
ints = [8, 23, 45, 12, 78] print [(i,ints[i]) for i in range(len(ints))]
ints = [8, 23, 45, 12, 78] names = ["John", "Sue", "Johannes", "Patel", "Ian"] for int, name = zip(ints, names): print("{} - {}".format(name, int)
8 - John 23 - Sue 45 - Johannes 12 - Patel 78 - Ian
globvar = 0 def set_globvar_to_one(): global globvar globvar = 1 def print_globvar(): print(globvar) set_globvar_to_one() print_globvar()
myGlobal = 5 def func1(): myGlobal = 42 def func2(): print myGlobal func1() func2()
>>> import dis >>> def foo(): ... global bar ... baz = 5 ... print bar ... print baz ... print quux ... >>> dis.disassemble(foo.func_code) 3 0 LOAD_CONST 1 (5) 3 STORE_FAST 0 (baz) 4 6 LOAD_GLOBAL 0 (bar) 9 PRINT_ITEM 10 PRINT_NEWLINE 5 11 LOAD_FAST 0 (baz) 14 PRINT_ITEM 15 PRINT_NEWLINE 6 16 LOAD_GLOBAL 1 (quux) 19 PRINT_ITEM 20 PRINT_NEWLINE 21 LOAD_CONST 0 (None) 24 RETURN_VALUE >>>
def create_global_variable(): global global_variable global_variable =
def use_global_variable(): return global_variable +
def change_global_variable(): global global_variable global_variable =
def use_local_with_same_name_as_global(): global_variable = return global_variable + >>> use_local_with_same_name_as_global()
import multiprocessing import os import random import sys import time def worker(new_value): old_value = get_value() set_value(random.randint(1, 99)) print( pid=str(os.getpid()), old_value=old_value, new_value=new_value, get_value=get_value())) def get_value(): global global_variable return global_variable def set_value(new_value): global global_variable global_variable = new_value global_variable = -1 print( set_value(new_value=-2) print( processPool = multiprocessing.Pool(processes=5) processPool.map(func=worker, iterable=range(15))
before set_value(), get_value() = [-1] after set_value(), get_value() = [-2] pid=[53970] old_value=[-2] new_value=[ 0] get_value=[23] pid=[53971] old_value=[-2] new_value=[ 1] get_value=[42] pid=[53970] old_value=[23] new_value=[ 4] get_value=[50] pid=[53970] old_value=[50] new_value=[ 6] get_value=[14] pid=[53971] old_value=[42] new_value=[ 5] get_value=[31] pid=[53972] old_value=[-2] new_value=[ 2] get_value=[44] pid=[53973] old_value=[-2] new_value=[ 3] get_value=[94] pid=[53970] old_value=[14] new_value=[ 7] get_value=[21] pid=[53971] old_value=[31] new_value=[ 8] get_value=[34] pid=[53972] old_value=[44] new_value=[ 9] get_value=[59] pid=[53973] old_value=[94] new_value=[10] get_value=[87] pid=[53970] old_value=[21] new_value=[11] get_value=[21] pid=[53971] old_value=[34] new_value=[12] get_value=[82] pid=[53972] old_value=[59] new_value=[13] get_value=[ 4] pid=[53973] old_value=[87] new_value=[14] get_value=[70]
globavar = 5 def f(): global globvar print(globvar) f()
var = "test" def printGlobalText(): global var var = "global from printGlobalText fun." print "var from printGlobalText: " + var def printLocalText(): var = "local version from printLocalText fun" print "var from printLocalText: " + var printGlobalText() printLocalText()
def five(enterAnumber,sumation): global helper helper = enterAnumber + sumation def isTheNumber(): return helper
import TestPy def main(): atest = TestPy atest.five(5,8) print(atest.isTheNumber()) if __name__ == main()
def x1(): global x x = 6 def x2(): global x x = x+1 print x x = 5 x1() x2()
import initval as iv Def getmystocks (): iv.Stocksin = getstockcount () Def getmycharts (): For ic in range (0,iv.Stocksin):
import numpy as np hostValue = 3.14159 hostArray = np.array([2., 3.]) hostMatrix = np.array([[1.0, 0.0],[ 0.0, 1.0]]) def func1(): global hostValue hostValue = 2.0 def func2(): global hostValue hostValue += 1.0 def func3(): global hostArray hostArray = np.array([14., 15.]) def func4(): hostArray[0] = 123.4 def func5(): hostArray[1] += 1.0 def func6(): hostMatrix[1][1] = 12. def func7(): hostMatrix[0][0] += 0.33 func1() print "After func1(), hostValue = ", hostValue func2() print "After func2(), hostValue = ", hostValue func3() print "After func3(), hostArray = ", hostArray func4() print "After func4(), hostArray = ", hostArray func5() print "After func5(), hostArray = ", hostArray func6() print "After func6(), hostMatrix = \n", hostMatrix func7() print "After func7(), hostMatrix = \n", hostMatrix
from main import config def check_threads(): return max < thread_count
from main import runner from main.runner import check_threads class RunnerTest(unittest): def test_threads(self): runner.max = 0 check_threads()
from pickle import load def loaditem(name): with open(r"C:\pickle\file\location"+"\{}.dat".format(name), "rb") as openfile: globals()[name] = load(openfile) return True
from pickle import dump def dumpfile(name): with open(name+".dat", "wb") as outfile: dump(globals()[name], outfile) return True
+---+---+---+---+---+---+ | P | y | t | h | o | n | +---+---+---+---+---+---+ 0 1 2 3 4 5 6 -6 -5 -4 -3 -2 -1
>>> seq[:] >>> seq[low:] >>> seq[:high] >>> seq[low:high] >>> seq[::stride] >>> seq[low::stride] >>> seq[:high:stride] >>> seq[low:high:stride]
>>> seq[::-stride] >>> seq[high::-stride] >>> seq[:low:-stride] >>> seq[high:low:-stride]
>>> class slicee: ... def __getitem__(self, item): ... return `item` ... >>> slicee()[0, 1:2, ::5, ...]
+---+---+---+---+---+---+ | P | y | t | h | o | n | +---+---+---+---+---+---+ Slice position: 0 1 2 3 4 5 6 Index position: 0 1 2 3 4 5 >>> p = [ >>> p[0] >>> p[5] >>> p[0:1] [ >>> p[0:2] [
>>> p[2:3] [ >>> p[2:3] = [ >>> p [ >>> p[2:3] = Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can only assign an iterable
>>> p = [ >>> p[0:4] [ >>> p[1:4] [ >>> p[2:4] [ >>> p[3:4] [ >>> p[4:4] []
>>> p = [ >>> p[2:4] = [ >>> p [ >>> p = [ >>> p[3:4] = [ >>> p [ >>> p = [ >>> p[4:4] = [ >>> p [
>>> p = [ >>> p[0:4] [ >>> p[1:4] [ >>> p[2:4] [ >>> p[3:4] [ >>> p[4:4] [] >>> p[5:4] [] >>> p[6:4] []
>>> p[4:4] [] >>> p[5:4] [] >>> p[6:4] [] >>> p[6] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: list index out of range
>>> r=[1,2,3,4] >>> r[1:1] [] >>> r[1:1]=[9,8] >>> r [1, 9, 8, 2, 3, 4] >>> r[1:1]=[ >>> r [1,
+---+---+---+---+---+---+ | P | y | t | h | o | n | +---+---+---+---+---+---+ 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1
if (step_is_negative) { lower = PyLong_FromLong(-1L); if (lower == NULL) goto error; upper = PyNumber_Add(length, lower); if (upper == NULL) goto error; }
else { lower = _PyLong_Zero; Py_INCREF(lower); upper = length; Py_INCREF(upper); }
if (self->start == Py_None) { start = step_is_negative ? upper : lower; Py_INCREF(start); }
if (self->stop == Py_None) { stop = step_is_negative ? lower : upper; Py_INCREF(stop); }
>>> list(range(100))[last_nine_slice] [91, 92, 93, 94, 95, 96, 97, 98, 99]
length = 100 last_nine_iter = itertools.islice(list(range(length)), length-9, None, 1) list_last_nine = list(last_nine_iter)
>>> list_last_nine [91, 92, 93, 94, 95, 96, 97, 98, 99]
[a:b:c] len = length of string, tuple or list c -- default is +1. The sign of c indicates forward or backward, absolute value of c indicates steps. Default is forward with step size 1. Positive means forward, negative means backward. a -- When c is positive or blank, default is 0. When c is negative, default is -1. b -- When c is positive or blank, default is len. When c is negative, default is -(len+1).
In forward direction, starts at 0 and ends at len-1 In backward direction, starts at -1 and ends at -len
...,-len -2 ,-len-1,-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1, len, len +1, len+2 , ....
0 1 2 3 4 5 6 7 8 9 10 11 a s t r i n g -9 -8 -7 -6 -5 -4 -3 -2 -1
>>> l1 [2, 3, 4] >>> l1[:] [2, 3, 4] >>> l1[::-1] [4, 3, 2] >>> l1[:-4:-1] [4, 3, 2] >>> l1[:-3:-1] [4, 3] >>> l1[::] [2, 3, 4] >>> l1[::-1] [4, 3, 2] >>> l1[-100:-200:-1] [] >>> l1[-1:-200:-1] [4, 3, 2] >>> l1[-1:-1:1] [] >>> l1[-1:5:1] [4] >>> l1[1:-7:1] [] >>> l1[1:-7:-1] [3, 2] >>> l1[:-2:-2] [4]
Python indexes and slices for a six-element list. Indexes enumerate the elements, slices enumerate the spaces between the elements. Index from rear: -6 -5 -4 -3 -2 -1 a=[0,1,2,3,4,5] a[1:]==[1,2,3,4,5] Index from front: 0 1 2 3 4 5 len(a)==6 a[:5]==[0,1,2,3,4] +---+---+---+---+---+---+ a[0]==0 a[:-2]==[0,1,2,3] | a | b | c | d | e | f | a[5]==5 a[1:2]==[1] +---+---+---+---+---+---+ a[-1]==5 a[1:-1]==[1,2,3,4] Slice from front: : 1 2 3 4 5 : a[-2]==4 Slice from rear: : -5 -4 -3 -2 -1 : b=a[:] b==[0,1,2,3,4,5] (shallow copy of a)
def range(start=0, stop, step=1): i = start while (i < stop if step > 0 else i > stop): yield i i += step
def this_is_how_slicing_works(seq, start=None, stop=None, step=1): if start is None: start = (0 if step > 0 else len(seq)-1) elif start < 0: start += len(seq) if not 0 <= start < len(seq): start = (0 if step > 0 else len(seq)-1) if stop is None: stop = (len(seq) if step > 0 else -1) elif stop < 0: stop += len(seq) for i in range(start, stop, step): if 0 <= i < len(seq): yield seq[i]
Index: ------------> 0 1 2 3 4 +---+---+---+---+---+ | a | b | c | d | e | +---+---+---+---+---+ 0 -4 -3 -2 -1 <------------ Slice: <---------------| |---------------> : 1 2 3 4 : +---+---+---+---+---+ | a | b | c | d | e | +---+---+---+---+---+ : -4 -3 -2 -1 : |---------------> <---------------|
In [122]: alpha = [ In [123]: alpha Out[123]: [ In [124]: alpha[0] Out[124]: In [127]: alpha[0] = In [128]: alpha Out[128]: [ In [129]: alpha[0,1] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-129-c7eb16585371> in <module>() ----> 1 alpha[0,1] TypeError: list indices must be integers, not tuple
In [130]: alpha[0:1] Out[130]: [ In [131]: alpha[0:1] = In [132]: alpha Out[132]: [ In [133]: alpha[0:2] = [ In [134]: alpha Out[134]: [ In [135]: alpha[2:2] = [ In [136]: alpha Out[136]: [
In [137]: alpha = [ In [142]: alpha[1:5:2] Out[142]: [ In [143]: alpha[-1:-5:-2] Out[143]: [ In [144]: alpha[1:5:-2] Out[144]: [] In [145]: alpha[-1:-5:2] Out[145]: []
def py_slice_get_indices_ex(obj, start=None, stop=None, step=None): length = len(obj) if step is None: step = 1 if step == 0: raise Exception("Step cannot be zero.") if start is None: start = 0 if step > 0 else length - 1 else: if start < 0: start += length if start < 0: start = 0 if step > 0 else -1 if start >= length: start = length if step > 0 else length - 1 if stop is None: stop = length if step > 0 else -1 else: if stop < 0: stop += length if stop < 0: stop = 0 if step > 0 else -1 if stop >= length: stop = length if step > 0 else length - 1 if (step < 0 and stop >= start) or (step > 0 and start >= stop): slice_length = 0 elif step < 0: slice_length = (stop - start + 1)/(step) + 1 else: slice_length = (stop - start - 1)/(step) + 1 return (start, stop, step, slice_length)
In [21]: alpha = [ In [22]: s = slice(None, None, None) In [23]: s Out[23]: slice(None, None, None) In [24]: s.indices(len(alpha)) Out[24]: (0, 6, 1) In [25]: range(*s.indices(len(alpha))) Out[25]: [0, 1, 2, 3, 4, 5] In [26]: s = slice(None, None, -1) In [27]: range(*s.indices(len(alpha))) Out[27]: [5, 4, 3, 2, 1, 0] In [28]: s = slice(None, 3, -1) In [29]: range(*s.indices(len(alpha))) Out[29]: [5, 4]
>>> l[len(l):-len(l)-1:-1] [467, 945, 7, 67, 456, 345, 23, 12] >>> l[:-len(l)-1:-1] [467, 945, 7, 67, 456, 345, 23, 12] >>> l[len(l)::-1] [467, 945, 7, 67, 456, 345, 23, 12] >>> l[::-1] [467, 945, 7, 67, 456, 345, 23, 12] >>> l[-1:-len(l)-1:-1] [467, 945, 7, 67, 456, 345, 23, 12]
>>> items = [0, 1, 2, 3, 4, 5, 6] >>> a = slice(2, 4) >>> items[2:4] [2, 3] >>> items[a] [2, 3] >>> items[a] = [10,11] >>> items [0, 1, 10, 11, 4, 5, 6] >>> del items[a] >>> items [0, 1, 4, 5, 6]
>>> a = slice(10, 50, 2) >>> a.start 10 >>> a.stop 50 >>> a.step 2 >>>
s[start:end] s[start:] s[:end] s[:end:step] s[start::step] s[::step] s[:]
In [1]: s = [i for i in range(10)] In [2]: s Out[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] In [3]: s[2:] Out[3]: [2, 3, 4, 5, 6, 7, 8, 9] In [4]: s[:8] Out[4]: [0, 1, 2, 3, 4, 5, 6, 7] In [5]: s[4:7] Out[5]: [4, 5, 6] In [6]: s[:-2] Out[6]: [0, 1, 2, 3, 4, 5, 6, 7] In [7]: s[-2:] Out[7]: [8, 9] In [8]: s[::-1] Out[8]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] In [9]: s[::-2] Out[9]: [9, 7, 5, 3, 1] In [11]: s[-2::-2] Out[11]: [8, 6, 4, 2, 0] In [12]: s[3:15] Out[12]: [3, 4, 5, 6, 7, 8, 9] In [14]: s[5:1] Out[14]: [] In [15]: s[11] --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-15-79ffc22473a3> in <module>() ----> 1 s[11] IndexError: list index out of range
>>> a array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]]) >>> a[:2,0:3:2] array([[1, 3], [5, 7]])
def slicegraphical(s, lista): if len(s) > 9: print return 0; print print for letter in s: print print print " ",; print print " ", for letter in range(len(s) +1): print print "" for letter in range(-1*(len(s)), 0): print print print for triada in lista: if len(triada) == 3: if triada[0]==None and triada[1] == None and triada[2] == None: print s+ elif triada[0] == None and triada[1] == None and triada[2] != None: print s+ elif triada[0] == None and triada[1] != None and triada[2] == None: print s+ elif triada[0] == None and triada[1] != None and triada[2] != None: print s+ elif triada[0] != None and triada[1] == None and triada[2] == None: print s+ elif triada[0] != None and triada[1] == None and triada[2] != None: print s+ elif triada[0] != None and triada[1] != None and triada[2] == None: print s+ elif triada[0] != None and triada[1] != None and triada[2] != None: print s+ elif len(triada) == 2: if triada[0] == None and triada[1] == None: print s+ elif triada[0] == None and triada[1] != None: print s+ elif triada[0] != None and triada[1] == None: print s+ elif triada[0] != None and triada[1] != None: print s+ elif len(triada) == 1: print s+ if __name__ == s = lista = [[4,7],[2,5,2],[-5,1,-1],[4],[-4,-6,-1], [2,-3,1],[2,-3,-1], [None,None,-1],[-5,None],[-5,0,-1],[-5,None,-1],[-1,1,-2]] slicegraphical(s, lista)
+---+---+---+---+---+---+---+---+---+ | C | O | M | P | U | T | E | R | S | +---+---+---+---+---+---+---+---+---+ 0 1 2 3 4 5 6 7 8 9 -9 -8 -7 -6 -5 -4 -3 -2 -1 COMPUTERS[ 4 : 7 ] = UTE COMPUTERS[ 2 : 5 : 2 ] = MU COMPUTERS[-5 : 1 :-1 ] = UPM COMPUTERS[ 4 ] = U COMPUTERS[-4 :-6 :-1 ] = TU COMPUTERS[ 2 :-3 : 1 ] = MPUT COMPUTERS[ 2 :-3 :-1 ] = COMPUTERS[ : :-1 ] = SRETUPMOC COMPUTERS[-5 : ] = UTERS COMPUTERS[-5 : 0 :-1 ] = UPMO COMPUTERS[-5 : :-1 ] = UPMOC COMPUTERS[-1 : 1 :-2 ] = SEUM [Finished in 0.9s]
In [1]: l = list(range(10)) In [2]: l[:5] Out[2]: [0, 1, 2, 3, 4] In [3]: l[-5:] Out[3]: [5, 6, 7, 8, 9]
In [5]: l[:3] == l[0:3] Out[5]: True In [6]: l[7:] == l[7:len(l)] Out[6]: True
In [7]: l[:-1] Out[7]: [0, 1, 2, 3, 4, 5, 6, 7, 8] In [8]: l[-3:] Out[8]: [7, 8, 9]
In [9]: l[:20] Out[9]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] In [11]: l[-20:] Out[11]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [16]: l[2:6] = list( In [17]: l Out[17]: [0, 1, In [18]: l[2:5] = list( In [19]: l Out[19]: [0, 1,
In [14]: l_copy = l[:] In [15]: l == l_copy and l is not l_copy Out[15]: True
In [22]: l = list(range(10)) In [23]: l[::2] Out[23]: [0, 2, 4, 6, 8] In [24]: l[1::2] Out[24]: [1, 3, 5, 7, 9]
In [25]: l[::-1] Out[25]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
In [29]: l = l[::2] In [30]: l Out[30]: [0, 2, 4, 6, 8] In [31]: l = l[1:-1] In [32]: l Out[32]: [2, 4, 6]
+---+---+---+---+---+ | H | e | l | p | A | +---+---+---+---+---+ 0 1 2 3 4 5 -5 -4 -3 -2 -1 str="Name string"
print str[0]=N print str[0:2]=Na print str[0:7]=Name st print str[0:7:2]=Nm t print str[0:-1:2]=Nm ti
+---+---+---+---+---+---+ | P | Y | T | H | O | N | +---+---+---+---+---+---+ 0 1 2 3 4 5
[ start cutting before this index : end cutting before this index ]
| | +---+---|---+---+---|---+ | P | Y | T | H | O | N | +---+---|---+---+---|---+ 0 1 | 2 3 4 | 5
values[1:3] Index 1 through index 3. values[2:-1] Index 2 through index one from last. values[:2] Start through index 2. values[2:] Index 2 through end. values[::2] Start through end, skipping ahead 2 places each time.
def slice(list, start = None, end = None, step = 1): start = 0 if start is None else start end = len(list) if end is None else end start = len(list) + start if start < 0 else start end = len(list) + end if end < 0 else end return [list[i] for i in range(start, end, step)]
A = list(range(1,10,1)) B = list(range(9)) print("This is List A:",A) print("This is List B:",B)
from functools import wraps def makebold(fn): @wraps(fn) def wrapped(): return "<b>" + fn() + "</b>" return wrapped def makeitalic(fn): @wraps(fn) def wrapped(): return "<i>" + fn() + "</i>" return wrapped @makebold @makeitalic def hello(): return "hello world" print hello() print hello.__name__
def shout(word="yes"): return word.capitalize()+"!" print(shout()) scream = shout print(scream()) del shout try: print(shout()) except NameError, e: print(e) print(scream())
def talk(): def whisper(word="yes"): return word.lower()+"..." print(whisper()) talk() try: print(whisper()) except NameError, e: print(e)
def getTalk(kind="shout"): def shout(word="yes"): return word.capitalize()+"!" def whisper(word="yes") : return word.lower()+"..."; if kind == "shout": return shout else: return whisper talk = getTalk() print(talk) print(talk()) print(getTalk("whisper")())
def doSomethingBefore(func): print("I do something before then I call the function you gave me") print(func()) doSomethingBefore(scream)
def my_shiny_new_decorator(a_function_to_decorate): def the_wrapper_around_the_original_function(): print("Before the function runs") a_function_to_decorate() print("After the function runs") return the_wrapper_around_the_original_function def a_stand_alone_function(): print("I am a stand alone function, don a_stand_alone_function() a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function) a_stand_alone_function_decorated()
a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function) a_stand_alone_function()
@my_shiny_new_decorator def another_stand_alone_function(): print("Leave me alone") another_stand_alone_function()
another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)
def bread(func): def wrapper(): print("</ func() print("<\______/>") return wrapper def ingredients(func): def wrapper(): print(" func() print("~salad~") return wrapper def sandwich(food="--ham--"): print(food) sandwich() sandwich = bread(ingredients(sandwich)) sandwich()
@bread @ingredients def sandwich(food="--ham--"): print(food) sandwich()
@ingredients @bread def strange_sandwich(food="--ham--"): print(food) strange_sandwich()
def makebold(fn): def wrapper(): return "<b>" + fn() + "</b>" return wrapper def makeitalic(fn): def wrapper(): return "<i>" + fn() + "</i>" return wrapper @makebold @makeitalic def say(): return "hello" print(say()) def say(): return "hello" say = makebold(makeitalic(say)) print(say())
def a_decorator_passing_arguments(function_to_decorate): def a_wrapper_accepting_arguments(arg1, arg2): print("I got args! Look: {0}, {1}".format(arg1, arg2)) function_to_decorate(arg1, arg2) return a_wrapper_accepting_arguments @a_decorator_passing_arguments def print_full_name(first_name, last_name): print("My name is {0} {1}".format(first_name, last_name)) print_full_name("Peter", "Venkman")
def method_friendly_decorator(method_to_decorate): def wrapper(self, lie): lie = lie - 3 return method_to_decorate(self, lie) return wrapper class Lucy(object): def __init__(self): self.age = 32 @method_friendly_decorator def sayYourAge(self, lie): print("I am {0}, what did you think?".format(self.age + lie)) l = Lucy() l.sayYourAge(-3)
def a_decorator_passing_arbitrary_arguments(function_to_decorate): def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs): print("Do I have args?:") print(args) print(kwargs) function_to_decorate(*args, **kwargs) return a_wrapper_accepting_arbitrary_arguments @a_decorator_passing_arbitrary_arguments def function_with_no_argument(): print("Python is cool, no argument here.") function_with_no_argument() @a_decorator_passing_arbitrary_arguments def function_with_arguments(a, b, c): print(a, b, c) function_with_arguments(1,2,3) @a_decorator_passing_arbitrary_arguments def function_with_named_arguments(a, b, c, platypus="Why not ?"): print("Do {0}, {1} and {2} like platypus? {3}".format(a, b, c, platypus)) function_with_named_arguments("Bill", "Linus", "Steve", platypus="Indeed!") class Mary(object): def __init__(self): self.age = 31 @a_decorator_passing_arbitrary_arguments def sayYourAge(self, lie=-3): print("I am {0}, what did you think?".format(self.age + lie)) m = Mary() m.sayYourAge()
def my_decorator(func): print("I am an ordinary function") def wrapper(): print("I am function returned by the decorator") func() return wrapper def lazy_function(): print("zzzzzzzz") decorated_function = my_decorator(lazy_function) @my_decorator def lazy_function(): print("zzzzzzzz")
def decorator_maker(): print("I make decorators! I am executed only once: " "when you make me create a decorator.") def my_decorator(func): print("I am a decorator! I am executed only when you decorate a function.") def wrapped(): print("I am the wrapper around the decorated function. " "I am called when you call the decorated function. " "As the wrapper, I return the RESULT of the decorated function.") return func() print("As the decorator, I return the wrapped function.") return wrapped print("As a decorator maker, I return a decorator") return my_decorator new_decorator = decorator_maker() def decorated_function(): print("I am the decorated function.") decorated_function = new_decorator(decorated_function) decorated_function()
def decorated_function(): print("I am the decorated function.") decorated_function = decorator_maker()(decorated_function) decorated_function()
@decorator_maker() def decorated_function(): print("I am the decorated function.") decorated_function()
def decorator_maker_with_arguments(decorator_arg1, decorator_arg2): print("I make decorators! And I accept arguments: {0}, {1}".format(decorator_arg1, decorator_arg2)) def my_decorator(func): print("I am the decorator. Somehow you passed me arguments: {0}, {1}".format(decorator_arg1, decorator_arg2)) def wrapped(function_arg1, function_arg2) : print("I am the wrapper around the decorated function.\n" "I can access all the variables\n" "\t- from the decorator: {0} {1}\n" "\t- from the function call: {2} {3}\n" "Then I can pass them to the decorated function" .format(decorator_arg1, decorator_arg2, function_arg1, function_arg2)) return func(function_arg1, function_arg2) return wrapped return my_decorator @decorator_maker_with_arguments("Leonard", "Sheldon") def decorated_function_with_arguments(function_arg1, function_arg2): print("I am the decorated function and only knows about my arguments: {0}" " {1}".format(function_arg1, function_arg2)) decorated_function_with_arguments("Rajesh", "Howard")
c1 = "Penny" c2 = "Leslie" @decorator_maker_with_arguments("Leonard", c1) def decorated_function_with_arguments(function_arg1, function_arg2): print("I am the decorated function and only knows about my arguments:" " {0} {1}".format(function_arg1, function_arg2)) decorated_function_with_arguments(c2, "Howard")
def decorator_with_args(decorator_to_enhance): def decorator_maker(*args, **kwargs): def decorator_wrapper(func): return decorator_to_enhance(func, *args, **kwargs) return decorator_wrapper return decorator_maker
@decorator_with_args def decorated_decorator(func, *args, **kwargs): def wrapper(function_arg1, function_arg2): print("Decorated with {0} {1}".format(args, kwargs)) return func(function_arg1, function_arg2) return wrapper @decorated_decorator(42, 404, 1024) def decorated_function(function_arg1, function_arg2): print("Hello {0} {1}".format(function_arg1, function_arg2)) decorated_function("Universe and", "everything")
def foo(): print("foo") print(foo.__name__) def bar(func): def wrapper(): print("bar") return func() return wrapper @bar def foo(): print("foo") print(foo.__name__) import functools def bar(func): @functools.wraps(func) def wrapper(): print("bar") return func() return wrapper @bar def foo(): print("foo") print(foo.__name__)
def benchmark(func): import time def wrapper(*args, **kwargs): t = time.clock() res = func(*args, **kwargs) print("{0} {1}".format(func.__name__, time.clock()-t)) return res return wrapper def logging(func): """ A decorator that logs the activity of the script. (it actually just prints it, but it could be logging!) """ def wrapper(*args, **kwargs): res = func(*args, **kwargs) print("{0} {1} {2}".format(func.__name__, args, kwargs)) return res return wrapper def counter(func): def wrapper(*args, **kwargs): wrapper.count = wrapper.count + 1 res = func(*args, **kwargs) print("{0} has been used: {1}x".format(func.__name__, wrapper.count)) return res wrapper.count = 0 return wrapper @counter @benchmark @logging def reverse_string(string): return str(reversed(string)) print(reverse_string("Able was I ere I saw Elba")) print(reverse_string("A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!"))
@counter @benchmark @logging def get_random_futurama_quote(): from urllib import urlopen result = urlopen("http: try: value = result.split("<br><b><hr><br>")[1].split("<br><br><hr>")[0] return value.strip() except: return "No, I print(get_random_futurama_quote()) print(get_random_futurama_quote())
from functools import wraps def wrap_in_tag(tag): def factory(func): @wraps(func) def decorator(): return { return decorator return factory
makebold = wrap_in_tag( makeitalic = wrap_in_tag( @makebold @makeitalic def say(): return
from functools import wraps def wrap_in_tag(tag): def factory(func): @wraps(func) def decorator(val): return func( { return decorator return factory
@wrap_in_tag( @wrap_in_tag( def say(val): return val say(
def makebold(f): return lambda: "<b>" + f() + "</b>" def makeitalic(f): return lambda: "<i>" + f() + "</i>" @makebold @makeitalic def say(): return "Hello" print say()
def makeitalic(fn): def newFunc(): return "<i>" + fn() + "</i>" return newFunc
class foo: def bar(self): print "hi" def foobar(self): print "hi again"
def addDashes(fn): def newFunction(self): print "---" fn(self) print "---" return newFunction
class foo: @addDashes def bar(self): print "hi" @addDashes def foobar(self): print "hi again"
from functools import wraps def makebold(fn): @wraps(fn) def wrapped(*args, **kwargs): return "<b>" + fn(*args, **kwargs) + "</b>" return wrapped def makeitalic(fn): @wraps(fn) def wrapped(*args, **kwargs): return "<i>" + fn(*args, **kwargs) + "</i>" return wrapped @makebold @makeitalic def say(): return print(say())
def html_deco(tag): def decorator(fn): @wraps(fn) def wrapped(*args, **kwargs): return return wrapped return decorator @html_deco( @html_deco( def greet(whom= return print(greet(
makebold = html_deco( makeitalic = html_deco( @makebold @makeitalic def greet(whom= return print(greet(
makebolditalic = lambda fn: makebold(makeitalic(fn)) @makebolditalic def greet(whom= return print(greet(
def multi_html_deco(*tags): start_tags, end_tags = [], [] for tag in tags: start_tags.append( end_tags.append( start_tags = end_tags = def decorator(fn): @wraps(fn) def wrapped(*args, **kwargs): return start_tags + fn(*args, **kwargs) + end_tags return wrapped return decorator makebolditalic = multi_html_deco( @makebolditalic def greet(whom= return print(greet(
class bol(object): def __init__(self, f): self.f = f def __call__(self): return "<b>{}</b>".format(self.f()) class ita(object): def __init__(self, f): self.f = f def __call__(self): return "<i>{}</i>".format(self.f()) @bol @ita def sayhi(): return
class sty(object): def __init__(self, tag): self.tag = tag def __call__(self, f): def newf(): return "<{tag}>{res}</{tag}>".format(res=f(), tag=self.tag) return newf @sty( @sty( def sayhi(): return
def makeitalic(fn): return lambda: def makebold(fn): return lambda:
>>> say.__closure__[0].cell_contents <function <lambda> at 0x4ACFA030> >>> say.__closure__[0].cell_contents.__closure__[0].cell_contents <function say at 0x4ACFA730>
from functools import wraps def makeitalic(fn): @wraps(fn) def wrapped(*args, **kwargs): return return wrapped def makebold(fn): @wraps(fn) def wrapped(*args, **kwargs): return return wrapped
>>> say <function say at 0x14BB8F70> >>> help(say) Help on function say in module __main__: say(*args, **kwargs) This function returns a bolded, italicized
def deco(func): def inner(letter): return func(letter).upper() return inner
def makeHtmlTag(tag, *args, **kwds): def real_decorator(fn): css_class = " class= if "css_class" in kwds else "" def wrapped(*args, **kwds): return "<"+tag+css_class+">" + fn(*args, **kwds) + "</"+tag+">" return wrapped return real_decorator @makeHtmlTag(tag="b", css_class="bold_css") @makeHtmlTag(tag="i", css_class="italic_css") def hello(): return "hello world" print hello()
class makeHtmlTagClass(object): def __init__(self, tag, css_class=""): self._tag = tag self._css_class = " class= if css_class != "" else "" def __call__(self, fn): def wrapped(*args, **kwargs): return "<" + self._tag + self._css_class+">" \ + fn(*args, **kwargs) + "</" + self._tag + ">" return wrapped @makeHtmlTagClass(tag="b", css_class="bold_css") @makeHtmlTagClass(tag="i", css_class="italic_css") def hello(name): return "Hello, {}".format(name) print hello("Your name")
def counter(func): def wrapped(*args, **kws): print wrapped.count += 1 return func(*args, **kws) wrapped.count = 0 return wrapped
# # def bold(fn): def decorate(): return "<b>" + fn() + "</b>" return decorate def uk(fn): def decorate(): fields = fn().split( date = fields[1] + "/" + fields[0] + "/" + fields[2] return date return decorate import datetime def getDate(): now = datetime.datetime.now() return "%d/%d/%d" % (now.day, now.month, now.year) @bold def getBoldDate(): return getDate() @uk def getUkDate(): return getDate() @bold @uk def getBoldUkDate(): return getDate() print getDate() print getBoldDate() print getUkDate() print getBoldUkDate() print bold(uk(getDate))()
17/6/2013 <b>17/6/2013</b> 6/17/2013 <b>6/17/2013</b> <b>6/17/2013</b>
def frame_tests(fn): def wrapper(*args): print "\nStart: %s" %(fn.__name__) fn(*args) print "End: %s\n" %(fn.__name__) return wrapper @frame_tests def test_fn1(): print "This is only a test!" @frame_tests def test_fn2(s1): print "This is only a test! %s" %(s1) @frame_tests def test_fn3(s1, s2): print "This is only a test! %s %s" %(s1, s2) if __name__ == "__main__": test_fn1() test_fn2( test_fn3(
Start: test_fn1 This is only a test! End: test_fn1 Start: test_fn2 This is only a test! OK! End: test_fn2 Start: test_fn3 This is only a test! OK! Just a test! End: test_fn3
from abc import ABCMeta, abstractclassmethod class Decorator(metaclass=ABCMeta): def __init__(self): self.method = None def __call__(self, method): self.method = method return self.call @abstractclassmethod def call(self, *args, **kwargs): return self.method(*args, **kwargs)
class MakeBold(Decorator): def call(): return "<b>" + self.method() + "</b>" class MakeItalic(Decorator): def call(): return "<i>" + self.method() + "</i>" @MakeBold() @MakeItalic() def say(): return "Hello"
class ApplyRecursive(Decorator): def __init__(self, *types): super().__init__() if not len(types): types = (dict, list, tuple, set) self._types = types def call(self, arg): if dict in self._types and isinstance(arg, dict): return {key: self.call(value) for key, value in arg.items()} if set in self._types and isinstance(arg, set): return set(self.call(value) for value in arg) if tuple in self._types and isinstance(arg, tuple): return tuple(self.call(value) for value in arg) if list in self._types and isinstance(arg, list): return list(self.call(value) for value in arg) return self.method(arg) @ApplyRecursive(tuple, set, dict) def double(arg): return 2*arg print(double(1)) print(double({ print(double({1, 2, 3})) print(double((1, 2, 3, 4))) print(double([1, 2, 3, 4, 5]))
2 { {2, 4, 6} (2, 4, 6, 8) [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
>>> print(list.index.__doc__) L.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present.
>>> import timeit >>> timeit.timeit( 9.356267921015387 >>> timeit.timeit( 0.0004404920036904514
>>> [1, 1].index(1) 0 >>> [i for i, e in enumerate([1, 2, 1]) if e == 1] [0, 2] >>> g = (i for i, e in enumerate([1, 2, 1]) if e == 1) >>> next(g) 0 >>> next(g) 2
>>> [1, 1].index(2) Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: 2 is not in list
>>> help(["foo", "bar", "baz"]) Help on list object: class list(object) ... | | index(...) | L.index(value, [start, [stop]]) -> integer -- return first index of value |
from itertools import izip as zip, count [i for i, j in zip(count(), [
$ python -m timeit -s "from itertools import izip as zip, count" "[i for i, j in zip(count(), [ 10000 loops, best of 3: 174 usec per loop $ python -m timeit "[i for i, j in enumerate([ 10000 loops, best of 3: 196 usec per loop
def all_indices(value, qlist): indices = [] idx = -1 while True: try: idx = qlist.index(value, idx+1) indices.append(idx) except ValueError: break return indices all_indices("foo", ["foo","bar","baz","foo"])
def find_element_in_list(element, list_element): try: index_element = list_element.index(element) return index_element except ValueError: return None
a = ["foo","bar","baz", indexes = [index for index in range(len(a)) if a[index] ==
[i for i in range(len(mylist)) if mylist[i]==myterm] [each for each in mylist if each==myterm] mylist.index(myterm) if myterm in mylist else None
import numpy as np array = [1, 2, 1, 3, 4, 5, 1] item = 1 np_array = np.array(array) item_index = np.where(np_array==item) print item_index
def index(a_list, value): try: return a_list.index(value) except ValueError: return None
result = index(a_list, value) if result is not None: do_something(result)
>>> [index for index, v in enumerate(l) if v == [1, 3] >>> [index for index, v in enumerate(l) if v == []
indexes = [index for index, v in enumerate(l) if v == for index in indexes: do_something(index)
>>> import pandas as pd >>> series = pd.Series(l) >>> series 0 foo 1 bar 2 baz 3 bar dtype: object
>>> series == 0 False 1 True 2 False 3 True dtype: bool
>>> [i for i, value in enumerate(l) if value == [1, 3]
get_indexes = lambda x, xs: [i for (y, i) in zip(xs, range(len(xs))) if x == y] print get_indexes(2, [1, 2, 3, 4, 5, 6, 3, 2, 3, 2]) print get_indexes(
a = [[ b = [ res = [[x[0] for x in a].index(y) for y in b]
>>> a = [ >>> b = >>> offset = 0; >>> indices = list() >>> for i in range(a.count(b)): ... indices.append(a.index(b,offset)) ... offset = indices[-1]+1 ... >>> indices [0, 3] >>>
>>> a = [ >>> l = dict(zip(set(a), map(lambda y: [i for i,z in enumerate(a) if z is y ], set(a)))) >>> l[ [0, 5] >>> l [ [6] >>> l { >>>
def indices(l, val): retval = [] last = 0 while val in l[last:]: i = l[last:].index(val) retval.append(last + i) last += i + 1 return retval l = [ q = print indices(l,q) print indices(l, print indices(
Python 2.7.6 (v2.7.6:3a1db0d2747e, Nov 10 2013, 00:42:54) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> def indices(the_list, val): ... ... retval = [] ... last = 0 ... while val in the_list[last:]: ... i = the_list[last:].index(val) ... retval.append(last + i) ... last += i + 1 ... return retval ... >>> l = [ >>> q = >>> print indices(l,q) [0, 2, 4, 5] >>> print indices(l, [] >>> print indices( [0, 4, 5, 7] >>>
def indices(l, val): return [index for index, value in enumerate(l) if value == val] l = [ q = print indices(l,q) print indices(l, print indices(
Python 2.7.14 |Anaconda, Inc.| (default, Dec 7 2017, 11:07:58) [GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> def indices(l, val): ... ... return [index for index, value in enumerate(l) if value == val] ... >>> l = [ >>> q = >>> print indices(l,q) [0, 2, 4, 5] >>> print indices(l, [] >>> print indices( [0, 4, 5, 7] >>>
>>> alist = [ >>> foo_indexes = [n for n,x in enumerate(alist) if x== >>> foo_indexes [0, 3] >>>
def indexlist(item2find, list_or_string): "Returns all indexes of an item in a list or a string" return [n for n,item in enumerate(list_or_string) if item==item2find] print(indexlist("1", "010101010"))
for n, i in enumerate([1, 2, 3, 4, 1]): if i == 1: print(n)
def find_element(p,t): i = 0 for e in p: if e == t: return i else: i +=1 return -1
name ="bar" list = [["foo", 1], ["bar", 2], ["baz", 3]] new_list=[] for item in list: new_list.append(item[0]) print(new_list) try: location= new_list.index(name) except: location=-1 print (location)
>>> [i for i,j in zip(range(len(haystack)), haystack) if j ==
list(filter(lambda x: x[1]=="bar",enumerate(["foo", "bar", "baz", "bar", "baz", "bar", "a", "b", "c"])))
def get_index_of(lst, element): return list(map(lambda x: x[0],\ (list(filter(lambda x: x[1]==element, enumerate(lst))))))
try: index = array.index( except ValueError: index = -1
li=[10,20,30,20,40, 50, 10] [i for i, e in enumerate(li) if e == 20]
mylist = ["foo", "bar", "baz", "bar"] newlist = enumerate(mylist) for index, item in newlist: if item == "bar": print(index, item)
myList = ["foo", "bar", "baz"] myDict = dict((e,i) for i,e in enumerate(myList)) myDict["bar"]
from collections import defaultdict as dd myList = ["foo", "bar", "bar", "baz", "foo"] myDict = dd(list) for i,e in enumerate(myList): myDict[e].append(i) myDict["foo"]
import more_itertools as mit iterable = ["foo", "bar", "baz", "ham", "foo", "bar", "baz"]
list(mit.locate(iterable, lambda x: x in {"bar", "ham"}))
import numpy as np lst = ["foo", "bar", "baz"] print np.where( np.array(lst) == >>> 1
d = dict() for i in xrange(100): key = i % 10 if key in d: d[key] += 1 else: d[key] = 1
d = dict() for i in xrange(100): key = i % 10 d[key] = d.get(key, 0) + 1
from collections import defaultdict d = defaultdict(lambda: 0) for i in xrange(100): d[i % 10] += 1
>>> d = { >>> q = d.setdefault( >>> print q bar >>> print d { >>> r = d.setdefault( >>> print r 18 >>> print d {
try: my_dict_of_items[key_i_want_to_check] except KeyError: else:
mydict = {"a": 5} print mydict["a"] print mydict["b"] print mydict.get("a", 0) print mydict.get("b", 0)
>>> temp = {} >>> help(temp.__contains__) Help on built-in function __contains__: __contains__(key, /) method of builtins.dict instance True if D has a key k, else False.
d={1: try: needed=d[3] print(needed) except: print("Key doesnt exist")
st = d = {} try: print d[ except Exception, e: print
def checkKey(dict, key): if key in dict.keys(): print("Key is here, ", end =" ") print("value =", dict[key]) else: print("Key isn
dict = { key = checkKey(dict, key) key = checkKey(dict, key)
def checkKey(dict, key): if key in dict: print("Key is here, ", end =" ") print("value =", dict[key]) else: print("Key isn
dict = { key = checkKey(dict, key) key = checkKey(dict, key)
def checkKey(dict, key): if dict.has_key(key): print "Key is here, value =", dict[key] else: print "Key isn
dict = { key = checkKey(dict, key) key = checkKey(dict, key)
for key in dict.iterkeys(): ... for value in dict.itervalues(): ... for key, value in dict.iteritems(): ...
d = { for the_key, the_value in d.iteritems(): print the_key,
d = { for the_key, the_value in d.items(): print(the_key,
d = { for i, (key, value) in enumerate(d.items()): print(i, key, value)
>>> d.__iter__() <dict_keyiterator object at 0x7fb1747bee08>
>>> key_iterator = iter(d) >>> key_iterator <dict_keyiterator object at 0x7fb172fa9188>
>>> next(key_iterator) >>> next(key_iterator) >>> next(key_iterator) >>> next(key_iterator) Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration
>>> list(key_iterator) [] >>> new_key_iterator = iter(d) >>> list(new_key_iterator) [
>>> for each_key in d: ... print(each_key, ... x => 1 y => 2 z => 3
>>> list(d.values()) [1, 2, 3] >>> list(d.items()) [(
for a_key, corresponding_value in d.items(): print(a_key, corresponding_value)
_PyDict_Next(PyObject *op, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue, Py_hash_t *phash)
for key in my_dict: my_dict[key+"-1"] = my_dict[key]-1
l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] reduce(lambda x, y: x.extend(y), l)
Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 1, in <lambda> AttributeError:
flat_list = [item for sublist in l for item in sublist]
for sublist in l: for item in sublist: flat_list.append(item)
flatten = lambda l: [item for sublist in l for item in sublist]
$ python -mtimeit -s 10000 loops, best of 3: 143 usec per loop $ python -mtimeit -s 1000 loops, best of 3: 969 usec per loop $ python -mtimeit -s 1000 loops, best of 3: 1.1 msec per loop
>>> import itertools >>> list2d = [[1,2,3],[4,5,6], [7], [8,9]] >>> merged = list(itertools.chain(*list2d))
>>> import itertools >>> list2d = [[1,2,3],[4,5,6], [7], [8,9]] >>> merged = list(itertools.chain.from_iterable(list2d))
[me@home]$ python -mtimeit -s 10000 loops, best of 3: 24.2 usec per loop [me@home]$ python -mtimeit -s 10000 loops, best of 3: 45.2 usec per loop [me@home]$ python -mtimeit -s 1000 loops, best of 3: 488 usec per loop [me@home]$ python -mtimeit -s 1000 loops, best of 3: 522 usec per loop [me@home]$ python --version Python 2.7.3
import functools import itertools import numpy import operator import perfplot def forfor(a): return [item for sublist in a for item in sublist] def sum_brackets(a): return sum(a, []) def functools_reduce(a): return functools.reduce(operator.concat, a) def functools_reduce_iconcat(a): return functools.reduce(operator.iconcat, a, []) def itertools_chain(a): return list(itertools.chain.from_iterable(a)) def numpy_flat(a): return list(numpy.array(a).flat) def numpy_concatenate(a): return list(numpy.concatenate(a)) perfplot.show( setup=lambda n: [list(range(10))] * n, kernels=[ forfor, sum_brackets, functools_reduce, functools_reduce_iconcat, itertools_chain, numpy_flat, numpy_concatenate ], n_range=[2**k for k in range(16)], logx=True, logy=True, xlabel= )
from functools import reduce >>> l = [[1,2,3],[4,5,6], [7], [8,9]] >>> reduce(lambda x,y: x+y,l) [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> import operator >>> l = [[1,2,3],[4,5,6], [7], [8,9]] >>> reduce(operator.concat, l) [1, 2, 3, 4, 5, 6, 7, 8, 9]
from collections import Iterable def flatten(items): for x in items: if isinstance(x, Iterable) and not isinstance(x, (str, bytes)): for sub_x in flatten(x): yield sub_x else: yield x
lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] list(flatten(lst)) mixed = [[1, [2]], (3, 4, {5, 6}, 7), 8, "9"] list(flatten(mixed))
>>> timeit.Timer( ).timeit() 20.126545906066895 >>> timeit.Timer( ).timeit() 22.242258071899414 >>> timeit.Timer( ).timeit() 16.449732065200806
>>> timeit.Timer( ).timeit() 2.4598159790039062 >>> timeit.Timer( ).timeit() 1.5289170742034912 >>> timeit.Timer( ).timeit() 1.0598428249359131
>>> from iteration_utilities import deepflatten >>> l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] >>> list(deepflatten(l, depth=1)) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> l = [[1, 2, 3], [4, [5, 6]], 7, [8, 9]] >>> list(deepflatten(l)) [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> from iteration_utilities import flatten >>> l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] >>> list(flatten(l)) [1, 2, 3, 4, 5, 6, 7, 8, 9]
from itertools import chain from functools import reduce from collections import Iterable import operator from iteration_utilities import deepflatten def nested_list_comprehension(lsts): return [item for sublist in lsts for item in sublist] def itertools_chain_from_iterable(lsts): return list(chain.from_iterable(lsts)) def pythons_sum(lsts): return sum(lsts, []) def reduce_add(lsts): return reduce(lambda x, y: x + y, lsts) def pylangs_flatten(lsts): return list(flatten(lsts)) def flatten(items): for x in items: if isinstance(x, Iterable) and not isinstance(x, (str, bytes)): yield from flatten(x) else: yield x def reduce_concat(lsts): return reduce(operator.concat, lsts) def iteration_utilities_deepflatten(lsts): return list(deepflatten(lsts, depth=1)) from simple_benchmark import benchmark b = benchmark( [nested_list_comprehension, itertools_chain_from_iterable, pythons_sum, reduce_add, pylangs_flatten, reduce_concat, iteration_utilities_deepflatten], arguments={2**i: [[0]*5]*(2**i) for i in range(1, 13)}, argument_name= ) b.plot()
>>> list2d = ((1, 2, 3), (4, 5, 6), (7,), (8, 9)) >>> reduce(operator.concat, list2d) (1, 2, 3, 4, 5, 6, 7, 8, 9)
>>> list2d = [[1, 2, 3],[4, 5, 6], [7], [8, 9]] >>> reduce(operator.concat, list2d) [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list2d = [[1, 2, 3],[4, 5, 6], [7], [8, 9]] >>> %timeit list(itertools.chain.from_iterable(list2d)) 1000000 loops, best of 3: 1.36 µs per loop
>>> list2d = ((1, 2, 3),(4, 5, 6), (7,), (8, 9)) >>> %timeit reduce(operator.concat, list2d) 1000000 loops, best of 3: 492 ns per loop
import more_itertools lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] list(more_itertools.flatten(lst))
lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] list(more_itertools.collapse(lst)) lst = [[1, 2, 3], [[4, 5, 6]], [[[7]]], 8, 9] list(more_itertools.collapse(lst))
def flatten(l, a): for i in l: if isinstance(i, list): flatten(i, a) else: a.append(i) return a print(flatten([[[1, [1,1, [3, [4,5,]]]], 2, 3], [4, 5],6], []))
def list_flatten(l, a=None): if a is None: a = [] for i in l: if isinstance(i, list): list_flatten(i, a) else: a.append(i) return a
In [2]: lst = [1, 2, [3], [[4]],[5,[6]]] In [3]: lst Out[3]: [1, 2, [3], [[4]], [5, [6]]] In [11]: list_flatten(lst) Out[11]: [1, 2, 3, 4, 5, 6]
>>> import numpy as np >>> l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] >>> print (np.concatenate(l)) [1 2 3 4 5 6 7 8 9]
import matplotlib l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] print(list(matplotlib.cbook.flatten(l))) l2 = [[1, 2, 3], [4, 5, 6], [7], [8, [9, 10, [11, 12, [13]]]]] print list(matplotlib.cbook.flatten(l2))
[1, 2, 3, 4, 5, 6, 7, 8, 9] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
Average time over 1000 trials of matplotlib.cbook.flatten: 2.55e-05 sec Average time over 1000 trials of underscore._.flatten: 4.63e-04 sec (time for underscore._)/(time for matplotlib.cbook) = 18.1233394636
flat_list = [item for sublist in l for item in sublist] print(flat_list) [
flat_list = [] _ = [flat_list.extend(item) if isinstance(item, list) else flat_list.append(item) for item in l if item] print(flat_list) [
from underscore import _ _.flatten([[1, 2, 3], [4, 5, 6], [7], [8, 9]])
from underscore import _ _.flatten([1, [2, [3]], [4, 5, 6], [7], [8, 9]])
def flatten(alist): if alist == []: return [] elif type(alist) is not list: return [alist] else: return flatten(alist[0]) + flatten(alist[1:])
from typing import List def flatten(l: list) -> List[int]: """Flatten an arbitrary deep nested list of lists of integers. Examples: >>> flatten([1, 2, [1, [10]]]) [1, 2, 1, 10] Args: l: Union[l, Union[int, List[int]] Returns: Flatted list of integer """ return [int(i.strip(
import numpy l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] * 99 %timeit numpy.concatenate(l).ravel().tolist() 1000 loops, best of 3: 313 µs per loop %timeit numpy.concatenate(l).tolist() 1000 loops, best of 3: 312 µs per loop %timeit [item for sublist in l for item in sublist] 1000 loops, best of 3: 31.5 µs per loop
def concatList(data): results = [] for rec in data: if type(rec) == list: results += rec results = concatList(results) else: results.append(rec) return results
In [38]: concatList(test) Out[38]: Out[60]: [ 92001, 555555555,
>>> from collections import Iterable >>> from six import string_types >>> def flatten(obj): ... for i in obj: ... if isinstance(i, Iterable) and not isinstance(i, string_types): ... yield from flatten(i) ... else: ... yield i >>> list(flatten(obj)) [1, 2, 3, 4, 5, 6,
>>> from functools import reduce >>> from operator import add >>> flatten = lambda lst: [lst] if type(lst) is int else reduce(add, [flatten(ele) for ele in lst]) >>> flatten(l) [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> l2 = [[3, [1, 2], [[[6], 5], 4, 0], 7, [[8]], [9, 10]]] >>> flatten(l2) [3, 1, 2, 6, 5, 4, 0, 7, 8, 9, 10]
alist = [1,[1,2],[1,2,[4,5,6],3, "33"]] newlist = [] while len(alist) > 0 : templist = alist.pop() if type(templist) == type(list()) : while len(templist) > 0 : temp = templist.pop() if type(temp) == type(list()) : for x in temp : templist.append(x) else : newlist.append(temp) else : newlist.append(templist) print(list(reversed(newlist)))
def make_list_flat (l): flist = [] flist.extend ([l]) if (type (l) is not list) else [flist.extend (make_list_flat (e)) for e in l] return flist a = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]] flist = make_list_flat(a) print (flist)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
a = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]] flist = [] def make_list_flat (l): flist.extend ([l]) if (type (l) is not list) else [make_list_flat (e) for e in l] make_list_flat(a) print (flist)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
$ source <venv>/bin/activate C:\> <venv>\Scripts\activate.bat
New python executable in myvirtualenv\Scripts\python.exe Installing setuptools....................................done. Installing pip.........................done.
(myvirtualenv) PATH\TO\YOUR\PROJECT\FOLDER>pip install package_name
[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Python\PythonCore\2.6\InstallPath] @="C:\\Python26\\"
[HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore\2.6\InstallPath] @="C:\\Python26\\"
Step 1: wget https: Step 2: wget https: Step 2: python ez_setup.py Step 3: python get-pip.py
Downloading/unpacking beautifulsoup4 Getting page https: Could not fetch URL https: Will skip URL https:
pip install --trusted-host pypi.python.org --upgrade pip
import time while True: print("This prints once a minute.") time.sleep(60)
import time from itertools import count def buzzergen(period): nexttime = time.time() + period for i in count(): now = time.time() tosleep = nexttime - now if tosleep > 0: time.sleep(tosleep) nexttime += period else: nexttime = now + period yield i, nexttime
from sleepy import buzzergen import time buzzer = buzzergen(3) print time.time() buzzer.next() print time.time() time.sleep(2) buzzer.next() print time.time() time.sleep(5) buzzer.next() print time.time() buzzer.next() print time.time()
1400102636.46 1400102639.46 1400102642.46 1400102647.47 1400102650.47
import random for ring in buzzergen(3): print "now", time.time() print "ring", ring time.sleep(random.choice([0, 2, 4, 6]))
now 1400102751.46 ring (0, 1400102754.461676) now 1400102754.46 ring (1, 1400102757.461676) now 1400102757.46 ring (2, 1400102760.461676) now 1400102760.46 ring (3, 1400102763.461676) now 1400102766.47 ring (4, 1400102769.47115) now 1400102769.47 ring (5, 1400102772.47115) now 1400102772.47 ring (6, 1400102775.47115) now 1400102775.47 ring (7, 1400102778.47115)
>>> def party_time(): ... print( ... >>> sleep(3); party_time() hooray!
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed from time import sleep, time def party_later(kind= sleep(3) return kind + n + def main(): with ProcessPoolExecutor() as proc_executor: with ThreadPoolExecutor() as thread_executor: start_time = time() proc_future1 = proc_executor.submit(party_later, kind= proc_future2 = proc_executor.submit(party_later, kind= thread_future1 = thread_executor.submit(party_later, kind= thread_future2 = thread_executor.submit(party_later, kind= for f in as_completed([ proc_future1, proc_future2, thread_future1, thread_future2,]): print(f.result()) end_time = time() print( if __name__ == main()
thread1 party time!: __main__ thread2 party time!: __main__ proc1 party time!: __mp_main__ proc2 party time!: __mp_main__ total time to execute four 3-sec functions: 3.4519670009613037
>>> from threading import Timer >>> t = Timer(3, party_time, args=None, kwargs=None) >>> t.start() >>> >>> hooray! >>>
import pygame pygame.init() print( pygame.time.wait(5000) print(
import matplotlib print( matplotlib.pyplot.pause(5) print(
import tkinter as tk root = tk.Tk() print( def ohhi(): print( root.after(5000, ohhi) print(
self.wait.until(EC.presence_of_element_located((By.ID,
import time def delay(period= try: time.sleep(period) except: return
import tkinter def tick(): pass root=Tk() delay=100 root.after(delay,tick) root.mainloop()
import asyncio from datetime import datetime @asyncio.coroutine def countdown(iteration_name, countdown_sec): while countdown_sec > 0: print(f yield from asyncio.sleep(1) countdown_sec -= 1 loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(countdown( asyncio.ensure_future(countdown( start_time = datetime.utcnow() loop.run_until_complete(asyncio.wait(tasks)) loop.close() print(f
from threading import Event from time import sleep delay_in_sec = 2 sleep(delay_in_sec) print(f Event().wait(delay_in_sec) print(f
from threading import Timer delay_in_sec = 2 def hello(delay_in_sec): print(f t = Timer(delay_in_sec, hello, [delay_in_sec]) t.start() print("Started")
import time for i in range(2): print( time.sleep(.500) print(
import time def delay(seconds): return time.sleep(seconds) delay(2.5)
log(INFO, "I am in the weird function and a is", a, "and b is", b, "but I got a null C — using default", default_c)
[moshe is, 3, hello world, this is a list, oh I don
>>> class Sic(object): pass ... >>> print str(Sic()) <__main__.Sic object at 0x8b7d0> >>> print repr(Sic()) <__main__.Sic object at 0x8b7d0> >>>
>>> class Sic(object): ... def __repr__(object): return ... >>> print str(Sic()) foo >>> print repr(Sic()) foo >>> class Sic(object): ... def __str__(object): return ... >>> print str(Sic()) foo >>> print repr(Sic()) <__main__.Sic object at 0x2617f0> >>>
>>> s="""w >>> repr(s) >>> str(s) >>> eval(str(s))==s Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1 w ^ SyntaxError: EOL while scanning single-quoted string >>> eval(repr(s))==s True
>>> import datetime >>> today = datetime.datetime.now() >>> str(today) >>> repr(today)
repr(...) repr(object) -> string Return the canonical string representation of the object. For most object types, eval(repr(object)) == object.
def __repr__(self): return self.__module__, type(self).__name__, hex(id(self)))
>>> datetime.datetime.now() datetime.datetime(2015, 1, 24, 20, 5, 36, 491180)
>>> print(datetime.datetime.now()) 2015-01-24 20:05:44.977951
>>> the_past = datetime.datetime(2015, 1, 24, 20, 5, 36, 491180) >>> print(the_past) 2015-01-24 20:05:36.491180
def __repr__(self): """Convert to formal string, for repr().""" L = [self._year, self._month, self._day, self._hour, self._minute, self._second, self._microsecond] if L[-1] == 0: del L[-1] if L[-1] == 0: del L[-1] s = ", ".join(map(str, L)) s = "%s(%s)" % ( if self._tzinfo is not None: assert s[-1:] == ")" s = s[:-1] + ", tzinfo=%r" % self._tzinfo + ")" return s
def __str__(self): "Convert to string, for str()." return self.isoformat(sep=
In [38]: str( Out[38]: In [39]: repr( Out[39]: " In [40]: eval(str( Traceback (most recent call last): File "<ipython-input-40-abd46c0c43e7>", line 1, in <module> eval(str( File "<string>", line 1, in <module> NameError: name In [41]: eval(repr( Out[41]:
class Fraction: def __init__(self, num, den): self.__num = num self.__den = den def __str__(self): return def __repr__(self): return f = Fraction(1,2) print( print(
"A basic requirement for a Python object is to provide usable string representations of itself, one used for debugging and logging, another for presentation to end users. That is why the special methods __repr__ and __str__ exist in the data model."
>>> print(decimal.Decimal(23) / decimal.Decimal("1.05")) 21.90476190476190476190476190 >>> decimal.Decimal(23) / decimal.Decimal("1.05") Decimal(
>>> from datetime import datetime >>> from decimal import Decimal >>> print (Decimal( (Decimal( >>> str((Decimal( "(Decimal(
>>> import datetime >>> now = datetime.datetime.now() >>> str(now) >>> repr(now) >>mydate = eval(repr(now))
class Demo: def __repr__(self): return def __str__(self): return demo = Demo() print(demo) s = str(demo) r = repr(demo) import logging logger = logging.getLogger(logging.INFO) logger.info(demo) from pprint import pprint, pformat pprint(demo) result = pformat(demo)
In [30]: str(datetime.datetime.now()) Out[30]: Disguised in string form
In [32]: datetime.datetime.now() Out[32]: datetime.datetime(2017, 12, 7, 15, 43, 27, 297769) Presence in real body which allows to be manipulated directly.
In [33]: datetime.datetime.now() Out[33]: datetime.datetime(2017, 12, 7, 15, 47, 9, 741521) In [34]: datetime.datetime(2017, 12, 7, 15, 47, 9, 741521) - datetime.datetime(2 ...: 017, 12, 7, 15, 43, 27, 297769) Out[34]: datetime.timedelta(0, 222, 443752)
In [35]: TypeError: unsupported operand type(s) for -:
class PassByReference: def __init__(self): self.variable = self.change(self.variable) print(self.variable) def change(self, var): var =
def try_to_change_list_contents(the_list): print( the_list.append( print( outer_list = [ print( try_to_change_list_contents(outer_list) print(
def try_to_change_list_reference(the_list): print( the_list = [ print( outer_list = [ print( try_to_change_list_reference(outer_list) print(
def try_to_change_string_reference(the_string): print( the_string = print( outer_string = print( try_to_change_string_reference(outer_string) print(
def return_a_whole_new_string(the_string): new_string = something_to_do_with_the_old_string(the_string) return new_string my_string = return_a_whole_new_string(my_string)
def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change): new_string = something_to_do_with_the_old_string(stuff_to_change[0]) stuff_to_change[0] = new_string wrapper = [my_string] use_a_wrapper_to_simulate_pass_by_reference(wrapper) do_something_with(wrapper[0])
def __init__(self): self.variable = self.Change(self.variable) def Change(self, var): var =
def __init__(self): self.variable = [ self.Change(self.variable) def Change(self, var): var[0] =
def Change(self, var): var[0] = variable = [ self.Change(variable) print variable[0]
x = [ 2, 4, 4, 5, 5 ] print x def go( li ) : li = [ 5, 6, 7, 8 ] go( x ) print x raw_input(
>>> class PassByReference: ... def __init__(self): ... self.variable = [ ... self.change(self.variable) ... print self.variable ... ... def change(self, var): ... var.append( ... >>> q = PassByReference() [ >>>
>>> def x(y): ... global z ... z = y ... >>> x <function x at 0x00000000020E1730> >>> y Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name >>> z Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name >>> x(2) >>> x <function x at 0x00000000020E1730> >>> y Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name >>> z 2
def test(l): print "Received", l , id(l) l = [0, 0, 0] print "Changed to", l, id(l) l= [1,2,3] print "Original", l, id(l) test(l) print "After", l, id(l)
Original [1, 2, 3] 4454645632 Received [1, 2, 3] 4454645632 Changed to [0, 0, 0] 4474591928 After [1, 2, 3] 4454645632
def change_me(list): list = [1, 2, 3] my_list = [0, 1] change_me(my_list)
class PassByReference: def __init__(self): self.variable = self.Change() print self.variable def Change(self): self.variable =
class PassByReference: def __init__(self): self.variable = self.variable = PassByReference.Change(self.variable) print self.variable @staticmethod def Change(var): var = return var
class PassByReference: def __init__(self, name): self.name = name def changeRef(ref): ref[0] = PassByReference( obj = PassByReference( print obj.name p = [obj] changeRef(p) print p[0].name
a=0 b=0 c=0 def myfunc(a,b,c): a=1 b=2 c=3 return a,b,c a,b,c = myfunc(a,b,c) print a,b,c
def change(wrapper): wrapper(7) x = 5 def setter(val): global x x = val print(x)
class ByRef: def __init__(self, r, w, d): self._read = r self._write = w self._delete = d def set(self, val): self._write(val) def get(self): return self._read() def remove(self): self._delete() wrapped = property(get, set, remove) r = ByRef(get, set, remove) r.wrapped = 15
class ByRef: def __init__(self, locs, name): self._locs = locs self._name = name def set(self, val): self._locs[self._name] = val def get(self): return self._locs[self._name] def remove(self): del self._locs[self._name] wrapped = property(get, set, remove) def change(x): x.wrapped = 7 def test_me(): x = 6 print(x) change(ByRef(locals(), "x")) print(x)
class PassByReferenceIsh: def __init__(self): self.variable = self.change( print self.variable def change(self, var): self.__dict__[var] =
class PassByReference: def __init__(self): self.variable = self.change( print(self.variable) def change(self, var): setattr(self, var, o = PassByReference() assert o.variable ==
class RefsObj(object): "A class which helps to create references to variables." pass ... def change_ref_var(ref_obj): ref_obj.val = 24 ref_obj = RefsObj() ref_obj.val = 1 print(ref_obj.val) change_ref_var(ref_obj) print(ref_obj.val)
>>> foo() [5] >>> foo() [5, 5] >>> foo() [5, 5, 5] >>> foo() [5, 5, 5, 5] >>> foo()
>>> def a(): ... print("a executed") ... return [] ... >>> >>> def b(x=a()): ... x.append(5) ... print(x) ... a executed >>> b() [5] >>> b() [5, 5]
fruits = ("apples", "bananas", "loganberries") def eat(food=fruits): ...
def some_random_function(): global fruits fruits = ("blueberries", "mangos")
class BananaBunch: bananas = [] def addBanana(self, banana): self.bananas.append(banana)
def foo(arg=something_expensive_to_compute())): ...
def make_func(i): return lambda: i funcs = [make_func(i) for i in range(10)]
_undefined = object() def foo(a=_undefined, b=_undefined, c=_undefined) if a is _undefined: a= if b is _undefined: b=100 if c is _undefined: c=[]
>>> func(); func(); func() >>> func.__defaults__ ([5, 5, 5, 5],)
>>> def func(a = []): ... a.append(5) ... return id(a) >>> >>> id(func.__defaults__[0]) == func() True
def x(a=0, b=[], c=[], d=0): a = a + 1 b = b + [1] c.append(1) print a, b, c
def func(a=None, b = None): a_default = lambda: [] b_default = lambda: 2 def actual_func(a=None, b=None): if a is None: a = a_default() if b is None: b = b_default() return actual_func func = func()
def foo(a=[]): a.append(5) return a >>> somevar = [1, 2] >>> foo(somevar) [1, 2, 5] >>> somevar [1, 2, 5]
class Test(object): def __init__(self, var1=[]): self._var1 = var1 somevar = [1, 2] t1 = Test(somevar) t2 = Test(somevar) t1._var1.append([1]) print somevar print t2._var1
>>> def foo(a): a.append(5) print a >>> a = [5] >>> foo(a) [5, 5] >>> foo(a) [5, 5, 5] >>> foo(a) [5, 5, 5, 5] >>> foo(a) [5, 5, 5, 5, 5]
def print_tuple(some_tuple=(1,2,3)): print some_tuple print_tuple() print_tuple((1,2,3))
0 LOAD_GLOBAL 0 (print_tuple) 3 CALL_FUNCTION 0 6 POP_TOP 7 LOAD_CONST 0 (None) 10 RETURN_VALUE
0 LOAD_GLOBAL 0 (print_tuple) 3 LOAD_CONST 4 ((1, 2, 3)) 6 CALL_FUNCTION 1 9 POP_TOP 10 LOAD_CONST 0 (None) 13 RETURN_VALUE
def bar(a=[]): print id(a) a = a + [1] print id(a) return a >>> bar() 4484370232 4484524224 [1] >>> bar() 4484370232 4484524152 [1] >>> bar() 4484370232 4484523720 [1] >>> id(bar.func_defaults[0]) 4484370232
_a_list = [] def foo(mutable_default_argument=_a_list): del _a_list
print( def create_list(): l = [] print( return l print( def example_function(default_kwarg1=create_list()): print( default_kwarg1.append("a") print( print( if __name__ == print( example_function() example_function()
1. Global scope being evaluated 2. example_function about to be compiled to an object 3. list being created and returned, id: 140502758808032 4. example_function compiled: <function example_function at 0x7fc9590905f0> 5. calling example_function twice!: appending "a" in default default_kwarg1 list with id: 140502758808032 - is now: [ appending "a" in default default_kwarg1 list with id: 140502758808032 - is now: [
def example_function_2(default_kwarg=None): if default_kwarg is None: default_kwarg = []
def f(a, L=None): if L is None: L = [] L.append(a) return L
def foo(a, L=None): if L is None: L = [] L.append(a) return L
>>> def bar(b, data=None): ... data = data or [] ... data.append(b) ... return data ... >>> bar(3) [3] >>> bar(3) [3] >>> bar(3) [3] >>> bar(3, [34]) [34, 3] >>> bar(3, [34]) [34, 3]
def foo(list_arg=[5]): return list_arg a = foo() a.append(6) >>> a [5, 6] b = foo() b.append(7) >>> b [5, 6, 7] >>> a.pop() 7
def foo(list_arg=None): if not list_arg: list_arg = [5] return list_arg a = foo() a.append(6) >>> a [5, 6] b = foo() b.append(7) >>> b [5, 7] c = foo([10]) c.append(11) >>> c [10, 11]
singleton = None def use_singleton(): global singleton if singleton is None: singleton = _make_singleton() return singleton.use_me()
def use_singleton(singleton=_make_singleton()): return singleton.use_me()
>>> ivan = [1, 2, 3, 4] >>> foo(a=ivan) [1, 2, 3, 4, 5] >>> ivan [1, 2, 3, 4, 5]
def example(errors=[]): mistake = True if mistake: tryToFixIt(errors) tryToFixItAnotherway(errors) return errors def tryToFixIt(err): err.append( def tryToFixItAnotherway(err): err.append( def main(): for item in range(2): errors = example() print main()
Attempt to fix it Attempt to fix it by another way Attempt to fix it Attempt to fix it by another way
def foo(x, items=None): if items is None: items = [] items.append(x) return items foo(1) foo(2) foo(3)
def foo(x, items=[]): items.append(x) return items foo(1) foo(2,[]) foo(3)
for i in range(10): def callback(): print "clicked button", i UI.Button("button %s" % i, callback)
x=[] for i in range(10): def callback(): print(i) x.append(callback)
def notastonishinganymore(a = []): a = a[:] a.append(5) return a
def name(parameter=defined): ... def name(parameter=None): parameter = [] if parameter is None else parameter ...
>>> def a(): >>> print "a executed" >>> return [] >>> x =a() a executed >>> def b(m=[]): >>> m.append(5) >>> print m >>> b(x) [5] >>> b(x) [5, 5]
>>> import datetime >>> datetime.datetime.now() datetime.datetime(2009, 1, 6, 15, 8, 24, 78915) >>> print(datetime.datetime.now()) 2018-07-29 09:17:13.812189
>>> datetime.datetime.now().time() datetime.time(15, 8, 24, 78915) >>> print(datetime.datetime.now().time()) 09:17:51.914526
>>> from time import gmtime, strftime >>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
>>> from datetime import datetime >>> str(datetime.now())
>>> from datetime import datetime >>> datetime.now().strftime(
>>> datetime.datetime.now() datetime.datetime(2015, 2, 17, 23, 43, 49, 94252) >>> print(datetime.datetime.now()) 2015-02-17 23:43:51.782461
>>> datetime.datetime.utcnow() datetime.datetime(2015, 2, 18, 4, 53, 28, 394163) >>> print(datetime.datetime.utcnow()) 2015-02-18 04:53:31.783988
>>> import pytz >>> then = datetime.datetime.now(pytz.utc) >>> then datetime.datetime(2015, 2, 18, 4, 55, 58, 753949, tzinfo=<UTC>)
>>> datetime.datetime.now(datetime.timezone.utc) datetime.datetime(2015, 2, 18, 22, 31, 56, 564191, tzinfo=datetime.timezone.utc)
>>> print(then) 2015-02-18 04:55:58.753949+00:00 >>> print(then.astimezone(pytz.timezone( 2015-02-17 23:55:58.753949-05:00
>>> pytz.utc.localize(datetime.datetime.utcnow()) datetime.datetime(2015, 2, 18, 6, 6, 29, 32285, tzinfo=<UTC>) >>> datetime.datetime.utcnow().replace(tzinfo=pytz.utc) datetime.datetime(2015, 2, 18, 6, 9, 30, 728550, tzinfo=<UTC>)
>>> from time import gmtime, strftime >>> strftime("%a, %d %b %Y %X +0000", gmtime())
In [2]: from time import ctime In [3]: ctime() Out[3]:
import datetime print(datetime.datetime.now().strftime(
import time print(time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime()))
>>> import datetime >>> now = datetime.datetime.now() >>> datetime.time(now.hour, now.minute, now.second) datetime.time(11, 23, 44)
>>> import datetime >>> datetime.datetime.now().isoformat()
import requests from lxml import html page = requests.get( tree = html.fromstring(page.content) print(tree.xpath(
>>>from time import strftime >>>strftime("%m/%d/%Y %H:%M") 01/09/2015 13:11
import pandas as pd print (pd.datetime.now()) print (pd.datetime.now().date()) print (pd.datetime.now().year) print (pd.datetime.now().month) print (pd.datetime.now().day) print (pd.datetime.now().hour) print (pd.datetime.now().minute) print (pd.datetime.now().second) print (pd.datetime.now().microsecond)
2017-09-22 12:44:56.092642 2017-09-22 2017 9 22 12 44 56 92693
import datetime date_time = datetime.datetime.now() date = date_time.date() time = date_time.time() print date.year, date.month, date.day print time.hour, time.minute, time.second, time.microsecond
from datetime import datetime utc_time = datetime.utcnow() print(utc_time)
from datetime import datetime, timezone now = datetime.now(timezone.utc).astimezone() print(now)
import time print time.strftime("%d/%m/%Y") >>> 06/02/2015
>>> import datetime, time >>> time = strftime("%H:%M:%S:%MS", time.localtime()) >>> print time
import time, datetime print(datetime.datetime.now().time()) print(datetime.datetime.now().time().isoformat()) print(datetime.datetime.now().time().strftime( print(time.strftime("%H:%M:%S.%f", time.localtime()), str)
import time time.strftime("%H:%M:%S", time.localtime()) +
def get_time_str(decimal_points=3): return time.strftime("%H:%M:%S", time.localtime()) +
import datetime currentDT = datetime.datetime.now() print (str(currentDT))
from time import ctime print ctime().split()[0] print ctime().split()[1] print ctime().split()[2] print ctime().split()[3] print ctime().split()[4]
import timeit start_time = timeit.default_timer() do_stuff_you_want_to_measure() end_time = timeit.default_timer() print("Elapsed time: {}".format(end_time - start_time))
>>> import pendulum >>> print(pendulum.now()) 2018-08-14T05:29:28.315802+10:00 >>> print(pendulum.utcnow()) 2018-08-13T19:29:35.051023+00:00
>>> print(pendulum.now().timezone_name) Australia/Melbourne >>>
def gettime(): from datetime import datetime return ((str(datetime.now())).split(
def gethour(): from datetime import datetime return return (((str(datetime.now())).split(
def getminute(): from datetime import datetime return (((str(datetime.now())).split(
def getsecond(): from datetime import datetime return (((str(datetime.now())).split(
def getmillisecond(): from datetime import datetime return return (str(datetime.now())).split(
from datetime import datetime import pytz JST = pytz.timezone("Asia/Tokyo") local_time = JST.fromutc(datetime.utcnow())
import datetime date_time = str(datetime.datetime.now()) date = date_time.split()[0] time = date_time.split()[1]
try: except IDontLikeYouException: except YouAreTooShortException:
try: except IDontLikeYouException: except YouAreBeingMeanException:
try: except IDontLikeYouException, YouAreBeingMeanException:
except (IDontLikeYouException, YouAreBeingMeanException) as e: pass
except (IDontLikeYouException, YouAreBeingMeanException), e: pass
try: may_raise_specific_errors(): except (SpecificErrorOne, SpecificErrorTwo) as error: handle(error)
try: mainstuff() except (KeyboardInterrupt, EOFError): quit(0)
try: mainstuff() except (KeyboardInterrupt, EOFError) as err: print(err) print(err.args) quit(0)
try: mainstuff() except (KeyboardInterrupt, EOFError), err: print err print err.args quit(0)
try: do_something() except (IDontLikeYouException, YouAreBeingMeanException) as e: pass
from contextlib import suppress with suppress(IDontLikeYouException, YouAreBeingMeanException): do_something()
except (IDontLikeYouException, YouAreBeingMeanException), e: print e
ConnectErrs = (URLError, SSLError, SocketTimeoutError, BadStatusLine, ConnectionResetError) def connect(url, data): return(received_data) def some_function(var_a, var_b, ...): try: o = connect(url, data) except ConnectErrs as e: blah
try: You do your operations here; ...................... except(Exception1[, Exception2[,...ExceptionN]]]): If there is any exception from the given exception list, then execute this block. ...................... else: If there is no exception then execute this block.
try: You do your operations here; ...................... except Exception1: functionname(parameterList) except Exception2: functionname(parameterList) except Exception3: functionname(parameterList) else: If there is no exception then execute this block. def functionname( parameters ): return [expression]
try: raise ValueError("hello") except (RuntimeError, ValueError, KeyError) as a: print a
class Base(object): def __init__(self): print "Base created" class ChildA(Base): def __init__(self): Base.__init__(self) class ChildB(Base): def __init__(self): super(ChildB, self).__init__() ChildA() ChildB()
class ChildB(Base): def __init__(self): super().__init__()
class ChildA(Base): def __init__(self): Base.__init__(self) class ChildB(Base): def __init__(self): super(ChildB, self).__init__()
class ChildB(Base): def __init__(self): mro = type(self).mro() check_next = mro.index(ChildB) + 1 while check_next < len(mro): next_class = mro[check_next] if next_class.__init__(self) break check_next += 1
class ChildB(Base): def __init__(self): mro = type(self).mro() for next_class in mro[mro.index(ChildB) + 1:]: if hasattr(next_class, next_class.__init__(self) break
class Base(object): def __init__(self): print("Base init class ChildA(Base): def __init__(self): print("ChildA init Base.__init__(self) class ChildB(Base): def __init__(self): print("ChildB init super(ChildB, self).__init__()
class UserDependency(Base): def __init__(self): print("UserDependency init super(UserDependency, self).__init__()
class UserA(ChildA, UserDependency): def __init__(self): print("UserA init super(UserA, self).__init__() class UserB(ChildB, UserDependency): def __init__(self): print("UserB init super(UserB, self).__init__()
>>> UserA() UserA init ChildA init Base init <__main__.UserA object at 0x0000000003403BA8>
>>> UserB() UserB init ChildB init UserDependency init Base init <__main__.UserB object at 0x0000000003403438>
>>> class Polygon(object): ... def __init__(self, id): ... self.id = id ... >>> class Rectangle(Polygon): ... def __init__(self, id, width, height): ... super(self.__class__, self).__init__(id) ... self.shape = (width, height) ... >>> class Square(Rectangle): ... pass ... >>> Square( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 3, in __init__ TypeError: __init__() missing 2 required positional arguments:
class Polygon(object): def __init__(self, id): self.id = id class Rectangle(Polygon): def __init__(self, id, width, height): super(self.__class__, self).__init__(id) self.shape = (width, height) class Square(Rectangle): pass
class Mixin(Base): def __init__(self): print "Mixin stuff" super(Mixin, self).__init__() class ChildC(ChildB, Mixin): pass ChildC() help(ChildC)
>>> x = {1:2} >>> print x {1: 2} >>> x.update({3:4}) >>> print x {1: 2, 3: 4}
data = { data = dict(a=1, b=2, c=3) data = {k: v for k, v in ((
data[ data.update({ data.update(dict(a=1)) data.update(a=1)
for key in data: for key, value in d.items(): for key in d.keys(): for value in d.values():
>>> d = {} >>> d.__setitem__( >>> d { >>> def f(): ... d = {} ... for i in xrange(100): ... d[ ... >>> def g(): ... d = {} ... for i in xrange(100): ... d.__setitem__( ... >>> import timeit >>> number = 100 >>> min(timeit.repeat(f, number=number)) 0.0020880699157714844 >>> min(timeit.repeat(g, number=number)) 0.005071878433227539
dictionary = {} dictionary["new key"] = "some new entry" dictionary["dictionary_within_a_dictionary"] = {} dictionary["dictionary_within_a_dictionary"]["sub_dict"] = {"other" : "dictionary"} print (dictionary)
c = dict( a, **b ) c = dict( list(a.items()) + list(b.items()) ) c = dict( i for d in [a,b] for i in d.items() )
def functional_dict_add( dictionary, key, value ): temp = dictionary.copy() temp[key] = value return temp c = functional_dict_add( a,
class myDict(dict): def __init__(self): self = dict() def add(self, key, value): self[key] = value myd = myDict() myd.add( myd.add( print(myd)
params = { new_params = params.copy() new_params.update({
try: value = my_dict[key] except KeyError: value = my_dict[key] = default
>>> mydict = { >>> mydict.setdefault( 4 >>> print(mydict) { >>> mydict.setdefault( 1 >>> print(mydict) {
import timeit timeit.timeit( >> 0.49582505226135254 timeit.timeit( >> 0.20782899856567383
import android droid = android.Android() code = droid.scanBarcode() isbn = int(code[ url = "http: droid.startActivity(
from android import Android droid = Android() droid.ttsSpeak(
let droid = new Android(); droid.ttsSpeak("hello from js");
import copy class Foo(object): def __init__(self, val): self.val = val def __repr__(self): return str(self.val) foo = Foo(1) a = [ b = a.copy() c = a[:] d = list(a) e = copy.copy(a) f = copy.deepcopy(a) a.append( foo.val = 5 print( % (a, b, c, d, e, f))
original: [ list.copy(): [ slice: [ list(): [ copy: [ deepcopy: [
from copy import deepcopy class old_class: def __init__(self): self.blah = class new_class(object): def __init__(self): self.blah = dignore = {str: None, unicode: None, int: None, type(None): None} def Copy(obj, use_deepcopy=True): t = type(obj) if t in (list, tuple): if t == tuple: is_tuple = True obj = list(obj) else: obj = obj[:] is_tuple = False for x in xrange(len(obj)): if type(obj[x]) in dignore: continue obj[x] = Copy(obj[x], use_deepcopy) if is_tuple: obj = tuple(obj) elif t == dict: obj = obj.copy() for k in obj: if type(obj[k]) in dignore: continue obj[k] = Copy(obj[k], use_deepcopy) elif t in dignore: pass elif use_deepcopy: obj = deepcopy(obj) return obj if __name__ == import copy from time import time num_times = 100000 L = [None, [ old_class(), new_class()] t = time() for i in xrange(num_times): Copy(L) print t = time() for i in xrange(num_times): Copy(L, use_deepcopy=False) print t = time() for i in xrange(num_times): copy.copy(L) print t = time() for i in xrange(num_times): copy.deepcopy(L) print t = time() for i in xrange(num_times): L[:] print t = time() for i in xrange(num_times): list(L) print t = time() for i in xrange(num_times): [i for i in L] print t = time() for i in xrange(num_times): a = [] a.extend(L) print t = time() for i in xrange(num_times): a = [] for y in L: a.append(y) print t = time() for i in xrange(num_times): a = [] a.extend(i for i in L) print
>>> timeit >>> l = range(20) >>> min(timeit.repeat(lambda: l[:])) 0.30504298210144043 >>> min(timeit.repeat(lambda: list(l))) 0.40698814392089844
>>> import timeit >>> l = list(range(20)) >>> min(timeit.repeat(lambda: l[:])) 0.38448613602668047 >>> min(timeit.repeat(lambda: list(l))) 0.6309100328944623 >>> min(timeit.repeat(lambda: l.copy())) 0.38122922903858125
>>> l = [[], [], []] >>> l_copy = l[:] >>> l_copy [[], [], []] >>> l_copy[0].append( >>> l_copy [[ >>> l [[
>>> import copy >>> l [[ >>> l_deep_copy = copy.deepcopy(l) >>> l_deep_copy[0].pop() >>> l_deep_copy [[], [], []] >>> l [[
>>> import timeit >>> import copy >>> l = range(10) >>> min(timeit.repeat(lambda: copy.deepcopy(l))) 27.55826997756958 >>> min(timeit.repeat(lambda: eval(repr(l)))) 29.04534101486206
>>> import timeit >>> import copy >>> l = list(range(10)) >>> min(timeit.repeat(lambda: copy.deepcopy(l))) 16.84255409205798 >>> min(timeit.repeat(lambda: eval(repr(l)))) 34.813894678023644
new_list = list(my_list) new_list = [element for element in my_list]
import copy new_list = [copy.copy(element) for element in my_list]
>>> a = [1,2] >>> b = a[:] >>> a += [3] >>> a [1, 2, 3] >>> b [1, 2] >>>
old_list = [[0 for j in range(y)] for i in range(x)] new_list = eval(repr(old_list)) for j in range(y): for i in range(x): new_list[i][j] += 1
>>> new_list [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> old_list [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
The id() function shows us that both variables point to the same list object, i.e. they share this object.
print(id(copy_1)) print(id(list_1)) 4338792136 4338791432
METHOD TIME TAKEN b = a[:] 6.468942025996512 b = a.copy() 6.986593422974693 b = []; b.extend(a) 7.309216841997113 b = a[0:len(a)] 10.916740721993847 *b, = a 11.046738261007704 b = list(a) 11.761539687984623 b = [i for i in a] 24.66165203397395 b = copy.copy(a) 30.853400873980718 b = [] for item in a: b.append(item) 48.19176080400939
import timeit COUNT = 50000000 print("Array duplicating. Tests run", COUNT, "times") setup = print("b = list(a)\t\t", timeit.timeit(stmt= print("b = copy.copy(a)\t\t", timeit.timeit(stmt= print("b = a.copy()\t\t", timeit.timeit(stmt= print("b = a[:]\t\t", timeit.timeit(stmt= print("b = a[0:len(a)]\t", timeit.timeit(stmt= print("*b, = a\t", timeit.timeit(stmt= print("b = []; b.extend(a)\t", timeit.timeit(stmt= print("b = []\nfor item in a: b.append(item)\t", timeit.timeit(stmt= print("b = [i for i in a]\t", timeit.timeit(stmt=
old_list = [1, 2, 3] new_list = [*old_list] new_list.append(4) old_list == [1, 2, 3] new_list == [1, 2, 3, 4]
x = [random.random() for _ in range(1000)] %timeit a = list(x) %timeit a = x.copy() %timeit a = x[:] %timeit a = [*x]
a = { b = a c = a.copy() a[ a Out[14]: { b Out[15]: { c Out[16]: {
>>> a = range(5) >>> b = a*1 >>> a,b ([0, 1, 2, 3, 4], [0, 1, 2, 3, 4]) >>> a[2] = 55 >>> a,b ([0, 1, 55, 3, 4], [0, 1, 2, 3, 4])
>>> from copy import deepcopy >>> a = [range(i,i+4) for i in range(3)] >>> a [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]] >>> b = a*1 >>> c = deepcopy(a) >>> for i in (a, b, c): print i [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]] [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]] [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]] >>> a[2].append( >>> for i in (a, b, c): print i [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]] [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]] [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
import copy class MyList(list): pass lst = MyList([1,2,3]) lst.name = d = { } for k,v in d.items(): print( try: name = v.name except AttributeError: name = print(
lst: original, name: custom list lst: slicecopy, name: NA lst: lstcopy, name: NA lst: copycopy, name: custom list lst: deepcopy, name: custom list
my_lst=[1,2,3,4,5] print my_lst, my_lst_copy = my_lst=[1,2,3,4,5] my_lst_copy[2] = 55 print my_lst_copy, print my_lst, >>>[1, 2, 3, 4, 5] my_lst (before copy) >>>[1, 2, 55, 4, 5] my_lst_copy (copy of python list) >>>[1, 2, 55, 4, 5] my_lst (after copy)
from copy import deepcopy my_lst=[1,2,3,4,5] print my_lst, my_lst_copy = deepcopy(my_lst) my_lst_copy[2] = 55 print my_lst_copy, print my_lst, >>>[1, 2, 3, 4, 5] my_lst (before copy) >>>[1, 2, 55, 4, 5] my_lst_copy (copy of python list) >>>[1, 2, 3, 4, 5] my_lst (after copy)
>>> a = "545.2222" >>> float(a) 545.22220000000004 >>> int(float(a)) 545
def num(s): try: return int(s) except ValueError: return float(s)
def is_float(value): try: float(value) return True except: return False
val is_float(val) Note -------------------- ---------- -------------------------------- "" False Blank string "127" True Passed string True True Pure sweet Truth "True" False Vile contemptible lie False True So false it becomes true "123.456" True Decimal " -127 " True Spaces trimmed "\t\n12\r\n" True whitespace ignored "NaN" True Not a number "NaNanananaBATMAN" False I am Batman "-iNF" True Negative infinity "123.E4" True Exponential notation ".1" True mantissa only "1,234" False Commas gtfo u "NULL" False Null is not special 0x3fade True Hexadecimal "6e7777777777777" True Shrunk to infinity "1.797693e+308" True This is max value "infinity" True Same as inf "infinityandBEYOND" False Extra characters wreck it "12.34.56" False Only one dot allowed u " "56%" False Percent of what? "0E0" True Exponential, move dot 0 places 0**0 True 0___0 Exponentiation "-5e-5" True Raise to a negative number "+1e1" True Plus is OK with exponent "+1e1^5" False Fancy exponent not interpreted "+1e1.3" False No decimals in exponent "-+1" False Make up your mind "(1)" False Parenthesis is bad
>>> import ast >>> ast.literal_eval("545.2222") 545.2222 >>> ast.literal_eval("31") 31
>>> import locale >>> a = u >>> locale.setlocale(locale.LC_ALL, >>> locale.atof(a) 545545.2222 >>> int(locale.atof(a)) 545545 >>>
>>> import locale >>> b = u >>> locale.setlocale(locale.LC_ALL, >>> locale.atof(b) 545.2222
>>> x = ["545.0", "545.6", "999.2"] >>> map(float, x) [545.0, 545.60000000000002, 999.20000000000005] >>>
>>> from fastnumbers import fast_real >>> fast_real("545.2222") 545.2222 >>> type(fast_real("545.2222")) float >>> fast_real("31") 31 >>> type(fast_real("31")) int
>>> import string >>> parseStr = lambda x: x.isalpha() and x or x.isdigit() and \ ... int(x) or x.isalnum() and x or \ ... len(set(string.punctuation).intersection(x)) == 1 and \ ... x.count( >>> parseStr( 123 >>> parseStr( 123.3 >>> parseStr( >>> parseStr( 1200000.0 >>> parseStr( >>> parseStr(
>>> int("0b11111", 2) 31 >>> int("11111", 2) 31 >>> int( 31 >>> int( 31 >>> int( 31 >>> int( 31
>>> 037 File "<stdin>", line 1 037 ^ SyntaxError: invalid token
>>> import yaml >>> a = "545.2222" >>> result = yaml.load(a) >>> result 545.22220000000004 >>> type(result) <type >>> b = "31" >>> result = yaml.load(b) >>> result 31 >>> type(result) <type >>> c = "HI" >>> result = yaml.load(c) >>> result >>> type(result) <type
def get_int_or_float(v): number_as_float = float(v) number_as_int = int(number_as_float) return number_as_int if number_as_float == number_as_int else number_as_float
import ast def parse_str(s): try: return ast.literal_eval(str(s)) except: return
def convert(n): try: return int(n) except ValueError: return float(n + 0.5)
def num(s): """num(s) num(3),num(3.7)-->3 num( num( num( num( """ try: return int(s) except ValueError: try: return float(s) except ValueError: raise ValueError(
import re def parseNumber(value, as_int=False): try: number = float(re.sub( if as_int: return int(number + 0.5) else: return number except ValueError: return float(
parseNumber( > 13345.0 parseNumber( > -123000.0 parseNumber( > 99999.0
import numbers def is_number(value): return isinstance(value, numbers.Number)
str = "545.2222" print ("int: ", + int(float(a))) print ("float: ", +(float(a)))
def get_int_or_float(v): number_as_float = float(v) number_as_int = int(number_as_float) return number_as_int if number_as_float == number_as_int else number_as_float
str_to_float = float("545.2222") str_to_int = int("31")
def num(s): try: for each in s: yield int(each) except ValueError: yield float(each) a = num(["123.55","345","44"]) print a.next() print a.next()
>>> str_float = "545.2222" >>> float(str_float) 545.2222 >>> type(_) <type >>> str_int = "31" >>> int(str_int) 31 >>> type(_) <type
def parseIntOrFloat( aString ): return eval( aString )
>>> parseIntOrFloat("545.2222") 545.22220000000004 >>> parseIntOrFloat("545") 545
with open(fname) as f: content = f.readlines() content = [x.strip() for x in content]
with open("file.txt", "r") as ins: array = [] for line in ins: array.append(line)
with open(fname) as f: content = f.read().splitlines()
fp = open( lines = fp.read().split("\n") fp.close()
>>> with open("myfile.txt", encoding="utf-8") as file: ... x = [l.strip() for l in file] >>> x [
x = [] with open("myfile.txt") as file: for l in file: x.append(l.strip())
>>> x = open("myfile.txt").read().splitlines() >>> x [
>>> y = [x.rstrip() for x in open("my_file.txt")] >>> y [ with open( file = file.read().splitlines() print(file) with open( file = file.readlines() print(file)
array = [] with open("file.txt", "r") as f: for line in f: array.append(line)
with open(filename) as f: for line in f: print(line)
with open(filename) as f: for line in f: print(line[:-1])
with open(filename) as f: for line in f: if line.endswith( line = line[:-1] print(line)
with open(filename) as f: for line in f: print(f.rstrip())
with open(filename) as f: lst = [line.rstrip() for line in f]
with open(filename) as f: lst = f.read().splitlines()
lines = [] with open("myfile.txt") as f: for line in f: lines.append(line)
import numpy as np data = np.genfromtxt("yourfile.dat",delimiter="\n")
import fileinput content = [] for line in fileinput.input(): content.append(line.strip()) fileinput.close()
lines = [ with open( fp.write( with open( read_lines = fp.readlines() read_lines = [line.rstrip( print(lines == read_lines)
from pathlib import Path p = Path( lines = p.read_text().splitlines()
inp = "file.txt" data = open(inp) dat = data.read() lst = dat.splitlines() print lst
file = raw_input ("Enter EXACT file name: ") with open(file) as g: stuff = g.readlines() print (stuff) exit = raw_input("Press enter when you are done.")
file1 = open("filename","r") lines = file1.readlines() file1.close()
array = [] with open(PATH, for line in reader : array.append(line)
import pandas as pd data = pd.read_csv(filename) array = data.values
import numpy data = numpy.loadtxt(filename, delimiter="\n")
fileOb=open("filename.txt","r") data=fileOb.readlines()
filename = with open(filename) as f: for line in f: line
import fileinput for line in fileinput.input(filename): line
from pathlib import Path path = Path(filename) with path.open() as f: f.readlines()
line_list = [] for line in fileinput.input(filename): line_list.append(line) line_list
line_list = [] line_list.extend(fileinput.input(filename)) line_list
import os import sys abspath = os.path.abspath(__file__) dname = os.path.dirname(abspath) filename = dname + sys.argv[1] arr = open(filename).read().split("\n") print(arr)
listone = [1,2,3] listtwo = [4,5,6] mergedlist = listone + listtwo
import itertools for item in itertools.chain(listone, listtwo):
>>> l1 = [1, 2, 3] >>> l2 = [4, 5, 6] >>> joinedList = [*l1, *l2] >>> print(joinedList) [1, 2, 3, 4, 5, 6]
listone = [1,2,3] listtwo = [4,5,6] mergedlist = [] mergedlist.extend(listone) mergedlist.extend(listtwo)
>>> listone = [1,2,3] >>> listtwo = [4,5,6] >>> >>> listone + listtwo [1, 2, 3, 4, 5, 6]
>>> a = [[1,2,3], [4,5,6], [7,8,9]] >>> [x for xs in a for x in xs] [1, 2, 3, 4, 5, 6, 7, 8, 9]
a = [[1,2,3], [4,5,6], [7,8,9]] reduce(lambda c, x: c + x, a, [])
a = [[1,2,3], [4,5,6], [7,8,9]] list(itertools.chain(*a))
>>> l1 = [ >>> [i for i in itertools.chain(l1, l2)] [ >>> [i for i in itertools.chain(l1, l2, l3)] [
>>> il = [[ >>> [i for i in itertools.chain.from_iterable(il)] [
listone = [1,2,3] listtwo = [4,5,6] def merge(l1, l2): yield from l1 yield from l2 >>> list(merge(listone, listtwo)) [1, 2, 3, 4, 5, 6]
def merge(*iters): for it in iters: yield from it >>> list(merge(listone, listtwo, [1, 2, 3, 4, 5, 6,
from heapq import merge a = [1,2,4] b = [2,4,6,7] print list(merge(a,b))
listone = [1,2,3] listtwo = [4,5,6] result = list.__add__(listone, listtwo) print(result) >>> [1, 2, 3, 4, 5, 6]
import operator listone = [1,2,3] listtwo = [4,5,6] result = operator.add(listone, listtwo) print(result) >>> [1, 2, 3, 4, 5, 6]
>>> l=[[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> import itertools >>> list(itertools.chain.from_iterable(l)) [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a = [1, 2, 3, 4] >>> b = [1, 4, 6, 7] >>> c = a + b >>> c [1, 2, 3, 4, 1, 4, 6, 7]
>>> a = [1, 2, 3, 4, 5, 6] >>> b = [5, 6, 7, 8] >>> c = list(set(a + b)) >>> c [1, 2, 3, 4, 5, 6, 7, 8]
list1 = [1,2,5] list2 = [2,3,4] newlist = [] while list1 and list2: if list1[0] == list2[0]: newlist.append(list1.pop(0)) list2.pop(0) elif list1[0] < list2[0]: newlist.append(list1.pop(0)) else: newlist.append(list2.pop(0)) if list1: newlist.extend(list1) if list2: newlist.extend(list2) assert(newlist == [1, 2, 3, 4, 5])
for it in iterables: for element in it: yield element
for iterable, header, flag in ( (newList, print header + for path in iterable: [...] command = print >> SCRIPT , command, flag, srcPath, mergedDirPath [...]
mergedlist =[] for elem in listone: mergedlist.append(elem) for elem in listtwo: mergedlist.append(elem)
list_of_lists = [[1,2,3], [4,5,6], [7,8,9]] reduce(list.__add__, list_of_lists)
lst1 = [1,2] lst2 = [3,4] def list_combinationer(Bushisms, are_funny): for item in lst1: lst2.append(item) lst1n2 = sorted(lst2) print lst1n2 list_combinationer(lst1, lst2) [1,2,3,4]
import itertools A = list(zip([1,3,5,7,9],[2,4,6,8,10])) B = [1,3,5,7,9]+[2,4,6,8,10] C = list(set([1,3,5,7,9] + [2,4,6,8,10])) D = [1,3,5,7,9] D.append([2,4,6,8,10]) E = [1,3,5,7,9] E.extend([2,4,6,8,10]) F = [] for a in itertools.chain([1,3,5,7,9], [2,4,6,8,10]): F.append(a) print ("A: " + str(A)) print ("B: " + str(B)) print ("C: " + str(C)) print ("D: " + str(D)) print ("E: " + str(E)) print ("F: " + str(F))
A: [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)] B: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10] C: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] D: [1, 3, 5, 7, 9, [2, 4, 6, 8, 10]] E: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10] F: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
joined_list = [y for x in [list_one, list_two] for y in x]
>>> listone = [1,2,3] >>> listome = [4,5,6] >>> >>> listone+listome [1, 2, 3, 4, 5, 6] >>> >>> listone.extend(listome) >>> listone [1, 2, 3, 4, 5, 6] >>> >>> listone = [1,2,3] >>> >>> listone.__add__(listome) [1, 2, 3, 4, 5, 6]
>>> for i in listome: ... listone.append(i) ... >>> listone [1, 2, 3, 4, 5, 6] >>>
def concatenate_list(listOne, listTwo): joinedList = [] for i in listOne: joinedList.append(i) for j in listTwo: joinedList.append(j) sorted(joinedList) return joinedList
In [1]: a = [1, 2, 3] In [2]: b = [4, 5, 6] In [3]: a + b Out[3]: [1, 2, 3, 4, 5, 6] In [4]: %timeit a + b 10000000 loops, best of 3: 126 ns per loop
In [1]: a = [1, 2, 3] In [2]: b = [4, 5, 6] In [3]: %timeit a.extend(b) 10000000 loops, best of 3: 91.1 ns per loop
>>> listone = [1,2,3] >>> listtwo = [4,5,6] >>> >>> listSum = [] >>> listSum = listone + listtwo >>> print(listSum) [1, 2, 3, 4, 5, 6]
def foo(param1, *param2): def bar(param1, **param2):
In [1]: def foo(*args): ...: for a in args: ...: print a ...: ...: In [2]: foo(1) 1 In [4]: foo(1,2,3) 1 2 3
In [5]: def bar(**kwargs): ...: for a in kwargs: ...: print a, kwargs[a] ...: ...: In [6]: bar(name= age 27 name one
In [9]: def foo(bar, lee): ...: print bar, lee ...: ...: In [10]: l = [1,2] In [11]: foo(*l) 1 2
first, *rest = [1,2,3,4] first, *l, last = [1,2,3,4]
def func(arg1, arg2, arg3, *, kwarg1, kwarg2): pass
def foo(x,y,z): print("x=" + str(x)) print("y=" + str(y)) print("z=" + str(z))
>>> mylist = [1,2,3] >>> foo(*mylist) x=1 y=2 z=3 >>> mydict = { >>> foo(**mydict) x=1 y=2 z=3 >>> mytuple = (1, 2, 3) >>> foo(*mytuple) x=1 y=2 z=3
>>> mydict = { >>> foo(**mydict) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: foo() got an unexpected keyword argument
def foo(param1, *param2): print(param1) print(param2) def bar(param1, **param2): print(param1) print(param2) foo(1,2,3,4,5) bar(1,a=2,b=3)
def foo(arg, kwarg=None, *args, kwarg2=None, **kwargs): return arg, kwarg, args, kwarg2, kwargs
def foo(arg, kwarg=None, *, kwarg2=None, **kwargs): return arg, kwarg, kwarg2, kwargs
>>> foo(1,2,3,4,5, kwarg2= Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: foo() takes from 1 to 2 positional arguments but 5 positional arguments (and 1 keyword-only argument) were given
>>> bar( Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: bar() takes 0 positional arguments but 1 was given
def foo(a, b=10, *args, **kwargs): this function takes required argument a, not required keyword argument b and any number of unknown positional arguments and keyword arguments after print( print( print( for arg in args: print( print( len(kwargs))) for kw, arg in kwargs.items(): print( print( print( max(a, b, *args))) kweg = for k, v in sorted(kwargs.items()))) print( dict(**kwargs), kweg=kweg))
a is a required argument, and its value is 1 b not required, its default value is 10, actual value: 2 args is of type <type unknown arg: 3 unknown arg: 4 kwargs is of type <type unknown kwarg - kw: e, arg: 5 unknown kwarg - kw: g, arg: 7 unknown kwarg - kw: f, arg: 6 Args or kwargs can be passed without knowing what they are. e.g. max(a, b, *args) 4 e.g. dict(**kwargs) (same as dict(e=5, f=6, g=7)) returns: {
def bar(a): b, c, d, e, f = 2, 3, 4, 5, 6 foo(**locals())
a is a required argument, and its value is 100 b not required, its default value is 10, actual value: 2 args is of type <type kwargs is of type <type unknown kwarg - kw: c, arg: 3 unknown kwarg - kw: e, arg: 5 unknown kwarg - kw: d, arg: 4 unknown kwarg - kw: f, arg: 6 Args or kwargs can be passed without knowing what they are. e.g. max(a, b, *args) 100 e.g. dict(**kwargs) (same as dict(c=3, d=4, e=5, f=6)) returns: {
def foo(a, b, c, d=0, e=100): preprocess() differentiating_process_foo(a,b,c,d,e) postprocess() def bar(a, b, c=None, d=0, e=100, f=None): preprocess() differentiating_process_bar(a,b,c,d,e,f) postprocess() def baz(a, b, c, d, e, f): ... and so on
def decorator(function): @functools.wraps(function) def wrapper(*args, **kwargs): preprocess() function(*args, **kwargs) postprocess() return wrapper
@decorator def foo(a, b, c, d=0, e=100): differentiating_process_foo(a,b,c,d,e) @decorator def bar(a, b, c=None, d=0, e=100, f=None): differentiating_process_bar(a,b,c,d,e,f) @decorator def baz(a, b, c=None, d=0, e=100, f=None, g=None): differentiating_process_baz(a,b,c,d,e,f, g) @decorator def quux(a, b, c=None, d=0, e=100, f=None, g=None, h=None): differentiating_process_quux(a,b,c,d,e,f,g,h)
def test(a,b,c): print(a) print(b) print(c) test(1,2,3) 1 2 3
def test(a,b,c): print(a) print(b) print(c) test(a=1,b=2,c=3) 1 2 3
def test(a=0,b=0,c=0): print(a) print(b) print(c) print( test(a=1,b=2,c=3) 1 2 3 -------------------------
def test(a=0,b=0,c=0): print(a) print(b) print(c) print( test(1,2,3) 1 2 3 ---------------------------------
def sum(a,b): print(a+b) my_tuple = (1,2) my_list = [1,2] my_dict = { sum(*my_tuple) sum(*my_list) sum(**my_dict)
def sum(*args): sum = 0 for a in args: sum+=a print(sum) sum(1,2,3,4) 10
def sum(**args): sum=0 for k,v in args.items(): sum+=v print(sum) sum(a=1,b=2,c=3,d=4)
def f(x, y, *myArgs, **myKW): print(" print(" print(" print(" print(" myList = ["Left", "Right", "Up", "Down"] myDict = {"Wubba": "lubba", "Dub": "dub"} myArgDict = { f("myEx", *myList, **myDict) f("myEx", **myArgDict) f("myEx", *myArgDict) f("myEx", 4, 42, 420, *myList, *myDict, **myDict) f(myList, myDict)
In function *construction* In function *call* ======================================================================= | def f(*args): | def f(a, b): *args | for arg in args: | return a + b | print(arg) | args = (1, 2) | f(1, 2) | f(*args) ----------|--------------------------------|--------------------------- | def f(a, b): | def f(a, b): **kwargs | return a + b | return a + b | def g(**kwargs): | kwargs = dict(a=1, b=2) | return f(**kwargs) | f(**kwargs) | g(a=1, b=2) | -----------------------------------------------------------------------
x = [1, 2, 3] y = [4, 5, 6] unzip_x, unzip_y = zip(*zip(x, y))
>>> (0, *range(1, 4), 5, *range(6, 8)) (0, 1, 2, 3, 5, 6, 7) >>> [0, *range(1, 4), 5, *range(6, 8)] [0, 1, 2, 3, 5, 6, 7] >>> {0, *range(1, 4), 5, *range(6, 8)} {0, 1, 2, 3, 5, 6, 7} >>> d = { >>> e = { >>> { {
def __init__(self, *args, **kwargs): for attribute_name, value in zip(self._expected_attributes, args): setattr(self, attribute_name, value) if kwargs.has_key(attribute_name): kwargs.pop(attribute_name) for attribute_name in kwargs.viewkeys(): setattr(self, attribute_name, kwargs[attribute_name])
class RetailItem(Item): _expected_attributes = Item._expected_attributes + [ class FoodItem(RetailItem): _expected_attributes = RetailItem._expected_attributes + [
food_item = FoodItem(name = price = 12.0, category = country_of_origin = expiry_date = datetime.datetime.now())
class ElectronicAccessories(RetailItem): _expected_attributes = RetailItem._expected_attributes + [ def __init__(self, specifications = None, *args, **kwargs): self.specifications = specifications super(ElectronicAccessories, self).__init__(*args, **kwargs)
usb_key = ElectronicAccessories(name = price = category = country_of_origin = specifications =
>>> def foo(*arg,**kwargs): ... print arg ... print kwargs >>> >>> a = (1, 2, 3) >>> b = { >>> >>> >>> foo(*a,**b) (1, 2, 3) { >>> >>> >>> foo(a,**b) ((1, 2, 3),) { >>> >>> >>> foo(a,b) ((1, 2, 3), { {} >>> >>> >>> foo(a,*b) ((1, 2, 3), {}
class base(object): def __init__(self, base_param): self.base_param = base_param class child1(base): def __init__(self, child_param, *args) self.child_param = child_param super(child1, self).__init__(*args) class child2(base): def __init__(self, child_param, **kwargs): self.child_param = child_param super(child2, self).__init__(**kwargs) c1 = child1(1,0) c2 = child2(1,base_param=0) print c1.base_param print c1.child_param print c2.base_param print c2.child_param
def foo(*args): for arg in args: print(arg) foo("two", 3)
def bar(**kwargs): for key in kwargs: print(key, kwargs[key]) bar(dic1="two", dic2=3)
def args(normal_arg, *argv): print ("normal argument:",normal_arg) for arg in argv: print("Argument in list of arguments from *argv:", arg) args(
normal argument: animals Argument in list of arguments from *argv: fish Argument in list of arguments from *argv: duck Argument in list of arguments from *argv: bird
def who(**kwargs): if kwargs is not None: for key, value in kwargs.items(): print ("Your %s is %s." %(key,value)) who (name="Nikola", last_name="Tesla", birthday = "7.10.1856", birthplace = "Croatia")
Your name is Nikola. Your last_name is Tesla. Your birthday is 7.10.1856. Your birthplace is Croatia.
def chunks(l, n): for i in range(0, len(l), n): yield l[i:i + n]
import pprint pprint.pprint(list(chunks(range(10, 75), 10))) [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35, 36, 37, 38, 39], [40, 41, 42, 43, 44, 45, 46, 47, 48, 49], [50, 51, 52, 53, 54, 55, 56, 57, 58, 59], [60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [70, 71, 72, 73, 74]]
def chunks(l, n): for i in xrange(0, len(l), n): yield l[i:i + n]
def chunks(l, n): n = max(1, n) return (l[i:i+n] for i in xrange(0, len(l), n))
from itertools import izip, chain, repeat def grouper(n, iterable, padvalue=None): "grouper(3, return izip(*[chain(iterable, repeat(padvalue, n-1))]*n)
from itertools import zip_longest def grouper(n, iterable, padvalue=None): "grouper(3, return zip_longest(*[iter(iterable)]*n, fillvalue=padvalue)
lst = range(50) In [26]: np.array_split(lst,5) Out[26]: [array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]), array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19]), array([20, 21, 22, 23, 24, 25, 26, 27, 28, 29]), array([30, 31, 32, 33, 34, 35, 36, 37, 38, 39]), array([40, 41, 42, 43, 44, 45, 46, 47, 48, 49])]
def split_seq(iterable, size): it = iter(iterable) item = list(itertools.islice(it, size)) while item: yield item item = list(itertools.islice(it, size))
>>> import pprint >>> pprint.pprint(list(split_seq(xrange(75), 10))) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35, 36, 37, 38, 39], [40, 41, 42, 43, 44, 45, 46, 47, 48, 49], [50, 51, 52, 53, 54, 55, 56, 57, 58, 59], [60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [70, 71, 72, 73, 74]]
from itertools import islice def chunk(it, size): it = iter(it) return iter(lambda: tuple(islice(it, size)), ())
>>> list(chunk(range(14), 3)) [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13)]
from itertools import islice, chain, repeat def chunk_pad(it, size, padval=None): it = chain(iter(it), repeat(padval)) return iter(lambda: tuple(islice(it, size)), (padval,) * size)
>>> list(chunk_pad(range(14), 3)) [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, None)] >>> list(chunk_pad(range(14), 3, [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13,
_no_padding = object() def chunk(it, size, padval=_no_padding): if padval == _no_padding: it = iter(it) sentinel = () else: it = chain(iter(it), repeat(padval)) sentinel = (padval,) * size return iter(lambda: tuple(islice(it, size)), sentinel)
>>> list(chunk(range(14), 3)) [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13)] >>> list(chunk(range(14), 3, None)) [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, None)] >>> list(chunk(range(14), 3, [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13,
_no_padding = object() def chunk(it, size, padval=_no_padding): it = iter(it) chunker = iter(lambda: tuple(islice(it, size)), ()) if padval == _no_padding: yield from chunker else: for ch in chunker: yield ch if len(ch) == size else ch + (padval,) * (size - len(ch))
>>> list(chunk([1, 2, (), (), 5], 2)) [(1, 2), ((), ()), (5,)] >>> list(chunk([1, 2, None, None, 5], 2, None)) [(1, 2), (None, None), (5, None)]
def chunk(input, size): return map(None, *([iter(input)] * size))
l = range(1, 1000) print [l[x:x+10] for x in xrange(0, len(l), 10)]
chunks = lambda l, n: [l[x: x+n] for x in xrange(0, len(l), n)] chunks(l, 10)
[60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [70, 71, 72, 73, 74]]
def baskets_from(items, maxbaskets=25): baskets = [[] for _ in xrange(maxbaskets)] for i, item in enumerate(items): baskets[i % maxbaskets].append(item) return filter(None, baskets)
def iter_baskets_from(items, maxbaskets=3): item_count = len(items) baskets = min(item_count, maxbaskets) for x_i in xrange(baskets): yield [items[y_i] for y_i in xrange(x_i, item_count, baskets)]
def iter_baskets_contiguous(items, maxbaskets=3, item_count=None): generates balanced baskets from iterable, contiguous contents provide item_count if providing a iterator that doesn item_count = item_count or len(items) baskets = min(item_count, maxbaskets) items = iter(items) floor = item_count ceiling = floor + 1 stepdown = item_count % baskets for x_i in xrange(baskets): length = ceiling if x_i < stepdown else floor yield [items.next() for _ in xrange(length)]
print(baskets_from(xrange(6), 8)) print(list(iter_baskets_from(xrange(6), 8))) print(list(iter_baskets_contiguous(xrange(6), 8))) print(baskets_from(xrange(22), 8)) print(list(iter_baskets_from(xrange(22), 8))) print(list(iter_baskets_contiguous(xrange(22), 8))) print(baskets_from( print(list(iter_baskets_from( print(list(iter_baskets_contiguous( print(baskets_from(xrange(26), 5)) print(list(iter_baskets_from(xrange(26), 5))) print(list(iter_baskets_contiguous(xrange(26), 5)))
[[0], [1], [2], [3], [4], [5]] [[0], [1], [2], [3], [4], [5]] [[0], [1], [2], [3], [4], [5]] [[0, 8, 16], [1, 9, 17], [2, 10, 18], [3, 11, 19], [4, 12, 20], [5, 13, 21], [6, 14], [7, 15]] [[0, 8, 16], [1, 9, 17], [2, 10, 18], [3, 11, 19], [4, 12, 20], [5, 13, 21], [6, 14], [7, 15]] [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13, 14], [15, 16, 17], [18, 19], [20, 21]] [[ [[ [[ [[0, 5, 10, 15, 20, 25], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24]] [[0, 5, 10, 15, 20, 25], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24]] [[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]
from itertools import zip_longest a = range(1, 16) i = iter(a) r = list(zip_longest(i, i, i)) >>> print(r) [(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, 15)]
[(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, None)]
def SplitList(list, chunk_size): return [list[offs:offs+chunk_size] for offs in range(0, len(list), chunk_size)]
def IterChunks(sequence, chunk_size): res = [] for item in sequence: res.append(item) if len(res) >= chunk_size: yield res res = [] if res: yield res
def chunks(seq, n): return (seq[i:i+n] for i in xrange(0, len(seq), n))
from toolz.itertoolz.core import partition list(partition(2, [1, 2, 3, 4])) [(1, 2), (3, 4)]
from itertools import islice def chunks(n, iterable): iterable = iter(iterable) while True: yield tuple(islice(iterable, n)) or iterable.next()
from itertools import chain, islice def chunks(n, iterable): iterable = iter(iterable) while True: yield chain([next(iterable)], islice(iterable, n-1))
def chunks(li, n): if li == []: return yield li[:n] for e in chunks(li[n:], n): yield e
def chunks(li, n): if li == []: return yield li[:n] yield from chunks(li[n:], n)
def dec(gen): def new_gen(li, n): for e in gen(li, n): if e == []: return yield e return new_gen @dec def chunks(li, n): yield li[:n] for e in chunks(li[n:], n): yield e
>>> from utilspie import iterutils >>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(iterutils.get_chunks(a, 5)) [[1, 2, 3, 4, 5], [6, 7, 8, 9]]
import time batch_size = 7 arr_len = 298937 print("\r\nslice") start = time.time() arr = [i for i in range(0, arr_len)] while True: if not arr: break tmp = arr[0:batch_size] arr = arr[batch_size:-1] print(time.time() - start) print("\r\nindex") arr = [i for i in range(0, arr_len)] start = time.time() for i in range(0, round(len(arr) / batch_size + 1)): tmp = arr[batch_size * i : batch_size * (i + 1)] print(time.time() - start) def batch(iterable, n=1): l = len(iterable) for ndx in range(0, l, n): yield iterable[ndx:min(ndx + n, l)] print("\r\nbatches 1") arr = [i for i in range(0, arr_len)] start = time.time() for x in batch(arr, batch_size): tmp = x print(time.time() - start) from itertools import islice, chain def batch(iterable, size): sourceiter = iter(iterable) while True: batchiter = islice(sourceiter, size) yield chain([next(batchiter)], batchiter) print("\r\nbatches 2") arr = [i for i in range(0, arr_len)] start = time.time() for x in batch(arr, batch_size): tmp = x print(time.time() - start) def chunks(l, n): for i in range(0, len(l), n): yield l[i:i + n] print("\r\nchunks") arr = [i for i in range(0, arr_len)] start = time.time() for x in chunks(arr, batch_size): tmp = x print(time.time() - start) from itertools import zip_longest def grouper(iterable, n, padvalue=None): "grouper(3, return zip_longest(*[iter(iterable)]*n, fillvalue=padvalue) arr = [i for i in range(0, arr_len)] print("\r\ngrouper") start = time.time() for x in grouper(arr, batch_size): tmp = x print(time.time() - start)
slice 31.18285083770752 index 0.02184295654296875 batches 1 0.03503894805908203 batches 2 0.22681021690368652 chunks 0.019841909408569336 grouper 0.006506919860839844
>>> AA=range(10,21);SS=3 >>> [AA[i:i+SS] for i in range(len(AA))[::SS]] [[10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20]]
def split_list(the_list, chunk_size): result_list = [] while the_list: result_list.append(the_list[:chunk_size]) the_list = the_list[chunk_size:] return result_list a_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print split_list(a_list, 3)
In [48]: chunk = lambda ulist, step: map(lambda i: ulist[i:i+step], xrange(0, len(ulist), step)) In [49]: chunk(range(1,100), 10) Out[49]: [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36, 37, 38, 39, 40], [41, 42, 43, 44, 45, 46, 47, 48, 49, 50], [51, 52, 53, 54, 55, 56, 57, 58, 59, 60], [61, 62, 63, 64, 65, 66, 67, 68, 69, 70], [71, 72, 73, 74, 75, 76, 77, 78, 79, 80], [81, 82, 83, 84, 85, 86, 87, 88, 89, 90], [91, 92, 93, 94, 95, 96, 97, 98, 99]]
def split_seq(seq, num_pieces): start = 0 for i in xrange(num_pieces): stop = start + len(seq[i::num_pieces]) yield seq[start:stop] start = stop
seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] for seq in split_seq(seq, 3): print seq
def chunkList(initialList, chunkSize): """ This function chunks a list into sub lists that have a length equals to chunkSize. Example: lst = [3, 4, 9, 7, 1, 1, 2, 3] print(chunkList(lst, 3)) returns [[3, 4, 9], [7, 1, 1], [2, 3]] """ finalList = [] for i in range(0, len(initialList), chunkSize): finalList.append(initialList[i:i+chunkSize]) return finalList
def splitter(l, n): i = 0 chunk = l[:n] while chunk: yield chunk i += n chunk = l[i:i+n]
def isplitter(l, n): l = iter(l) chunk = list(islice(l, n)) while chunk: yield chunk chunk = list(islice(l, n))
def isplitter2(l, n): return takewhile(bool, (tuple(islice(start, n)) for start in repeat(iter(l))))
def chunks_gen_sentinel(n, seq): continuous_slices = imap(islice, repeat(iter(seq)), repeat(0), repeat(n)) return iter(imap(tuple, continuous_slices).next,())
def chunks_gen_filter(n, seq): continuous_slices = imap(islice, repeat(iter(seq)), repeat(0), repeat(n)) return takewhile(bool,imap(tuple, continuous_slices))
import matplotlib.cbook as cbook segments = cbook.pieces(np.arange(20), 3) for s in segments: print s
a = [1, 2, 3, 4, 5, 6, 7, 8, 9] CHUNK = 4 [a[i*CHUNK:(i+1)*CHUNK] for i in xrange((len(a) + CHUNK - 1) / CHUNK )]
Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))) chunks = Y(lambda f: lambda n: [n[0][:n[1]]] + f((n[0][n[1]:], n[1])) if len(n[0]) > 0 else [])
from boltons import iterutils list(iterutils.chunked_iter(list(range(50)), 11))
[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32], [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43], [44, 45, 46, 47, 48, 49]]
def make_chunks(data, chunk_size): while data: chunk, data = data[:chunk_size], data[chunk_size:] yield chunk >>> for chunk in make_chunks([1, 2, 3, 4, 5, 6, 7], 2): ... print chunk ... [1, 2] [3, 4] [5, 6] [7] >>>
def chunks(iterable,n): iterable=iter(iterable) while True: result=[] for i in range(n): try: a=next(iterable) except StopIteration: break else: result.append(a) if result: yield result else: break g1=(i*i for i in range(10)) g2=chunks(g1,3) print g2 print list(g2)
def demo_bad_catch(): try: raise ValueError( raise Exception( except Exception as error: print( >>> demo_bad_catch() Caught this error: ValueError(
def demo_no_catch(): try: raise Exception( except ValueError as e: print( >>> demo_no_catch() Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 3, in demo_no_catch Exception: general exceptions not caught by specific handling
try: some_code_that_may_raise_our_value_error() except ValueError as err: print(err.args)
logger = logging.getLogger(__name__) try: do_something_in_app_that_breaks_easily() except AppError as error: logger.error(error) raise
raise AppError, error, sys.exc_info()[2] raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]
def error(): raise ValueError( def catch_error_modify_message(): try: error() except ValueError: error_type, error_instance, traceback = sys.exc_info() error_instance.args = (error_instance.args[0] + raise error_type, error_instance, traceback
>>> catch_error_modify_message() Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 3, in catch_error_modify_message File "<stdin>", line 2, in error ValueError: oops! <modification>
def api_func(foo): if foo not in _ALLOWED_ARGS: raise ValueError(
if important_key not in resource_dict and not ok_to_be_missing: raise MyAppLookupError(
if 0 < distance <= RADIUS: elif RADIUS < distance: else: raise AssertionError("Unexpected value of
1. raise exception 2. raise exception (args) 3. raise 4. raise exception (args) from original_exception
try: raise ValueError("I have raised an Exception") except ValueError as exp: print ("Error", exp) try: raise ValueError except ValueError as exp: print ("Error", exp)
def somefunction(): print("some cleaning") a=10 b=0 result=None try: result=a/b print(result) except Exception: somefunction() raise
class MyCustomException(Exception): pass a=10 b=0 reuslt=None try: try: result=a/b except ZeroDivisionError as exp: print("ZeroDivisionError -- ",exp) raise MyCustomException("Zero Division ") from exp except MyCustomException as exp: print("MyException",exp) print(exp.__cause__)
ZeroDivisionError -- division by zero MyException Zero Division division by zero
>>> x = "Hello World!" >>> x[2:] >>> x[:2] >>> x[:-2] >>> x[-2:] >>> x[2:-2]
>>> x = "Hello World!" >>> x >>> x[:] >>> x==x[:] True >>>
>>> stop = step = None >>> start = 2 >>> myString[start:stop:step]
>>> start = None >>> stop = 2 >>> myString[start:stop:step]
def substring(s, start, end): """Remove `start` characters from the beginning and `end` characters from the end of string `s`. Examples -------- >>> substring( >>> substring( """ return s[start:end]
s = print(s[:]) print(s[:5]) print(s[5:]) print(s[3:7])
string = "my company has 1000$ on profit, but I lost 500$ gambling."
final = int(string[15:19]) - int(string[43:46]) print(final) >>>500
EARNINGS = slice(15, 19) LOSSES = slice(43, 46) final = int(string[EARNINGS]) - int(string[LOSSES]) print(final) >>>500
items = [] items.append("apple") items.append("orange") items.append("banana") items.amount()
items = [] items.append("apple") items.append("orange") items.append("banana")
>>> all(hasattr(cls, xrange, dict, set, frozenset)) True
class slist(list): @property def length(self): return len(self)
>>> l = slist(range(10)) >>> l.length 10 >>> print l [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> from operator import length_hint >>> l = ["apple", "orange", "banana"] >>> len(l) 3 >>> length_hint(l) 3 >>> list_iterator = iter(l) >>> len(list_iterator) TypeError: object of type >>> length_hint(list_iterator) 3
items = [] items.append("apple") items.append("orange") items.append("banana") print items.__len__()
def count(list): item_count = 0 for item in list[:]: item_count = item_count + 1 return item_count count([1,2,3,4,5])
def copyfileobj_example(source, dest, buffer_size=1024*1024): while True: copy_buffer = source.read(buffer_size) if not copy_buffer: break dest.write(copy_buffer)
def copyfile_example(source, dest): with open(source, copyfileobj_example(src, dst)
shutil.copyfile(src_file, dest_file, *, follow_symlinks=True) shutil.copyfile(
shutil.copy(src_file, dest_file, *, follow_symlinks=True) shutil.copy(
shutil.copy2(src_file, dest_file, *, follow_symlinks=True) shutil.copy2(
shutil.copyfileobj(src_file_object, dest_file_object[, length]) file_src = f_src = open(file_src, file_dest = f_dest = open(file_dest, shutil.copyfileobj(f_src, f_dest)
os.popen(cmd[, mode[, bufsize]]) os.popen( os.popen(
subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False) status = subprocess.call( status = subprocess.call(
subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False) status = subprocess.check_output( status = subprocess.check_output(
import os import shutil import tempfile filename1 = tempfile.mktemp (".txt") open (filename1, "w").close () filename2 = filename1 + ".copy" print filename1, "=>", filename2 shutil.copy (filename1, filename2) if os.path.isfile (filename2): print "Success" dirname1 = tempfile.mktemp (".dir") os.mkdir (dirname1) dirname2 = dirname1 + ".copy" print dirname1, "=>", dirname2 shutil.copytree (dirname1, dirname2) if os.path.isdir (dirname2): print "Success"
for line in open("file.txt", "r"): list.append(line) if len(list) == 1000000: output.writelines(list) del list[:]
from subprocess import call call("cp -p <file> <file>", shell=True)
In [3]: src = In [4]: dst = In [5]: shutil.copyfileobj(src, dst) AttributeError: In [7]: with open(src, ...: shutil.copyfileobj(f1, f2) In [8]: os.stat(os.path.join(dst, Out[8]: os.stat_result(st_mode=33188, st_ino=8598319475, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067347, st_mtime=1516067335, st_ctime=1516067345)
In [9]: shutil.copyfile(src, dst) IsADirectoryError: [Errno 21] Is a directory: ~/desktop'
In [10]: shutil.copy(src, dst) Out[10]: ~/desktop/Head+First+SQL.pdf' In [25]: os.stat(src) Out[25]: os.stat_result(st_mode=33188, st_ino=597749, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516066425, st_mtime=1493698739, st_ctime=1514871215) In [26]: os.stat(os.path.join(dst, Out[26]: os.stat_result(st_mode=33188, st_ino=8598313736, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516066427, st_mtime=1516066425, st_ctime=1516066425)
In [30]: shutil.copy2(src, dst) Out[30]: ~/desktop/Head+First+SQL.pdf' In [31]: os.stat(src) Out[31]: os.stat_result(st_mode=33188, st_ino=597749, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067055, st_mtime=1493698739, st_ctime=1514871215) In [32]: os.stat(os.path.join(dst, Out[32]: os.stat_result(st_mode=33188, st_ino=8598313736, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067063, st_mtime=1493698739, st_ctime=1516067055)
from datetime import datetime datetime_object = datetime.strptime(
from dateutil import parser dt = parser.parse("Aug 28 1999 12:00AM")
$ python >>> import time >>> time.strptime( time.struct_time(tm_year=2005, tm_mon=6, tm_mday=1, tm_hour=13, tm_min=33, tm_sec=0, tm_wday=2, tm_yday=152, tm_isdst=-1)
>>> import timestring >>> timestring.Date( <timestring.Date 2015-08-15 20:40:00 4491909392> >>> timestring.Date( datetime.datetime(2015, 8, 15, 20, 40) >>> timestring.Range( <timestring.Range From 03/10/14 00:00:00 to 03/03/14 00:00:00 4496004880> >>> (timestring.Range( (datetime.datetime(2014, 3, 10, 0, 0), datetime.datetime(2014, 3, 14, 0, 0))
>>> dates = [] >>> dates.append( >>> dates.append( >>> from datetime import datetime >>> for d in dates: ... date = datetime.strptime(d, ... print type(date) ... print date ...
<type 2005-06-01 13:33:00 <type 1999-08-28 00:00:00
>>> import dateutil >>> dates = [] >>> dates.append( >>> dates.append( >>> dates.append( >>> dates.append( >>> [parser.parse(x) for x in dates]
[datetime.datetime(2017, 12, 1, 0, 0), datetime.datetime(2017, 1, 1, 0, 0), datetime.datetime(2017, 1, 12, 0, 0), datetime.datetime(2017, 6, 1, 1, 30)]
>>> datetime.datetime.strptime( ... "March 5, 2014, 20:13:50", "%B %d, %Y, %H:%M:%S" ... ).replace(tzinfo=datetime.timezone(datetime.timedelta(hours=-3)))
import time def num_suffix(n): Returns the suffix for any given int suf = ( n = abs(n) tens = int(str(n)[-2:]) units = n % 10 if tens > 10 and tens < 20: return suf[0] elif units <= 3: return suf[units] else: return suf[0] def day_suffix(t): Returns the suffix of the given struct_time day return num_suffix(t.tm_mday) print num_suffix(123) print num_suffix(3431) print num_suffix(1234) print print day_suffix(time.strptime("1 Dec 00", "%d %b %y")) print day_suffix(time.strptime("2 Nov 01", "%d %b %y")) print day_suffix(time.strptime("3 Oct 02", "%d %b %y")) print day_suffix(time.strptime("4 Sep 03", "%d %b %y")) print day_suffix(time.strptime("13 Nov 90", "%d %b %y")) print day_suffix(time.strptime("14 Oct 10", "%d %b %y"))​​​​​​​
import pandas as pd dates = [ >>> [d.date() for d in pd.to_datetime(dates)] [datetime.date(2015, 12, 25), datetime.date(2015, 12, 26)] >>> pd.DatetimeIndex(dates).date.tolist() [datetime.date(2015, 12, 25), datetime.date(2015, 12, 26)]
dates = pd.DatetimeIndex(start= >>> %timeit [d.date() for d in pd.to_datetime(dates)] >>> %timeit pd.DatetimeIndex(dates).date.tolist()
datetimes = [ >>> pd.to_datetime(datetimes).to_pydatetime().tolist() [datetime.datetime(2005, 6, 1, 13, 33), datetime.datetime(1999, 8, 28, 0, 0)]
import datetime from django.utils.timezone import get_current_timezone tz = get_current_timezone() format = date_object = datetime.datetime.strptime( date_obj = tz.localize(date_object)
RuntimeWarning: DateTimeField MyModel.created received a naive datetime (2016-03-04 00:00:00) while time zone support is active.
from dateutil import parser from datetime import datetime import timeit def dt(): dt = parser.parse("Jun 1 2005 1:33PM") def strptime(): datetime_object = datetime.strptime( print(timeit.timeit(stmt=dt, number=10**5)) print(timeit.timeit(stmt=strptime, number=10**5)) >10.70296801342902 >1.3627995655316933
In [34]: import datetime In [35]: _now = datetime.datetime.now() In [36]: _now Out[36]: datetime.datetime(2016, 1, 19, 9, 47, 0, 432000) In [37]: print _now 2016-01-19 09:47:00.432000 In [38]: _parsed = datetime.datetime.strptime(str(_now),"%Y-%m-%d %H:%M:%S.%f") In [39]: _parsed Out[39]: datetime.datetime(2016, 1, 19, 9, 47, 0, 432000) In [40]: assert _now == _parsed
def date(datestr="", format="%Y-%m-%d"): from datetime import datetime if not datestr: return datetime.today().date() return datetime.strptime(datestr, format).date()
import datetime new_date_format1 = datetime.datetime.strptime( new_date_format2 = datetime.datetime.strptime( print new_date_format1 print new_date_format2
>>> import arrow >>> dateStrings = [ >>> for dateString in dateStrings: ... dateString ... arrow.get(dateString.replace( ... arrow.get(dateString.replace( ... arrow.get(dateString.replace( ... datetime.datetime(2005, 6, 1, 13, 33, tzinfo=tzutc()) datetime.datetime(1999, 8, 28, 0, 0, tzinfo=tzutc())
from datetime import datetime datetime_object = datetime.strptime(
import date_converter converted_date = date_converter.string_to_datetime(
>>> import datetime >>> date = datetime.date(int( >>> date datetime.date(2017, 12, 21) >>> type(date) <type
selected_month_rec = date_formate = datetime.date(int(selected_month_rec.split(
def convert_string_to_time(date_string, timezone): from datetime import datetime import pytz date_time_obj = datetime.strptime(date_string[:26], date_time_obj_timezone = pytz.timezone(timezone).localize(date_time_obj) return date_time_obj_timezone date = TIME_ZONE = date_time_obj_timezone = convert_string_to_time(date, TIME_ZONE)
emp = pd.read_csv("C:\\py\\programs\\pandas_2\\pandas\\employees.csv") emp.info()
<class RangeIndex: 1000 entries, 0 to 999 Data columns (total 8 columns): First Name 933 non-null object Gender 855 non-null object
Start Date 1000 non-null object Last Login Time 1000 non-null object
Salary 1000 non-null int64 Bonus % 1000 non-null float64 Senior Management 933 non-null object Team 957 non-null object dtypes: float64(1), int64(1), object(6) memory usage: 62.6+ KB
emp = pd.read_csv("C:\\py\\programs\\pandas_2\\pandas\\employees.csv", parse_dates=["Start Date", "Last Login Time"]) emp.info() <class RangeIndex: 1000 entries, 0 to 999 Data columns (total 8 columns): First Name 933 non-null object Gender 855 non-null object
Start Date 1000 non-null datetime64[ns] Last Login Time 1000 non-null datetime64[ns]
Salary 1000 non-null int64 Bonus % 1000 non-null float64 Senior Management 933 non-null object Team 957 non-null object dtypes: datetime64[ns](2), float64(1), int64(1), object(4) memory usage: 62.6+ KB
def try_strptime(s, fmts=[ for fmt in fmts: try: return datetime.strptime(s, fmt) except: continue return None
python3 -m venv venv source venv/bin/activate pip install --upgrade pip
lrwxr-xr-x 1 chris admin 35B Dec 2 13:40 /usr/local/bin/python -> ../Cellar/python/2.7.8_2/bin/python
sudo python Desktop/get-pip.py Password: Downloading/unpacking pip Downloading pip-1.5.2-py2.py3-none-any.whl (1.2MB): 1.2MB downloaded Installing collected packages: pip Successfully installed pip Cleaning up... sudo pip install pymongo Password: Downloading/unpacking pymongo Downloading pymongo-2.6.3.tar.gz (324kB): 324kB downloaded Running setup.py (path:/private/var/folders/0c/jb79t3bx7cz6h7p71ydhwb_m0000gn/T/pip_build_goker/pymongo/setup.py) egg_info for package pymongo Installing collected packages: pymongo ...
import os dir_path = os.path.dirname(os.path.realpath(__file__))
import os print("Path at terminal when executing this file") print(os.getcwd() + "\n") print("This file path, relative to os.getcwd()") print(__file__ + "\n") print("This file full path (following symlinks)") full_path = os.path.realpath(__file__) print(full_path + "\n") print("This file directory and name") path, filename = os.path.split(full_path) print(path + print("This file directory only") print(os.path.dirname(full_path))
>>import os >>str1=os.getcwd() >>str2=str1.split( >>n=len(str2) >>print str2[n-1]
dirname, filename = os.path.split(os.path.abspath(__file__))
$ pwd /home/skovorodkin/stack $ tree . └── scripts ├── 1.py └── 2.py
$ cat scripts/2.py from pathlib import Path p = Path(__file__).resolve() with p.open() as f: pass with open(str(p)) as f: pass with open(p) as f: pass print( $ python3.5 scripts/2.py Traceback (most recent call last): File "scripts/2.py", line 11, in <module> with open(p) as f: TypeError: invalid file: PosixPath(
current_folder_path, current_folder_name = os.path.split(os.getcwd())
import pathlib filepath = pathlib.Path(__file__).resolve().parent
import os this_py_file = os.path.realpath(__file__)
class bcolors: HEADER = OKBLUE = OKGREEN = WARNING = FAIL = ENDC = BOLD = UNDERLINE =
print bcolors.WARNING + "Warning: No active frommets remain. Continue?" + bcolors.ENDC
def print_format_table(): for style in range(8): for fg in range(30,38): s1 = for bg in range(40,48): format = s1 += print(s1) print( print_format_table()
CRED = CEND = print(CRED + "Error, does not compute!" + CEND)
CEND = CBOLD = CITALIC = CURL = CBLINK = CBLINK2 = CSELECTED = CBLACK = CRED = CGREEN = CYELLOW = CBLUE = CVIOLET = CBEIGE = CWHITE = CBLACKBG = CREDBG = CGREENBG = CYELLOWBG = CBLUEBG = CVIOLETBG = CBEIGEBG = CWHITEBG = CGREY = CRED2 = CGREEN2 = CYELLOW2 = CBLUE2 = CVIOLET2 = CBEIGE2 = CWHITE2 = CGREYBG = CREDBG2 = CGREENBG2 = CYELLOWBG2 = CBLUEBG2 = CVIOLETBG2 = CBEIGEBG2 = CWHITEBG2 =
x = 0 for i in range(24): colors = "" for j in range(5): code = str(x+j) colors = colors + "\33[" + code + "m\\33[" + code + "m\033[0m " print(colors) x=x+5
CSI="\x1B[" print CSI+"31;40m" + "Colored Text" + CSI + "0m"
from blessings import Terminal t = Terminal() print t.red( print t.bold_bright_red_on_black(
class colors: reset all colors with colors.reset two subclasses fg for foreground and bg for background. use as colors.subclass.colorname. i.e. colors.fg.red or colors.bg.green also, the generic bold, disable, underline, reverse, strikethrough, and invisible work with the main class i.e. colors.bold reset= bold= disable= underline= reverse= strikethrough= invisible= class fg: black= red= green= orange= blue= purple= cyan= lightgrey= darkgrey= lightred= lightgreen= yellow= lightblue= pink= lightcyan= class bg: black= red= green= orange= blue= purple= cyan= lightgrey=
def prRed(prt): print("\033[91m {}\033[00m" .format(prt)) def prGreen(prt): print("\033[92m {}\033[00m" .format(prt)) def prYellow(prt): print("\033[93m {}\033[00m" .format(prt)) def prLightPurple(prt): print("\033[94m {}\033[00m" .format(prt)) def prPurple(prt): print("\033[95m {}\033[00m" .format(prt)) def prCyan(prt): print("\033[96m {}\033[00m" .format(prt)) def prLightGray(prt): print("\033[97m {}\033[00m" .format(prt)) def prBlack(prt): print("\033[98m {}\033[00m" .format(prt)) prGreen("Hello world")
import ctypes STD_OUTPUT_HANDLE = -11 FOREGROUND_RED = 0x0004 def get_csbi_attributes(handle): import struct csbi = ctypes.create_string_buffer(22) res = ctypes.windll.kernel32.GetConsoleScreenBufferInfo(handle, csbi) assert res (bufx, bufy, curx, cury, wattr, left, top, right, bottom, maxx, maxy) = struct.unpack("hhhhHhhhhhh", csbi.raw) return wattr handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE) reset = get_csbi_attributes(handle) ctypes.windll.kernel32.SetConsoleTextAttribute(handle, FOREGROUND_RED) print "Cherry on top" ctypes.windll.kernel32.SetConsoleTextAttribute(handle, reset)
from sty import fg, bg, ef, rs, Rule foo = fg.red + bar = bg.blue + baz = ef.italic + qux = fg(201) + qui = fg(255, 10, 10) + fg.orange = Rule( buf = fg.orange + print(foo, bar, baz, qux, qui, buf, sep=
class PrintInColor: RED = GREEN = YELLOW = LIGHT_PURPLE = PURPLE = END = @classmethod def red(cls, s, **kwargs): print(cls.RED + s + cls.END, **kwargs) @classmethod def green(cls, s, **kwargs): print(cls.GREEN + s + cls.END, **kwargs) @classmethod def yellow(cls, s, **kwargs): print(cls.YELLOW + s + cls.END, **kwargs) @classmethod def lightPurple(cls, s, **kwargs): print(cls.LIGHT_PURPLE + s + cls.END, **kwargs) @classmethod def purple(cls, s, **kwargs): print(cls.PURPLE + s + cls.END, **kwargs)
HEADER = OKBLUE = OKGREEN = WARNING = FAIL = ENDC = BOLD = "\033[1m" def disable(): HEADER = OKBLUE = OKGREEN = WARNING = FAIL = ENDC = def infog( msg): print OKGREEN + msg + ENDC def info( msg): print OKBLUE + msg + ENDC def warn( msg): print WARNING + msg + ENDC def err( msg): print FAIL + msg + ENDC
import log log.info("Hello World") log.err("System Error")
from lazyme.string import color_print >>> color_print( abc >>> color_print( abc >>> color_print( abc >>> color_print( abc >>> color_print( abc >>> color_print( abc >>> color_print( abc >>> color_print( abc
>>> from lazyme.string import palette, highlighter, formatter >>> from lazyme.string import color_print >>> palette.keys() [ >>> highlighter.keys() [ >>> formatter.keys() [
>>> color_print( foo bar >>> color_print( foo bar >>> color_print( foo bar >>> color_print( foo bar >>> color_print( foo bar >>> color_print( foo bar
from colorama import Fore, Style import sys class Highlight: def __init__(self, clazz, color): self.color = color self.clazz = clazz def __enter__(self): print(self.color, end="") def __exit__(self, type, value, traceback): if self.clazz == Fore: print(Fore.RESET, end="") else: assert self.clazz == Style print(Style.RESET_ALL, end="") sys.stdout.flush() with Highlight(Fore, Fore.GREEN): print("this is highlighted") print("this is not")
from clint.textui import colored print colored.red( print colored.green(
print " "+ "\033[01;41m" + " " +"\033[01;46m" + " " + "\033[01;42m"
from asciimatics.effects import RandomNoise from asciimatics.renderers import SpeechBubble, Rainbow from asciimatics.scene import Scene from asciimatics.screen import Screen from asciimatics.exceptions import ResizeScreenError def demo(screen): render = Rainbow(screen, SpeechBubble( effects = [RandomNoise(screen, signal=render)] screen.play([Scene(effects, -1)], stop_on_resize=True) while True: try: Screen.wrapper(demo) break except ResizeScreenError: pass
import curses def main(stdscr): stdscr.clear() if curses.has_colors(): for i in xrange(1, curses.COLORS): curses.init_pair(i, i, curses.COLOR_BLACK) stdscr.addstr("COLOR %d! " % i, curses.color_pair(i)) stdscr.addstr("BOLD! ", curses.color_pair(i) | curses.A_BOLD) stdscr.addstr("STANDOUT! ", curses.color_pair(i) | curses.A_STANDOUT) stdscr.addstr("UNDERLINE! ", curses.color_pair(i) | curses.A_UNDERLINE) stdscr.addstr("BLINK! ", curses.color_pair(i) | curses.A_BLINK) stdscr.addstr("DIM! ", curses.color_pair(i) | curses.A_DIM) stdscr.addstr("REVERSE! ", curses.color_pair(i) | curses.A_REVERSE) stdscr.refresh() stdscr.getch() if __name__ == print "init..." curses.wrapper(main)
""" .. versionadded:: 0.9.2 Functions for wrapping strings in ANSI color codes. Each function within this module returns the input string ``text``, wrapped with ANSI color codes for the appropriate color. For example, to print some text as green on supporting terminals:: from fabric.colors import green print(green("This text is green!")) Because these functions simply return modified strings, you can nest them:: from fabric.colors import red, green print(red("This sentence is red, except for " + \ green("these words, which are green") + ".")) If ``bold`` is set to ``True``, the ANSI flag for bolding will be flipped on for that particular invocation, which usually shows up as a bold or brighter version of the original color on most terminals. """ def _wrap_with(code): def inner(text, bold=False): c = code if bold: c = "1;%s" % c return "\033[%sm%s\033[0m" % (c, text) return inner red = _wrap_with( green = _wrap_with( yellow = _wrap_with( blue = _wrap_with( magenta = _wrap_with( cyan = _wrap_with( white = _wrap_with(
from __future__ import print_function from colorprint import * print( print(
from ctypes import windll try: input = raw_input except: pass STD_OUTPUT_HANDLE = -11 stdout_handle = windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE) for color in range(0, 75): windll.kernel32.SetConsoleTextAttribute(stdout_handle, color) print("%X --> %s" % (color, "Have a fine day!")) input("Press Enter to go on ... ")
>>> from django.utils.termcolors import colorize >>> print colorize("Hello World!", fg="blue", bg= ... opts=( Hello World! >>> help(colorize)
fg = lambda text, color: "\33[38;5;" + str(color) + "m" + text + "\33[0m" bg = lambda text, color: "\33[48;5;" + str(color) + "m" + text + "\33[0m" def print_six(row, format): for col in range(6): color = row*6 + col + 4 if color>=0: text = "{:3d}".format(color) print (format(text,color), end=" ") else: print(" ", end=" ") for row in range(-1,42): print_six(row, fg) print("",end=" ") print_six(row, bg) print()
import unicodedata fp= open("character_list", "w") for index in xrange(65536): char= unichr(index) try: its_name= unicodedata.name(char) except ValueError: its_name= "N/A" fp.write("%05d %04x %s %s\n" % (index, index, char.encode("UTF-8"), its_name) fp.close()
>>> s= >>> print s.lower() Километр >>> print s.decode( километр
>>> "Maße".casefold() >>> "Maße".lower() >>> "MASSE" == "Maße" False >>> "MASSE".lower() == "Maße".lower() False >>> "MASSE".casefold() == "Maße".casefold() True
>>> string = >>> string >>> string.lower() >>> print string.lower() Километр
>>> unicode_literal = u >>> print(unicode_literal.lower()) километр
>>> unicode_literal u >>> unicode_literal.lower() u
>>> unicode_from_string = unicode(string, >>> print(unicode_from_string.lower()) километр >>> string_to_unicode = string.decode( >>> print(string_to_unicode.lower()) километр >>> unicode_from_string == string_to_unicode == unicode_literal True
>>> print string Километр >>> string >>> string.decode( u >>> string.decode( u >>> string.decode( >>> print string.decode( километр
s = "Kilometer" print(s.lower()) - kilometer print(s) - Kilometer
string = "StackOverFlow" f = map(lambda x:chr(ord(x)+32) if 90>ord(x)>65 else x,list(string)) print("".join(f))
>>> m = MyClass() >>> m.i = 4 >>> MyClass.i, m.i >>> (3, 4)
>>> t = Test() >>> t.i 3 >>> t.i = 5 >>> Test.i 3 >>> t.i 5 >>> Test.i = 6 >>> t.i 5 >>> Test.i 6 >>> u = Test() >>> u.i 6 >>> Test.__dict__ { >>> t.__dict__ { >>> u.__dict__ {}
class Test(object): @staticmethod def f(arg1, arg2, ...): ...
class Test(object): i = 3 @classmethod def g(cls, arg): if arg > cls.i: cls.i = arg
class Test(object): def MyMethod(self): pass @classmethod def MyClassMethod(klass): pass @staticmethod def MyStaticMethod(): pass
class Test(object): i = 3 x = Test() x.i = 12 assert x.i == Test.i assert Test.i == 3 assert x.i == 12
class Test(object): _i = 3 @property def i(self): return type(self)._i @i.setter def i(self,val): type(self)._i = val class Test(object): _i = 3 def get_i(self): return type(self)._i def set_i(self,val): type(self)._i = val i = property(get_i, set_i)
x1 = Test() x2 = Test() x1.i = 50 assert x2.i == x1.i assert x2.i == 50
class Test(object): _i = 3 @property def i(self): return type(self)._i class Test(object): _i = 3 def get_i(self): return type(self)._i i = property(get_i)
x = Test() assert x.i == Test.i type(Test.i) type(x.i)
class MyClass(metaclass = MyMeta): pass type(MyClass)
from functools import wraps class StaticVarsMeta(type): of other languages. I do not advise actually using this for anything!!! Behavior is intended to be similar to classes that use __slots__. However, "normal" attributes and __statics___ can coexist (unlike with __slots__). Example usage: class MyBaseClass(metaclass = StaticVarsMeta): __statics__ = { i = 0 a = 1 class MyParentClass(MyBaseClass): __statics__ = { j = 2 d, e, f = 3, 4, 5 a, b, c = 6, 7, 8 class MyChildClass(MyParentClass): __statics__ = { j = 2 d, e, f = 9, 10, 11 a, b, c = 12, 13, 14 statics = {} def __new__(mcls, name, bases, namespace): cls = super().__new__(mcls, name, bases, namespace) cls.__sro__ = tuple(c for c in cls.__mro__ if isinstance(c,mcls)) cls.__getattribute__ = StaticVarsMeta.__inst_getattribute__(cls, cls.__getattribute__) cls.__setattr__ = StaticVarsMeta.__inst_setattr__(cls, cls.__setattr__) cls.__delattr__ = StaticVarsMeta.__inst_delattr__(cls, cls.__delattr__) try: mcls.statics[cls] = getattr(cls, except AttributeError: mcls.statics[cls] = namespace[ if any(not isinstance(static,str) for static in mcls.statics[cls]): typ = dict(zip((not isinstance(static,str) for static in mcls.statics[cls]), map(type,mcls.statics[cls])))[True].__name__ raise TypeError( if len(cls.__sro__) > 1: for attr,value in namespace.items(): if attr not in StaticVarsMeta.statics[cls] and attr != [ for c in cls.__sro__[1:]: if attr in StaticVarsMeta.statics[c]: setattr(c,attr,value) delattr(cls,attr) return cls def __inst_getattribute__(self, orig_getattribute): @wraps(orig_getattribute) def wrapper(self, attr): if StaticVarsMeta.is_static(type(self),attr): return StaticVarsMeta.__getstatic__(type(self),attr) else: return orig_getattribute(self, attr) return wrapper def __inst_setattr__(self, orig_setattribute): @wraps(orig_setattribute) def wrapper(self, attr, value): if StaticVarsMeta.is_static(type(self),attr): StaticVarsMeta.__setstatic__(type(self),attr, value) else: orig_setattribute(self, attr, value) return wrapper def __inst_delattr__(self, orig_delattribute): @wraps(orig_delattribute) def wrapper(self, attr): if StaticVarsMeta.is_static(type(self),attr): StaticVarsMeta.__delstatic__(type(self),attr) else: orig_delattribute(self, attr) return wrapper def __getstatic__(cls,attr): for c in cls.__sro__: if attr in StaticVarsMeta.statics[c]: try: return getattr(c,attr) except AttributeError: pass raise AttributeError(cls.__name__ + " object has no attribute def __setstatic__(cls,attr,value): for c in cls.__sro__: if attr in StaticVarsMeta.statics[c]: setattr(c,attr,value) break def __delstatic__(cls,attr): for c in cls.__sro__: if attr in StaticVarsMeta.statics[c]: try: delattr(c,attr) break except AttributeError: pass raise AttributeError(cls.__name__ + " object has no attribute def __delattr__(cls,attr): if attr == raise AttributeError( super().__delattr__(attr) def is_static(cls,attr): if any(attr in StaticVarsMeta.statics[c] for c in cls.__sro__): return True return False
>>> class X: ... pass ... >>> X.bar = 0 >>> x = X() >>> x.bar 0 >>> x.foo Traceback (most recent call last): File "<interactive input>", line 1, in <module> AttributeError: X instance has no attribute >>> X.foo = 1 >>> x.foo 1
class X: l = [] def __init__(self): self.l.append(1) print X().l print X().l >python test.py [1] [1, 1]
class myObj(object): def myMethod(cls) ... myMethod = classmethod(myMethod)
class myObj(object): @classmethod def myMethod(cls)
class my_cls: my_prop = 0 print my_cls.my_prop my_cls.my_prop = 1 print my_cls.my_prop my_inst = my_cls() print my_inst.my_prop my_inst.my_prop = 2 print my_cls.my_prop print my_inst.my_prop
class MyClass: def myInstanceMethod(self): print @classmethod def myStaticMethod(cls): print >>> MyClass.myInstanceMethod() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unbound method myInstanceMethod() must be called [...] >>> MyClass.myStaticMethod() output from a static method
>>> MyClass.myInstanceMethod(MyClass()) output from an instance method
class A: var=1 def printvar(self): print "self.var is %d" % self.var print "A.var is %d" % A.var a = A() a.var = 2 a.printvar() A.var = 3 a.printvar()
class StaticClassError(Exception): pass class StaticClass: __metaclass__ = abc.ABCMeta def __new__(cls, *args, **kw): raise StaticClassError("%s is a static class and cannot be initiated." % cls) class MyClass(StaticClass): a = 1 b = 3 @staticmethod def add(x, y): return x+y
class Static: def __init__(self, value, doc=None): self.deleted = False self.value = value self.__doc__ = doc def __get__(self, inst, cls=None): if self.deleted: raise AttributeError( return self.value def __set__(self, inst, value): self.deleted = False self.value = value def __delete__(self, inst): self.deleted = True class StaticType(type): def __delattr__(cls, name): obj = cls.__dict__.get(name) if isinstance(obj, Static): obj.__delete__(name) else: super(StaticType, cls).__delattr__(name) def __getattribute__(cls, *args): obj = super(StaticType, cls).__getattribute__(*args) if isinstance(obj, Static): obj = obj.__get__(cls, cls.__class__) return obj def __setattr__(cls, name, val): obj = cls.__dict__.get(name) if isinstance(obj, Static): obj.__set__(name, val) else: super(StaticType, cls).__setattr__(name, val)
class MyStatic(metaclass=StaticType): a = Static(9) b = Static(12) c = 3 class YourStatic(MyStatic): d = Static( e = Static(
ms1 = MyStatic() ms2 = MyStatic() ms3 = MyStatic() assert ms1.a == ms2.a == ms3.a == MyStatic.a assert ms1.b == ms2.b == ms3.b == MyStatic.b assert ms1.c == ms2.c == ms3.c == MyStatic.c ms1.a = 77 assert ms1.a == ms2.a == ms3.a == MyStatic.a ms2.b = 99 assert ms1.b == ms2.b == ms3.b == MyStatic.b MyStatic.a = 101 assert ms1.a == ms2.a == ms3.a == MyStatic.a MyStatic.b = 139 assert ms1.b == ms2.b == ms3.b == MyStatic.b del MyStatic.b for inst in (ms1, ms2, ms3): try: getattr(inst, except AttributeError: pass else: print( ms1.c = 13 ms2.c = 17 ms3.c = 19 assert ms1.c == 13 assert ms2.c == 17 assert ms3.c == 19 MyStatic.c = 43 assert ms1.c == 13 assert ms2.c == 17 assert ms3.c == 19 ys1 = YourStatic() ys2 = YourStatic() ys3 = YourStatic() MyStatic.b = assert ys1.a == ys2.a == ys3.a == YourStatic.a == MyStatic.a assert ys1.b == ys2.b == ys3.b == YourStatic.b == MyStatic.b assert ys1.d == ys2.d == ys3.d == YourStatic.d assert ys1.e == ys2.e == ys3.e == YourStatic.e ys1.a = assert ys1.a == ys2.a == ys3.a == YourStatic.a == MyStatic.a ys2.b = assert ys1.b == ys2.b == ys3.b == YourStatic.b == MyStatic.b ys1.d = assert ys1.d == ys2.d == ys3.d == YourStatic.d ys2.e = assert ys1.e == ys2.e == ys3.e == YourStatic.e MyStatic.a = assert ys1.a == ys2.a == ys3.a == YourStatic.a == MyStatic.a
class A(object): label="Amazing" def __init__(self,d): self.data=d def say(self): print("%s %s!"%(self.label,self.data)) class B(A): label="Bold" A(5).say() B(3).say()
class staticFlag: def __init__(self): self.__success = False def isSuccess(self): return self.__success def succeed(self): self.__success = True class tryIt: def __init__(self, staticFlag): self.isSuccess = staticFlag.isSuccess self.succeed = staticFlag.succeed tryArr = [] flag = staticFlag() for i in range(10): tryArr.append(tryIt(flag)) if i == 5: tryArr[i].succeed() print tryArr[i].isSuccess()
False False False False False True True True True True
class A: counter =0 def callme (self): A.counter +=1 def getcount (self): return self.counter >>> x=A() >>> y=A() >>> print(x.getcount()) >>> print(y.getcount()) >>> x.callme() >>> print(x.getcount()) >>> print(y.getcount())
here object (x) alone increment the counter variable from 0 to 1 by not object y. But result it as "static counter"
class ConstantAttribute(object): def __init__(self, value): self.value = value def __get__(self, obj, type=None): return self.value def __set__(self, obj, val): pass class Demo(object): x = ConstantAttribute(10) class SubDemo(Demo): x = 10 demo = Demo() subdemo = SubDemo() demo.x = 100 subdemo.x = 100 print "small demo", demo.x print "small subdemo", subdemo.x print "big demo", Demo.x print "big subdemo", SubDemo.x
small demo 10 small subdemo 100 big demo 10 big subdemo 10
class StaticAttribute(object): def __init__(self, value): self.value = value def __get__(self, obj, type=None): return self.value def __set__(self, obj, val): self.value = val
>>> def SomeFactory(some_var=None): ... class SomeClass(object): ... nonlocal some_var ... def print(): ... print(some_var) ... return SomeClass ... >>> SomeFactory(some_var="hello world").print() hello world
>>> class A: ...my_var = "shagun" >>> print(A.my_var) shagun
>>> a = A() >>> a.my_var = "pruthi" >>> print(A.my_var,a.my_var) shagun pruthi
>>> class A: ... @staticmethod ... def my_static_method(): ... print("Yippey!!") ... >>> A.my_static_method() Yippey!!
switch( key ) { case result = 1; break; case result = 2; break; default : result = -1; }
choices = { (result1, result2, result3) = choices.get(key, (
class switch(object): value = None def __new__(class_, value): class_.value = value return True def case(*args): return any((arg == switch.value for arg in args))
while switch(n): if case(0): print "You typed zero." break if case(1, 4, 9): print "n is a perfect square." break if case(2): print "n is an even number." if case(2, 3, 5, 7): print "n is a prime number." break if case(6, 8): print "n is an even number." break print "Only single-digit numbers are allowed." break
class SMTP: def lookupMethod(self, command): return getattr(self, def do_HELO(self, rest): return def do_QUIT(self, rest): return SMTP().lookupMethod( SMTP().lookupMethod(
class SMTP: def do_UNKNOWN(self, rest): raise NotImplementedError, def state_COMMAND(self, line): line = line.strip() parts = line.split(None, 1) if parts: method = self.lookupMethod(parts[0]) or self.do_UNKNOWN if len(parts) == 2: return method(parts[1]) else: return method( else: raise SyntaxError, SMTP().state_COMMAND(
v = for case in switch(v): if case( print 1 break if case( print 2 break if case( print 10 break if case( print 11 break if case(): print "something else!" c = for case in switch(c): if case( if case( if case( if case( print "c is lowercase!" break if case( if case( print "c is uppercase!" break if case(): print "I dunno what c was!" import string c = for case in switch(c): if case(*string.lowercase): print "c is lowercase!" break if case(*string.uppercase): print "c is uppercase!" break if case( print "c is a sentence terminator!" break if case(): print "I dunno what c was!"
class Switch: def __init__(self, value): self._val = value def __enter__(self): return self def __exit__(self, type, value, traceback): return False def __call__(self, *mconds): return self._val in mconds from datetime import datetime with Switch(datetime.today().weekday()) as case: if case(0): print("I hate mondays so much.") elif case(1,2): print("When is the weekend going to be here?") elif case(3,4): print("The weekend is near.") else: print("Let
func, args = { }.get(value, (obj.default, (x,))) result = func(*args)
if something: return "first thing" elif somethingelse: return "second thing" elif yetanotherthing: return "third thing" else: return "default thing"
def f(x): try: return { }[x] except KeyError: return
def first_case(): print "first" def second_case(): print "second" def third_case(): print "third" mycase = { } myfunc = mycase[ myfunc()
macro switch(arg1): while True: cont=False val=%arg1% socket case(arg2): if val==%arg2% or cont: cont=True socket socket else: socket break
a=3 switch(a): case(0): print("Zero") case(1): print("Smaller than 2"): break else: print ("greater than 1")
a=3 while True: cont=False if a==0 or cont: cont=True print ("Zero") if a==1 or cont: cont=True print ("Smaller than 2") break print ("greater than 1") break
l = [ for x in l: if x in ( x += " has four legs" elif x in ( x += " has wings." elif x in ( x += " has a forked tongue." else: x += " is a big mystery by default." print(x) print() for x in range(10): if x in (0, 1): x = "Values 0 and 1 caught here." elif x in (2,): x = "Value 2 caught here." elif x in (3, 7, 8): x = "Values 3, 7, 8 caught here." elif x in (4, 6): x = "Values 4 and 6 caught here" else: x = "Values 5 and 9 caught in default." print(x)
Dog has four legs Cat has four legs Bird has wings. Bigfoot is a big mystery by default. Dragonfly has wings. Snake has a forked tongue. Bat has wings. Loch Ness Monster is a big mystery by default. Values 0 and 1 caught here. Values 0 and 1 caught here. Value 2 caught here. Values 3, 7, 8 caught here. Values 4 and 6 caught here Values 5 and 9 caught in default. Values 4 and 6 caught here Values 3, 7, 8 caught here. Values 3, 7, 8 caught here. Values 5 and 9 caught in default.
switch ...parameter... case p1: v1; break; case p2: v2; break; default: v3;
result = { }.get(whatToUse, lambda x: x - 22)(value)
some_value = 5.0 while True: if some_value > 5: print ( break if some_value == 5: print ( break print ( break
def dispatch(self, value): method_name = method = getattr(self, method_name) method()
if x == 1: print( elif x == 2: print( elif x == 3: print( else: print(
In [2]: result = { ...: ...: ...: ...: } ...: result[ ...: Out[2]: In [3]: result = { ...: ...: ...: ...: None: lambda : ...: } ...: result[ ...: Out[3]:
class ChoiceManager: def __init__(self): self.__choice_table = \ { "CHOICE1" : self.my_func1, "CHOICE2" : self.my_func2, } def my_func1(self, data): pass def my_func2(self, data): pass def process(self, case, data): return self.__choice_table[case](data) ChoiceManager().process("CHOICE1", my_data)
class PacketManager: def __init__(self): self.__choice_table = \ { ControlMessage : self.my_func1, DiagnosticMessage : self.my_func2, } def my_func1(self, data): pass def my_func2(self, data): pass def process(self, pkt): return self.__choice_table[pkt.__class__](pkt) pkt = GetMyPacketFromNet() PacketManager().process(pkt) def test_control_packet(): p = ControlMessage() PacketManager().my_func1(p)
def switch1(value, options): if value in options: options[value]()
def sample1(x): local = switch1(x, { print("goodbye," + local), print("!")), })
def switch(value, *maps): options = {} for m in maps: options.update(m) if value in options: options[value]() elif None in options: options[None]()
def sample(x): switch(x, { _: lambda: print("other") for _ in }, { print("goodbye,"), print("!")), None: lambda: print("I dunno") })
def numbers_to_strings(argument): switcher = { 0: "zero", 1: "one", 2: "two", } return switcher.get(argument, "nothing")
function(argument){ switch(argument) { case 0: return "zero"; case 1: return "one"; case 2: return "two"; default: return "nothing"; } }
def decision_time( key, *args, **kwargs): def action1() pass def action2() pass def action3() pass return {1:action1, 2:action2, 3:action3}.get(key,default)()
for case in [expression]: if case == 1: do_stuff() if case in range(2, 5): do_other_stuff() break do_default()
exec { 1: """ print ( print ( """, 3: """ print ( """, }.get(value, """ print ( """)
switch (value) { case 1: printf("one"); break; case 2: printf("two"); break; case 3: printf("three"); break; default: printf("None"); break; }
def switch(value, cases, default): exec cases.get(value, default)
switch(value, { 1: """ print ( print ( """, 3: """ print ( """, }, """ print ( """)
def case(callable): class case_class(object): def __init__(self, *args, **kwargs): self.args = args self.kwargs = kwargs def do_call(self): return callable(*self.args, **self.kwargs) return case_class def switch(key, cases, default=None): ret = None try: ret = case[key].do_call() except KeyError: if default: ret = default.do_call() finally: return ret
@case def case_1(arg1): print @case def case_2(arg1, arg2): print return arg1, arg2 @case def default_case(arg1, arg2, arg3): print ret = switch(somearg, { 1: case_1( 2: case_2(13, 42) }, default_case(123, print ret
database/ __init__.py schema.py insertions.py queries.py
import os from sqlalchemy.orm import sessionmaker from sqlalchemy import create_engine engine = create_engine(os.environ[ Session = sessionmaker(bind=engine)
from database.create_session import Session session = Session()
your_package/ __init__.py file1.py/ file2.py/ ... fileN.py from file1 import * from file2 import * ... from fileN import * def add(): pass
import logging.config logging.config.dictConfig(Your_logging_config)
$ mkdir -p /tmp/test_init $ touch /tmp/test_init/module.py /tmp/test_init/__init__.py $ tree -at /tmp/test_init /tmp/test_init ├── module.py └── __init__.py $ python3 >>> import sys >>> sys.path.insert(0, >>> from test_init import module >>> import test_init.module $ rm -f /tmp/test_init/__init__.py $ tree -at /tmp/test_init /tmp/test_init └── module.py $ python3 >>> import sys >>> sys.path.insert(0, >>> from test_init import module >>> import test_init.module
package_x/ |-- __init__.py |-- subPackage_a/ |------ __init__.py |------ module_m1.py |-- subPackage_b/ |------ __init__.py |------ module_n1.py |------ module_n2.py |------ module_n3.py
def function_X(): print "function_X in module_n1" return
>>>from package_x.subPackage_b.module_n1 import function_X >>>function_X() function_X in module_n1
>>>from package_x.subPackage_b import * >>>module_n1.function_X() Traceback (most recent call last): File "<stdin>", line 1, in <module> ImportError: No module named module_n1
$ find /tmp/mydir/ /tmp/mydir/ /tmp/mydir /tmp/mydir /tmp/mydir $ cd ~ $ python >>> import sys >>> sys.path.insert(0, >>> from spam import module >>> module.myfun(3) 9 >>> exit() $ $ rm /tmp/mydir/spam/__init__.py* $ $ python >>> import sys >>> sys.path.insert(0, >>> from spam import module Traceback (most recent call last): File "<stdin>", line 1, in <module> ImportError: No module named spam >>>
from main_methods.methods import foo from main_methods import methods import main_methods.methods
import os myfile="/tmp/foo.txt" if os.path.isfile(myfile): os.remove(myfile) else: print("Error: %s file not found" % myfile)
import os myfile= raw_input("Enter file name to delete: ") try: os.remove(myfile) except OSError as e: print ("Error: %s - %s." % (e.filename, e.strerror))
import os import sys import shutil mydir= raw_input("Enter directory name: ") try: shutil.rmtree(mydir) except OSError as e: print ("Error: %s - %s." % (e.filename, e.strerror))
shutil.rmtree(path, ignore_errors=False, onerror=None)
def remove(path): if os.path.isfile(path): os.remove(path) elif os.path.isdir(path): shutil.rmtree(path) else: raise ValueError("file {} is not a file or dir.".format(path))
import pathlib path = pathlib.Path(name_of_file) path.unlink()
import pathlib path = pathlib.Path(name_of_folder) path.rmdir()
from pathlib import Path dir_path = Path.home() / file_path = dir_path / file_path.unlink() dir_path.rmdir()
from pathlib import Path directory_path = Path.home() / directory_path.mkdir() file_path = directory_path / file_path.touch()
>>> file_path.unlink() >>> file_path.is_file() False >>> file_path.exists() False
>>> for each_file_path in directory_path.glob( ... print(f ... each_file_path.unlink() ... removing ~/directory/foo.my removing ~/directory/bar.my
>>> directory_path.rmdir() >>> directory_path.is_dir() False >>> directory_path.exists() False
>>> directory_path.rmdir() Traceback (most recent call last): File "<stdin>", line 1, in <module> File "~/anaconda3/lib/python3.6/pathlib.py", line 1270, in rmdir self._accessor.rmdir(self) File "~/anaconda3/lib/python3.6/pathlib.py", line 387, in wrapped return strfunc(str(pathobj), *args) OSError: [Errno 39] Directory not empty:
from os import unlink, remove from os.path import join, expanduser remove(join(expanduser(
import os import shutil shutil.rmtree(path) while os.path.exists(path): pass print(
import os folder = fileList = os.listdir(folder) for f in fileList: filePath = folder + if os.path.isfile(filePath): os.remove(filePath) elif os.path.isdir(filePath): newFileList = os.listdir(filePath) for f1 in newFileList: insideFilePath = filePath + if os.path.isfile(insideFilePath): os.remove(insideFilePath)
import subprocess subprocess.Popen("rm -r my_dir", shell=True)
>>> some_list = [1, 2, 3] >>> some_list[-1] = 5 >>> some_list[-2] = 3 >>> some_list [1, 3, 5]
alist = [] alist[-1] alist[-1:] astr = astr[-1] astr[-1:]
+---+---+---+---+---+---+ | P | y | t | h | o | n | +---+---+---+---+---+---+ 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 >>> p = >>> p[-1]
def last(a_list): return a_list[-1] def first(a_list): return a_list[0]
>>> import operator >>> last = operator.itemgetter(-1) >>> first = operator.itemgetter(0)
>>> empty_list = [] >>> tail = empty_list[-1:] >>> if tail: ... do_something(tail)
>>> empty_list[-1] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: list index out of range
>>> def do_something(arg): pass >>> for item in a_list: ... do_something(item) ... >>> item
>>> def do_something(arg): raise Exception >>> for item in a_list: ... do_something(item) ... Traceback (most recent call last): File "<stdin>", line 2, in <module> File "<stdin>", line 1, in do_something Exception >>> item
reverse_iterator = reversed([1,2,3]) last_element = next(reverse_iterator) use_later = list(reverse_iterator)
mylist = [ 1 , 2 , 3 , 4 , 5] print(mylist[-1]) print(mylist[len(mylist) - 1]) print(mylist.pop())
import more_itertools as mit mit.last([0, 1, 2, 3]) mit.last(iter([1, 2, 3])) mit.last([], "some default")
import pip from subprocess import call packages = [dist.project_name for dist in pip.get_installed_distributions()] call("pip install --upgrade " +
import pkg_resources from subprocess import call packages = [dist.project_name for dist in pkg_resources.working_set] call("pip install --upgrade " +
$ pip install pip-review $ pip-review --local --interactive
py2 $ pip install pip-review $ pip-review --local --interactive py3 $ pip3 install pip-review $ py -3 -m pip_review --local --interactive
pip freeze | cut -d = -f 1 | xargs -n 1 pip search | grep -B2
pip install -U `pip list --outdated | tail -n +3 | awk
Package Version Latest Type --------- ------- ------ ----- fonttools 3.31.0 3.32.0 wheel urllib3 1.24 1.24.1 wheel requests 2.20.0 2.20.1 wheel
urllib3 (1.7.1) - Latest: 1.15.1 [wheel] wheel (0.24.0) - Latest: 0.29.0 [wheel]
sed="s/^([^= sed="$sed/echo" sed="$sed; echo Processing \1 ..." sed="$sed; pip3 install -U \1" sed="$sed/p" pip3 freeze --local |sed -rn "$sed" |sh
pip install `pip freeze -l | cut --fields=1 -d = -` --upgrade
from pip import get_installed_distributions from pip.commands import install install_cmd = install.InstallCommand() options, args = install_cmd.parse_args([package.project_name for package in get_installed_distributions()]) options.upgrade = True install_cmd.run(options, args)
import pip for dist in pip.get_installed_distributions(): if try: pip.call_subprocess([ except Exception, exc: print exc
pip freeze > requirements.txt && pip install --upgrade -r requirements.txt && rm requirements.txt
import pip pkgs = [p.key for p in pip.get_installed_distributions()] for pkg in pkgs: pip.main([
import pip commands = [ pkgs = commands.extend([p.key for p in pip.get_installed_distributions()]) pip.main(commands)
pip list -o --format json | ConvertFrom-Json | foreach {pip install $_.name -U --no-warn-script-location}
usage: pip_upgrade_outdated [-h] [-3 | -2 | --pip_cmd PIP_CMD] [--serial | --parallel] [--dry_run] [--verbose] [--version] Upgrade outdated python packages with pip. optional arguments: -h, --help show this help message and exit -3 use pip3 -2 use pip2 --pip_cmd PIP_CMD use PIP_CMD (default pip) --serial, -s upgrade in serial (default) --parallel, -p upgrade in parallel --dry_run, -n get list, but don --verbose, -v may be specified multiple times --version show program
1000000000000000000000 in range(0,1000000000000000000001,10)
def my_crappy_range(N): i = 0 while i < N: yield i i += 1 return
class my_range(object): def __init__(self, start, stop=None, step=1): if stop is None: start, stop = 0, start self.start, self.stop, self.step = start, stop, step if step < 0: lo, hi = stop, start else: lo, hi = start, stop self.length = ((hi - lo - 1) def __iter__(self): current = self.start if self.step < 0: while current > self.stop: yield current current += self.step else: while current < self.stop: yield current current += self.step def __len__(self): return self.length def __getitem__(self, i): if i < 0: i += self.length if 0 <= i < self.length: return self.start + i * self.step raise IndexError( def __contains__(self, num): if self.step < 0: if not (self.stop < num <= self.start): return False else: if not (self.start <= num < self.stop): return False return (num - self.start) % self.step == 0
>>> a = range(5) >>> print(list(a)) [0, 1, 2, 3, 4] >>> print(list(a)) [0, 1, 2, 3, 4]
>>> b = my_crappy_range(5) >>> print(list(b)) [0, 1, 2, 3, 4] >>> print(list(b)) []
>>> import collections.abc >>> isinstance(a, collections.abc.Sequence) True
>>> a[3] 3 >>> len(a) 5 >>> 3 in a True >>> reversed(a) <range_iterator at 0x101cd2360> >>> a.index(3) 3 >>> a.count(3) 1
>>> x, r = 1000000000000000, range(1000000000000001) >>> class MyInt(int): ... pass ... >>> x_ = MyInt(x) >>> x in r True >>> x_ in r ^\Quit (core dumped)
def range_contains (rangeObj, obj): if isinstance(obj, int): return range_contains_long(rangeObj, obj) return any(obj == x for x in rangeObj) def range_contains_long (r, num): if r.step > 0: cmp2 = r.start <= num cmp3 = num < r.stop else: cmp2 = num <= r.start cmp3 = r.stop < num if not cmp2 or not cmp3: return False return (num - r.start) % r.step == 0
>>> r = range(5) >>> for i in r: print(i, 2 in r, list(r)) 0 True [0, 1, 2, 3, 4] 1 True [0, 1, 2, 3, 4] 2 True [0, 1, 2, 3, 4] 3 True [0, 1, 2, 3, 4] 4 True [0, 1, 2, 3, 4]
public struct Range : IRange, IEnumerable<int>, IEquatable<Range> { private readonly int _start; private readonly int _stop; private readonly int _step; public bool Contains(int number) { if ((_start % _step + _step) % _step != (number % _step + _step) % _step) return false; int vector = Math.Abs(_step) / _step; return vector * number >= vector * _start && vector * number < vector * _stop; } }
>>> for i in xrange(0,10): print . . . . . . . . . . >>> for i in xrange(0,10): print . . . . . . . . . .
>>> for i in range(10): ... print i, ... else: ... print ... 0 1 2 3 4 5 6 7 8 9 >>>
>>> strings = [ "one", "two", "three" ] >>> >>> for i in xrange(3): ... print "Item %d: %s" % (i, strings[i]) ... Item 0: one Item 1: two Item 2: three
from __future__ import print_function for x in xrange(10): print(
from __future__ import print_function def printf(str, *args): print(str % args, end=
from printf import printf for x in xrange(10): printf( print
import sys for i in xrange(0,10): sys.stdout.write(".") sys.stdout.flush()
>>> import functools >>> printf = functools.partial(print, end="") >>> printf("Hello world\n") Hello world
import sys import time sys.stdout.write("\rfoobar bar black sheep") sys.stdout.flush() time.sleep(2) sys.stdout.write("\r"+ sys.stdout.flush() sys.stdout.write(
import sys, os sys.stdout = os.fdopen(sys.stdout.fileno(), "w", newline=None) for i in range(1,10): print(i)
import sys page=1 search_string=input( print( sys.stdout.flush() while page: page=page+1 sys.stdout.write( sys.stdout.flush() if done: print( page=0 list.sort() for item_count in range(0, items) print(list[item_count]) if not (len(list)==items): print(
def Print(*args,sep= print(*args,sep=sep,end=end,file=file,flush=flush)
for i in range (0,5): print "hi" OUTPUT: hi hi hi hi hi
>>> print( hello >>> print( world >>> print( hello world
>>> type([]) is list True >>> type({}) is dict True >>> type( True >>> type(0) is int True >>> type({}) <type >>> type([]) <type
>>> class Test1 (object): pass >>> class Test2 (Test1): pass >>> a = Test1() >>> b = Test2() >>> type(a) is Test1 True >>> type(b) is Test2 True
>>> isinstance(b, Test1) True >>> isinstance(b, Test2) True >>> isinstance(a, Test1) True >>> isinstance(a, Test2) False >>> isinstance([], list) True >>> isinstance({}, dict) True
>>> a = [] >>> type(a) <type >>> f = () >>> type(f) <type
>>> str = "str" >>> str.__class__ <class >>> i = 2 >>> i.__class__ <class >>> class Test(): ... pass ... >>> a = Test() >>> a.__class__ <class
def foo(obj): if isinstance(obj, str): obj = str.split() return _foo_handles_only_lists_or_tuples(obj)
from collections import Iterable from numbers import Number def bar(obj): if isinstance(obj, Number): obj = (obj,) if not isinstance(obj, Iterable): raise TypeError( return _bar_sensible_with_iterable(obj)
def baz(obj): """given an obj, a dict (or anything with an .items method) do something sensible with each key-value pair """ for key, value in obj.items(): _baz_something_sensible(key, value)
>>> the_d = {} >>> t = lambda x: "aight" if type(x) is dict else "NOPE" >>> t(the_d) >>> dict = "dude." >>> t(the_d)
>>> import __builtin__ >>> the_d = {} >>> type({}) is dict True >>> dict ="" >>> type({}) is dict False >>> type({}) is __builtin__.dict True
class One: pass class Two: pass o = One() t = Two() o_type = type(o) t_type = type(t) print "Are o and t instances of the same class?", o_type is t_type
from types import ClassType _NO_CLASS=object() def get_object_type(obj): obj_type = getattr(obj, "__class__", _NO_CLASS) if obj_type is not _NO_CLASS: return obj_type obj_type = type(obj) if obj_type is not ClassType: raise ValueError("Could not determine object return obj_type
from collections.abc import Sequence isinstance(my_obj, Sequence)
isinstance(True, bool) True >>> isinstance(True, int) True
type(True) == bool True >>> type(True) == int False
my_list = ["Hello", "world"] print my_list.join("-")
my_list = ["Hello", "world"] print "-".join(my_list)
>>> b"".join <built-in method join of bytes object at 0x00A46800> >>> "".join <built-in method join of str object at 0x00A28D40>
class OurList(list): def join(self, s): return s.join(self)
>>> import timeit >>> min(timeit.repeat(lambda: 3.839168446022086 >>> min(timeit.repeat(lambda: 3.339879313018173
newlist = sorted(list_to_be_sorted, key=lambda k: k[
from operator import itemgetter newlist = sorted(list_to_be_sorted, key=itemgetter(
my_list = [{ sortedlist = sorted(my_list , key=lambda elem: "%02d %s" % (elem[
import operator a_list_of_dicts.sort(key=operator.itemgetter(
sort_on = "name" decorated = [(dict_[sort_on], dict_) for dict_ in py] decorated.sort() result = [dict_ for (key, dict_) in decorated]
def mykey(adict): return adict[ x = [{ sorted(x, key=mykey)
from operator import itemgetter x = [{ sorted(x, key=itemgetter(
a = [{ a.sort(key=lambda k : k[ sorted(a, key=lambda k : k[
def sort_key_func(item): """ helper function used to sort list of dicts :param item: dict :return: sorted list of tuples (k, v) """ pairs = [] for k, v in item.items(): pairs.append((k, v)) return sorted(pairs) sorted(A, key=sort_key_func)
lists = [{ { { lists = sorted(lists, key=lambda k: k[ print(lists) lists = sorted(lists, key=lambda k: k[ print(lists)
import pandas as pd listOfDicts = [{ df = pd.DataFrame(listOfDicts) df = df.sort_values( sorted_listOfDicts = df.T.to_dict().values()
setup_large = "listOfDicts = [];\ [listOfDicts.extend(({ from operator import itemgetter;import pandas as pd;\ df = pd.DataFrame(listOfDicts);" setup_small = "listOfDicts = [];\ listOfDicts.extend(({ from operator import itemgetter;import pandas as pd;\ df = pd.DataFrame(listOfDicts);" method1 = "newlist = sorted(listOfDicts, key=lambda k: k[ method2 = "newlist = sorted(listOfDicts, key=itemgetter( method3 = "df = df.sort_values( sorted_listOfDicts = df.T.to_dict().values()" import timeit t = timeit.Timer(method1, setup_small) print( t = timeit.Timer(method2, setup_small) print( t = timeit.Timer(method3, setup_small) print( t = timeit.Timer(method1, setup_large) print( t = timeit.Timer(method2, setup_large) print( t = timeit.Timer(method3, setup_large) print(
D = { def get_count(tuple): return tuple[1] sorted(D.items(), key = get_count, reverse=True) or sorted(D.items(), key = lambda x: x[1], reverse=True) avoiding get_count function call
data_two = [{ new_data = sorted(data_two, key=get_name)
sorted_dct = sorted(dct_name.items(), key = lambda x : x[1])
>>> from subprocess import * >>> command_stdout = Popen([
>>> print(command_stdout) -rw-rw-r-- 1 thomas thomas 0 Mar 3 07:03 file1 -rw-rw-r-- 1 thomas thomas 0 Mar 3 07:03 file2
bytes = [112, 52, 52] "".join(map(chr, bytes)) >> p44
PY3K = sys.version_info >= (3, 0) lines = [] for line in stream: if not PY3K: lines.append(line) else: lines.append(line.decode(
>>> b Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeDecodeError: start byte
PY3K = sys.version_info >= (3, 0) lines = [] for line in stream: if not PY3K: lines.append(line) else: lines.append(line.decode(
import codecs def slashescape(err): thebyte = err.object[err.start:err.end] repl = u return (repl, err.end) codecs.register_error( stream = [b lines = [] for line in stream: lines.append(line.decode(
>>> from subprocess import * >>> command_stdout = Popen([ >>> command_text = command_stdout.decode(encoding=
unicode_text = bytestring.decode(character_encoding)
import os import subprocess output = os.fsdecode(subprocess.check_output(
>>> from subprocess import Popen, PIPE >>> text = Popen([ >>> type(text) str >>> print(text) total 0 -rw-r--r-- 1 wim badger 0 May 31 12:45 some_file.txt
def cleanLists(self, lista): lista = [x.strip() for x in lista] lista = [x.replace( lista = [x.replace( lista = [x.encode( lista = [x.decode( return lista
String = Bytes.decode("utf-8").replace("\r\n", "\n")
Bytes = open("Input.txt", "rb").read() String = Bytes.decode("utf-8") open("Output.txt", "w").write(String)
Bytes = open("Input.txt", "rb").read() String = Bytes.decode("utf-8").replace("\r\n", "\n") open("Output.txt", "w").write(String)
def byte_to_str(bytes_or_str): if isinstance(bytes_or_str, bytes): print(bytes_or_str.decode( else: print("Object not of byte type") byte_to_str(b
total 0 -rw-rw-r-- 1 thomas thomas 0 Mar 3 07:03 file1 -rw-rw-r-- 1 thomas thomas 0 Mar 3 07:03 file2
def toString(string): try: return v.decode("utf-8") except ValueError: return string b = b s = print(toString(b)) print(toString(s))
class MyClass(object): @staticmethod def the_static_method(x): print x MyClass.the_static_method(2)
class MyClass(object): def the_static_method(x): print x the_static_method = staticmethod(the_static_method) MyClass.the_static_method(2)
class Dog: count = 0 dogs = [] def __init__(self, name): self.name = name Dog.count += 1 Dog.dogs.append(name) def bark(self, n): print("{} says: {}".format(self.name, "woof! " * n)) def rollCall(n): print("There are {} dogs.".format(Dog.count)) if n >= len(Dog.dogs) or n < 0: print("They are:") for dog in Dog.dogs: print(" {}".format(dog)) else: print("The dog indexed at {} is {}.".format(n, Dog.dogs[n])) fido = Dog("Fido") fido.bark(3) Dog.rollCall(-1) rex = Dog("Rex") Dog.rollCall(0)
class Dog: count = 0 dogs = [] def __init__(self, name): self.name = name Dog.count += 1 Dog.dogs.append(name) def bark(self, n): print("{} says: {}".format(self.name, "woof! " * n)) @staticmethod def rollCall(n): print("There are {} dogs.".format(Dog.count)) if n >= len(Dog.dogs) or n < 0: print("They are:") for dog in Dog.dogs: print(" {}".format(dog)) else: print("The dog indexed at {} is {}.".format(n, Dog.dogs[n])) fido = Dog("Fido") fido.bark(3) Dog.rollCall(-1) rex = Dog("Rex") Dog.rollCall(0) rex.rollCall(-1)
>>> class C: ... @staticmethod ... def hello(): ... print "Hello World" ... >>> C.hello() Hello World
class ClassName(object): @staticmethod def static_method(kwarg1=None):
class ClassName(object): def static_method(kwarg1=None): static_method = staticmethod(static_method)
class ClassName(object): @classmethod def class_method(cls, kwarg1=None):
def trim(a): pass def strip(a): pass def bunch(a, b): pass def _foo(foo): pass class powertools(object): @staticmethod def answer_to_the_ultimate_question_of_life_the_universe_and_everything(): return 42 @staticmethod def random(): return 13 @staticmethod def promise(): return True def _bar(baz, quux): pass class _Dice(object): pass class _6d(_Dice): pass class _12d(_Dice): pass class _Smarter: pass class _MagicalPonies: pass class _Samurai: pass class Foo(_6d, _Samurai): pass class Bar(_12d, _Smarter, _MagicalPonies): pass
import unittest import garden class GardenTests(unittest.TestCase): pass class PowertoolsTests(unittest.TestCase): pass class FooTests(unittest.TestCase): pass class BarTests(unittest.TestCase): pass
from garden import trim, bunch, Foo f = trim(Foo()) bunch(f, Foo())
import garden from garden import powertools class _Cowboy(garden._Samurai): def hit(): return powertools.promise() and powertools.random() or 0 class Foo(_Cowboy, garden.Foo): pass
class socket(object): @staticmethod def check_if_port_available(port): pass @staticmethod def get_free_port(port) pass class image(object): @staticmethod def to_rgb(image): pass @staticmethod def to_cmyk(image): pass
class Dog(object): def __init__(self, name): self.name = name def bark(self): if self.name == "Doggy": return barking_sound() else: return "yip yip" def barking_sound(): return "woof woof"
class Account: def login(self, url, email, password): self.login_url = url self.user_email = email self.user_password = password print(self.login_url, self.user_email, self.user_password)
""" * Referencing the Account.login(self, url, email, password) * Just call the `Account` object as the self """ Account.login(Account, "https: :$ https:
class Arithmetic: def add(x, y): return x + y Arithmetic.add = staticmethod(Arithmetic.add) print(
class Arithmetic: @staticmethod def add(x, y): return x + y print(
jeffs@jeffs-desktop:/home/jeffs $ python36 Python 3.6.1 (default, Sep 7 2017, 16:36:03) [GCC 6.3.0 20170406] on linux Type "help", "copyright", "credits" or "license" for more information. >>> import cmath >>> print(cmath.sqrt(-4)) 2j >>> >>> dir(cmath) [ >>>
try: os.environ["FOO"] except KeyError: print "Please set the environment variable FOO" sys.exit(1)
import os for a in os.environ: print( print("all done")
from envparse import env white_list = env.list("WHITE_LIST", default=[]) DEBUG = env.bool("DEBUG", default=False)
import os for param in os.environ.keys(): print("%s: %s " % (param, os.environ[param]))
try: env_value = os.environ.get("key_maybe_not_exist") except KeyError: print("Not exist environment value for %s" % "key_maybe_not_exist")
if "key_maybe_not_exist" in os.environ: existed_env_value = os.environ["key_maybe_not_exist"]
existed_env_value = os.getenv("key_maybe_not_exist")
existed_env_value = os.getenv("key_maybe_not_exist", default=None)
import os for item, value in os.environ.items(): print(
import random foo = [ secure_random = random.SystemRandom() print(secure_random.choice(foo))
from random import randrange random_index = randrange(len(foo)) print(foo[random_index])
import random group_of_items = {1, 2, 3, 4} num_to_select = 2 list_of_random_items = random.sample(group_of_items, num_to_select) first_random_item = list_of_random_items[0] second_random_item = list_of_random_items[1]
import secrets secure_random = secrets.SystemRandom() group_of_items = {1, 2, 3, 4} num_to_select = 2 list_of_random_items = secure_random.sample(group_of_items, num_to_select) first_random_item = list_of_random_items[0] second_random_item = list_of_random_items[1]
s=set(range(1,6)) import random while len(s)>0: s.remove(random.choice(list(s))) print(s)
>>> set([1, 3, 4, 5]) set([3, 4, 5]) set([3, 4]) set([4]) set([]) >>> set([1, 2, 3, 5]) set([2, 3, 5]) set([2, 3]) set([2]) set([]) >>> set([1, 2, 3, 5]) set([1, 2, 3]) set([1, 2]) set([1]) set([])
random_items = random.sample(population=foo, k=number_of_samples)
random_items = random.choices(population=foo, k=number_of_samples)
import random foo = [ print int(random.random() * len(foo)) print foo[int(random.random() * len(foo))]
import random foo = [ randomindex = random.randint(0,len(foo)-1) print (foo[randomindex])
import random foo = [ print (foo[random.randint(0,len(foo)-1)])
>>> import random >>> sr = random.SystemRandom() >>> foo = list( >>> foo [
>>> sr.choice(foo) >>> sr.choice(foo) >>> sr.choice(foo) >>> sr.choice(foo) >>> sr.choice(foo) >>> sr.choice(foo) >>> sr.choice(foo)
>>> random.choice <bound method Random.choice of <random.Random object at 0x800c1034>>
>>> random.seed(42); random.choice(foo), random.choice(foo), random.choice(foo) ( >>> random.seed(42); random.choice(foo), random.choice(foo), random.choice(foo) ( >>> random.seed(42); random.choice(foo), random.choice(foo), random.choice(foo) ( >>> random.seed(42); random.choice(foo), random.choice(foo), random.choice(foo) ( >>> random.seed(42); random.choice(foo), random.choice(foo), random.choice(foo) (
np.random.choice(foo, 5) np.random.choice(foo, 5, False)
from random import randint l= [ def get_rand_element(l): if l: return l[randint(0,len(l)-1)] else: return None get_rand_element(l)
import random as random random.seed(0) print(random.sample(foo,3)) Output:[
from random import * library = ["New York", "Berlin", "Rome"] for x in range (10): i = randrange(0,3) print(library[i])
import random pick = [ print (pick[int(random.random() * len(pick))])
import random_necessary pick = [ print pick [int(random_necessary.random_necessary() * len(pick))]
>>> x = 5 >>> 1 < x < 10 True >>> 10 < x < 20 False >>> x < 10 < x*10 < 100 True >>> 10 > x <= 9 True >>> 5 == x > 4 True
>>> re.compile("^\[font(?:=(?P<size>[-+][0-9]{1,2}))?\](.*?)[/font]", re.DEBUG) at at_beginning literal 91 literal 102 literal 111 literal 110 literal 116 max_repeat 0 1 subpattern None literal 61 subpattern 1 in literal 45 literal 43 max_repeat 1 2 in range (48, 57) literal 93 subpattern 2 min_repeat 0 65535 any None in literal 47 literal 102 literal 111 literal 110 literal 116
>>> re.compile(""" ^ \[font (?:=(?P<size> [-+][0-9]{1,2} ))? \] (.*?) \[/font\] """, re.DEBUG|re.VERBOSE|re.DOTALL)
>>> a = [ >>> for index, item in enumerate(a): print index, item ... 0 a 1 b 2 c 3 d 4 e >>>
>>> n = ((a,b) for a in range(0,2) for b in range(4,6)) >>> for i in n: ... print i (0, 4) (0, 5) (1, 4) (1, 5)
def seek_next_line(f): for c in iter(lambda: f.read(1), pass
>>> def foo(x=[]): ... x.append(1) ... print x ... >>> foo() [1] >>> foo() [1, 1] >>> foo() [1, 1, 1]
>>> def foo(x=None): ... if x is None: ... x = [] ... x.append(1) ... print x >>> foo() [1] >>> foo() [1]
def mygen(): """Yield 5 until something else is passed back via send()""" a = 5 while True: f = (yield a) if f is not None: a = f
>>> g = mygen() >>> g.next() 5 >>> g.next() 5 >>> g.send(7) 7 >>> g.next() 7
>>> def print_args(function): >>> def wrapper(*args, **kwargs): >>> print >>> return function(*args, **kwargs) >>> return wrapper >>> @print_args >>> def write(text): >>> print text >>> write( Arguments: ( foo
for i in foo: if i == 0: break else: print("i was never 0")
found = False for i in foo: if i == 0: found = True break if not found: print("i was never 0")
>>> class MyDict(dict): ... def __missing__(self, key): ... self[key] = rv = [] ... return rv ... >>> m = MyDict() >>> m["foo"].append(1) >>> m["foo"].append(2) >>> dict(m) {
>>> from collections import defaultdict >>> m = defaultdict(list) >>> m["foo"].append(1) >>> m["foo"].append(2) >>> dict(m) {
>>> a = 10 >>> b = 5 >>> a, b (10, 5) >>> a, b = b, a >>> a, b (5, 10)
>>> pattern = """ ... ^ ... M{0,4} ... (CM|CD|D?C{0,3}) ... ... (XC|XL|L?X{0,3}) ... ... (IX|IV|V?I{0,3}) ... ... $ ... """ >>> re.search(pattern,
>>> p = re.compile(r >>> m = p.search( >>> m.group(
>>> pattern = ( ... "^" ... "M{0,4}" ... "(CM|CD|D?C{0,3})" ... ... "(XC|XL|L?X{0,3})" ... ... "(IX|IV|V?I{0,3})" ... ... "$" ... ) >>> print pattern "^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$"
def draw_point(x, y): point_foo = (3, 4) point_bar = { draw_point(*point_foo) draw_point(**point_bar)
>>> NewType = type("NewType", (object,), {"x": "hello"}) >>> n = NewType() >>> n.x "hello"
>>> class NewType(object): >>> x = "hello" >>> n = NewType() >>> n.x "hello"
from __future__ import with_statement with open( f.write(
class Property(object): def __init__(self, fget): self.fget = fget def __get__(self, obj, type): if obj is None: return self return self.fget(obj)
class MyClass(object): @Property def foo(self): return "Foo!"
def factorial(n): """Return the factorial of n, an exact integer >= 0. If the result is small enough to fit in an int, return an int. Else return a long. >>> [factorial(n) for n in range(6)] [1, 1, 2, 6, 24, 120] >>> factorial(-1) Traceback (most recent call last): ... ValueError: n must be >= 0 Factorials of floats are OK, but the float must be an exact integer: """ import math if not n >= 0: raise ValueError("n must be >= 0") if math.floor(n) != n: raise ValueError("n must be exact integer") if n+1 == n: raise OverflowError("n too large") result = 1 factor = 2 while factor <= n: result *= factor factor += 1 return result def _test(): import doctest doctest.testmod() if __name__ == "__main__": _test()
>>> print "The %(foo)s is %(bar)i." % { The answer is 42. >>> foo, bar = >>> print "The %(foo)s is %(bar)i." % locals() The question is 123.
try: put_4000000000_volts_through_it(parrot) except Voom: print " else: print "This parrot is no more!" finally: end_sketch()
try: some_operation() except SomeError, e: if is_fatal(e): raise handle_nonfatal(e) try: some_operation() except SomeError as e: if is_fatal(e): raise handle_nonfatal(e)
try: import readline except ImportError: print "Unable to load readline module." else: import rlcompleter readline.parse_and_bind("tab: complete") >>> class myclass: ... def function(self): ... print "my function" ... >>> class_instance = myclass() >>> class_instance.<TAB> class_instance.__class__ class_instance.__module__ class_instance.__doc__ class_instance.function >>> class_instance.f<TAB>unction()
[(i,j) for i in range(3) for j in range(i) ] ((i,j) for i in range(4) for j in range(i) )
>>> a = set([1,2,3,4]) >>> b = set([3,4,5,6]) >>> a | b {1, 2, 3, 4, 5, 6} >>> a & b {3, 4} >>> a < b False >>> a - b {1, 2} >>> a ^ b {1, 2, 5, 6}
>>> s = " \n\r\n \n abc def \n\r\n \n " >>> s.strip() >>> s.lstrip() >>> s.rstrip()
>>> text = "line 1\nline 2\r\nline 3\nline 4" >>> text.splitlines() [
def chomp(x): if x.endswith("\r\n"): return x[:-2] if x.endswith("\n") or x.endswith("\r"): return x[:-1] return x
$ python Python 2.7.1 (r271:86832, Mar 18 2011, 09:09:48) [GCC 4.5.0 20100604 [gcc-4_5-branch revision 160292]] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> import os, sys >>> sys.platform >>> "foo\r\n".rstrip(os.linesep) >>>
import os sep_pos = -len(os.linesep) with open("file.txt") as f: for line in f: if line[sep_pos:] == os.linesep: line = line[:sep_pos] process(line)
import re r_unwanted = re.compile("[\n\t\r]") r_unwanted.sub("", your_text)
def chomp(s): if len(s): lines = s.splitlines(True) last = lines.pop() return else: return
def chomped_lines(it): return map(operator.methodcaller(
with open("file.txt") as infile: for line in chomped_lines(infile): process(line)
>>> re.sub(r >>> re.sub(r >>> re.sub(r >>> re.sub(r
>>> >>> "AABAA".rstrip("A") >>> "ABBA".rstrip("AB") >>> "ABCABBA".rstrip("AB")
import re text_1 = "hellothere\n\n\n" text_2 = "hellothere\n\n\r" text_3 = "hellothere\n\n\r\n" a = re.sub(r"\r?\n?$", "", text_1, 1) b = re.sub(r"\r?\n?$", "", text_2, 1) c = re.sub(r"\r?\n?$", "", text_3, 1)
import time loops = 50000000 def method1(loops=loops): test_string = t0 = time.time() for num in xrange(loops): out_sting = test_string[:-1] t1 = time.time() print( def method2(loops=loops): test_string = t0 = time.time() for num in xrange(loops): out_sting = test_string.rstrip() t1 = time.time() print( method1() method2()
import re if re.search("(\\r|)\\n$", line): line = re.sub("(\\r|)\\n$", "", line)
class Date(object): def __init__(self, day=0, month=0, year=0): self.day = day self.month = month self.year = year @classmethod def from_string(cls, date_as_string): day, month, year = map(int, date_as_string.split( date1 = cls(day, month, year) return date1 @staticmethod def is_date_valid(date_as_string): day, month, year = map(int, date_as_string.split( return day <= 31 and month <= 12 and year <= 3999 date2 = Date.from_string( is_date = Date.is_date_valid(
class Date(object): def __init__(self, day=0, month=0, year=0): self.day = day self.month = month self.year = year
day, month, year = map(int, string_date.split( date1 = Date(day, month, year)
@classmethod def from_string(cls, date_as_string): day, month, year = map(int, date_as_string.split( date1 = cls(day, month, year) return date1 date2 = Date.from_string(
@staticmethod def is_date_valid(date_as_string): day, month, year = map(int, date_as_string.split( return day <= 31 and month <= 12 and year <= 3999 is_date = Date.is_date_valid(
class Date: def __init__(self, month, day, year): self.month = month self.day = day self.year = year def display(self): return "{0}-{1}-{2}".format(self.month, self.day, self.year) @staticmethod def millenium(month, day): return Date(month, day, 2000) new_year = Date(1, 1, 2013) millenium_new_year = Date.millenium(1, 1) new_year.display() millenium_new_year.display() isinstance(new_year, Date) isinstance(millenium_new_year, Date)
class DateTime(Date): def display(self): return "{0}-{1}-{2} - 00:00:00PM".format(self.month, self.day, self.year) datetime1 = DateTime(10, 10, 1990) datetime2 = DateTime.millenium(10, 10) isinstance(datetime1, DateTime) isinstance(datetime2, DateTime) datetime1.display() datetime2.display()
@classmethod def millenium(cls, month, day): return cls(month, day, 2000)
datetime1 = DateTime(10, 10, 1990) datetime2 = DateTime.millenium(10, 10) isinstance(datetime1, DateTime) isinstance(datetime2, DateTime) datetime1.display() datetime2.display()
class Hero: @staticmethod def say_hello(): print("Helllo...") @classmethod def say_class_hello(cls): if(cls.__name__=="HeroSon"): print("Hi Kido") elif(cls.__name__=="HeroDaughter"): print("Hi Princess") class HeroSon(Hero): def say_son_hello(self): print("test hello") class HeroDaughter(Hero): def say_daughter_hello(self): print("test hello daughter") testson = HeroSon() testson.say_class_hello() testson.say_hello() testdaughter = HeroDaughter() testdaughter.say_class_hello() testdaughter.say_hello()
class Example(object): def regular_instance_method(self): """A function of an instance has access to every attribute of that instance, including its class (and its attributes.) Not accepting at least one argument is a TypeError. Not understanding the semantics of that argument is a user error. """ return some_function_f(self) @classmethod def a_class_method(cls): return some_function_g(cls) @staticmethod def a_static_method(): """A static method has no information about instances or classes unless explicitly given. It just lives in the class (and thus its instances """ return some_function_h()
some_function_h = some_function_g = some_function_f = lambda x=None: x
instance = Example() instance.regular_instance_method
>>> instance = Example() >>> instance.regular_instance_method() <__main__.Example object at 0x00000000399524E0>
>>> instance.a_class_method() <class >>> Example.a_class_method() <class
def an_instance_method(self, arg, kwarg=None): cls = type(self) ... @classmethod def a_class_method(cls, arg, kwarg=None): ... @staticmethod def a_static_method(arg, kwarg=None): ...
>>> class MyDict(dict): pass >>> type(MyDict.fromkeys( <class
class PythonBook: def __init__(self, name, author): self.name = name self.author = author def __repr__(self): return f
book1 = PythonBook( In [20]: book1 Out[20]: Book: Learning Python, Author: Mark Lutz book2 = PythonBook( In [22]: book2 Out[22]: Book: Python Think, Author: Allen B Dowey
class PythonBook: def __init__(self, name, author): self.name = name self.author = author def __repr__(self): return f @classmethod def book1(cls): return cls( @classmethod def book2(cls): return cls(
In [31]: PythonBook.book1() Out[31]: Book: Learning Python, Author: Mark Lutz In [32]: PythonBook.book2() Out[32]: Book: Python Think, Author: Allen B Dowey
class C: def __init__(self, parameters): .... @classmethod def construct_from_func(cls, parameters): .... obj1 = C(parameters) obj2 = C.construct_from_func(parameters)
class C: def __init__(self): .... @staticmethod def static_method(args): .... def normal_method(parameters): .... result = C.static_method(parameters) result = obj.normal_method(parameters)
class empDetails: def __init__(self,name,sal): self.name=name self.sal=sal @classmethod def increment(cls,name,none): return cls( @staticmethod def salChecking(sal): return sal > 6000 emp1=empDetails( emp2=empDetails.increment( print emp1.name print emp1.sal print emp2.sal print emp2.name print empDetails.salChecking(6500)
def is_number(s): try: float(s) return True except ValueError: return False
>>> a = "03523" >>> a.isdigit() True >>> b = "963spam" >>> b.isdigit() False
def is_number_tryexcept(s): try: float(s) return True except ValueError: return False import re def is_number_regex(s): if re.match("^\d+?\.\d+?$", s) is None: return s.isdigit() return True def is_number_repl_isdigit(s): return s.replace(
funcs = [ is_number_tryexcept, is_number_regex, is_number_repl_isdigit ] a_float = print( for f in funcs: if not f(a_float): print(
scientific1 = scientific2 = print( for f in funcs: if not f(scientific1): print( print( for f in funcs: if not f(scientific2): print(
import timeit test_cases = [ times_n = {f.__name__:[] for f in funcs} for t in test_cases: for f in funcs: f = f.__name__ times_n[f].append(min(timeit.Timer( .repeat(repeat=3, number=1000000)))
from re import match as re_match from re import compile as re_compile def is_number_tryexcept(s): try: float(s) return True except ValueError: return False def is_number_regex(s): if re_match("^\d+?\.\d+?$", s) is None: return s.isdigit() return True comp = re_compile("^\d+?\.\d+?$") def compiled_regex(s): if comp.match(s) is None: return s.isdigit() return True def is_number_repl_isdigit(s): return s.replace(
def is_number(s): try: complex(s) except ValueError: return False return True
def is_number(s): try: float(s) except ValueError: try: complex(s) except ValueError: return False return True
>>> "12.34".isdigit() False >>> "12.34".replace( True >>> "12.3.4".replace( False
def parse(string): try: return float(string) except Exception: throw TypeError
def try_parse(string, fail=None): try: return float(string) except Exception: return fail;
def monkey_patch(): if(!hasattr(float, float.parse = parse if(!hasattr(float, float.try_parse = try_parse
float.parse( float.parse( float.tryParse( float.tryParse(
from __future__ import print_function import timeit prep_base = x = y = z = prep_try_method = def is_number_try(val): try: float(val) return True except ValueError: return False prep_re_method = import re float_match = re.compile(r def is_number_re(val): return bool(float_match(val)) fn_method = from fastnumbers import isfloat print( prep_base + prep_try_method), print( prep_base + prep_try_method), print( prep_base + prep_try_method), print() print( prep_base + prep_re_method), print( prep_base + prep_re_method), print( prep_base + prep_re_method), print() print( prep_base + print( prep_base + print( prep_base + print()
Try with non-number strings 2.39108395576 seconds Try with integer strings 0.375686168671 seconds Try with float strings 0.369210958481 seconds Regex with non-number strings 0.748660802841 seconds Regex with integer strings 1.02021503448 seconds Regex with float strings 1.08564686775 seconds fastnumbers with non-number strings 0.174362897873 seconds fastnumbers with integer strings 0.179651021957 seconds fastnumbers with float strings 0.20222902298 seconds
>>> s = "345" >>> u = unicode(s) >>> u.isnumeric() True
def is_number(n): try: float(n) except ValueError: return False return True
>>> is_number( True >>> is_number( True >>> is_number( True >>> is_number( True >>> is_number( False
>>> import math >>> nan_num = float( >>> math.isnan(nan_num) True
def is_number(n): is_number = True try: num = float(n) is_number = num == num except ValueError: is_number = False return is_number
>>> is_number( False >>> is_number( False >>> is_number( True >>> is_number( True >>> is_number( True >>> is_number( False
import time, re, random, string ITERATIONS = 10000000 class Timer: def __enter__(self): self.start = time.clock() return self def __exit__(self, *args): self.end = time.clock() self.interval = self.end - self.start def check_regexp(x): return re.compile("^\d*\.?\d*$").match(x) is not None def check_replace(x): return x.replace( def check_exception(s): try: float(s) return True except ValueError: return False to_check = [check_regexp, check_replace, check_exception] print( good_numbers = [ str(random.random() / random.random()) for x in range(ITERATIONS)] bad_numbers = [ strings = [ for x in range(ITERATIONS)] print( for func in to_check: with Timer() as t: for x in good_numbers: res = func(x) print( with Timer() as t: for x in bad_numbers: res = func(x) print( with Timer() as t: for x in strings: res = func(x) print(
check_regexp with good floats: 12.688639 check_regexp with bad floats: 11.624862 check_regexp with strings: 11.349414 check_replace with good floats: 4.419841 check_replace with bad floats: 4.294909 check_replace with strings: 4.086358 check_exception with good floats: 3.276668 check_exception with bad floats: 13.843092 check_exception with strings: 15.786169
check_regexp with good floats: 13.472906000000009 check_regexp with bad floats: 12.977665000000016 check_regexp with strings: 12.417542999999995 check_replace with good floats: 6.011045999999993 check_replace with bad floats: 4.849356 check_replace with strings: 4.282754000000011 check_exception with good floats: 6.039081999999979 check_exception with bad floats: 9.322753000000006 check_exception with strings: 9.952595000000002
check_regexp with good floats: 2.693217 check_regexp with bad floats: 2.744819 check_regexp with strings: 2.532414 check_replace with good floats: 0.604367 check_replace with bad floats: 0.538169 check_replace with strings: 0.598664 check_exception with good floats: 1.944103 check_exception with bad floats: 2.449182 check_exception with strings: 2.200056
def is_number(s): try: n=str(float(s)) if n == "nan" or n=="inf" or n=="-inf" : return False except ValueError: try: complex(s) except ValueError: return False return True
def str_to_type (s): try: f = float(s) if "." not in s: return int return float except ValueError: value = s.upper() if value == "TRUE" or value == "FALSE": return bool return type(s)
str_to_type("true") str_to_type("6.0") str_to_type("6") str_to_type("6abc") str_to_type(u"6abc")
import ast import number def is_numeric(obj): if isinstance(obj, numbers.Number): return True elif isinstance(obj, str): nodes = list(ast.walk(ast.parse(obj)))[1:] if not isinstance(nodes[0], ast.Expr): return False if not isinstance(nodes[-1], ast.Num): return False nodes = nodes[1:-1] for i in range(len(nodes)): if i % 2 == 0: if not isinstance(nodes[i], ast.UnaryOp): return False else: if not isinstance(nodes[i], (ast.USub, ast.UAdd)): return False return True else: return False
>>> is_numeric("54") True >>> is_numeric("54.545") True >>> is_numeric("0x45") True
import ast def is_float(obj): if isinstance(obj, float): return True if isinstance(obj, int): return False elif isinstance(obj, str): nodes = list(ast.walk(ast.parse(obj)))[1:] if not isinstance(nodes[0], ast.Expr): return False if not isinstance(nodes[-1], ast.Num): return False if not isinstance(nodes[-1].n, float): return False nodes = nodes[1:-1] for i in range(len(nodes)): if i % 2 == 0: if not isinstance(nodes[i], ast.UnaryOp): return False else: if not isinstance(nodes[i], (ast.USub, ast.UAdd)): return False return True else: return False
>>> is_float("5.4") True >>> is_float("5") False >>> is_float(5) False >>> is_float("5") False >>> is_float("+5.4") True
>>> a=454 >>> a.isdigit() Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: >>> a="454" >>> a.isdigit() True
>>> isinstance("54", int) False >>> isinstance(54, int) True >>>
>>> isinstance("45.1", float) False >>> isinstance(45.1, float) True
def is_float(text): try: float(text) if text.isalpha(): return False return True except ValueError: return False
try: myvar.append( float(string_to_check) ) except: continue
import sys def fix_quotes(s): try: float(s) return s except ValueError: return for line in sys.stdin: input = line.split() print input[0],
def string_or_number(s): try: z = int(s) return z except ValueError: try: z = float(s) return z except ValueError: return s
def is_number(var): try: if var == int(var): return True except Exception: return False
import re def is_number(num): pattern = re.compile(r result = pattern.match(num) if result: return True else: return False ​>>>: is_number( True >>>: is_number( True >>>: is_number( True >>>: is_number( True >>>: is_number( False >>>: is_number( False
import foo method_to_call = getattr(foo, result = method_to_call()
class A: def __init__(self): pass def sampleFunc(self, arg): print( m = globals()[ func = getattr(m, func( getattr(globals()[
import importlib function_string = mod_name, func_name = function_string.rsplit( mod = importlib.import_module(mod_name) func = getattr(mod, func_name) result = func()
functions = { mystring = if mystring in functions: functions[mystring]()
getattr(locals().get("foo") or globals().get("foo"), "bar")()
getattr( locals().get("foo") or globals().get("foo") or __import__("foo"), "bar")()
getattr(next((x for x in (f("foo") for f in [locals().get, globals().get, self.__dict__.get, __import__]) if x)), "bar")()
getattr(next((x for x in (f("foo") for f in ([locals().get, globals().get, self.__dict__.get] + [d.get for d in (list(dd.values()) for dd in [locals(),globals(),self.__dict__] if isinstance(dd,dict)) if isinstance(d,dict)] + [__import__])) if x)), "bar")()
myFnName = "MyFn" myAppName = "MyApp" app = sys.modules[myAppName] fn = getattr(app,myFnName)
def say_hello(name): print method_name = method = eval(method_name) args = [ kwargs = {} method(*args, **kwargs)
json_data=open(file_directory).read() data = json.loads(json_data) pprint(data)
{ "maps": [ { "id": "blabla", "iscategorical": "0" }, { "id": "blabla", "iscategorical": "0" } ], "masks": { "id": "valore" }, "om_points": "value", "parameters": { "id": "valore" } }
import json from pprint import pprint with open( data = json.load(f) pprint(data)
data["maps"][0]["id"] data["masks"]["id"] data["om_points"]
{ "maps":[ {"id":"blabla","iscategorical":"0"}, {"id":"blabla","iscategorical":"0"} ], "masks": {"id":"valore"}, "om_points":"value", "parameters": {"id":"valore"} }
import json from pprint import pprint with open( data = json.load(data_file) pprint(data)
data["maps"][0]["id"] data["masks"]["id"] data["om_points"]
data = [] with codecs.open( for line in f: data.append(json.loads(line))
{ "connection1": { "DSN": "con1", "UID": "abc", "PWD": "1234", "connection_string_python":"test1" } , "connection2": { "DSN": "con2", "UID": "def", "PWD": "1234" } }
connection_file = open( conn_string = json.load(connection_file) conn_string[ connection_file.close() >>>test1
{ "maps": [ { "id": "blabla", "iscategorical": "0" }, { "id": "blabla", "iscategorical": "0" } ], "masks": [{ "id": "valore" }], "om_points": "value", "parameters": [{ "id": "valore" }] } import json from pprint import pprint with open( data_item = json.load(data_file) pprint(data_item) print(data_item[ { { valore
import json json = json.loads(open( value = json[ print json[
from matplotlib.pyplot import figure figure(num=None, figsize=(8, 6), dpi=80, facecolor=
fig = matplotlib.pyplot.gcf() fig.set_size_inches(18.5, 10.5) fig.savefig(
from matplotlib import pyplot as plt plt.figure(figsize=(1,1)) x = [1,2,3] plt.plot(x, x) plt.show()
import matplotlib.pyplot as plt plt.rcParams["figure.figsize"] = (20,3)
import matplotlib print "using MPL version:", matplotlib.__version__ matplotlib.use("WXAgg") import pylab import numpy as np x = np.arange(0, 2*np.pi, 0.1) y = np.sin(x) pylab.plot(x,y) F = pylab.gcf() DPI = F.get_dpi() print "DPI:", DPI DefaultSize = F.get_size_inches() print "Default size in Inches", DefaultSize print "Which should result in a %i x %i Image"%(DPI*DefaultSize[0], DPI*DefaultSize[1]) F.savefig("test1.png") F.set_size_inches( (DefaultSize[0]*2, DefaultSize[1]*2) ) Size = F.get_size_inches() print "Size in Inches", Size F.savefig("test2.png") F.set_size_inches( DefaultSize ) Size = F.get_size_inches() print "Size in Inches", Size F.savefig("test3.png", dpi = (200))
using MPL version: 0.98.1 DPI: 80 Default size in Inches [ 8. 6.] Which should result in a 640 x 480 Image Size in Inches [ 16. 12.] Size in Inches [ 16. 12.]
%matplotlib inline import numpy as np import matplotlib.pyplot as plt N = 50 x = np.random.rand(N) y = np.random.rand(N) area = np.pi * (15 * np.random.rand(N))**2 fig = plt.figure(figsize=(18, 18)) plt.scatter(x, y, s=area, alpha=0.5) plt.show()
N = 2 params = pl.gcf() plSize = params.get_size_inches() params.set_size_inches( (plSize[0]*N, plSize[1]*N) )
from matplotlib import pyplot as plt F = gcf() Size = F.get_size_inches() F.set_size_inches(Size[0]*2, Size[1]*2, forward=True) plt.show()
def cm2inch(*tupl): inch = 2.54 if isinstance(tupl[0], tuple): return tuple(i/inch for i in tupl[0]) else: return tuple(i/inch for i in tupl)
matplotlib.pyplot.get_current_fig_manager().resize(width_px, height_px)
with open("test.txt", "a") as myfile: myfile.write("appended text")
>>> with open( f.write( >>> with open( f.write( >>> with open( f.read()
>>> f = open( >>> f.write( >>> f.seek(0) >>> f.read() >>> f.seek(0) >>> f.write( >>> f.seek(0) >>> f.read()
>>> open("test","wb").write("test") >>> open("test","a+b").write("koko") >>> open("test","rb").read()
with open("foo", "a") as f: f.write("cool beans...")
def FileSave(filename,content): with open(filename, "a") as myfile: myfile.write(content) FileSave("test.txt","test1 \n") FileSave("test.txt","test2 \n")
with open("test.txt", "a") as myfile: myfile.write("append me")
shortPath = "../file_to_be_appended" short = open(shortPath, long_path = "../file_to_be_appended_to" long = open(long_path, for i,l in enumerate(long): pass print "%s has %i lines initially" %(long_path,i) long.close() long = open(long_path, l = True c = 0 while l: try: l = short.next() c += 1 long.write(l) except: l = None long.close() print "Done!, wrote %s lines" %c long = open(long_path, for i,l in enumerate(long): pass print "%s has %i lines after appending new lines" %(long_path, i) long.close()
>>> a 13.949999999999999 >>> round(a, 2) 13.949999999999999
>>> 125650429603636838/(2**53) 13.949999999999999 >>> 234042163/(2**24) 13.949999988079071 >>> a=13.946 >>> print(a) 13.946 >>> print("%.2f" % a) 13.95 >>> round(a,2) 13.949999999999999 >>> print("%.2f" % round(a,2)) 13.95 >>> print("{0:.2f}".format(a)) 13.95 >>> print("{0:.2f}".format(round(a,2))) 13.95 >>> print("{0:.15f}".format(round(a,2))) 13.949999999999999
>>> x = 13.949999999999999999 >>> x 13.95 >>> g = float("{0:.2f}".format(x)) >>> g 13.95 >>> x == g True >>> h = round(x, 2) >>> h 13.95 >>> x == h True
>>> a = 0.99334 >>> a = int((a * 100) + 0.5) / 100.0 >>> print a 0.99
older_method_string = "%.9f" % numvar newer_method_string = "{:.9f}".format(numvar)
>>> a = 13.95 >>> a 13.949999999999999 >>> print "%.2f" % a 13.95
import random for x in iter(random.random, None): assert float(repr(x)) == x assert len(repr(round(x, 10))) <= 12 if x >= 0.1: assert str(x) == repr(round(x, 12)) y = 1000 * x assert str(y) == repr(round(y, 12 - 3))
a = 13.949999999999999 output = float("%0.2f"%a) print output
>>> sum = 0.0 >>> for i in range(10): ... sum += 0.1 ... >>> sum 0.99999999999999989
a = 70000 b = 0.14 c = a * b print c c = int(c * 10000)/100000 print c
from decimal import * getcontext().prec = 6 Decimal(1) / Decimal(7) getcontext().prec = 28 Decimal(1) / Decimal(7)
from decimal import Decimal def round_float(v, ndigits=2, rt_str=False): d = Decimal(v) v_str = ("{0:.%sf}" % ndigits).format(round(d, ndigits)) if rt_str: return v_str return Decimal(v_str)
Python 3.6.1 (default, Dec 11 2018, 17:41:10) >>> round_float(3.1415926) Decimal( >>> round_float(3.1445926) Decimal( >>> round_float(3.1455926) Decimal( >>> round_float(3.1455926, rt_str=True) >>> str(round_float(3.1455926))
>>> import numpy as np >>> value = 13.949999999999999 >>> resolution = 0.01 >>> newValue = int(np.round(value/resolution))*resolution >>> print newValue 13.95 >>> resolution = 0.5 >>> newValue = int(np.round(value/resolution))*resolution >>> print newValue 14.0
>>> def print_everything(*args): for count, thing in enumerate(args): ... print( ... >>> print_everything( 0. apple 1. banana 2. cabbage
>>> def table_things(**kwargs): ... for name, value in kwargs.items(): ... print( ... >>> table_things(apple = cabbage = vegetable apple = fruit
>>> def print_three_things(a, b, c): ... print( ... >>> mylist = [ >>> print_three_things(*mylist) a = aardvark, b = baboon, c = cat
class Foo(object): def __init__(self, value1, value2): print value1, value2 class MyFoo(Foo): def __init__(self, *args, **kwargs): print super(MyFoo, self).__init__(*args, **kwargs)
def func(required_arg, *args, **kwargs): print required_arg if args: print args if kwargs: print kwargs >>> func() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: func() takes at least 1 argument (0 given) >>> func("required argument") required argument >>> func("required argument", 1, 2, required argument (1, 2, >>> func("required argument", 1, 2, required argument (1, 2, {
mynum = 1000 mystr = print "{mystr} New-style formatting is {mynum}x more fun!".format(**locals())
def mydecorator( f ): @functools.wraps( f ) def wrapper( *args, **kwargs ): print "Calling f", args, kwargs v = f( *args, **kwargs ) print "f returned", v return v return wrapper
def sumFunction(*args): result = 0 for x in args: result += x return result
>>> import operator >>> def multiply(*args): ... return reduce(operator.mul, args)
>>> multiply(1,2,3) 6 or >>> numbers = [1,2,3] >>> multiply(*numbers) 6
tuple_of_data = struct.unpack(format_str, data) ... manipulate the data new_data = struct.pack(format_str, *tuple_of_data)
new_data = struct.pack(format_str, tuple_of_data[0], tuple_of_data[1], tuple_of_data[2],...)
def myprint(*args): for arg in args: print arg, print
def foo(bar=2, baz=5): print bar, baz def proxy(x, *args, **kwargs): print x foo(*args, **kwargs) proxy(23, 5, baz= proxy(6) proxy(7, bar=
>>> a = SomeClass() >>> a.someProperty = value >>> a.property Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: SomeClass instance has no attribute
try: doStuff(a.property) except AttributeError: otherStuff()
if hasattr(a, doStuff(a.property) else: otherStuff()
try: getattr(someObject, except AttributeError: print "Doesn else print "Exists"
a = SomeClass() try: return a.fake_prop except AttributeError: return default_value
try: doStuff(a.property) except AttributeError: otherStuff()
try: val = a.property except AttributeError: otherStuff() else: doStuff(val)
property = getattr(a,"property",None) if property: print property
import fileinput for line in fileinput.input(): pass
import sys data = sys.stdin.readlines() print "Counted", len(data), "lines."
% cat countlines.py | python countlines.py Counted 3 lines.
C:\> type countlines.py | python countlines.py Counted 3 lines.
while 1: try: line = sys.stdin.readline() except KeyboardInterrupt: break if not line: break print line
$ echo foo | python -c "import sys; print(sys.stdin.read())" foo
python -c "import sys; sys.stdout.write(sys.stdin.read())" < inputs.txt
$ python -c "import sys; sys.stdout.write(sys.stdin.read())" < inputs.txt foo bar baz
read(size=-1, /) method of _io.TextIOWrapper instance Read at most n characters from stream. Read from underlying buffer until we have n characters or we hit EOF. If n is negative or omitted, read until EOF.
$ python -c "import sys; sys.stdout.write(sys.stdin.read())" < stdindemo.py try: while True: print(input()) except EOFError: pass
input(prompt=None, /) Read a string from standard input. The trailing newline is stripped. The prompt string, if given, is printed to standard output without a trailing newline before reading input. If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError. On *nix systems, readline is used if available.
$ python -c "import sys; sys.stdout.write(sys.stdin.read())" < stdindemo2.py import sys for line in sys.stdin: sys.stdout.write(line)
$ python -c "import sys; sys.stdout.write(sys.stdin.read())" < inputs.txt foo bar baz
$ python -c "from io import open; open(1, foo bar baz
import fileinput for line in fileinput.input(): pass
import sys line = sys.stdin.readline() while line: print line, line = sys.stdin.readline()
import sys f = open(sys.argv[1]) if len(sys.argv) > 1 else sys.stdin for line in f:
import sys input_str = sys.stdin.read() print input_str.split()
import argparse import sys parser = argparse.ArgumentParser() parser.add_argument( default=sys.stdin, type=argparse.FileType( nargs= args = parser.parse_args() data = args.infile.read()
import sys PY3K = sys.version_info >= (3, 0) if PY3K: source = sys.stdin.buffer else: if sys.platform == "win32": import os, msvcrt msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY) source = sys.stdin b = source.read()
import sys import select if select.select([sys.stdin], [], [], 0.0)[0]: help_file_fragment = sys.stdin.read() else: print("No data passed to stdin", file=sys.stderr) sys.exit(2)
import sys, os sep=os.linesep while sep == os.linesep: data = sys.stdin.readline() sep = data[-len(os.linesep):] print
n = int(raw_input()) for i in xrange(n): name, number = raw_input().split()
>>> df = pd.DataFrame({ >>> df.columns = [ >>> df a b 0 1 10 1 2 20
In [11]: df.columns Out[11]: Index([u In [12]: df.rename(columns=lambda x: x[1:], inplace=True) In [13]: df.columns Out[13]: Index([u
df = pd.DataFrame({ $a $b $c $d $e 0 1 3 5 7 9 1 2 4 6 8 10
df.some_method1() .some_method2() .set_axis() .some_method3() df1 = df.some_method1() .some_method2() df1.columns = columns df1.some_method3()
old_names = [ new_names = [ df.rename(columns=dict(zip(old_names, new_names)), inplace=True)
df.rename(columns={"old_column_name1":"new_column_name1", "old_column_name2":"new_column_name2"})
df.columns = [ df.columns.names = [ df.index.names = [ name of the list of columns column_one column_two name of the index 0 4 1 1 5 2 2 6 3
|one | |one |two | 0 | 4 | 1 | 1 | 5 | 2 | 2 | 6 | 3 |
df = pd.DataFrame({ new = [ df Jack Mahesh Xin 0 1 3 5 1 2 4 6
d = { df.rename(columns=d) x098 y765 z432 0 1 3 5 1 2 4 6
df.rename(columns=dict(zip(df, new))) x098 y765 z432 0 1 3 5 1 2 4 6
df = pd.DataFrame( [[1, 3, 5], [2, 4, 6]], columns=[ ) new = [ df Mahesh Mahesh Xin 0 1 3 5 1 2 4 6
df.rename(columns=dict(zip(df, new))) y765 y765 z432 0 1 3 5 1 2 4 6
pd.concat([c for _, c in df.items()], axis=1, keys=new) x098 y765 z432 0 1 3 5 1 2 4 6
pd.DataFrame(df.values, df.index, new) x098 y765 z432 0 1 3 5 1 2 4 6
pd.DataFrame(df.values, df.index, new).astype(dict(zip(new, df.dtypes))) x098 y765 z432 0 1 3 5 1 2 4 6
df.T.set_index(np.asarray(new)).T x098 y765 z432 0 1 3 5 1 2 4 6
df.T.set_index(np.asarray(new)).T.astype(dict(zip(new, df.dtypes))) x098 y765 z432 0 1 3 5 1 2 4 6
df.rename(columns=lambda x, y=iter(new): next(y)) x098 y765 z432 0 1 3 5 1 2 4 6
df.rename(columns=lambda x, *, y=iter(new): next(y)) x098 y765 z432 0 1 3 5 1 2 4 6
new_cols = [ df.columns = new_cols >>> df a b c d e 0 1 1 1 1 1
d = { df.columns = df.columns.map(lambda col: d[col]) >>> df a b c d e 0 1 1 1 1 1
columns = df.columns columns = [row.replace("$","") for row in columns] df.rename(columns=dict(zip(columns, things)), inplace=True) df.head()
import pandas as pd import cProfile, pstats, re old_names = [ new_names = [ col_dict = { df = pd.DataFrame({ df.head() def eumiro(df,nn): df.columns = nn return df def lexual1(df): return df.rename(columns=col_dict) def lexual2(df,col_dict): return df.rename(columns=col_dict, inplace=True) def Panda_Master_Hayden(df): return df.rename(columns=lambda x: x[1:], inplace=True) def paulo1(df): return df.rename(columns=lambda x: x.replace( def paulo2(df): return df.rename(columns=lambda x: x.replace( def migloo(df,on,nn): return df.rename(columns=dict(zip(on, nn)), inplace=True) def kadee(df): return df.columns.str.replace( def awo(df): columns = df.columns columns = [row.replace("$","") for row in columns] return df.rename(columns=dict(zip(columns, def kaitlyn(df): df.columns = [col.strip( return df print cProfile.run( print cProfile.run( print cProfile.run( print cProfile.run( print cProfile.run( print cProfile.run( print cProfile.run( print cProfile.run( print cProfile.run( print cProfile.run(
import pandas as pd import re df = pd.DataFrame({ delimiters = matchPattern = df.columns = [re.split(matchPattern, i)[1] for i in df.columns ]
>>> df $a $b $c $d $e 0 1 3 5 7 9 1 2 4 6 8 10 >>> df a b c d e 0 1 3 5 7 9 1 2 4 6 8 10
>>> df = pd.DataFrame({( >>> df $a $b e $x $y f 0 1 3 5 1 2 4 6 >>> rename = {( >>> df.columns = pandas.MultiIndex.from_tuples([ rename.get(item, item) for item in df.columns.tolist()]) >>> df a b e x y f 0 1 3 5 1 2 4 6
import pandas as pd data = { } df = pd.DataFrame(data) df.rename(columns={ df = df.columns.str.replace(
import pandas as pd import re df = pd.DataFrame({ df = df.rename(columns=lambda x: re.sub( >>> df a b c 0 1 3 5 1 2 4 6
Renaming columns while reading the Dataframe: >>> df = pd.DataFrame({ { Out[1]: a b c 0 1 1 1
dict=dict(zip(df.columns,df.columns.str.replace( dict[ dict[ dict[ dict[ df.rename(columns=dict, inplace=True)
df.rename(index=str, columns={"$a": "a", "$b": "b", "$c" : "c", "$d" : "d", "$e" : "e"})
def rename(data, oldnames, newname): if type(oldnames) == str: oldnames = [oldnames] newname = [newname] i = 0 for name in oldnames: oldvar = [c for c in data.columns if name in c] if len(oldvar) == 0: raise ValueError("Sorry, couldn if len(oldvar) > 1: print("Found multiple columns that matched " + str(name) + " :") for c in oldvar: print(str(oldvar.index(c)) + ": " + str(c)) ind = input( oldvar = oldvar[int(ind)] if len(oldvar) == 1: oldvar = oldvar[0] data = data.rename(columns = {oldvar : newname[i]}) i += 1 return data
In [2]: df = pd.DataFrame(np.random.randint(0,10,size=(10, 4)), columns=[ In [3]: df = rename(df, [ Found multiple columns that matched col : 0: col1 1: col2 please enter the index of the column you would like to rename: 0 In [4]: df.columns Out[5]: Index([
sub1 = "python string!" sub2 = "an arg" a = "i am a %s" % sub1 b = "i am a {0}".format(sub1) c = "with %(kwarg)s!" % { d = "with {kwarg}!".format(kwarg=sub2) print a print b print c print d
li = [12,45,78,784,2,69,1254,4785,984] print map( print from datetime import datetime,timedelta once_upon_a_time = datetime(2010, 7, 1, 12, 0, 0) delta = timedelta(days=13, hours=8, minutes=20) gen =(once_upon_a_time +x*delta for x in xrange(20)) print
[ 2010-07-01 12:00:00 2010-07-14 20:20:00 2010-07-28 04:40:00 2010-08-10 13:00:00 2010-08-23 21:20:00 2010-09-06 05:40:00 2010-09-19 14:00:00 2010-10-02 22:20:00 2010-10-16 06:40:00 2010-10-29 15:00:00 2010-11-11 23:20:00 2010-11-25 07:40:00 2010-12-08 16:00:00 2010-12-22 00:20:00 2011-01-04 08:40:00 2011-01-17 17:00:00 2011-01-31 01:20:00 2011-02-13 09:40:00 2011-02-26 18:00:00 2011-03-12 02:20:00
>>> origin = "London" >>> destination = "Paris" >>> f"from {origin} to {destination}"
Python 2.7.2 (default, Aug 27 2012, 19:52:55) [GCC 4.1.2 20080704 (Red Hat 4.1.2-48)] on linux2 ; s= ; u=u ; s ; u u
; ; Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeEncodeError:
In [12]: class A(object): ....: def __init__(self, x, y): ....: self.x = x ....: self.y = y ....: In [13]: a = A(2,3) In [14]: Out[14]:
from decimal import * getcontext().prec = 50 d = Decimal( print( print(
> format: 0.5864730989560485 > %: 0.013593495357781649
import logging class NewStyleLogMessage(object): def __init__(self, message, *args, **kwargs): self.message = message self.args = args self.kwargs = kwargs def __str__(self): args = (i() if callable(i) else i for i in self.args) kwargs = dict((k, v() if callable(v) else v) for k, v in self.kwargs.items()) return self.message.format(*args, **kwargs) N = NewStyleLogMessage logging.debug(N( def expensive_func(): return logging.debug(N(
In [1]: params=[ In [2]: %timeit "%s %s, the answer to everything is %d."%(params[0],params[1],params[2]) 448 ns ± 1.48 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) In [3]: %timeit "{} {}, the answer to everything is {}.".format(*params) 449 ns ± 1.42 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) In [4]: %timeit f"{params[0]} {params[1]}, the answer to everything is {params[2]}." 12.7 ns ± 0.0129 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)
foo = "john" bar = "smith" print(f"My name is {foo} {bar}")
mylist = ["foo", "bar"] print(f"mylist = {mylist}")
>>> Traceback (most recent call last): File "<pyshell ValueError: Single >>> >>>
>>> import timeit >>> timeit.timeit("d={ 0.23399464370632472 >>> timeit.timeit("d={ 0.15225347193388927 >>> timeit.timeit("d={ 0.5365207354998063
>>> timeit.timeit("d={nr: nr for nr in range(100)}; d.pop(3)") 5.478138627299643 >>> timeit.timeit("d={nr: nr for nr in range(100)}; del d[3]") 5.362219126590048 >>> timeit.timeit("d={nr: nr for nr in range(100)}; d2 = {key: val for key, val in d.items() if key != 3}") 13.93129749387532
map(lambda x: myDict.pop(x,None), [ [1, 3, None] >>> myDict {
myDict = { print(myDict) if myDict.get( print(myDict)
myDict = { {key:value for key, value in myDict.items() if key !=
var = {key:value for key, value in myDict.items() if key !=
myDict = { print(myDict) if myDict.get( print(myDict)
>>> from collections import Counter >>> z = [ >>> Counter(z) Counter({
>>> l = ["a","b","b"] >>> l.count("a") 1 >>> l.count("b") 2
>>> l = ["a","b","b"] >>> [[x,l.count(x)] for x in set(l)] [[ >>> dict((x,l.count(x)) for x in set(l)) {
>>> l = ["a","b","b"] >>> from collections import Counter >>> Counter(l) Counter({
from __future__ import print_function import timeit t1=timeit.Timer( ) t2=timeit.Timer( ) print("Counter(): ", t1.repeat(repeat=3,number=10000)) print("count(): ", t2.repeat(repeat=3,number=10000)
Counter(): [0.46062711701961234, 0.4022796869976446, 0.3974247490405105] count(): [7.779430688009597, 7.962715800967999, 8.420845870045014]
>>> from collections import Counter >>> c = Counter(l) >>> c[ 4
>>> c.update(list( >>> c[ 7 >>> c.subtract(list( >>> c[ 4
>>> c2 = Counter(list( >>> c - c2 Counter({ >>> c + c2 Counter({ >>> c | c2 Counter({ >>> c & c2 Counter({
import numpy as np a = np.array([1, 2, 3, 4, 1, 4, 1]) np.bincount(a)
from collections import Counter from collections import defaultdict import numpy import operator import pandas import perfplot def counter(a): return Counter(a) def count(a): return dict((i, a.count(i)) for i in set(a)) def bincount(a): return numpy.bincount(a) def pandas_value_counts(a): return pandas.Series(a).value_counts() def occur_dict(a): d = {} for i in a: if i in d: d[i] = d[i]+1 else: d[i] = 1 return d def count_unsorted_list_items(items): counts = defaultdict(int) for item in items: counts[item] += 1 return dict(counts) def operator_countof(a): return dict((i, operator.countOf(a, i)) for i in set(a)) perfplot.show( setup=lambda n: list(numpy.random.randint(0, 100, n)), n_range=[2**k for k in range(20)], kernels=[ counter, count, bincount, pandas_value_counts, occur_dict, count_unsorted_list_items, operator_countof ], equality_check=None, logx=True, logy=True, )
from collections import Counter from collections import defaultdict import numpy import operator import pandas import perfplot def counter(a): return Counter(a) def count(a): return dict((i, a.count(i)) for i in set(a)) def bincount(a): return numpy.bincount(a) def pandas_value_counts(a): return pandas.Series(a).value_counts() def occur_dict(a): d = {} for i in a: if i in d: d[i] = d[i]+1 else: d[i] = 1 return d def count_unsorted_list_items(items): counts = defaultdict(int) for item in items: counts[item] += 1 return dict(counts) def operator_countof(a): return dict((i, operator.countOf(a, i)) for i in set(a)) perfplot.show( setup=lambda n: list(numpy.random.randint(0, 100, n)), n_range=[2**k for k in range(20)], kernels=[ counter, count, bincount, pandas_value_counts, occur_dict, count_unsorted_list_items, operator_countof ], equality_check=None, logx=True, logy=True, )
>>> import pandas as pd >>> a = [1, 2, 3, 4, 1, 4, 1] >>> pd.Series(a).value_counts() 1 3 4 2 3 1 2 1 dtype: int64
>>> pd.Series(a).value_counts().reset_index().values.tolist() [[1, 3], [4, 2], [3, 1], [2, 1]]
import pandas as pd l = [ my_count = pd.Series(l).value_counts() my_count
def occurDict(items): d = {} for i in items: if i in d: d[i] = d[i]+1 else: d[i] = 1 return d
from collections import defaultdict def count_unsorted_list_items(items): counts = defaultdict(int) for item in items: counts[item] += 1 return dict(counts) def count_sorted_list_items(items): """ :param items: sorted iterable of items to count :type items: sorted iterable :returns: generator of (item, count) tuples :rtype: generator """ if not items: return elif len(items) == 1: yield (items[0], 1) return prev_item = items[0] count = 1 for item in items[1:]: if prev_item == item: count += 1 else: yield (prev_item, count) count = 1 prev_item = item yield (item, count) return import unittest class TestListCounters(unittest.TestCase): def test_count_unsorted_list_items(self): D = ( ([], []), ([2], [(2,1)]), ([2,2], [(2,2)]), ([2,2,2,2,3,3,5,5], [(2,4), (3,2), (5,2)]), ) for inp, exp_outp in D: counts = count_unsorted_list_items(inp) print inp, exp_outp, counts self.assertEqual(counts, dict( exp_outp )) inp, exp_outp = UNSORTED_WIN = ([2,2,4,2], [(2,3), (4,1)]) self.assertEqual(dict( exp_outp ), count_unsorted_list_items(inp) ) def test_count_sorted_list_items(self): D = ( ([], []), ([2], [(2,1)]), ([2,2], [(2,2)]), ([2,2,2,2,3,3,5,5], [(2,4), (3,2), (5,2)]), ) for inp, exp_outp in D: counts = list( count_sorted_list_items(inp) ) print inp, exp_outp, counts self.assertEqual(counts, exp_outp) inp, exp_outp = UNSORTED_FAIL = ([2,2,4,2], [(2,3), (4,1)]) self.assertEqual(exp_outp, list( count_sorted_list_items(inp) ))
from collections import Counter country=[ count_country = Counter(country) output_list= [] for i in count_country: output_list.append([i,count_country[i]]) print output_list
>>> import operator >>> operator.countOf([1, 2, 3, 4, 1, 4, 1], 1) 3
from itertools import groupby L = [ counts = [(i, len(list(c))) for i,c in groupby(L)] print(counts)
counts = [(i, len(list(c))) for i,c in groupby(sorted(L))] print(counts)
>>> a = [[ >>> dict(zip(*np.unique(a, return_counts=True))) {
sum([1 for elem in <yourlist> if elem==<your_value>])
arr = np.array([ print(set(map(lambda x : (x , list(arr).count(x)) , arr)))
print(dict(map(lambda x : (x , list(arr).count(x)) , arr)))
import time from collections import Counter def countElement(a): g = {} for i in a: if i in g: g[i] +=1 else: g[i] =1 return g z = [1,1,1,1,2,2,2,2,3,3,4,5,5,234,23,3,12,3,123,12,31,23,13,2,4,23,42,42,34,234,23,42,34,23,423,42,34,23,423,4,234,23,42,34,23,4,23,423,4,23,4] st = time.monotonic() for i in range(1000000): b = countElement(z) et = time.monotonic() print(b) print( st = time.monotonic() for i in range(1000000): a = Counter(z) et = time.monotonic() print (a) print( st = time.monotonic() for i in range(1000000): g = dict([(i, z.count(i)) for i in set(z)]) et = time.monotonic() print(g) print(
{1: 4, 2: 5, 3: 4, 4: 6, 5: 2, 234: 3, 23: 10, 12: 2, 123: 1, 31: 1, 13: 1, 42: 5, 34: 4, 423: 3} Simple for loop and storing it in dict - Duration: 12.032000000000153
Counter({23: 10, 4: 6, 2: 5, 42: 5, 1: 4, 3: 4, 34: 4, 234: 3, 423: 3, 5: 2, 12: 2, 123: 1, 31: 1, 13: 1}) Using collections.Counter - Duration: 15.889999999999418
{1: 4, 2: 5, 3: 4, 4: 6, 5: 2, 34: 4, 423: 3, 234: 3, 42: 5, 12: 2, 13: 1, 23: 10, 123: 1, 31: 1} Using list comprehension - Duration: 33.0
>>> from collections import Counter >>> z = [ >>> single_occurrences = Counter(z) >>> print(single_occurrences.get("blue")) 3 >>> print(single_occurrences.values()) dict_values([3, 2, 1])
def countfrequncyinarray(arr1): r=len(arr1) return {i:arr1.count(i) for i in range(1,r+1)} arr1=[4,4,4,4] a=countfrequncyinarray(arr1) print(a)
me@mymachine:~$ workon env1 (env1)me@mymachine:~$ workon env2 (env2)me@mymachine:~$ workon env1 (env1)me@mymachine:~$
bash-4.3$ deactivate pyenv-virtualenv: deactivate must be sourced. Run bash-4.3$ source deactivate pyenv-virtualenv: no virtualenv has been activated.
[bobstein@host ~]$ workon django_project (django_project)[bobstein@host ~]$ workoff [bobstein@host ~]$
export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh
; cd dtree Switching to virtual environment: Development tree utiles ;dtree(feature/task24|✓); cat .autoenv.zsh echo -n "Switching to virtual environment: " printf "\e[38;5;93m%s\e[0m\n" "Development tree utiles" workon dtree dtree(feature/task24|✓); cat .autoenv_leave.zsh deactivate
import os import sys venv_path = os.path.join( old_os_path = os.environ[ old_sys_path = list(sys.path) old_sys_prefix = sys.prefix def deactivate(): os.environ[ sys.prefix = old_sys_prefix sys.path[:0] = old_sys_path activate_this = os.path.join(venv_path, execfile(activate_this, dict(__file__=activate_this)) import pip print str(pip.get_installed_distributions()) del pip deactivate() import pip print str(pip.get_installed_distributions())
def reversed_string(a_string): return a_string[::-1]
slice_obj = slice(start, stop, step) string[slice_obj]
start = stop = None step = -1 reverse_slice = slice(start, stop, step)
def reversed_string(a_string): return a_string[::-1]
def reverse_a_string_slowly(a_string): new_string = index = len(a_string) while index: index -= 1 new_string += a_string[index] return new_string
def reverse_a_string_more_slowly(a_string): new_strings = [] index = len(a_string) while index: index -= 1 new_strings.append(a_string[index]) return
>>> a_string = >>> min(timeit.repeat(lambda: reverse_string_readable_answer(a_string))) 10.38789987564087 >>> min(timeit.repeat(lambda: reversed_string(a_string))) 0.6622700691223145 >>> min(timeit.repeat(lambda: reverse_a_string_slowly(a_string))) 25.756799936294556 >>> min(timeit.repeat(lambda: reverse_a_string_more_slowly(a_string))) 38.73570013046265
mystring = backwards = mystring[::-1] print backwards mystring = print mystring gnipuorg_eta_puoc
print print print print print print print print print print print print print print print print print print print
string_reversed = string[-1::-1] print(string_reversed)
def rev_string(s): if len(s) == 1: return s return s[-1] + rev_string(s[:-1])
def reverse(test): n = len(test) x="" for i in range(n-1,-1,-1): x += test[i] return x
def reverse(input): return reduce(lambda x,y : y+x, input)
def reverse_words_1(s): rev = for i in range(len(s)): j = ~i rev += s[j] return rev
def reverse_words_2(s): rev = for i in reversed(range(len(s)): rev += s[i] return rev
def reverse(text): r_text = index = len(text) - 1 while index >= 0: r_text += text[index] index -= 1 return r_text print reverse("hello, world!")
string ="hello,world" for i in range(-1,-len(string)-1,-1): print (string[i],end=(" "))
def reverse_string(string): character_list = [] for char in string: character_list.append(char) reversed_string = "" for char in reversed(character_list): reversed_string += char return reversed_string
def reverse(text): new_string = [] n = len(text) while (n > 0): new_string.append(text[n-1]) n -= 1 return print reverse("abcd")
def reverse(s): return s[0] if len(s)==1 else s[len(s)-1] + reverse(s[0:len(s)-1])
def reverse_string(string): length = len(string) temp = for i in range(length): temp += string[length - i - 1] return temp print(reverse_string(
original = "string" rev_index = original[::-1] rev_func = list(reversed(list(original))) print(original) print(rev_index) print(
def str_reverse_fun(): empty_list = [] new_str = index = len(new_str) while index: index = index - 1 empty_list.append(new_str[index]) return print str_reverse_fun()
def reverse_sentence(text): words = text.split(" ") reverse ="" for word in reversed(words): reverse += word+ " " return reverse
def reverse_string(phrase): reversed = "" length = len(phrase) for i in range(length): reversed += phrase[length-1-i] return reversed phrase = raw_input("Provide a string: ") print reverse_string(phrase)
s = ln = len(s) i = 1 while True: rev = s[ln-i] print rev, i = i + 1 if i == ln + 1 : break
>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> del a[-1] >>> a [0, 1, 2, 3, 4, 5, 6, 7, 8]
>>> a = [1, 2, 3, 4, 5, 6] >>> index = 3 >>> a = a[:index] + a[index+1 :]
class foo(object): def __init__(self, items): self.items = items def __getitem__(self, index): return foo(self.items[index]) def __add__(self, right): return foo( self.items + right.items )
def del_method(): global a global index del a[index]
10 0 LOAD_GLOBAL 0 (a) 3 LOAD_GLOBAL 1 (index) 6 DELETE_SUBSCR 7 LOAD_CONST 0 (None) 10 RETURN_VALUE None
def pop_method(): global a global index a.pop(index)
17 0 LOAD_GLOBAL 0 (a) 3 LOAD_ATTR 1 (pop) 6 LOAD_GLOBAL 2 (index) 9 CALL_FUNCTION 1 12 POP_TOP 13 LOAD_CONST 0 (None) 16 RETURN_VALUE
def slice_method(): global a global index a = a[:index] + a[index+1:]
24 0 LOAD_GLOBAL 0 (a) 3 LOAD_GLOBAL 1 (index) 6 SLICE+2 7 LOAD_GLOBAL 0 (a) 10 LOAD_GLOBAL 1 (index) 13 LOAD_CONST 1 (1) 16 BINARY_ADD 17 SLICE+1 18 BINARY_ADD 19 STORE_GLOBAL 0 (a) 22 LOAD_CONST 0 (None) 25 RETURN_VALUE None
>>> myList = [10,20,30,40,50] >>> rmovIndxNo = 3 >>> del myList[rmovIndxNo] >>> myList [10, 20, 30, 50]
>>> l = [1, 2, 3, 4, 5] >>> l.pop(2) 3 >>> l [1, 2, 4, 5]
>>> l = [1, 2, 3, 4, 5] >>> del l[2] >>> l [1, 2, 4, 5]
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] a[3:4] = [] a[3:7] = []
letters = ["a", "b", "c", "d", "e"] letters.remove(letters[1]) print(*letters)
list = [1, 2, 3, 4] list.remove(1) print(list) output = [2, 3, 4]
list = [1, 2, 3, 4] list.remove(list[2]) print(list) output : [1, 2, 4]
a = [ def remove_element(list_,index_): clipboard = [] for i in range(len(list_)): if i is not index_: clipboard.append(list_[i]) return clipboard print(remove_element(a,2)) >> [
l = range(20) inds2rem = [2,5,1,7] map(lambda x: l.pop(x), sorted(inds2rem, key = lambda x:-x)) >>> l [0, 3, 4, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
new list = [j for i, j in enumerate(my_list) if i not in [2, 3, 7]]
>>> l = [1,2,3,4,5] >>> del l[-1:] >>> l [1, 2, 3, 4] >>> l.pop(-1) 4 >>> l [1, 2, 3]
>>> a=[1,2,3,4,5] >>> del a[1] >>> a [1, 3, 4, 5] >>> a.pop(1) 3 >>> a [1, 4, 5] >>>
print([v for i,v in enumerate(your_list) if i not in list_of_unwanted_indexes])
print([v for i,v in enumerate(your_list) if i != unwanted_index])
from enum import Enum Animal = Enum( Animal.ant Animal[ Animal.ant.name
class Animal(Enum): ant = 1 bee = 2 cat = 3 dog = 4
>>> Numbers = enum(ONE=1, TWO=2, THREE= >>> Numbers.ONE 1 >>> Numbers.TWO 2 >>> Numbers.THREE
def enum(*sequential, **named): enums = dict(zip(sequential, range(len(sequential))), **named) return type(
>>> Numbers = enum( >>> Numbers.ZERO 0 >>> Numbers.ONE 1
def enum(*sequential, **named): enums = dict(zip(sequential, range(len(sequential))), **named) reverse = dict((value, key) for key, value in enums.iteritems()) enums[ return type(
class Animal(Enum): DOG = 1 CAT = 2 print(Animal.DOG) print(Animal.DOG.value) print(Animal.DOG.name)
class Animal(Enum): DOG = 1 CAT = 2 COW = 0 list(Animal) [animal.value for animal in Animal] Animal.CAT in Animal
class Enum(set): def __getattr__(self, name): if name in self: return name raise AttributeError
Animals = Enum(["DOG", "CAT", "HORSE"]) print(Animals.DOG)
class Stationery: Pen, Pencil, Eraser = range(0, 3)
class Animal: def __init__(self, name): self.name = name def __str__(self): return self.name def __repr__(self): return "<Animal: %s>" % self Animal.DOG = Animal("dog") Animal.CAT = Animal("cat") >>> x = Animal.DOG >>> x <Animal: dog> >>> x == 1 False
>>> State = Enum([ >>> State.Claimed 1 >>> State[1] >>> State ( >>> range(len(State)) [0, 1] >>> [(k, State[k]) for k in range(len(State))] [(0, >>> [(k, getattr(State, k)) for k in State] [(
ANIMALS = [ def take_for_a_walk(animal): assert animal in ANIMALS ...
class Animal(object): values = [ class __metaclass__(type): def __getattr__(self, name): return self.values.index(name)
>>> from enum import Enum >>> class Color(Enum): ... red = 1 ... green = 2 ... blue = 3
>>> print(Color.red) Color.red >>> print(repr(Color.red)) <Color.red: 1>
>>> for color in Color: ... print(color) ... Color.red Color.green Color.blue
class Animal: class Dog: pass class Cat: pass x = Animal.Dog
def M_add_class_attribs(attribs): def foo(name, bases, dict_): for v, k in attribs: dict_[k] = v return type(name, bases, dict_) return foo def enum(*names): class Foo(object): __metaclass__ = M_add_class_attribs(enumerate(names)) def __setattr__(self, name, value): raise NotImplementedError return Foo()
Animal = enum( Animal.DOG Animal.CAT Animal.DOG = 2
__metaclass__ = M_add_class_attribs(enumerate(names))
__metaclass__ = M_add_class_attribs((object(), name) for name in names)
from collections import namedtuple def enum(*keys): return namedtuple( MyEnum = enum(
def enum(*keys): return namedtuple( def enum(**kwargs): return namedtuple(
class Enum(object): def __init__(self, names, separator=None): self.names = names.split(separator) for value, name in enumerate(self.names): setattr(self, name.upper(), value) def tuples(self): return tuple(enumerate(self.names))
>>> state = Enum( >>> state.DRAFT 0 >>> state.RETRACTED 2 >>> state.FOO Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: >>> state.tuples() ((0,
from enum import Enum class Color(Enum): red = 1 green = 2 blue = 3
def cmp(a,b): if a < b: return -1 if b < a: return 1 return 0 def Enum(*names): class EnumClass(object): __slots__ = names def __iter__(self): return iter(constants) def __len__(self): return len(constants) def __getitem__(self, i): return constants[i] def __repr__(self): return def __str__(self): return class EnumValue(object): __slots__ = ( def __init__(self, value): self.__value = value Value = property(lambda self: self.__value) EnumType = property(lambda self: EnumType) def __hash__(self): return hash(self.__value) def __cmp__(self, other): assert self.EnumType is other.EnumType, "Only values from the same enum are comparable" return cmp(self.__value, other.__value) def __lt__(self, other): return self.__cmp__(other) < 0 def __eq__(self, other): return self.__cmp__(other) == 0 def __invert__(self): return constants[maximum - self.__value] def __nonzero__(self): return bool(self.__value) def __repr__(self): return str(names[self.__value]) maximum = len(names) - 1 constants = [None] * len(names) for i, each in enumerate(names): val = EnumValue(i) setattr(EnumClass, each, val) constants[i] = val constants = tuple(constants) EnumType = EnumClass() return EnumType if __name__ == print( print( Days = Enum( print( Days) print( Days.Mo) print( Days.Fr) print( Days.Mo < Days.Fr) print( list(Days)) for each in Days: print( print( Confirmation = Enum( answer = Confirmation.No print(
class Enum(object): def __init__(self, tupleList): self.tupleList = tupleList def __getattr__(self, name): return self.tupleList.index(name)
>>> class Enum(int): ... def __new__(cls, value): ... if isinstance(value, str): ... return getattr(cls, value) ... elif isinstance(value, int): ... return cls.__index[value] ... def __str__(self): return self.__name ... def __repr__(self): return "%s.%s" % (type(self).__name__, self.__name) ... class __metaclass__(type): ... def __new__(mcls, name, bases, attrs): ... attrs[ ... cls = type.__new__(mcls, name, bases, attrs) ... cls._Enum__index = _index = {} ... for base in reversed(bases): ... if hasattr(base, ... _index.update(base._Enum__index) ... ... for attr in attrs.keys(): ... value = attrs[attr] ... if isinstance(value, int): ... evalue = int.__new__(cls, value) ... evalue._Enum__name = attr ... _index[value] = evalue ... setattr(cls, attr, evalue) ... return cls ...
>>> class Citrus(Enum): ... Lemon = 1 ... Lime = 2 ... >>> Citrus.Lemon Citrus.Lemon >>> >>> Citrus(1) Citrus.Lemon >>> Citrus(5) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 6, in __new__ KeyError: 5 >>> class Fruit(Citrus): ... Apple = 3 ... Banana = 4 ... >>> Fruit.Apple Fruit.Apple >>> Fruit.Lemon Citrus.Lemon >>> Fruit(1) Citrus.Lemon >>> Fruit(3) Fruit.Apple >>> "%d %s %r" % ((Fruit.Apple,)*3) >>> Fruit(1) is Citrus.Lemon True
def enum_base(t, **enums): T = type( for key,val in enums.items(): setattr(T, key, T(val)) return T
>>> Numbers = enum_base(int, ONE=1, TWO=2, THREE=3) >>> Numbers.ONE 1 >>> x = Numbers.TWO >>> 10 + x 12 >>> type(Numbers) <type >>> type(Numbers.ONE) <class >>> isinstance(x, Numbers) True
def enum_repr(t, **enums): class Enum(t): def __repr__(self): return for key,val in enums.items(): i = Enum(val) i._name = key setattr(Enum, key, i) return Enum >>> Numbers = enum_repr(int, ONE=1, TWO=2, THREE=3) >>> repr(Numbers.ONE) >>> str(Numbers.ONE)
>>> from flufl.enum import Enum >>> class Colors(Enum): ... red = 1 ... green = 2 ... blue = 3 >>> for color in Colors: print color Colors.red Colors.green Colors.blue
def enum(*sequential, **named): enums = dict(zip(sequential, [object() for _ in range(len(sequential))]), **named) return type(
>>> DOG = enum( >>> CAT = enum( >>> DOG.WALK == CAT.WALK False
>>> DOG = enum( >>> CAT = enum( >>> pet1_state = DOG.BARK >>> pet2_state = CAT.WALK >>> pet1_state == pet2_state True
>>> from enum import Enum >>> Colors = Enum( >>> shirt_color = Colors.green >>> shirt_color = Colors[2] >>> shirt_color > Colors.red True >>> shirt_color.index 2 >>> str(shirt_color)
class Animal: TYPE_DOG = 1 TYPE_CAT = 2 type2str = { TYPE_DOG: "dog", TYPE_CAT: "cat" } def __init__(self, type_): assert type_ in self.type2str.keys() self._type = type_ def __repr__(self): return "<%s type=%s>" % ( self.__class__.__name__, self.type2str[self._type].upper())
def enum(*args, **kwargs): return type( x = enum( assert x.POOH == 0 assert x.TIGGER == 1
import new def create(class_name, names): return new.classobj( class_name, (object,), dict((y, x) for x, y in enumerate(names)) )
def enum(*names): """ SYNOPSIS Well-behaved enumerated type, easier than creating custom classes DESCRIPTION Create a custom type that implements an enumeration. Similar in concept to a C enum but with some additional capabilities and protections. See http: PARAMETERS names Ordered list of names. The order in which names are given will be the sort order in the enum type. Duplicate names are not allowed. Unicode names are mapped to ASCII. RETURNS Object of type enum, with the input names and the enumerated values. EXAMPLES >>> letters = enum( >>> letters.a < letters.e True >>> letters.a a >>> letters[0] a >>> letters[ a >>> letters.u < letters.b True >>> letters[-1] z >>> letters[99] Traceback (most recent call last): ... IndexError: tuple index out of range >>> letters[ Traceback (most recent call last): ... ValueError: tuple.index(x): x not in tuple >>> numbers = enum(1,2,3,4) Traceback (most recent call last): ... AssertionError: Enum values must be string or unicode >>> a = enum( Traceback (most recent call last): ... TypeError: Error when calling the metaclass bases __slots__ must be identifiers >>> tags = enum( >>> tags.a a >>> letters.a a >>> letters.a == tags.a Traceback (most recent call last): ... AssertionError: Only values from the same enum are comparable >>> letters.a < tags.a Traceback (most recent call last): ... AssertionError: Only values from the same enum are comparable >>> letters.a = Traceback (most recent call last): ... AttributeError: >>> del letters.u Traceback (most recent call last): ... AttributeError: >>> x = enum( Traceback (most recent call last): ... AssertionError: Enums must not repeat values >>> x = enum() Traceback (most recent call last): ... AssertionError: Empty enums are not supported >>> x = enum( Traceback (most recent call last): ... AssertionError: Enum values beginning with __ are not supported LIMITATIONS Enum values of unicode type are not preserved, mapped to ASCII instead. """ assert names, assert len([i for i in names if not isinstance(i, types.StringTypes) and not \ isinstance(i, unicode)]) == 0, assert len([i for i in names if i.startswith("__")]) == 0,\ assert names == uniquify(names), class EnumClass(object): __slots__ = names def __iter__(self): return iter(constants) def __len__(self): return len(constants) def __getitem__(self, i): if isinstance(i, types.StringTypes): i = names.index(i) return constants[i] def __repr__(self): return def __str__(self): return def index(self, i): return names.index(i) class EnumValue(object): __slots__ = ( def __init__(self, value): self.__value = value value = property(lambda self: self.__value) enumtype = property(lambda self: enumtype) def __hash__(self): return hash(self.__value) def __cmp__(self, other): assert self.enumtype is other.enumtype, return cmp(self.value, other.value) def __invert__(self): return constants[maximum - self.value] def __nonzero__(self): return True def __repr__(self): return str(names[self.value]) maximum = len(names) - 1 constants = [None] * len(names) for i, each in enumerate(names): val = EnumValue(i) setattr(EnumClass, each, val) constants[i] = val constants = tuple(constants) enumtype = EnumClass() return enumtype
class _Constants(object): pass opAssoc = _Constants() opAssoc.LEFT = object() opAssoc.RIGHT = object()
>>> i = 123 >>> type(i) <type >>> type(i) is int True >>> i = 123456789L >>> type(i) <type >>> type(i) is long True >>> i = 123.456 >>> type(i) <type >>> type(i) is float True
>>> import sys >>> format(sys.maxint, >>> format(-sys.maxint - 1,
>>> sys.float_info sys.floatinfo(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.2204460492503131e-16, radix=2, rounds=1)
In [9]: var = 123 In [10]: var? Type: int Base Class: <type String Form: 123 Namespace: Interactive Docstring: int(x[, base]) -> integer
>>> a = [1, 2, 3, 4] >>> a.__class__ <type >>> b = { >>> b.__class__ <type >>> c = 12 >>> c.__class__ <type
assert type(variable_name) == int assert type(variable_name) == bool assert type(variable_name) == list
>>> struct.calcsize( 1 >>> struct.calcsize( 2 >>> struct.calcsize( 4 >>> struct.calcsize( 4
>>> import sys, math >>> math.ceil(math.log(sys.maxint, 2)) + 1 32.0
>>> sys.float_info sys.floatinfo(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.2204460492503131e-16, radix=2, rounds=1)
>>> import ctypes >>> a = ctypes.c_uint() >>> type(a) <class
select * from table where colume_name = some_value.
import pandas as pd import numpy as np df = pd.DataFrame({ print(df) print(df.loc[df[
A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
A B C D 0 foo one 0 0 1 bar one 1 2 3 bar three 3 6 6 foo one 6 12 7 foo three 7 14
A C D B one foo 0 0 one bar 1 2 two foo 2 4 two foo 4 8 two bar 5 10 one foo 6 12
table[(table.column_name == some_value) | (table.column_name2 == some_value2)]
import pandas as pd d = { df = pd.DataFrame(d) df df[df.foo == 222]
import pandas as pd, numpy as np df = pd.DataFrame({
df[mask] A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
mask = df[ pos = np.flatnonzero(mask) df.iloc[pos] A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
df.set_index( A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
df.query( A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
%timeit mask = df[ %timeit mask = df[ 5.84 µs ± 195 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) 166 µs ± 4.45 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
mask = df[ %timeit df[mask] mask = df[ %timeit df[mask] 219 µs ± 12.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 239 µs ± 7.03 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
pd.DataFrame(df.values[mask], df.index[mask], df.columns).astype(df.dtypes)
%timeit df[m] %timeit pd.DataFrame(df.values[mask], df.index[mask], df.columns).astype(df.dtypes) 216 µs ± 10.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 1.43 ms ± 39.6 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
np.random.seed([3,1415]) d1 = pd.DataFrame(np.random.randint(10, size=(10, 5)), columns=list( d1 A B C D E 0 0 2 7 3 8 1 7 0 6 8 6 2 0 2 0 4 9 3 7 3 2 4 3 4 3 6 7 7 4 5 5 3 7 5 9 6 8 7 6 4 7 7 6 2 6 6 5 8 2 8 7 5 8 9 4 7 6 1 5
%%timeit mask = d1[ d1[mask] 179 µs ± 8.73 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
%%timeit mask = d1[ pd.DataFrame(d1.values[mask], d1.index[mask], d1.columns) 87 µs ± 5.12 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
mask = df[ df[mask] A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
mask = np.in1d(df[ df[mask] A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
res.div(res.min()) 10 30 100 300 1000 3000 10000 30000 mask_standard 2.156872 1.850663 2.034149 2.166312 2.164541 3.090372 2.981326 3.131151 mask_standard_loc 1.879035 1.782366 1.988823 2.338112 2.361391 3.036131 2.998112 2.990103 mask_with_values 1.010166 1.000000 1.005113 1.026363 1.028698 1.293741 1.007824 1.016919 mask_with_values_loc 1.196843 1.300228 1.000000 1.000000 1.038989 1.219233 1.037020 1.000000 query 4.997304 4.765554 5.934096 4.500559 2.997924 2.397013 1.680447 1.398190 xs_label 4.124597 4.272363 5.596152 4.295331 4.676591 5.710680 6.032809 8.950255 mask_with_isin 1.674055 1.679935 1.847972 1.724183 1.345111 1.405231 1.253554 1.264760 mask_with_in1d 1.000000 1.083807 1.220493 1.101929 1.000000 1.000000 1.000000 1.144175
def mask_standard(df): mask = df[ return df[mask] def mask_standard_loc(df): mask = df[ return df.loc[mask] def mask_with_values(df): mask = df[ return df[mask] def mask_with_values_loc(df): mask = df[ return df.loc[mask] def query(df): return df.query( def xs_label(df): return df.set_index( def mask_with_isin(df): mask = df[ return df[mask] def mask_with_in1d(df): mask = np.in1d(df[ return df[mask]
res = pd.DataFrame( index=[ ], columns=[10, 30, 100, 300, 1000, 3000, 10000, 30000], dtype=float ) for j in res.columns: d = pd.concat([df] * j, ignore_index=True) for i in res.index:a stmt = setp = res.at[i, j] = timeit(stmt, setp, number=50)
spec.div(spec.min()) 10 30 100 300 1000 3000 10000 30000 mask_with_values 1.009030 1.000000 1.194276 1.000000 1.236892 1.095343 1.000000 1.000000 mask_with_in1d 1.104638 1.094524 1.156930 1.072094 1.000000 1.000000 1.040043 1.027100 reconstruct 1.000000 1.142838 1.000000 1.355440 1.650270 2.222181 2.294913 3.406735
np.random.seed([3,1415]) d1 = pd.DataFrame(np.random.randint(10, size=(10, 5)), columns=list( def mask_with_values(df): mask = df[ return df[mask] def mask_with_in1d(df): mask = np.in1d(df[ return df[mask] def reconstruct(df): v = df.values mask = np.in1d(df[ return pd.DataFrame(v[mask], df.index[mask], df.columns) spec = pd.DataFrame( index=[ columns=[10, 30, 100, 300, 1000, 3000, 10000, 30000], dtype=float )
for j in spec.columns: d = pd.concat([df] * j, ignore_index=True) for i in spec.index: stmt = setp = spec.at[i, j] = timeit(stmt, setp, number=50)
In [167]: n = 10 In [168]: df = pd.DataFrame(np.random.rand(n, 3), columns=list( In [169]: df Out[169]: a b c 0 0.687704 0.582314 0.281645 1 0.250846 0.610021 0.420121 2 0.624328 0.401816 0.932146 3 0.011763 0.022921 0.244186 4 0.590198 0.325680 0.890392 5 0.598892 0.296424 0.007312 6 0.634625 0.803069 0.123872 7 0.924168 0.325076 0.303746 8 0.116822 0.364564 0.454607 9 0.986142 0.751953 0.561512 In [170]: df[(df.a < df.b) & (df.b < df.c)] Out[170]: a b c 3 0.011763 0.022921 0.244186 8 0.116822 0.364564 0.454607 In [171]: df.query( Out[171]: a b c 3 0.011763 0.022921 0.244186 8 0.116822 0.364564 0.454607
In [76]: df.iloc[np.where(df.A.values== Out[76]: A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
In [68]: %timeit df.iloc[np.where(df.A.values== 1000 loops, best of 3: 380 µs per loop In [69]: %timeit df.loc[df[ 1000 loops, best of 3: 745 µs per loop In [71]: %timeit df.loc[df[ 1000 loops, best of 3: 562 µs per loop In [72]: %timeit df[df.A== 1000 loops, best of 3: 796 µs per loop In [74]: %timeit df.query( 1000 loops, best of 3: 1.71 ms per loop
from pandas import DataFrame d = { df = DataFrame(d) mask = df[ print mask df[mask]
import pandas as pd import numpy as np df = pd.DataFrame({ print(df) print(df.loc[df[
A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
A B C D 0 foo one 0 0 1 bar one 1 2 3 bar three 3 6 6 foo one 6 12 7 foo three 7 14
A B C D foo one 0 0 foo two 2 4 foo two 4 8 foo one 6 12 foo three 7 14
df = pd.DataFrame({ df[df[ OUTPUT: A B C D 0 foo one 0 0 2 foo two 2 4 4 foo two 4 8 6 foo one 6 12 7 foo three 7 14
import pandas as pd df = pd.DataFrame({ print("Original dataframe:") print(df) b_is_two_dataframe = pd.DataFrame(df.groupby( print( print(b_is_two_dataframe)
Original dataframe: A B 0 foo one 1 bar one 2 foo two 3 bar three 4 foo two 5 bar two 6 foo one 7 foo three Sub dataframe where B is two: A B 0 foo two 1 foo two 2 bar two
select col_name1, col_name2 from table where column_name = some_value.
A B 0 foo one 1 bar one 2 foo two 3 bar three 4 foo two 5 bar two 6 foo one 7 foo three
A B C D 0 foo one 0 0 1 bar one 1 2 3 bar three 3 6 6 foo one 6 12 7 foo three 7 14
number = raw_input() try: value = int(number) except ValueError: value = 0
t=raw_input() c=[] for j in range(0,int(t)): n=raw_input() a=[] a,b= (int(i) for i in n.split( d=pow(a,b) d2=str(d) c.append(d2[0]) for j in c: print j
>>> i = 5 >>> print "Hello, world the number is " + i TypeError: must be str, not int >>> s = str(i) >>> print "Hello, world the number is " + s Hello, world the number is 5
>>> import itertools >>> x = itertools.count(0) >>> type(x).__name__
>>> class A(object): ... def whoami(self): ... print type(self).__name__ ... >>> >>> class B(A): ... pass ... >>> >>> >>> o = B() >>> o.whoami() >>>
"{0}.{1}".format(a.__class__.__module__,a.__class__.__name__)
type(instance).__name__ != instance.__class__.__name class A(): ... type(instance) == instance.__class__ class A(object): ...
>>> class aclass(object): ... pass ... >>> a = aclass() >>> type(a) <class >>> a.__class__ <class >>> >>> type(a).__name__ >>> >>> a.__class__.__name__ >>> >>> class bclass(): ... pass ... >>> b = bclass() >>> >>> type(b) <type >>> b.__class__ <class __main__.bclass at 0xb765047c> >>> type(b).__name__ >>> >>> b.__class__.__name__ >>>
>>> class person(object): def init(self,name): self.name=name def info(self) print "My name is {0}, I am a {1}".format(self.name,self.__class__.__name__) >>> bob = person(name= >>> bob.info() My name is Robert, I am a person
class Spam: def meth(self): pass class Bar: pass >>> s = Spam() >>> type(s).__name__ >>> type(s).__qualname__ >>> type(s).Bar.__name__ >>> type(s).Bar.__qualname__ >>> type(s).meth.__name__ >>> type(s).meth.__qualname__
d = dict((key, value) for (key, value) in iterable)
d = {value: foo(value) for value in sequence if bar(value)} def key_value_gen(k): yield chr(k+65) yield chr((k+13)%26+65) d = dict(map(key_value_gen, range(26)))
>>> ts = [(1, 2), (3, 4), (5, 6)] >>> dict(ts) {1: 2, 3: 4, 5: 6} >>> gen = ((i, i+1) for i in range(1, 6, 2)) >>> gen <generator object <genexpr> at 0xb7201c5c> >>> dict(gen) {1: 2, 3: 4, 5: 6}
>>> list1, list2 = [ >>> dict( zip( list1, list2)) {
d = dict((key, value) for (key, value) in zip(key_list, value_list))
d = {(key, value) for (key, value) in zip(key_list, value_list)}
>>> mydict = {k: v for k, v in blahs if not int(k[-1]) % 2} >>> mydict {
>>> import string >>> dict1 = {value: (int(key) + 1) for key, value in enumerate(list(string.ascii_lowercase))} >>> dict1 { 19, >>>
def get_dic_from_two_lists(keys, values): return { keys[i] : values[i] for i in range(len(keys)) }
{index:nums[index] for index in range(0,len(nums))}
>>> {k: v**3 for (k, v) in zip(string.ascii_lowercase, range(26))}
>>> import string >>> import random >>> def id_generator(size=6, chars=string.ascii_uppercase + string.digits): ... return ... >>> id_generator() >>> id_generator(3, "6793YUIO")
>>> string.ascii_uppercase >>> string.digits >>> string.ascii_uppercase + string.digits
>>> random.choice("abcde") >>> random.choice("abcde") >>> random.choice("abcde")
>>> [random.choice( [ >>> [random.choice( [ >>> [random.choice( [
import uuid def my_random_string(string_length=10): random = str(uuid.uuid4()) random = random.upper() random = random.replace("-","") return random[0:string_length] print(my_random_string(6))
import random import string char_set = string.ascii_uppercase + string.digits print
>>> from strgen import StringGenerator as SG >>> SG("[\u\d]{6}").render() u
from os import urandom from itertools import islice, imap, repeat import string def rand_string(length=5): chars = set(string.ascii_uppercase + string.digits) char_gen = (c for c in imap(urandom, repeat(1)) if c in chars) return
import random def random_alphanumeric(limit): r = (range(48, 58) + range(65, 91) + range(97, 123)) random.shuffle(r) return reduce(lambda i, s: i + chr(s), r[:random.randint(0, len(r))], "")
_ALPHABET = def generate_with_randbits(size=32): def chop(x): while x: yield x & 31 x = x >> 5 return
import random from string import digits, ascii_uppercase legals = digits + ascii_uppercase def rand_string(length, char_set=legals): output = for _ in range(length): output += random.choice(char_set) return output
import numpy as np import string if __name__ == length = 16 a = np.random.choice(list(string.ascii_uppercase + string.digits), length) print(
from itertools import imap, starmap, islice, repeat from functools import partial from string import letters, digits, join from random import choice join_chars = partial(join, sep= identity = lambda o: o def irand_seqs(symbols=join_chars((letters, digits)), length=6, join=join_chars, select=choice, breakup=islice): """ Generates an indefinite sequence of joined random symbols each of a specific length :param symbols: symbols to select, [defaults to string.letters + string.digits, digits 0 - 9, lower and upper case English letters.] :param length: the length of each sequence, [defaults to 6] :param join: method used to join selected symbol, [defaults to :param select: method used to select a random element from the giving population. [defaults to random.choice, which selects a single element randomly] :return: indefinite iterator generating random sequences of giving [:param length] >>> from tools import irand_seqs >>> strings = irand_seqs() >>> a = next(strings) >>> assert isinstance(a, (str, unicode)) >>> assert len(a) == 6 >>> assert next(strings) != next(strings) """ return imap(join, starmap(breakup, repeat((imap(select, repeat(symbols)), None, length))))
>>> irand_tuples = irand_seqs(xrange(10), join=tuple) >>> next(irand_tuples) (0, 5, 5, 7, 2, 8) >>> next(irand_tuples) (3, 2, 2, 0, 3, 1)
>>> irand_tuples = irand_seqs(xrange(10), join=tuple) >>> make_rand_tuples = partial(next, irand_tuples) >>> make_rand_tuples() (1, 6, 2, 8, 1, 9)
>>> irand_tuples = irand_seqs(xrange(10), join=identity) >>> selections = next(irand_tuples) >>> next(selections) 8 >>> list(selections) [6, 3, 8, 2, 2]
>>> from random import SystemRandom >>> rand_strs = irand_seqs(select=SystemRandom().choice)
>>> from random import sample >>> irand_samples = irand_seqs(xrange(10), length=1, join=next, select=lambda pool: sample(pool, 6)) >>> next(irand_samples) [0, 9, 2, 3, 1, 6]
import string, random passkey= for x in range(8): if random.choice([1,2]) == 1: passkey += passkey.join(random.choice(string.ascii_uppercase)) else: passkey += passkey.join(random.choice(string.digits)) print passkey
import string, random passkey= for x in range(8): if random.choice([1,2]) == 1: passkey += passkey.join(random.choice(string.ascii_letters)) else: passkey += passkey.join(random.choice(string.digits)) print passkey
import random import string oneFile = open( userInput = 0 key_count = 0 value_count = 0 chars = string.ascii_uppercase + string.digits + string.punctuation for userInput in range(int(input( while key_count <= userInput: key_count += 1 number = random.randint(1, 999) key = number text = str(key) + ": " + str( oneFile.write(text + "\n") oneFile.close()
>>> import random >>> str = [] >>> chars = >>> num = int(raw_input( How long do you want the string to be? 10 >>> for k in range(1, num+1): ... str.append(random.choice(chars)) ... >>> str = "".join(str) >>> str
import string import random character = string.lowercase + string.uppercase + string.digits + string.punctuation char_len = len(character) pass_len = random.randint(10,20) password = for x in range(pass_len): password = password + character[random.randint(0,char_len-1)] print password
import string from random import * characters = string.ascii_letters + string.punctuation + string.digits password = "".join(choice(characters) for x in range(randint(8, 16))) print password
import random q=2 o=1 list =[r while(q>o): print("") for i in range(1,128): x=random.choice(list) print(x,end="")
import crypt n = 10 crypt.crypt("any sring").replace(
import uuid import crypt n = 10 crypt.crypt(str(uuid.uuid4())).replace(
def randStr_1(chars:str, length:int) -> str: chars *= math.ceil(length / len(chars)) chars = letters[0:length] chars = list(chars) random.shuffle(characters) return
def randStr_2(chars:str, length:int) -> str: return
from timeit import timeit setup = """ import os, subprocess, time, string, random, math def randStr_1(letters:str, length:int) -> str: letters *= math.ceil(length / len(letters)) letters = letters[0:length] letters = list(letters) random.shuffle(letters) return def randStr_2(letters:str, length:int) -> str: return """ print( for length in [100,1000,10000,50000,100000,500000,1000000]: print(length, eff1 = timeit("randStr_1(string.ascii_letters, {})".format(length), setup=setup, number=10) eff2 = timeit("randStr_2(string.ascii_letters, {})".format(length), setup=setup, number=10) print( print(
Method 1 vs Method 2 , run 10 times each. 100 characters: 0.001411s : 0.00179s ratio = 1.0 : 1.27 1000 characters: 0.013857s : 0.017603s ratio = 1.0 : 1.27 10000 characters: 0.13426s : 0.151169s ratio = 1.0 : 1.13 50000 characters: 0.709403s : 0.855136s ratio = 1.0 : 1.21 100000 characters: 1.360735s : 1.674584s ratio = 1.0 : 1.23 500000 characters: 6.754923s : 7.160508s ratio = 1.0 : 1.06 1000000 characters: 11.232965s : 14.223914s ratio = 1.0 : 1.27
str_Key = "" str_FullKey = "" str_CharacterPool = "01234ABCDEFfghij~>()" for int_I in range(64): str_Key = random.choice(str_CharacterPool) str_FullKey = str_FullKey + str_Key
var chars = "ABC123"; var random = new Random(); var result = new string( Enumerable.Repeat(chars, 7) .Select(s => s[random.Next(s.Length)]) .ToArray()); textBox1.Text = result;
var chars = "ABC123"; var stringChars = new char[7]; var random = new Random(); for (int i = 0; i < stringChars.Length; i++) { stringChars[i] = chars[random.Next(chars.Length)]; } var finalString = new String(stringChars); textBox1.Text = finalstring;`
>>> n = 4 >>> print 004 >>> print format(n, 004 >>> print 004 >>> print 004 >>> print( 004 >>> print( 004 >>> print(f 004
print("{0:05d}".format(number)) print(format(number, "05d"))
>>> n = 3 >>> str(n).zfill(5) >>> n = >>> str(n).zfill(5) >>> n = >>> str(n).zfill(5)
hour = 4 minute = 3 "{:0>2}:{:0>2}".format(hour,minute) "{:0>3}:{:0>5}".format(hour,minute) "{:0<3}:{:0<5}".format(hour,minute) "{:$<3}:{:
width = 10 x = 5 print "%0*d" % (width, x) > 0000000005
>>> help(str.zfill) Help on method_descriptor: zfill(...) S.zfill(width) -> str Pad a numeric string S with zeros on the left, to fill a field of the specified width. The string S is never truncated.
>>> min(timeit.repeat(lambda: 0.18824880896136165 >>> min(timeit.repeat(lambda: 0.2104538488201797 >>> min(timeit.repeat(lambda: f 0.32585487607866526 >>> min(timeit.repeat(lambda: 0.34988890308886766
>>> min(timeit.repeat(lambda: 0.19728074967861176 >>> min(timeit.repeat(lambda: 0.2347015216946602
>>> Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: zfill() takes no keyword arguments
>>> width = 4 >>> x = 5 >>> print("%0*d" %(width,x)) >>> 00005
>>> a = 6340 >>> b = 90210 >>> print 06340 >>> print 90210
setup = from random import randint def test_1(): num = randint(0,1000000) return str(num).zfill(7) def test_2(): num = randint(0,1000000) return format(num, def test_3(): num = randint(0,1000000) return def test_4(): num = randint(0,1000000) return format(num, def test_5(): num = randint(0,1000000) return def test_6(): num = randint(0,1000000) return def test_7(): num = randint(0,1000000) return str(num).rjust(7, import timeit print timeit.Timer("test_1()", setup=setup).repeat(3, 900000) print timeit.Timer("test_2()", setup=setup).repeat(3, 900000) print timeit.Timer("test_3()", setup=setup).repeat(3, 900000) print timeit.Timer("test_4()", setup=setup).repeat(3, 900000) print timeit.Timer("test_5()", setup=setup).repeat(3, 900000) print timeit.Timer("test_6()", setup=setup).repeat(3, 900000) print timeit.Timer("test_7()", setup=setup).repeat(3, 900000) > [2.281613943830961, 2.2719342631547077, 2.261691106209631] > [2.311480238815406, 2.318420542148333, 2.3552384305184493] > [2.3824197456864304, 2.3457239951596485, 2.3353268829498646] > [2.312442972404032, 2.318053102249902, 2.3054072168069872] > [2.3482314132374853, 2.3403386400002475, 2.330108825844775] > [2.424549090688892, 2.4346475296851438, 2.429691196530058] > [2.3259756401716487, 2.333549212826732, 2.32049893822186]
def pad_left(n, width, pad="0"): return ((pad * width) + str(n))[-width:]
print >> sys.stderr, "spam" sys.stderr.write("spam\n") os.write(2, b"spam\n") from __future__ import print_function print("spam", file=sys.stderr)
from __future__ import print_function import sys def eprint(*args, **kwargs): print(*args, file=sys.stderr, **kwargs)
>>> print("Test") Test >>> eprint("Test") Test >>> eprint("foo", "bar", "baz", sep="---") foo---bar---baz
Old: print >>sys.stderr, "fatal error" New: print("fatal error", file=sys.stderr)
import logging logging.basicConfig(format= logging.warning( logging.info( print(
$ python3 foo.py > bar.txt I print to stderr by default
from sys import stderr def print_err(*args, **kwargs): print(*args, file=stderr, **kwargs)
print_err("Error: end of the file reached. The word ", end= print_err(word, "was not found")
from __future__ import print_function import sys from functools import partial error = partial(print, file=sys.stderr)
class NullDevice(): def write(self, s): pass sys.stderr = NullDevice() from print_error import error error("You won
[18:19 jsilverman@JSILVERMAN-LT7 pexpect]$ python3 >>> import sys >>> print("testing", file=sys.stderr) testing >>> [18:19 jsilverman@JSILVERMAN-LT7 pexpect]$
[18:22 jsilverman@JSILVERMAN-LT7 pexpect]$ python3 2> /tmp/test.txt >>> import sys >>> print("testing", file=sys.stderr) >>> [18:22 jsilverman@JSILVERMAN-LT7 pexpect]$ [18:22 jsilverman@JSILVERMAN-LT7 pexpect]$ cat /tmp/test.txt Python 3.4.3 (default, May 5 2015, 17:58:45) [GCC 4.9.2] on cygwin Type "help", "copyright", "credits" or "license" for more information. testing [18:22 jsilverman@JSILVERMAN-LT7 pexpect]$
import time import sys def run1(runs): x = 0 cur = time.time() while x < runs: x += 1 print >> sys.stderr, elapsed = (time.time()-cur) return elapsed def run2(runs): x = 0 cur = time.time() while x < runs: x += 1 sys.stderr.write( sys.stderr.flush() elapsed = (time.time()-cur) return elapsed def compare(runs): sum1, sum2 = 0, 0 x = 0 while x < runs: x += 1 sum1 += run1(runs) sum2 += run2(runs) return sum1, sum2 if __name__ == s1, s2 = compare(1000) print "Using (print >> sys.stderr, print "Using (sys.stderr.write( print "Ratio: %f" %(float(s1) / float(s2))
>>> import sys >>> print "hi" hi >>> print("hi") hi >>> print >> sys.stderr.write("hi") hi
>>> from __future__ import print_function >>> >>> def printex(*args, **kwargs): ... print(*args, file=sys.stderr, **kwargs) ... >>> printex("hii") hii >>>
import logging logging.info( FORMAT = "%(asctime)-15s %(clientip)s %(user)-8s %(message)s" logging.basicConfig(format=FORMAT) d = { logging.warning("Protocol problem: %s", "connection reset", extra=d)
from sys import stderr print("Hello, world!", file=stderr)
import logging logging.basicConfig(format= logging.error( logging.warning( print(
agent_telno = agent.find( agent_telno = p.agent_info = str(agent_contact +
Traceback (most recent call last): File "foobar.py", line 792, in <module> p.agent_info = str(agent_contact + UnicodeEncodeError:
str(a) Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeEncodeError:
$ echo $LANG en_US.utf8 $ echo $LC_ALL C $ python -c "print (u Traceback (most recent call last): File "<string>", line 1, in <module> UnicodeEncodeError: $ export LC_ALL= $ python -c "print (u voilà $ unset LC_ALL $ python -c "print (u voilà
vagrant init ubuntu/trusty64; vagrant up; vagrant ssh
$ python -c Traceback (most recent call last): File "<string>", line 1, in <module> UnicodeEncodeError:
$ sudo apt-get -y install language-pack-en The following extra packages will be installed: language-pack-en-base Generating locales... en_GB.UTF-8... /usr/sbin/locale-gen: done Generation complete.
def safeStr(obj): try: return str(obj) except UnicodeEncodeError: return obj.encode( except: return ""
if __name__ == print safeStr( 1 ) print safeStr( "test" ) print u print safeStr( u
def safe_unicode(obj, *args): try: return unicode(obj, *args) except UnicodeDecodeError: ascii_text = str(obj).encode( return unicode(ascii_text) def safe_str(obj): try: return str(obj) except UnicodeEncodeError: return unicode(obj).encode(
import unicodedata message = unicodedata.normalize("NFKD", message)
result_html = result.to_html(col_space=1, index=False, justify={ text = u""" <html> <body> <p> Hello all, <br> <br> Here <br> Data Summary <br> <br> <br> {0} </p> <p>Thanks,</p> <p>Data Team</p> </body></html> """.format(result_html)
locale-gen en_US.UTF-8 export LANG=en_US.UTF-8 LANGUAGE=en_US.en LC_ALL=en_US.UTF-8
>>> class MyClass(): ... def __init__(self): ... self.__superprivate = "Hello" ... self._semiprivate = ", world!" ... >>> mc = MyClass() >>> print mc.__superprivate Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: myClass instance has no attribute >>> print mc._semiprivate , world! >>> print mc.__dict__ {
class Test(object): def __init__(self): self.__a = self._b = >>> t = Test() >>> t._b
>>> t.__a Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError:
class BaseForm(StrAndUnicode): def _get_errors(self): "Returns an ErrorDict for the data provided for the form" if self._errors is None: self.full_clean() return self._errors errors = property(_get_errors)
class A(object): def __test(self): print "I def test(self): self.__test() a = A() a.test() a._A__test()
class B(A): def __test(self): print "I b = B() b.test()
>>> name = "test string" >>> name.__len__() 11 >>> len(name) 11 >>> number = 10 >>> number.__add__(40) 50 >>> number + 50 60
class FalseCalculator(object): def __init__(self, number): self.number = number def __add__(self, number): return self.number - number def __sub__(self, number): return self.number + number number = FalseCalculator(20) print number + 10 print number - 20
class PrivateVarC(object): def get_x(self): pass def set_x(self, val): pass rwvar = property(get_p, set_p) ronly = property(get_p)
class parent(object): __default = "parent" def __init__(self, name=None): self.default = name or self.__default @property def default(self): return self.__default @default.setter def default(self, value): self.__default = value class child(parent): __default = "child"
child_a = child() child_a.default child_a._child__default child_a._parent__default child_b = child("orphan") child_b.default child_a._child__default child_a._parent__default
class Circle(object): def __init__(self, radius): self.radius = radius def area(self): p = self.__perimeter() r = p / math.pi / 2.0 return math.pi * r ** 2.0 def perimeter(self): return 2.0 * math.pi * self.radius __perimeter = perimeter class Tire(Circle): def perimeter(self): return Circle.perimeter(self) * 1.25
class Tire(Circle): def perimeter(self): return Circle.perimeter(self) * 1.25 _perimeter = perimeter
from pycallgraph import PyCallGraph from pycallgraph.output import GraphvizOutput with PyCallGraph(output=GraphvizOutput()): code_to_profile()
class ProfiledThread(threading.Thread): def run(self): profiler = cProfile.Profile() try: return profiler.runcall(threading.Thread.run, self) finally: profiler.dump_stats(
pycallgraph -f svg -o pycallgraph.svg mine.py <args>
sudo pip install gprof2dot python -m cProfile -o profile.pstats mine.py gprof2dot -f pstats profile.pstats | dot -Tsvg -o mine.svg
$ sudo apt-get install graphviz $ git clone https: $ ln -s "$PWD"/gprof2dot/gprof2dot.py ~/bin $ cd $PROJECT_DIR $ gprof2dot.py -f pstats profile.pstats | dot -Tsvg -o callgraph.svg
python -m cProfile -o script.profile script.py pyprof2calltree -i script.profile -o script.calltree kcachegrind script.calltree
apt-get install kcachegrind pip install pyprof2calltree
1. pip install snakeviz 2. python -m cProfile -o temp.dat <PROGRAM>.py 3. snakeviz temp.dat
def count(): from math import sqrt for x in range(10**5): sqrt(x) if __name__ == import cProfile, pstats cProfile.run("count()", "{}.profile".format(__file__)) s = pstats.Stats("{}.profile".format(__file__)) s.strip_dirs() s.sort_stats("time").print_stats(10)
@staticmethod def startProfiler(): yappi.start() @staticmethod def stopProfiler(): yappi.stop() @staticmethod def printProfiler(): stats = yappi.get_stats(yappi.SORTTYPE_TTOT, yappi.SORTORDER_DESC, 20) statPrint = namesArr = [len(str(stat[0])) for stat in stats.func_stats] log.debug("namesArr %s", str(namesArr)) maxNameLen = max(namesArr) log.debug("maxNameLen: %s", maxNameLen) for stat in stats.func_stats: nameAppendSpaces = [ log.debug( blankSpace = for space in nameAppendSpaces: blankSpace += space log.debug("adding spaces: %s", len(nameAppendSpaces)) statPrint = statPrint + str(stat[0]) + blankSpace + " " + str(stat[1]).ljust(8) + "\t" + str( round(stat[2], 2)).ljust(8 - len(str(stat[2]))) + "\t" + str(round(stat[3], 2)) + "\n" log.log(1000, "\nname" + log.log(1000, statPrint)
2014-02-19 16:32:24,128-|SVR-MAIN |-(Thread-3 )-Level 1000: name ncall ttot tsub 2014-02-19 16:32:24,128-|SVR-MAIN |-(Thread-3 )-Level 1000: C:\Python27\lib\sched.py.run:80 22 0.11 0.05 M:\02_documents\_repos\09_aheadRepos\apps\ahdModbusSrv\pyAheadRpcSrv\xmlRpc.py.iterFnc:293 22 0.11 0.0 M:\02_documents\_repos\09_aheadRepos\apps\ahdModbusSrv\serverMain.py.makeIteration:515 22 0.11 0.0 M:\02_documents\_repos\09_aheadRepos\apps\ahdModbusSrv\pyAheadRpcSrv\PicklingXMLRPC.py._dispatch:66 1 0.0 0.0 C:\Python27\lib\BaseHTTPServer.py.date_time_string:464 1 0.0 0.0 c:\users\zasiec~1\appdata\local\temp\easy_install-hwcsr1\psutil-1.1.2-py2.7-win32.egg.tmp\psutil\_psmswindows.py._get_raw_meminfo:243 4 0.0 0.0 C:\Python27\lib\SimpleXMLRPCServer.py.decode_request_content:537 1 0.0 0.0 c:\users\zasiec~1\appdata\local\temp\easy_install-hwcsr1\psutil-1.1.2-py2.7-win32.egg.tmp\psutil\_psmswindows.py.get_system_cpu_times:148 4 0.0 0.0 <string>.__new__:8 220 0.0 0.0 C:\Python27\lib\socket.py.close:276 4 0.0 0.0 C:\Python27\lib\threading.py.__init__:558 1 0.0 0.0 <string>.__new__:8 4 0.0 0.0 C:\Python27\lib\threading.py.notify:372 1 0.0 0.0 C:\Python27\lib\rfc822.py.getheader:285 4 0.0 0.0 C:\Python27\lib\BaseHTTPServer.py.handle_one_request:301 1 0.0 0.0 C:\Python27\lib\xmlrpclib.py.end:816 3 0.0 0.0 C:\Python27\lib\SimpleXMLRPCServer.py.do_POST:467 1 0.0 0.0 C:\Python27\lib\SimpleXMLRPCServer.py.is_rpc_path_valid:460 1 0.0 0.0 C:\Python27\lib\SocketServer.py.close_request:475 1 0.0 0.0 c:\users\zasiec~1\appdata\local\temp\easy_install-hwcsr1\psutil-1.1.2-py2.7-win32.egg.tmp\psutil\__init__.py.cpu_times:1066 4 0.0 0.0
import statprof with statprof.profile(): my_questionable_function()
import glob, os os.chdir("/mydir") for file in glob.glob("*.txt"): print(file)
import os for file in os.listdir("/mydir"): if file.endswith(".txt"): print(os.path.join("/mydir", file))
import os for root, dirs, files in os.walk("/mydir"): for file in files: if file.endswith(".txt"): print(os.path.join(root, file))
for root, dirs, files in os.walk(directory): for file in files: if file.endswith( print file
>>> import os >>> path = >>> text_files = [f for f in os.listdir(path) if f.endswith( >>> text_files [
import os path = files = os.listdir(path) files_txt = [i for i in files if i.endswith(
import os, os.path for root, dirs, files in os.walk(dir): for f in files: fullpath = os.path.join(root, f) if os.path.splitext(fullpath)[1] == print fullpath
import os, os.path fileiter = (os.path.join(root, f) for root, _, files in os.walk(dir) for f in files) txtfileiter = (f for f in fileiter if os.path.splitext(f)[1] == for txt in txtfileiter: print txt
import glob for f in glob.iglob("/mydir/*/*.txt"): print f
import fnmatch, os print fnmatch.filter(os.listdir("/mydir"), "*.tx?")
from path import path p = path( for f in p.files(pattern= print f
import os the_dir = all_txt_files = filter(lambda x: x.endswith(
import os import sys if len(sys.argv)==2: print( sys.exit(1) dir = sys.argv[1] mask= sys.argv[2] files = os.listdir(dir); res = filter(lambda x: x.endswith(mask), files); print res
import os fnames = ([file for root, dirs, files in os.walk(dir) for file in files if file.endswith( ]) for fname in fnames: print(fname)
import glob import os filenames_without_extension = [os.path.basename(c).split( filenames_with_extension = [os.path.basename(c) for c in glob.glob(
import fnmatch import os for file in os.listdir( if fnmatch.fnmatch(file, print file
import os import pathlib import timeit import glob def a(): path = pathlib.Path().cwd() list_sqlite_files = [str(f) for f in path.glob("*.sqlite")] def b(): path = os.getcwd() list_sqlite_files = [f.path for f in os.scandir(path) if os.path.splitext(f)[1] == ".sqlite"] def c(): path = os.getcwd() list_sqlite_files = [os.path.join(path, f) for f in os.listdir(path) if f.endswith(".sqlite")] def d(): path = os.getcwd() os.chdir(path) list_sqlite_files = [os.path.join(path, f) for f in glob.glob("*.sqlite")] def e(): path = os.getcwd() list_sqlite_files = [os.path.join(path, f) for f in glob.glob1(str(path), "*.sqlite")] def f(): path = os.getcwd() list_sqlite_files = [] for root, dirs, files in os.walk(path): for file in files: if file.endswith(".sqlite"): list_sqlite_files.append( os.path.join(root, file) ) break print(timeit.timeit(a, number=1000)) print(timeit.timeit(b, number=1000)) print(timeit.timeit(c, number=1000)) print(timeit.timeit(d, number=1000)) print(timeit.timeit(e, number=1000)) print(timeit.timeit(f, number=1000))
from os import listdir from os.path import isfile, join path = "/dataPath/" onlyTxtFiles = [f for f in listdir(path) if isfile(join(path, f)) and f.endswith(".txt")] print onlyTxtFiles
import glob,os data_dir = file_dir_extension = os.path.join(data_dir, for file_name in glob.glob(file_dir_extension): if file_name.endswith( print file_name
import fnmatch import os for file in os.listdir("/Users/Johnny/Desktop/MyTXTfolder"): if fnmatch.fnmatch(file.upper(), print(file)
import os def findFilesInFolder(path, pathList, extension, subFolders = True): """ Recursive function to find all files of an extension type in a folder (and optionally in all subfolders too) path: Base directory to find files pathList: A list that stores all paths extension: File extension to find subFolders: Bool. If True, find files in all subfolders under path. If False, only searches files in the specified folder """ try: for entry in os.scandir(path): if entry.is_file() and entry.path.endswith(extension): pathList.append(entry.path) elif entry.is_dir() and subFolders: pathList = findFilesInFolder(entry.path, pathList, extension, subFolders) except OSError: print( return pathList dir_name = r extension = ".txt" pathList = [] pathList = findFilesInFolder(dir_name, pathList, extension, True)
from fnmatch import filter from functools import partial from itertools import chain from os import path, walk print(*chain(*(map(partial(path.join, root), filter(filenames, "*.txt")) for root, _, filenames in walk("mydir"))))
def yield_files_with_extensions(folder_path, file_extension): for _, _, files in os.walk(folder_path): for file in files: if file.endswith(file_extension): yield file
import glob import os path=os.getcwd() extensions=( for i in extensions: for files in glob.glob(i): print files
import glob, os os.chdir("H:\\wallpaper") for file in glob.glob("**/*.psd", recursive = True): print(file)
import os fileNames = [fileName for fileName in os.listdir("data") if fileName.endswith(".txt")]
def get_all_filepaths(root_path, ext): """ Search all files which have a given extension within root_path. This ignores the case of the extension and searches subdirectories, too. Parameters ---------- root_path : str ext : str Returns ------- list of str Examples -------- >>> get_all_filepaths( [ """ import os all_files = [] for root, dirs, files in os.walk(root_path): for filename in files: if filename.lower().endswith(ext): all_files.append(os.path.join(root, filename)) return all_files
types = ( images_list = [] for files in types: images_list.extend(glob.glob(os.path.join(path, files)))
import glob import os os.chdir("D:\...\DirName") filename_arr={} i=0 for files in glob.glob("*.txt"): filename_arr[i] = files i= i+1 for key,value in filename_arr.items(): print key , value
import os path = r extension = for root, dirs_list, files_list in os.walk(path): for file_name in files_list: if os.path.splitext(file_name)[-1] == extension: file_name_path = os.path.join(root, file_name) print file_name print file_name_path
import os def files_in_dir(path, extension= for _, dirs, files in os.walk(path): dirs[:] = [] yield from [f for f in files if f.endswith(extension)] for filename in files_in_dir( print("-", filename)
path, ext = "./python", ext = ".py" for _, _, dirfiles in os.walk(path): matches = (f for f in dirfiles if f.endswith(ext)) break for filename in matches: print("-", filename)
import os dir = ["e","x","e"] p = os.listdir( for n in range(len(p)): name = p[n] myfile = [name[-3],name[-2],name[-1]] if myfile == dir : print(name) else: print("nops")
>>> bool("") False >>> bool(" ") True >>> bool(" ".strip()) False
def isBlank (myString): if myString and myString.strip(): return False return True
def isNotBlank (myString): if myString and myString.strip(): return True return False
def isBlank (myString): return not (myString and myString.strip()) def isNotBlank (myString): return bool(myString and myString.strip())
print isNotEmpty("") print isNotEmpty(" ") print isNotEmpty("ok") print isNotEmpty(None)
if my_string is elif my_string is None : print( else: print(f
if formfields.name == not_filled_in: raise ValueError("We need your name")
class weirdstr(str): def __new__(cls, content): return str.__new__(cls, content if content is not None else def __nonzero__(self): return bool(self.strip())
>>> normal = weirdstr( >>> print normal, bool(normal) word True >>> spaces = weirdstr( >>> print spaces, bool(spaces) False >>> blank = weirdstr( >>> print blank, bool(blank) False >>> none = weirdstr(None) >>> print none, bool(none) False >>> if not spaces: ... print ... This is a so-called blank string
var1 = not var1 > True var1 = False not var1 > True
var1 = False not var1 and var1 != > True var1 = not var1 and var1 != > False
if mystring and mystring.strip(): print "not blank string" else: print "blank string"
str = "" if not str: print "Empty String" if(len(str)==0): print "Empty String"
def empty(mystring): assert isinstance(mystring, str) if len(mystring) == 0: return True else: return False
lines = open("my_file.log", "r").readlines() for line in lines: if not line.strip(): continue
def isNoneOrEmptyOrBlankString (myString): if myString: if not myString.strip(): return True else: return False return False
from multiprocessing.dummy import Pool as ThreadPool pool = ThreadPool(4) results = pool.map(my_function, my_array)
results = [] for item in my_array: results.append(my_function(item))
import urllib2 from multiprocessing.dummy import Pool as ThreadPool urls = [ ] pool = ThreadPool(4) results = pool.map(urllib2.urlopen, urls) pool.close() pool.join()
Single thread: 14.4 seconds 4 Pool: 3.1 seconds 8 Pool: 1.4 seconds 13 Pool: 1.3 seconds
results = pool.starmap(function, zip(list_a, list_b))
results = pool.starmap(function, zip(itertools.repeat(constant), list_a))
import Queue import threading import urllib2 def get_url(q, url): q.put(urllib2.urlopen(url).read()) theurls = ["http: q = Queue.Queue() for u in theurls: t = threading.Thread(target=get_url, args = (q,u)) t.daemon = True t.start() s = q.get() print s
import threading class SummingThread(threading.Thread): def __init__(self,low,high): super(SummingThread, self).__init__() self.low=low self.high=high self.total=0 def run(self): for i in range(self.low,self.high): self.total+=i thread1 = SummingThread(0,500000) thread2 = SummingThread(500000,1000000) thread1.start() thread2.start() thread1.join() thread2.join() result = thread1.total + thread2.total print result
from multiprocessing import Process def f(name): print if __name__ == p = Process(target=f, args=( p.start() p.join()
import threading from random import randint from time import sleep def print_number(number): rand_int_var = randint(1, 10) sleep(rand_int_var) print "Thread " + str(number) + " slept for " + str(rand_int_var) + " seconds" thread_list = [] for i in range(1, 10): t = threading.Thread(target=print_number, args=(i,)) thread_list.append(t) for thread in thread_list: thread.start() for thread in thread_list: thread.join() print "Done"
import Queue import threading import urllib2 worker_data = [ q = Queue.Queue() for url in worker_data: q.put(url) def worker(queue): queue_full = True while queue_full: try: url= queue.get(False) data = urllib2.urlopen(url).read() print len(data) except Queue.Empty: queue_full = False thread_count = 5 for i in range(thread_count): t = threading.Thread(target=worker, args = (q,)) t.start()
import Queue import threading import multiprocessing import subprocess q = Queue.Queue() for i in range(30): q.put(i) def worker(): while True: item = q.get() subprocess.call("echo "+str(item), shell=True) q.task_done() cpus=multiprocessing.cpu_count() print("Creating %d threads" % cpus) for i in range(cpus): t = threading.Thread(target=worker) t.daemon = True t.start() q.join()
import threading threading.Thread(target=f).start()
import threading import time class Monitor(threading.Thread): def __init__(self, mon): threading.Thread.__init__(self) self.mon = mon def run(self): while True: if self.mon[0] == 2: print "Mon = 2" self.mon[0] = 3;
>>>from thread_test import Monitor >>>a = [0] >>>mon = Monitor(a) >>>mon.start() >>>a[0] = 2 Mon = 2 >>>a[0] = 2 Mon = 2
import concurrent.futures import urllib.request URLS = [ def load_url(url, timeout): with urllib.request.urlopen(url, timeout=timeout) as conn: return conn.read() with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor: future_to_url = {executor.submit(load_url, url, 60): url for url in URLS} for future in concurrent.futures.as_completed(future_to_url): url = future_to_url[future] try: data = future.result() except Exception as exc: print( else: print(
import concurrent.futures import math PRIMES = [ 112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099, 1099726899285419] def is_prime(n): if n % 2 == 0: return False sqrt_n = int(math.floor(math.sqrt(n))) for i in range(3, sqrt_n + 1, 2): if n % i == 0: return False return True def main(): with concurrent.futures.ProcessPoolExecutor() as executor: for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)): print( if __name__ == main()
def sqr(val): import time time.sleep(0.1) return val * val def process_result(result): print(result) def process_these_asap(tasks): import concurrent.futures with concurrent.futures.ProcessPoolExecutor() as executor: futures = [] for task in tasks: futures.append(executor.submit(sqr, task)) for future in concurrent.futures.as_completed(futures): process_result(future.result()) def main(): tasks = list(range(10)) print( process_these_asap(tasks) print( return 0 if __name__ == import sys sys.exit(main())
from concurrent.futures import ThreadPoolExecutor, as_completed def get_url(url): return "" urls = ["url1", "url2"] with ThreadPoolExecutor(max_workers = 5) as executor: futures = {executor.submit(get_url, url) for url in urls} for f in as_completed(futures): rs = f.result()
from threading import Thread from project import app import csv def import_handler(csv_file_name): thr = Thread(target=dump_async_csv_data, args=[csv_file_name]) thr.start() def dump_async_csv_data(csv_file_name): with app.app_context(): with open(csv_file_name) as File: reader = csv.DictReader(File) for row in reader:
import threading import time tLock = threading.BoundedSemaphore(value=4) def timer(name, delay, repeat): print "\r\nTimer: ", name, " Started" tLock.acquire() print "\r\n", name, " has the acquired the lock" while repeat > 0: time.sleep(delay) print "\r\n", name, ": ", str(time.ctime(time.time())) repeat -= 1 print "\r\n", name, " is releaseing the lock" tLock.release() print "\r\nTimer: ", name, " Completed" def Main(): t1 = threading.Thread(target=timer, args=("Timer1", 2, 5)) t2 = threading.Thread(target=timer, args=("Timer2", 3, 5)) t3 = threading.Thread(target=timer, args=("Timer3", 4, 5)) t4 = threading.Thread(target=timer, args=("Timer4", 5, 5)) t5 = threading.Thread(target=timer, args=("Timer5", 0.1, 5)) t1.start() t2.start() t3.start() t4.start() t5.start() print "\r\nMain Complete" if __name__ == "__main__": Main()
import math import timeit import threading import multiprocessing from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor def time_stuff(fn): def wrapper(*args, **kwargs): t0 = timeit.default_timer() fn(*args, **kwargs) t1 = timeit.default_timer() print("{} seconds".format(t1 - t0)) return wrapper def find_primes_in(nmin, nmax): primes = [] for current in range(nmin, nmax + 1): sqrt_n = int(math.sqrt(current)) found = False for number in range(2, sqrt_n + 1): if current % number == 0: found = True break if not found: primes.append(current) print(len(primes)) @time_stuff def sequential_prime_finder(nmin, nmax): find_primes_in(nmin, nmax) @time_stuff def threading_prime_finder(nmin, nmax): """ If the minimum is 1000 and the maximum is 2000 and we have 4 workers 1000 - 1250 to worker 1 1250 - 1500 to worker 2 1500 - 1750 to worker 3 1750 - 2000 to worker 4 so lets split the min and max values according to the number of workers """ nrange = nmax - nmin threads = [] for i in range(8): start = int(nmin + i * nrange/8) end = int(nmin + (i + 1) * nrange/8) t = threading.Thread(target = find_primes_in, args = (start, end)) threads.append(t) t.start() for t in threads: t.join() @time_stuff def processing_prime_finder(nmin, nmax): nrange = nmax - nmin processes = [] for i in range(8): start = int(nmin + i * nrange/8) end = int(nmin + (i + 1) * nrange/8) p = multiprocessing.Process(target = find_primes_in, args = (start, end)) processes.append(p) p.start() for p in processes: p.join() @time_stuff def thread_executor_prime_finder(nmin, nmax): nrange = nmax - nmin with ThreadPoolExecutor(max_workers = 8) as e: for i in range(8): start = int(nmin + i * nrange/8) end = int(nmin + (i + 1) * nrange/8) e.submit(find_primes_in, start, end) @time_stuff def process_executor_prime_finder(nmin, nmax): nrange = nmax - nmin with ProcessPoolExecutor(max_workers = 8) as e: for i in range(8): start = int(nmin + i * nrange/8) end = int(nmin + (i + 1) * nrange/8) e.submit(find_primes_in, start, end) def main(): nmin = int(1e7) nmax = int(1.05e7) print("Sequential Prime Finder Starting") sequential_prime_finder(nmin, nmax) print("Threading Prime Finder Starting") threading_prime_finder(nmin, nmax) print("Processing Prime Finder Starting") processing_prime_finder(nmin, nmax) print("Thread Executor Prime Finder Starting") thread_executor_prime_finder(nmin, nmax) print("Process Executor Finder Starting") process_executor_prime_finder(nmin, nmax) main()
Sequential Prime Finder Starting 9.708213827005238 seconds Threading Prime Finder Starting 9.81836523200036 seconds Processing Prime Finder Starting 3.2467174359990167 seconds Thread Executor Prime Finder Starting 10.228896902000997 seconds Process Executor Finder Starting 2.656402041000547 seconds
from os import fork values = [ for i in range(len(values)): p = fork() if p == 0: my_function(values[i]) break
import threading import requests def send(): r = requests.get( thread = [] t = threading.Thread(target=send()) thread.append(t) t.start()
I was trying to format a small JSON for some purposes, like this:
import json data = "1,2" mydict = {"all": "false", "selected": data} json.dumps(mydict)
def custom_format(string, brackets, *args, **kwargs): if len(brackets) != 2: raise ValueError( padded = string.replace( substituted = padded.replace(brackets[0], formatted = substituted.format(*args, **kwargs) return formatted >>> custom_format(
import types if type(a) is types.DictType: do_something() if type(b) in types.StringTypes: do_something_else()
if isinstance(a, dict): do_something() if isinstance(b, str) or isinstance(b, unicode): do_something_else()
if isinstance(x, basestring) return treatasscalar(x) try: return treatasiter(iter(x)) except TypeError: return treatasscalar(x)
isinstance(Vehicle(), Vehicle) type(Vehicle()) == Vehicle isinstance(Truck(), Vehicle) type(Truck()) == Vehicle
def function_of_duck(duck): duck.quack() duck.swim()
function_of_duck(object_that_quacks_and_swims_like_a_duck)
def foo(data): if type(data) is not dict: raise ValueError(
from collections import OrderedDict foo(OrderedDict([(
Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 3, in foo ValueError: argument must be a dict
def foo(a_dict): if not isinstance(a_dict, dict): raise ValueError( return a_dict foo(OrderedDict([(
from collections import Mapping def foo(a_dict): if not isinstance(a_dict, Mapping): raise ValueError( return a_dict
if isinstance(b, (str, unicode)): do_something_else()
class b(): pass import sys sys.path.append( from aaa.aa import b from aa import b as c d = b() print(b, c, d.__class__) for i in [b, c, object]: print(i, print(i, print(i, print(i, print(isinstance(d, b)) print(isinstance(d, c)) <class <class <class <class <class <class <class <class <class <class <class <class <class True False
type(INSTANCE) ~= INSTANCE.__class__ type(CLASS) ~= CLASS.__class__
return any(c in cls.__mro__ or c in cls.__subclasses__ or cls.__subclasshook__(c) for c in {INSTANCE.__class__, type(INSTANCE)})
import MySQLdb db = MySQLdb.connect(host="localhost", user="john", passwd="megajonhy", db="jonhydb") cur = db.cursor() cur.execute("SELECT * FROM YOUR_TABLE_NAME") for row in cur.fetchall(): print row[0] db.close()
import peewee from peewee import * db = MySQLDatabase( class Book(peewee.Model): author = peewee.CharField() title = peewee.TextField() class Meta: database = db Book.create_table() book = Book(author="me", title= book.save() for book in Book.filter(author="me"): print book.title
from random import randrange, uniform irand = randrange(0, 10) frand = uniform(0, 10)
from random import randint x = [randint(0, 9) for p in range(0, 10)]
>>> import random >>> nums = [x for x in range(10)] >>> random.shuffle(nums) >>> nums [6, 3, 5, 4, 0, 1, 2, 9, 8, 7]
import numpy as np np.random.randint(10, size=(1, 20))
array([[1, 6, 1, 2, 8, 6, 3, 3, 2, 5, 6, 5, 0, 9, 5, 6, 4, 5, 9, 3]])
>>> import random >>> values = list(range(10)) >>> random.choice(values) 5
>>> values = [1, 2, 3, 5, 7, 10] >>> random.choice(values) 7
>>> import secrets >>> values = list(range(10)) >>> secrets.choice(values) 2
import random N = 5 [random.randint(0, 9) for _ in range(N)] [random.choice(range(10)) for _ in range(N)]
>>> import random >>> random.randrange(10) 3 >>> random.randrange(10) 1
>>> [random.randrange(10) for x in range(10)] [9, 0, 4, 0, 5, 7, 4, 3, 6, 8]
import random n = 1 num = random.sample(range(10), n) num[0]
import numpy X = numpy.random.randint(0, 10, size=10) print(X)
n={} for i in range(10): n[i]=i for p in range(10): print(n.popitem()[1])
from random import randint numberStartRange = 1 numberEndRange = 9 randomNumber = randint(numberStartRange, numberEndRange) print(randomNumber)
import numpy as np print ( np.random.uniform(low=0, high=10, size=(15,)) ).astype(int) >>> [8 3 6 9 1 0 3 6 3 3 1 2 4 0 4]
>>> import string >>> string.digits >>> import random >>> random.SystemRandom().choice(string.digits) >>> random.SystemRandom().choice(string.digits) >>> random.SystemRandom().choice(string.digits) >>> random.SystemRandom().choice(string.digits)
import numpy as np X = np.random.randint(0, 99, size=1000)
str_Key = "" str_RandomKey = "" for int_I in range(128): str_Key = random.choice( str_RandomKey = str_RandomKey + str_Key
" Hello " --> "Hello" " Hello" --> "Hello" "Hello " --> "Hello" "Bob has a cat" --> "Bob has a cat"
def strip_one_space(s): if s.endswith(" "): s = s[:-1] if s.startswith(" "): s = s[1:] return s >>> strip_one_space(" Hello ")
myphrases = [ " Hello ", " Hello", "Hello ", "Bob has a cat" ] for phrase in myphrases: print phrase.strip()
string = "Name : David Account: 1234 Another thing: something " ready = False while ready == False: pos = string.find(" ") if pos != -1: string = string.replace(" "," ") else: ready = True print(string)
>>> class MyError(Exception): ... def __init__(self, message): ... self.message = message ... >>> MyError("foo") _sandbox.py:3: DeprecationWarning: BaseException.message has been deprecated as of Python 2.6
class ValidationError(Exception): def __init__(self, message, errors): super(ValidationError, self).__init__(message) self.errors = errors
class ValidationError(Exception): def __init__(self, message, errors): super().__init__(message) self.errors = errors
class MyException(Exception): pass raise MyException("My hovercraft is full of eels")
raise MyException({"message":"My hovercraft is full of animals", "animal":"eels"})
try: raise MyException({"message":"My hovercraft is full of animals", "animal":"eels"}) except MyException as e: details = e.args[0] print(details["animal"])
class MyError(Exception): def __init__(self, message, animal): self.message = message self.animal = animal def __str__(self): return self.message
class MyAppValueError(ValueError): def __init__(self, message, foo, *args): self.message = message self.foo = foo super(MyAppValueError, self).__init__(message, foo, *args)
class ValidationError(Exception): def __init__(self, message, errors): super(ValidationError, self).__init__(message) self.errors = errors
>>> ValidationError( Traceback (most recent call last): File "<pyshell ValidationError( TypeError: __init__() takes exactly 3 arguments (4 given) >>> ValidationError( __main__:1: DeprecationWarning: BaseException.message has been deprecated as of Python 2.6
>>> raise Exception( Exception: bad thing happened >>> raise Exception( Exception: (
>>> nastyerr = NastyError( >>> raise nastyerr NastyError: bad thing happened >>> raise nastyerr() NastyError: bad thing happened >>> raise nastyerr( NastyError: (
class ExceptionTemplate(Exception): def __call__(self, *args): return self.__class__(*(self.args + args)) class NastyError(ExceptionTemplate): pass
>>> raise nastyerr( NastyError: bad thing happened: code is broken
class CustomExceptionName(Exception): def __init__(self, message, payload=None): self.message = message self.payload = payload def __str__(self): return str(self.message)
try: raise CustomExceptionName("Very bad mistake.", "Forgot upgrading from Python 1") except CustomExceptionName as error: print(str(error)) print("Detail: {}".format(self.payload))
class InvalidInputError(Exception): def __init__(self, msg): self.msg = msg def __str__(self): return repr(self.msg) inp = int(input("Enter a number between 1 to 10:")) try: if type(inp) != int or inp not in list(range(1,11)): raise InvalidInputError except InvalidInputError: print("Invalid input entered")
mypy script.py script.py:12: error: Argument 1 to "foo" has incompatible type "str"; expected "int"
class Bomb: def __init__(self): "" def talk(self): self.explode() def explode(self): print "BOOM!, The bomb explodes." class Duck: def __init__(self): "" def talk(self): print "I am a duck, I will not blow up if you ask me to talk." class Kid: kids_duck = None def __init__(self): print "Kid comes around a corner and asks you for money so he could buy a duck." def takeDuck(self, duck): self.kids_duck = duck print "The kid accepts the duck, and happily skips along" def doYourThing(self): print "The kid tries to get the duck to talk" self.kids_duck.talk() myKid = Kid() myBomb = Bomb() myKid.takeDuck(myBomb) myKid.doYourThing()
try: my_sequence.extend(o) except TypeError: my_sequence.append(o)
def chr_type(chrx): if chrx.isalpha()==True: return elif chrx.isdigit()==True: return else: return chr_type("12)
import pandas as pd inp = [{ df = pd.DataFrame(inp) print df
for index, row in df.iterrows(): print(row[ Output: 10 100 11 110 12 120
for index, row in df.iterrows(): print row["c1"], row["c2"]
for row in df.itertuples(index=True, name= print getattr(row, "c1"), getattr(row, "c2")
df = pd.DataFrame({ %timeit [row.a * 2 for idx, row in df.iterrows()] %timeit [row[1] * 2 for row in df.itertuples()]
def valuation_formula(x, y): return x * y * 0.5 df[
for i, row in df.iterrows(): for j, column in row.iteritems(): print(column)
for row in df.itertuples(): print "c1 :",row.c1,"c2 :",row.c2
from collections import namedtuple def myiter(d, cols=None): if cols is None: v = d.values.tolist() cols = d.columns.values.tolist() else: j = [d.columns.get_loc(c) for c in cols] v = d.values[:, j].tolist() n = namedtuple( for line in iter(v): yield n(*line)
list(myiter(df)) [MyTuple(c1=10, c2=100), MyTuple(c1=11, c2=110), MyTuple(c1=12, c2=120)]
list(df.itertuples(index=False)) [Pandas(c1=10, c2=100), Pandas(c1=11, c2=110), Pandas(c1=12, c2=120)]
def iterfullA(d): return list(myiter(d)) def iterfullB(d): return list(d.itertuples(index=False)) def itersubA(d): return list(myiter(d, [ def itersubB(d): return list(d[[ res = pd.DataFrame( index=[10, 30, 100, 300, 1000, 3000, 10000, 30000], columns= dtype=float ) for i in res.index: d = pd.DataFrame(np.random.randint(10, size=(i, 10))).add_prefix( for j in res.columns: stmt = setp = res.at[i, j] = timeit(stmt, setp, number=100) res.groupby(res.columns.str[4:-1], axis=1).plot(loglog=True);
for x in range(len(date_example.index)): print date_example[
for row in df.itertuples(index=False, name= print np.asarray(row)
df = pd.DataFrame({ for row_dict in df.to_dict(orient= print(row_dict)
import pandas as pd import numpy as np df_existing = pd.DataFrame(np.random.randint(0,100,size=(100, 4)), columns=list( for idx,row in df_existing.iterrows(): print row[
np.asarray(all) imgs[:] = cv2.resize(imgs[:], (224,224) )
def removekey(d, key): r = dict(d) del r[key] return r
>>>lol = {"hello":"gdbye"} >>>lol.pop("hello") >>> lol {}
>>> foo = { >>> fu = dict(foo) >>> del foo[ >>> print foo {} >>> print fu {
def minus_key(key, dictionary): shallow_copy = dict(dictionary) del shallow_copy[key] return shallow_copy
key_to_remove = "c" d = {"a": 1, "b": 2} del d[key_to_remove]
key_to_remove = "c" d = {"a": 1, "b": 2} d.pop(key_to_remove)
key_to_remove = "c" d = {"a": 1, "b": 2} try: del d[key_to_remove] except KeyError as ex: print("No such key:
key_to_remove = "c" d = {"a": 1, "b": 2} try: d.pop(key_to_remove) except KeyError as ex: print("No such key:
key_to_remove = "c" d = {"a": 1, "b": 2} if key_to_remove in d: del d[key_to_remove]
key_to_remove = "c" d = {"a": 1, "b": 2} if key_to_remove in d: d.pop(key_to_remove)
key_to_remove = "c" d = {"a": 1, "b": 2} d.pop(key_to_remove, None)
def get_dict_wo_key(dictionary, key): _dict = dictionary.copy() _dict.pop(key, None) return _dict d = {"a": [1, 2, 3], "b": 2, "c": 3} key_to_remove = "c" new_d = get_dict_wo_key(d, key_to_remove) print(d) print(new_d) new_d["a"].append(100) print(d) print(new_d) new_d["b"] = 2222 print(d) print(new_d)
from copy import deepcopy def get_dict_wo_key(dictionary, key): _dict = deepcopy(dictionary) _dict.pop(key, None) return _dict d = {"a": [1, 2, 3], "b": 2, "c": 3} key_to_remove = "c" new_d = get_dict_wo_key(d, key_to_remove) print(d) print(new_d) new_d["a"].append(100) print(d) print(new_d) new_d["b"] = 2222 print(d) print(new_d)
>>> from pyrsistent import m >>> d1 = m(a=1, b=2) >>> d2 = d1.set( >>> d3 = d1.remove( >>> d1 pmap({ >>> d2 pmap({ >>> d3 pmap({
def dictMinus(dct, val): copy = dct.copy() del copy[val] return copy
>>> def delete_key(dict, key): ... del dict[key] ... return dict ... >>> test_dict = { >>> print delete_key(test_dict, { >>>
def eraseElement(d,k): if isinstance(d, dict): if k in d: d.pop(k) print(d) else: print("Cannot find matching key") else: print("Not able to delete") exp = { eraseElement(exp,
def execute(): dic = { dic2 = remove_key_from_dict(dic, print(dict2) print(dict) def remove_key_from_dict(dictionary_to_use, key_to_delete): copy_of_dict = dict(dictionary_to_use) if key_to_delete in copy_of_dict : del copy_of_dict [key_to_delete] return copy_of_dict
res = d.pop("c", "key not found") print (res) print (d) res = d.pop("b", "key not found") print (res) print (d)
original_d = { d = dict((k,v) for k, v in original_d.iteritems() if v)
>>> import os >>> filename, file_extension = os.path.splitext( >>> filename >>> file_extension
import os.path extension = os.path.splitext(filename)[1]
import os.path extension = os.path.splitext(filename)[1][1:]
>>> filename = "example.jpeg" >>> filename.split(".")[-1]
import os.path extension = os.path.splitext(filename)[1][1:].strip()
>>> fileName, fileExtension = os.path.splitext( >>> fileExtension
import os fn = basename = os.path.basename(fn) Out[] a.tar.gz base = basename.split( Out[] a ext = ext = Out[] .tar.gz
def get_extension(filename): basename = os.path.basename(filename) ext = return
import pathlib x = pathlib.PurePosixPath("C:\\Path\\To\\File\\myfile.txt").suffix print(x)
f_extns = filename.split(".") print ("The extension of the file is : " + repr(f_extns[-1]))
s = if def split_filepath(s): """ get filename and extension from filepath filepath -> (filename, extension) """ if not r = s.rsplit( return (r[0], r[1])
string = "folder/to_path/filename.ext" extension = string.rpartition(".")[-1]
>>> import re >>> file_suffix = ".*(\..*)" >>> result = re.search(file_suffix, "somefile.ext") >>> result.group(1)
def NewFileName(fichier): cpt = 0 fic , *ext = fichier.split( ext = while os.path.isfile(fichier): cpt += 1 fichier = return fichier
import os.path class LinkChecker: @staticmethod def get_link_extension(link: str)->str: if link is None or link == "": return "" else: paths = os.path.splitext(link) ext = paths[1] new_link = paths[0] if ext != "": return LinkChecker.get_link_extension(new_link) + ext else: return ""
from __future__ import print_function import sys if sys.version_info[:2] < (3, 3): old_print = print def print(*args, **kwargs): flush = kwargs.pop( old_print(*args, **kwargs) if flush: file = kwargs.get( file.flush() if file is not None else sys.stdout.flush()
import functools print = functools.partial(print, flush=True)
>>> print = functools.partial(print, flush=True) >>> print functools.partial(<built-in function print>, flush=True)
def foo(): printf = functools.partial(print, flush=True) printf(
>>> from __future__ import print_function >>> help(print) print(...) print(value, ..., sep= Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline.
class flushfile(object): def __init__(self, f): self.f = f def write(self, x): self.f.write(x) self.f.flush() import sys sys.stdout = flushfile(sys.stdout)
class flushfile(file): def __init__(self, f): self.f = f def write(self, x): self.f.write(x) self.f.flush() import sys sys.stdout = flushfile(sys.stdout) print "foo"
Traceback (most recent call last): File "./passpersist.py", line 12, in <module> print "foo" ValueError: I/O operation on closed file
class FlushFile(object): def __init__(self, fd): self.fd = fd def write(self, x): ret = self.fd.write(x) self.fd.flush() return ret def writelines(self, lines): ret = self.writelines(lines) self.fd.flush() return ret def flush(self): return self.fd.flush def close(self): return self.fd.close() def fileno(self): return self.fd.fileno()
import io,sys class flushfile: def __init__(self, f): self.f = f def write(self, x): self.f.write(x) self.f.flush() sys.stdout = flushfile(sys.stdout)
def print(*objects, sep= __builtins__.print(*objects, sep=sep, end=end, file=file, flush=flush)
message = lambda x: print(x, flush=True, end="") message(
class Person(object): def __init__(self, name, age): self.name = name self.age = age def __eq__(self, other): return self.name == other.name and self.age == other.age jack1 = Person( jack2 = Person( jack1 == jack2 jack1 is jack2
>>> a = 1 >>> b = 1 >>> b is a True >>> a = 6000 >>> b = 6000 >>> b is a False
>>> s1 = u >>> s2 = >>> s1 is s2 False >>> s1 == s2 True
>>> s = >>> s2 = >>> s is s2 False >>> s2 = s2.replace( >>> s2 >>> s2 is s False >>>
>>> a = [1, 2, 3] >>> b = [1, 2, 3] >>> a is b False
>>> nan = float( >>> nan is nan True >>> nan == nan False
>>> whitespaces = " abcd ef gh ijkl " >>> tabs = " abcde fgh ijkl" >>> print whitespaces.replace(" ", "") abcdefghijkl >>> print tabs.replace(" ", "") abcdefghijkl
s= s1=s.splitlines() print s1 [ print [i.strip() for i in s1] [ for line in s.splitlines(): line=line.strip() process(line) for line in my_file: line=line.strip() process(line) s2=s.splitlines(True) print s2 [
>>> import re >>> p=re.compile( >>> m=p.match( >>> m.group(1) >>> m=p.match( >>> m.group(1) >>> m=p.match( >>> print m.group(1) None
>>> p1=re.compile( >>> m=p1.search( >>> m.group() >>> m=p1.search( >>> m.group() >>> m=p1.search( >>> m.group() Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError:
something = "\t please_ \t remove_ all_ \n\n\n\nwhitespaces\n\t " something = "".join(something.split())
>>> import string >>> print hello world >>> tr = string.maketrans(string.whitespace, >>> >>>
>>> myStr = "Hi\n Stack Over \r flow!" >>> charList = [u"\u005Cn",u"\u005Cr",u"\u005Ct"] >>> import re >>> for i in charList: myStr = re.sub(i, r"", myStr) >>> myStr
>>> s = " \n\t \n some \n text \n " >>> re.sub("^\s+|\s+$", "", s) >>> "some \n text"
class myClass: def myFunc(self, name): self.name = name
class Vector: def __init__(self, x, y): self.x = x self.y = y
def length(self): return math.sqrt(self.x ** 2 + self.y ** 2)
def length_global(vector): return math.sqrt(vector.x ** 2 + vector.y ** 2)
Vector.length_new = length_global v = Vector(3, 4) print(v.length_new())
class A: foo = [] a, b = A(), A() a.foo.append(5) b.foo ans: [5] class A: def __init__(self): self.foo = [] a, b = A(), A() a.foo.append(5) b.foo ans: []
def state_init(state): state[ def state_add(state, x): state[ def state_mult(state, x): state[ def state_getField(state): return state[ myself = {} state_init(myself) state_add(myself, state_mult(myself, 2) print( state_getField(myself) )
class State(object): def __init__(self): self.field = def add(self, x): self.field += x def mult(self, x): self.field *= x s = State() s.add( s.mult(2) print( s.field )
class C1(object): def __init__(self): print "C1 init" class C2(C1): def __init__(self): print "C2 init" C1.__init__(self)
class Animal(): def staticMethod(): print "This is a static method"
class Animal(): def objectMethod(self): print "This is an object method which needs an instance of a class"
class Animal(): def Animal(self): self.animalName = ""; def getAnimalName(self): return self.animalName
class Student: def __init__(self,name,age): self.name=name self.age=age def __str__(self): return "Student %s is %s years old" %(self.name,self.age) def call(self, msg): return ("Hey, %s! "+msg) %self.name bob=Student("Bob",20) alice=Student("Alice",19) print bob.name print bob.age print alice print alice.call("Come here!") alice.age=20 print alice
class Restaurant(object): bankrupt = False def open_branch(self): if not self.bankrupt: print("branch opened") >>> x = Restaurant() >>> x.bankrupt False >>> y = Restaurant() >>> y.bankrupt = True >>> y.bankrupt True >>> x.bankrupt False
def fubar(self, x) self.x = x class C: frob = fubar
class MyClass(): def staticMethod(): print "This is a static method" def objectMethod(self): print "This is an object method which needs an instance of a class, and that is what self refers to"
>>> print(sys.version) 2.5.2 (r252:60911, Jul 31 2008, 17:28:52) [GCC 4.2.3 (Ubuntu 4.2.3-2ubuntu7)]
>>> sys.version_info (2, 5, 2, >>> sys.hexversion 34014192
>>> import sys >>> sys.hexversion 33883376 >>> >>> sys.hexversion < 0x02060000 True
>>> import sys >>> sys.version_info (2, 6, 4, >>> if not sys.version_info[:2] == (2, 6): ... print "Error, I need python 2.6" ... else: ... from my_module import twoPointSixCode >>>
>>> try: ... from my_module import twoPointSixCode ... except Exception: ... print "can >>>
>>> from platform import python_version >>> print(python_version()) 2.7.8
import sys if sys.version_info<(2,6,0): sys.stderr.write("You need python 2.6 or later to run this script\n") exit(1)
python -c "print(__import__( python -c "print(__import__( python -c "print(__import__(
desktop:~$ python Python 2.7.6 (default, Jun 22 2015, 18:00:18) [GCC 4.8.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>>
import sys assert(sys.version_info >= (2,6)) import platform from distutils.version import StrictVersion assert(StrictVersion(platform.python_version()) >= "2.6")
via_platform = 0 check_sys = 0 via_sys_version_info = 0 via_sys_version = 0 test_sys = 0 try: import platform except (ImportError, NameError): check_sys = 1 if not check_sys: if hasattr(platform, "python_version"): via_platform = 1 else: check_sys = 1 if check_sys: try: import sys test_sys = 1 except (ImportError, NameError): pass if test_sys: if hasattr(sys, "version_info"): via_sys_version_info = 1 elif hasattr(sys, "version"): via_sys_version = 1 else: pass if via_platform: print(platform.python_version()) elif via_sys_version_info: print("%s.%s.%s" % sys.version_info[:3]) elif via_sys_version: import string verbose_version = sys.version version_list = string.split(verbose_version) print(version_list[0]) else: print("unknown")
import sys ver = sys.version_info if ver.major > 2: if ver.major == 3 and ver.minor <= 4: print( exit(1)
is_python_3_or_above = (lambda x: [x for x in [False]] and None or x)(True)
>>> foo is None True >>> foo = >>> foo is None False
>>> NoneType NameError: name >>> type(None) NoneType
>>> NoneType = type(None) >>> id(None) 10748000 >>> my_none = NoneType() >>> id(my_none) 10748000 >>> another_none = NoneType() >>> id(another_none) 10748000 >>> def function_that_does_nothing(): pass >>> return_value = function_that_does_nothing() >>> id(return_value) 10748000
>>> class SomeClass(object): ... def my_fnc(self): ... self.None = SyntaxError: cannot assign to None >>> def my_fnc(): None = SyntaxError: cannot assign to None >>> class SomeClass: ... def my_fnc(self): ... self.None = SyntaxError: invalid syntax >>> def my_fnc(): None = SyntaxError: cannot assign to keyword
>>> nothing = function_that_does_nothing() >>> nothing.__eq__(None) True
>>> class Empty(object): ... def __eq__(self, other): ... return not other
>>> bool(None) False >>> not None True >>> bool([]) False >>> not [] True >>> class MyFalsey(object): ... def __bool__(self): ... return False >>> f = MyFalsey() >>> bool(f) False >>> not f True
def some_function(value=None): if not value: value = init_value()
def my_function(value, param=None): if param is None:
>>> some_dict = {} >>> value = some_dict.get( >>> value is None True
try: value = some_obj.some_attribute if value is None: except AttributeError: value = None log_something(some_obj)
try: value = some_dict[ if value is None: except KeyError: value = None log_something(some_dict)
def my_function(**kwargs): try: value = kwargs[ if value is None: except KeyError: value = None log_something(
def my_function(value, param1=undefined, param2=undefined): if param1 is undefined: log_something( param1 = None if param2 is undefined: log_something( param2 = None
value = some_dict.get( if value is None: log_something(" if value is undefined: log_something(" value = None
value = getattr(obj, if value is None: log_something(" if value is undefined: log_something("no value = None
if yourObject is None: ... if yourString == "": ...
def parse_token(token): """ This function parses a token. TODO: write a decent docstring :-) """ if token == do_something() elif token == do_something_else() elif token == Note that we still need to provide support for the deprecated token \xor. Hopefully we can drop support in libfoo 2.0. do_a_different_thing() else: raise ValueError
class weather2(): """ def getStatus_code(self, url): world.url = url result = requests.get(url) return result.status_code """
""" print("What myName = input() print("It print("Number of characters is ") print(len(myName)) age = input("What print("You will be " + str(int(age)+1) + " next year.") """ a = input() print(a) print(a*5)
def foo(): "This is a doc string." """ print "This is a sample foo function" print "This function has no arguments" """ return True
hello = "Hello" world = "World" print(hello) print(world)
def say_hello(name): return "Hello " + name + print(say_hello("John"))
import tkinter as tk root = tk.Tk() w = tk.Label( text="Hello Tkinter") logo = tk.PhotoImage(file="Python.PNG") w1 = tk.Label(root, image=logo).pack(side="right") explanation = w2 = tk.Label(root, justify=tk.LEFT,padx = 0, text=explanation).pack(side="left") root.mainloop()
s = ("this is a very" "long string too" "for sure ..." )
longStr = "This is a very long string " \ "that I wrote to help somebody " \ "who had a question about " \ "writing long strings in Python"
query = ( "SELECT foo" "FROM bar" "WHERE baz" ) query == "SELECT fooFROM barWHERE baz"
body = """ <html> <head> </head> <body> <p>Lorem ipsum.</p> <dl> <dt>Asdf:</dt> <dd><a href="{link}">{name}</a></dd> </dl> </body> </html> """.format( link= name= ) print(body)
query= f role.id as role_id, role.descr as role FROM public.role_action_def, public.role, public.record_def, public.action WHERE role.id = role_action_def.role_id AND record_def.id = role_action_def.def_id AND action.id = role_action_def.action_id AND role_action_def.account_id = {account_id} AND record_def.account_id = {account_id} AND def_id = {def_id}
sql = ("select field1, field2, field3, field4 " "from table " "where condition1={} " "and condition2={}").format(1, 2) Output: where condition1=1 and condition2=2'
sql = ("select field1, field2, field3, field4 " "from table " "where condition1= "and condition2= Output: "select field1, field2, field3, field4 from table where condition1=
import textwrap query = textwrap.dedent(f SELECT action.descr as "action", role.id as role_id, role.descr as role FROM public.role_action_def, public.role, public.record_def, public.action WHERE role.id = role_action_def.role_id AND record_def.id = role_action_def.def_id AND action.id = role_action_def.action_id AND role_action_def.account_id = {account_id} AND record_def.account_id={account_id} AND def_id={def_id} )
query = SELECT action.descr as action, role.id as role_id, role.descr as role FROM public.role_action_def, public.role, public.record_def, public.action WHERE role.id = role_action_def.role_id AND record_def.id = role_action_def.def_id AND action.id = role_action_def.action_id AND role_action_def.account_id = ? AND record_def.account_id = ? AND def_id = ? vars = (account_id, account_id, def_id) cursor.execute(query, vars)
def create_snippet(): code_snippet = textwrap.dedent("""\ int main(int argc, char* argv[]) { return 0; } """) do_something(code_snippet)
text = This string was typed to be a demo on how could we write a multi-line text in Python.
def resolveSQL(sql_seed, sqlparams): sql = sql_seed % (sqlparams) if sql == sql_seed: return else: return resolveSQL(sql, sqlparams)
def some_method(): long_string = .strip( return long_string
class ClassName(): def method_name(): if condition_0: if condition_1: if condition_2: some_variable_0 =\ """ some_js_func_call( undefined, { }, undefined, undefined, true ) """
lines = list() lines.append( lines.append( lines.append( lines.append( lines.append( lines.append( lines.append( lines.append( query = " ".join(lines)
a = tuple(range(1000)) b = list(range(1000)) a.__sizeof__() b.__sizeof__()
a = (1,2) b = [1,2] id(a) id(b) a += (3,) b += [3] id(a) id(b)
>>> import numpy as np >>> a = np.arange(9).reshape(3,3) >>> a array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) >>> idx = (1,1) >>> a[idx] 4 >>> idx = [1,1] >>> a[idx] array([[3, 4, 5], [3, 4, 5]])
my_list = [0,1,2,3,4] top_rock_list = ["Bohemian Rhapsody","Kashmir","Sweet Emotion", "Fortunate Son"]
my_tuple = (a,b,c,d,e) celebrity_tuple = ("John", "Wayne", 90210, "Actor", "Male", "Dead")
>>> [0,2,0,0,0,0]>[0,0,0,0,0,500] True >>> (0,2,0,0,0,0)>(0,0,0,0,0,500) True
>>> top_rock_list [ >>> top_rock_list[1] >>> top_rock_list[1] = "Stairway to Heaven" >>> top_rock_list [ >>> celebrity_tuple ( >>> celebrity_tuple[5] >>> celebrity_tuple[5]="Alive" Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError:
>>> my_dict = {[a,b,c]:"some value"} Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unhashable type: >>> my_dict = {("John","Wayne"): 90210} >>> my_dict {(
tup = (1,2) list_ = [1,2] c = {tup : 1} c = {list_ : 1}
a = ["1", "2", "ra", "sa"] b = ("1", "2", "ra", "sa")
In [1]: df = DataFrame([[1, 2, 3], [4, 5, 6]]) In [2]: df[1] Out[2]: 0 2 1 5 Name: 1 In [3]: df.1 File "<ipython-input-3-e4803c0d1066>", line 1 df.1 ^ SyntaxError: invalid syntax
df.reindex_axis(np.setdiff1d(df.columns.values, dlst), 1)
df A B C D E F G H I J 0 1 2 3 4 5 6 7 8 9 10 1 1 2 3 4 5 6 7 8 9 10 2 1 2 3 4 5 6 7 8 9 10
df.drop(dlst, 1, errors= A B C D E F G 0 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 2 1 2 3 4 5 6 7
cols = [x for x in df.columns.values.tolist() if x not in dlst]
A B C D E F G 0 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 2 1 2 3 4 5 6 7
bools = [x not in dlst for x in df.columns.values.tolist()]
A B C D E F G 0 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 2 1 2 3 4 5 6 7
setdiff1d = lambda df, dlst: np.setdiff1d(df.columns.values, dlst) difference = lambda df, dlst: df.columns.difference(dlst) columndrop = lambda df, dlst: df.columns.drop(dlst, errors= setdifflst = lambda df, dlst: list(set(df.columns.values.tolist()).difference(dlst)) comprehension = lambda df, dlst: [x for x in df.columns.values.tolist() if x not in dlst] loc = lambda df, cols: df.loc[:, cols] slc = lambda df, cols: df[cols] ridx = lambda df, cols: df.reindex(columns=cols) ridxa = lambda df, cols: df.reindex_axis(cols, 1) isin = lambda df, dlst: ~df.columns.isin(dlst) in1d = lambda df, dlst: ~np.in1d(df.columns.values, dlst) comp = lambda df, dlst: [x not in dlst for x in df.columns.values.tolist()] brod = lambda df, dlst: (df.columns.values[:, None] != dlst).all(1)
res1 = pd.DataFrame( index=pd.MultiIndex.from_product([ ], names=[ columns=[10, 30, 100, 300, 1000], dtype=float ) res2 = pd.DataFrame( index=pd.MultiIndex.from_product([ ], names=[ columns=[10, 30, 100, 300, 1000], dtype=float ) res = res1.append(res2).sort_index() dres = pd.Series(index=res.columns, name= for j in res.columns: dlst = list(range(j)) cols = list(range(j d = pd.DataFrame(1, range(10), cols) dres.at[j] = timeit( for s, l in res.index: stmt = setp = res.at[(s, l), j] = timeit(stmt, setp, number=100) rs = res / dres
rs 10 30 100 300 1000 Select Label loc brod 0.747373 0.861979 0.891144 1.284235 3.872157 columndrop 1.193983 1.292843 1.396841 1.484429 1.335733 comp 0.802036 0.732326 1.149397 3.473283 25.565922 comprehension 1.463503 1.568395 1.866441 4.421639 26.552276 difference 1.413010 1.460863 1.587594 1.568571 1.569735 in1d 0.818502 0.844374 0.994093 1.042360 1.076255 isin 1.008874 0.879706 1.021712 1.001119 0.964327 setdiff1d 1.352828 1.274061 1.483380 1.459986 1.466575 setdifflst 1.233332 1.444521 1.714199 1.797241 1.876425 ridx columndrop 0.903013 0.832814 0.949234 0.976366 0.982888 comprehension 0.777445 0.827151 1.108028 3.473164 25.528879 difference 1.086859 1.081396 1.293132 1.173044 1.237613 setdiff1d 0.946009 0.873169 0.900185 0.908194 1.036124 setdifflst 0.732964 0.823218 0.819748 0.990315 1.050910 ridxa columndrop 0.835254 0.774701 0.907105 0.908006 0.932754 comprehension 0.697749 0.762556 1.215225 3.510226 25.041832 difference 1.055099 1.010208 1.122005 1.119575 1.383065 setdiff1d 0.760716 0.725386 0.849949 0.879425 0.946460 setdifflst 0.710008 0.668108 0.778060 0.871766 0.939537 slc columndrop 1.268191 1.521264 2.646687 1.919423 1.981091 comprehension 0.856893 0.870365 1.290730 3.564219 26.208937 difference 1.470095 1.747211 2.886581 2.254690 2.050536 setdiff1d 1.098427 1.133476 1.466029 2.045965 3.123452 setdifflst 0.833700 0.846652 1.013061 1.110352 1.287831
fig, axes = plt.subplots(2, 2, figsize=(8, 6), sharey=True) for i, (n, g) in enumerate([(n, g.xs(n)) for n, g in rs.groupby( ax = axes[i g.plot.bar(ax=ax, title=n) ax.legend_.remove() fig.tight_layout()
rs.idxmin().pipe( lambda x: pd.DataFrame( dict(idx=x.values, val=rs.lookup(x.values, x.index)), x.index ) ) idx val 10 (ridx, setdifflst) 0.653431 30 (ridxa, setdifflst) 0.746143 100 (ridxa, setdifflst) 0.816207 300 (ridx, setdifflst) 0.780157 1000 (ridxa, setdifflst) 0.861622
$ cat try.py import SimpleHTTPServer $ 2to3 try.py RefactoringTool: Skipping implicit fixer: buffer RefactoringTool: Skipping implicit fixer: idioms RefactoringTool: Skipping implicit fixer: set_literal RefactoringTool: Skipping implicit fixer: ws_comma RefactoringTool: Refactored try.py --- try.py (original) +++ try.py (refactored) @@ -1 +1 @@ -import SimpleHTTPServer +import http.server RefactoringTool: Files that need to be modified: RefactoringTool: try.py
$ python -m $(python -c Serving HTTP on 0.0.0.0 port 8000 ...
$ alias serve="python -m $(python -c $ serve Serving HTTP on 0.0.0.0 port 8000 ...
class NewStyleClass(object): pass class AnotherNewStyleClass(NewStyleClass): pass
class C: i = 0 class C1(C): pass class C2(C): i = 2 class C12(C1, C2): pass class C21(C2, C1): pass assert C12().i == 0 assert C21().i == 2 try: C12.__mro__ except AttributeError: pass else: assert False
class C(object): i = 0 class C1(C): pass class C2(C): i = 2 class C12(C1, C2): pass class C21(C2, C1): pass assert C12().i == 2 assert C21().i == 2 assert C12.__mro__ == (C12, C1, C2, C, object) assert C21.__mro__ == (C21, C2, C1, C, object)
class Old: pass try: raise Old() except Old: pass else: assert False class New(object): pass try: raise New() except TypeError: pass else: assert False class New(Exception): pass try: raise New() except New: pass else: assert False try: raise except TypeError: pass else: assert False
class Person(): _names_cache = {} def __init__(self,name): self.name = name def __new__(cls,name): return cls._names_cache.setdefault(name,object.__new__(cls,name)) ahmed1 = Person("Ahmed") ahmed2 = Person("Ahmed") print ahmed1 is ahmed2 print ahmed1 print ahmed2 >>> False <__main__.Person instance at 0xb74acf8c> <__main__.Person instance at 0xb74ac6cc> >>>
class Person(object): _names_cache = {} def __init__(self,name): self.name = name def __new__(cls,name): return cls._names_cache.setdefault(name,object.__new__(cls,name)) ahmed1 = Person("Ahmed") ahmed2 = Person("Ahmed") print ahmed2 is ahmed1 print ahmed1 print ahmed2 >>> True <__main__.Person object at 0xb74ac66c> <__main__.Person object at 0xb74ac66c> >>>
def f(x): y0 = x + 1 y1 = x * 3 y2 = y0 ** y3 return (y0,y1,y2)
def g(x): y0 = x + 1 y1 = x * 3 y2 = y0 ** y3 return {
class ReturnValue(object): def __init__(self, y0, y1, y2): self.y0 = y0 self.y1 = y1 self.y2 = y2 def g(x): y0 = x + 1 y1 = x * 3 y2 = y0 ** y3 return ReturnValue(y0, y1, y2)
class ReturnValue(object): __slots__ = ["y0", "y1", "y2"] def __init__(self, y0, y1, y2): self.y0 = y0 self.y1 = y1 self.y2 = y2
def h(x): result = [x + 1] result.append(x * 3) result.append(y0 ** y3) return result
>>> import collections >>> Point = collections.namedtuple( >>> p = Point(1, y=2) >>> p.x, p.y 1 2 >>> p[0], p[1] 1 2
class Employee(NamedTuple): name: str id: int = 3 employee = Employee( assert employee.id == 3
def getImageData(filename): [snip] return size, (format, version, compression), (width,height) size, type, dimensions = getImageData(x)
def f(): return True, False x, y = f() print(x) print(y)
def g(x): y0 = x + 1 y1 = x * 3 y2 = y0 ** y3 return {
>>> def f(x): y0 = x + 1 yield y0 yield x * 3 yield y0 ** 4 >>> a, b, c = f(5) >>> a 6 >>> b 15 >>> c 1296
def g(x): y0 = x + 1 y1 = x * 3 y2 = y0 ** y3 return {
>>> def func(): ... return [1,2,3] ... >>> a,b,c = func() >>> a 1 >>> b 2 >>> c 3
for score,id,name in scoreAllTheThings(): if score > goodScoreThreshold: print "%6.3f
for entry in scoreAllTheThings(): if entry.score > goodScoreThreshold: print "%6.3f
for entry in scoreAllTheThings(): if entry[ print "%6.3f
class Some3SpaceThing(object): def __init__(self,x): self.g(x) def g(self,x): self.y0 = x + 1 self.y1 = x * 3 self.y2 = y0 ** y3 r = Some3SpaceThing( x ) r.y0 r.y1 r.y2
form = { } } def test(form): form[ form[ return form >>> print(test(form)) {u
>>> class ClassicSpam: ... pass >>> ClassicSpam.__bases__ ()
>>> class NewSpam(object): ... pass >>> NewSpam.__bases__ (<type >>> class IntSpam(int): ... pass >>> IntSpam.__bases__ (<type >>> IntSpam.__bases__[0].__bases__ (<type
>>> [object in cls.__bases__ for cls in {Spam, NewSpam, ClassicSpam}] [True, True, True]
try: some_object_iterator = iter(some_object) except TypeError as te: print some_object,
try: _ = (e for e in my_object) except TypeError: print my_object,
import collections if isinstance(e, collections.Iterable):
try: iterator = iter(theElement) except TypeError: else:
from collections.abc import Iterable if isinstance(theElement, Iterable): else:
try: iter(maybe_iterable) print( except TypeError: print(
import random class DemoIterable(object): def __iter__(self): print( return DemoIterator() class DemoIterator(object): def __iter__(self): return self def __next__(self): print( r = random.randint(1, 10) if r == 5: print( raise StopIteration return r
>>> di = DemoIterable() >>> for x in di: ... print(x) ... __iter__ called __next__ called 9 __next__ called 8 __next__ called 10 __next__ called 3 __next__ called 10 __next__ called raising StopIteration
class BasicIterable(object): def __getitem__(self, item): if item == 3: raise IndexError return item
>>> b = BasicIterable() >>> iter(b) <iterator object at 0x7f1ab216e320>
>>> from collections import Iterable, Sequence >>> hasattr(b, False >>> isinstance(b, Iterable) False >>> isinstance(b, Sequence) False
>>> b = BasicIterable() >>> it = iter(b) >>> next(it) 0 >>> next(it) 1 >>> next(it) 2 >>> next(it) Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration
class WrappedDict(object): def __init__(self, dic): self._dict = dic def __getitem__(self, item): try: return self._dict[item] except KeyError: raise IndexError
>>> w = WrappedDict({-1: ... 0: ... 4: ... >>> for x in w: ... print(x) ... hi StackOverflow !
class FailIterIterable(object): def __iter__(self): return object() class FailGetitemIterable(object): def __getitem__(self, item): raise Exception
>>> fii = FailIterIterable() >>> iter(fii) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: iter() returned non-iterator of type >>> >>> fgi = FailGetitemIterable() >>> it = iter(fgi) >>> next(it) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "/path/iterdemo.py", line 42, in __getitem__ raise Exception Exception
class IterWinsDemo(object): def __iter__(self): return iter([ def __getitem__(self, item): return [
>>> iwd = IterWinsDemo() >>> for x in iwd: ... print(x) ... __iter__ wins
class WrappedList(object): def __init__(self, lst): self._list = lst def __getitem__(self, item): return self._list[item]
>>> wl = WrappedList([ >>> for x in wl: ... print(x) ... A B C
from collections import Iterable class MyObject(object): pass mo = MyObject() print isinstance(mo, Iterable) Iterable.register(MyObject) print isinstance(mo, Iterable) print isinstance("abc", Iterable)
from collections import Iterable from traceback import print_exc def check_and_raise(x): if not isinstance(x, Iterable): raise TypeError, "%s is not iterable" % x else: for i in x: print i def just_iter(x): for i in x: print i class NotIterable(object): pass if __name__ == "__main__": try: check_and_raise(5) except: print_exc() print try: just_iter(5) except: print_exc() print try: Iterable.register(NotIterable) ni = NotIterable() check_and_raise(ni) except: print_exc() print
isiterable = lambda obj: isinstance(obj, basestring) \ or getattr(obj,
def iterable(a): try: (x for x in a) return True except TypeError: return False
try: for i in object_in_question: do_something except TypeError: do_something_for_non_iterable
import collections def iterable(obj): return isinstance(obj, collections.Iterable):
def iterable(obj): try: iter(obj) except: return False return True
from typing import Iterable ... if isinstance(my_item, Iterable): print(True)
def is_iterable(x): try: 0 in x except TypeError: return False else: return True
import numpy class Yes: def __iter__(self): yield 1; yield 2; yield 3; class No: pass class Nope: def __iter__(self): return assert is_iterable(Yes()) assert is_iterable(range(3)) assert is_iterable((1,2,3)) assert is_iterable([1,2,3]) assert is_iterable({1,2,3}) assert is_iterable({1: assert is_iterable(numpy.array([1,2,3])) assert is_iterable(bytearray("not really a string", assert not is_iterable(No()) assert not is_iterable(Nope()) assert not is_iterable("string") assert not is_iterable(42) assert not is_iterable(True) assert not is_iterable(None)
import collections import numpy assert isinstance("string", collections.Iterable) assert isinstance("string", collections.Sequence) assert numpy.iterable("string") assert iter("string") assert hasattr("string",
class A(object): def __getitem__(self, item): return something class B(object): def __iter__(self): return iter([]) class C(object): def __iter__(self): return 1 class D(object): pass def iterable(obj): try: iter(obj) return True except: return False assert iterable(A()) assert iterable(B()) assert iterable(C()) assert not iterable(D())
def isiterable(object_): return hasattr(type(object_), "__iter__")
fruits = ("apple", "banana", "peach") isiterable(fruits) num = 345 isiterable(num) isiterable(str) hello = "hello dude !" isiterable(hello)
>>> hasattr(1, "__len__") False >>> hasattr(1.3, "__len__") False >>> hasattr("a", "__len__") True >>> hasattr([1,2,3], "__len__") True >>> hasattr({1,2}, "__len__") True >>> hasattr({"a":1}, "__len__") True >>> hasattr(("a", 1), "__len__") True
>>> import types >>> types.GeneratorType <class >>> gen = (i for i in range(10)) >>> isinstance(gen, types.GeneratorType) True
>>> keys = [ >>> values = [1, 2, 3] >>> dictionary = dict(zip(keys, values)) >>> print(dictionary) {
>>> import itertools >>> keys = ( >>> values = ( >>> adict = dict(itertools.izip(keys,values)) >>> adict {
from itertools import izip new_dict = dict(izip(keys, values))
>>> help(dict) class dict(object) | dict() -> new empty dictionary | dict(mapping) -> new dictionary initialized from a mapping object | (key, value) pairs | dict(iterable) -> new dictionary initialized as if via: | d = {} | for k, v in iterable: | d[k] = v | dict(**kwargs) -> new dictionary initialized with the name=value pairs | in the keyword argument list. For example: dict(one=1, two=2)
>>> zip(keys, values) <zip object at 0x7f0e2ad029c8>
generator_expression = ((k, v) for k, v in zip(keys, values)) dict(generator_expression)
>>> min(timeit.repeat(lambda: {k: v for k, v in zip(keys, values)})) 0.7836067057214677 >>> min(timeit.repeat(lambda: dict(zip(keys, values)))) 1.0321204089559615 >>> min(timeit.repeat(lambda: {keys[i]: values[i] for i in range(len(keys))})) 1.0714934510178864 >>> min(timeit.repeat(lambda: dict([(k, v) for k, v in zip(keys, values)]))) 1.6110592018812895 >>> min(timeit.repeat(lambda: dict((k, v) for k, v in zip(keys, values)))) 1.7361853648908436
>>> keys = ( >>> values = ( >>> dict(zip(keys, values)) {
>>> keys = ( >>> values = ( >>> {k: v for k, v in zip(keys, values)} {
keys = ( values = ( dict = {keys[i]: values[i] for i in range(len(keys))}
keys = ( values = ( dic = {k:v for k,v in zip(keys, values)} print(dic)
d = {List1[n]: List2[n] for n in range(len(List1))}
In [92]: keys = ( ...: values = ( ...: In [93]: dt = dict(zip(keys, values)) In [94]: dt Out[94]: {
lst = [( keys, values = zip(*lst) In [101]: keys Out[101]: ( In [102]: values Out[102]: (
a_dict={key:value for key,value in zip(keys,values)}
l1 = {1,2,3,4,5} l2 = { d1 = {} for l1_ in l1: for l2_ in l2: d1[l1_] = l2_ l2.remove(l2_) break print (d1) {1:
mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])
def filterfunc(x): return x % 3 == 0 mult3 = filter(filterfunc, [1, 2, 3, 4, 5, 6, 7, 8, 9])
mult3 = [x for x in [1, 2, 3, 4, 5, 6, 7, 8, 9] if x % 3 == 0]
>>> def transform(n): ... return lambda x: x + n ... >>> f = transform(3) >>> f(4) 7
>>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x)) [5, 4, 6, 3, 7, 2, 8, 1, 9]
for value in ["one","two","three"]: b = tk.Button(label=value, command=lambda arg=value: my_callback(arg)) b.pack()
>>> fs = [(lambda n: i + n) for i in range(10)] >>> fs[3](4) 13
>>> n = 4 >>> [i + n for i in range(10)] [4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
>>> fs = [(lambda n,i=i: i + n) for i in range(10)] >>> fs[3](4) 7
w = PyQt4.QtGui.QLineEdit() w.textChanged.connect(lambda event: dothing())
plural_rules = [ lambda n: lambda n: lambda n: ... ] plural_rule[1](4)
def main(): ... ... y = square(some_number) ... return something def square(x): return x**2
def main(): ... square = lambda x: x**2 y = square(some_number) return something
>>> square = lambda x: x**2 >>> [square(s) for x in a] [1,4,9,16]
>>> a = [1,2,3,4] >>> squared_list = map(lambda x: x**2, a)
log_timestamp(datetime.datetime.now() - datetime.timedelta(minutes = 30))
log_timestamp(lambda : datetime.datetime.now() - datetime.timedelta(minutes = 30))
def square(x): return x*x squared = map(square, [1, 2, 3, 4, 5])
def define_bindings(widget): widget.bind("<Button-1>", do-something-cool) def do-something-cool(event):
def main(): x, y = None, None widget.bind("<Button-1>", lambda event: do-something-cool(x, y)) def do-something-cool(event, x, y): x = event.x y = event.y
def a_func() ... if some_conditon: ... call_some_big_func(arg1, arg2, arg3, arg4...) else ... call_some_big_func(arg1, arg2, arg3, arg4...)
def a_func() ... call_big_f = lambda args_that_change: call_some_big_func(arg1, arg2, arg3, args_that_change) if some_conditon: ... call_big_f(argX) else ... call_big_f(argY)
>>> lis = [{"name": "Peter"}, {"name": "Josef"}] >>> loop_dic = lambda i: {"name": i["name"] + " Wallace" } >>> new_lis = [loop_dic(i) for i in lis] >>> new_lis [{
>>> lis = [{"name": "Peter"}, {"name": "Josef"}] >>> new_lis = [{"name": i["name"] + " Wallace"} for i in lis] >>> new_lis [{
import time start = time.time() def first(): squares = map(lambda x: x**2, range(10)) end = time.time() elapsed = end - start print elapsed + return elapsed def second(): lst = [] for i in range(10): lst.append(i**2) end = time.time() elapsed = end - start print elapsed + return elapsed print abs(second() - first())
{ DATA_PACKET: self.handle_data_packets NET_PACKET: self.handle_hardware_packets }.get(packet_type, lambda x : None)(payload)
def dump_hex(file, var) pass class X(object): def packet_received(data): self.callback(data)
dump_file = file( X.callback = lambda (x): dump_hex(dump_file, x) ... dump_file.close()
import imported.module def func(): return lambda: imported.module.method("foo", "bar")
import imported.module def func(): def cb(): return imported.module.method("foo", "bar") return cb
for code in bytearray(mystr): for code in bytearray(mystr,
a = dostuff(blahblah1, blahblah2, blahblah3, blahblah4, blahblah5, blahblah6, blahblah7)
class Rectangle(Blob): def __init__(self, width, height, color= if (width == 0 and height == 0 and color == highlight > 100): raise ValueError("sorry, you lose") if width == 0 and height == 0 and (color == emphasis is None): raise ValueError("I don (width, height)) Blob.__init__(self, width, height, color, emphasis, highlight)
income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest)
if 1900 < year < 2100 and 1 <= month <= 12 \ and 1 <= day <= 31 and 0 <= hour < 24 \ and 0 <= minute < 60 and 0 <= second < 60: return 1
from app import ( app, abort, make_response, redirect, render_template, request, session )
virtualenv --python=/usr/bin/python2.6 <path/to/new/virtualenv/>
mkdir ~/src wget http: tar -zxvf Python-2.7.9.tgz cd Python-2.7.9 mkdir ~/.localpython ./configure --prefix=$HOME/.localpython make make install
cd ~/src wget https: tar -zxvf virtualenv-15.0.2.tar.gz cd virtualenv-15.0.2/ ~/.localpython/bin/python setup.py install virtualenv ve -p $HOME/.localpython/bin/python2.7 source ve/bin/activate
virtualenv --python=/usr/bin/python2.6 <path/to/myvirtualenv>
which python3 >> /usr/local/bin/python3 virtualenv venv --python=/usr/local/bin/python3
virtualenv venv -p `which python` virtualenv venv -p `which python3`
$ ls -al /usr/local/bin/pip lrwxrwxr-x 1 root admin 65 Apr 10 2015 /usr/local/bin/pip -> ../../../Library/Frameworks/Python.framework/Versions/2.7/bin/pip
$ virtualenv -p python3.2 my_env Running virtualenv with interpreter /usr/local/bin/python3.2 New python executable in my_env/bin/python Installing setuptools, pip...done.
export WORKON_HOME=$HOME/.virtualenvs export PROJECT_HOME=$HOME/django_projects export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python2.7 source /Library/Frameworks/Python.framework/Versions/2.7/bin/virtualenvwrapper.sh
$ mkvirtualenv -p /usr/local/bin/python3.2 my_env Running virtualenv with interpreter /usr/local/bin/python3 New python executable in my_env/bin/python Installing setuptools, pip...done. Usage: source deactivate removes the activate
$ virtualenv --python=/usr/bin/python3.2 name_of_your_virtualenv
venv/bin/python Python 3.5.1 (v3.5.1:37a07cee5969, Dec 5 2015, 21:12:44) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>>
ruby -e "$(curl -fsSL https: brew install pyenv pyenv install 2.7.10 pyenv global 2.7.10 export PATH=/Users/{USERNAME}/.pyenv/versions/2.7.10/bin:$PATH mkvirtualenv -p ~/.pyenv/versions/2.7.10/bin/python {virtual_env_name}
$ python3 -m virtualenv --python=python2 vp27 $ source vp27/bin/activate (vp27)$ python --version Python 2.7.14
MacBook-Pro-2:~ admin$ virtualenv venv2 --python=`which python2` Running virtualenv with interpreter /usr/local/bin/python2 New python executable in /Users/admin/venv2/bin/python Installing setuptools, pip, wheel...done. MacBook-Pro-2:~ admin$ MacBook-Pro-2:~ admin$ ls venv2/bin/ activate easy_install pip2.7 python2.7 activate.csh easy_install-2.7 python wheel activate.fish pip python-config activate_this.py pip2 python2 MacBook-Pro-2:~ admin$
MacBook-Pro-2:~ admin$ virtualenv venv3 --python=`which python3` Running virtualenv with interpreter /usr/local/bin/python3 Using base prefix New python executable in /Users/admin/venv3/bin/python3 Also creating executable in /Users/admin/venv3/bin/python Installing setuptools, pip, wheel...done. MacBook-Pro-2:~ admin$ MacBook-Pro-2:~ admin$ ls venv3/bin/ activate easy_install pip3.6 python3.6 activate.csh easy_install-3.6 python wheel activate.fish pip python-config activate_this.py pip3 python3 MacBook-Pro-2:~ admin$
MacBook-Pro-2:~ admin$ which python2 /usr/local/bin/python2 MacBook-Pro-2:~ admin$ MacBook-Pro-2:~ admin$ which python3 /usr/local/bin/python3 MacBook-Pro-2:~ admin$
sudo apt-get install python3-minimal virtualenv --no-site-packages --distribute -p /usr/bin/python3 ~/.virtualenvs/py3
>>> os.direxists(os.path.join(os.getcwd()), True/False
import os print(os.path.isdir("/home/el")) print(os.path.exists("/home/el/myfile.txt"))
In [1]: from pathlib import Path In [2]: p = Path( In [3]: p.exists() Out[3]: True In [4]: p.is_dir() Out[4]: True In [5]: q = p / In [6]: q.exists() Out[6]: True In [7]: q.is_dir() Out[7]: False
import os, stat, errno def CheckIsDir(directory): try: return stat.S_ISDIR(os.stat(directory).st_mode) except OSError, e: if e.errno == errno.ENOENT: return False raise
import importlib.util spec = importlib.util.spec_from_file_location("module.name", "/path/to/file.py") foo = importlib.util.module_from_spec(spec) spec.loader.exec_module(foo) foo.MyClass()
from importlib.machinery import SourceFileLoader foo = SourceFileLoader("module.name", "/path/to/file.py").load_module() foo.MyClass()
import sys sys.path.append( from testcase import TestCase from testutils import RunTests from mock import Mock, sentinel, patch
configfile = import os import sys sys.path.append(os.path.dirname(os.path.expanduser(configfile))) import config
from runpy import run_path settings = run_path("/path/to/file.py")
from importlib.util import spec_from_loader, module_from_spec from importlib.machinery import SourceFileLoader spec = spec_from_loader("module.name", SourceFileLoader("module.name", "/path/to/file.py")) mod = module_from_spec(spec) spec.loader.exec_module(mod)
def import_file(full_path_to_module): try: import os module_dir, module_file = os.path.split(full_path_to_module) module_name, module_ext = os.path.splitext(module_file) save_cwd = os.getcwd() os.chdir(module_dir) module_obj = __import__(module_name) module_obj.__file__ = full_path_to_module globals()[module_name] = module_obj os.chdir(save_cwd) except: raise ImportError import_file(
config_file = "/tmp/config.py" with open(config_file) as f: code = compile(f.read(), config_file, exec(code, globals(), locals())
MODULE_PATH = "/path/to/your/module/__init__.py" MODULE_NAME = "mymodule" spec = importlib.util.spec_from_file_location(MODULE_NAME, MODULE_PATH) module = importlib.util.module_from_spec(spec) sys.modules[spec.name] = module spec.loader.exec_module(module)
import sys sys.path.append("/path/to/my/modules/") import my_module
export PYTHONPATH="${PYTHONPATH}:/path/to/my/modules/"
path = os.path.join( for infile in glob.glob(path): basename = os.path.basename(infile) basename_without_extension = basename[:-3] imp.load_source(basename_without_extension, infile)
def import_module_from_file(full_path_to_module): """ Import a module given the full path/filename of the .py file Python 3.4 """ module = None try: module_dir, module_file = os.path.split(full_path_to_module) module_name, module_ext = os.path.splitext(module_file) spec = importlib.util.spec_from_file_location(module_name,full_path_to_module) module = spec.loader.load_module() except Exception as ec: print(ec) finally: return module
module = dict() with open("/path/to/module") as f: exec(f.read(), module) module[
class MyModuleClass(dict): def __getattr__(self, name): return self.__getitem__(name)
filename = "directory/module.py" directory, module_name = os.path.split(filename) module_name = os.path.splitext(module_name)[0] path = list(sys.path) sys.path.insert(0, directory) try: module = __import__(module_name) finally: sys.path[:] = path
>>>from import_file import import_file >>>mylib = import_file( >>>another = import_file(
import sys, types def _get_mod(modulePath): try: aMod = sys.modules[modulePath] if not isinstance(aMod, types.ModuleType): raise KeyError except KeyError: aMod = __import__(modulePath, globals(), locals(), [ sys.modules[modulePath] = aMod return aMod def _get_func(fullFuncName): lastDot = fullFuncName.rfind(u".") funcName = fullFuncName[lastDot + 1:] modPath = fullFuncName[:lastDot] aMod = _get_mod(modPath) aFunc = getattr(aMod, funcName) assert callable(aFunc), u"%s is not callable." % fullFuncName return aFunc def _get_class(fullClassName, parentClass=None): """Load a module and retrieve a class (NOT an instance). If the parentClass is supplied, className must be of parentClass or a subclass of parentClass (or None is returned). """ aClass = _get_func(fullClassName) if parentClass is not None: if not issubclass(aClass, parentClass): raise TypeError(u"%s is not a subclass of %s" % (fullClassName, parentClass)) return aClass class StorageManager: pass class StorageManagerMySQL(StorageManager): pass def storage_object(aFullClassName, allOptions={}): aStoreClass = _get_class(aFullClassName, StorageManager) return aStoreClass(allOptions)
import pkgutil import importlib packages = pkgutil.walk_packages(path= for importer, name, is_package in packages: mod = importlib.import_module(name)
ln -s /absolute/path/to/module/module.py /absolute/path/to/script/module.py
libPath = import sys if not libPath in sys.path: sys.path.append(libPath) import pyfunc as pf
import sys sys.path.append("<project-path>/lib/") from tes1 import Client1 from tes2 import Client2 import tes3
from test import Client1 from test import Client2 from test import test3
import sys import importlib.machinery def load_module(name, filename): if name in sys.modules: del sys.modules[name] loader = importlib.machinery.ExtensionFileLoader(name, filename) module = loader.load_module() locals()[name] = module globals()[name] = module load_module( something.do_something()
import pathlib def likely_python_module(filename): Given a filename or Path, return the "likely" python module name. That is, iterate the parent directories until it doesn :rtype: str p = pathlib.Path(filename).resolve() paths = [] if p.name != paths.append(p.stem) while True: p = p.parent if not p: break if not p.is_dir(): break inits = [f for f in p.iterdir() if f.name == if not inits: break paths.append(p.stem) return
import imp import sys def __import__(name, globals=None, locals=None, fromlist=None): try: return sys.modules[name] except KeyError: pass fp, pathname, description = imp.find_module(name) try: return imp.load_module(name, fp, pathname, description) finally: if fp: fp.close()
from pylab import figure, axes, pie, title, show figure(1, figsize=(6, 6)) ax = axes([0.1, 0.1, 0.8, 0.8]) labels = fracs = [15, 30, 45, 10] explode = (0, 0.05, 0, 0) pie(fracs, explode=explode, labels=labels, autopct= title( show()
import matplotlib.pyplot as plt fig, ax = plt.subplots( nrows=1, ncols=1 ) ax.plot([0,1,2], [10,20,3]) fig.savefig( plt.close(fig)
import matplotlib matplotlib.use( import matplotlib.pyplot as plt plt.plot([1,2,3]) plt.savefig(
import matplotlib.image as mpimg img = mpimg.imread("src.png") mpimg.imsave("out.png", img)
import datetime import numpy as np from matplotlib.backends.backend_pdf import PdfPages import matplotlib.pyplot as plt with PdfPages( plt.figure(figsize=(3, 3)) plt.plot(range(7), [3, 1, 4, 1, 5, 9, 2], plt.title( pdf.savefig() plt.close() plt.rc( plt.figure(figsize=(8, 6)) x = np.arange(0, 5, 0.1) plt.plot(x, np.sin(x), plt.title( pdf.savefig() plt.close() plt.rc( fig = plt.figure(figsize=(4, 5)) plt.plot(x, x*x, plt.title( pdf.savefig(fig) plt.close() d = pdf.infodict() d[ d[ d[ d[ d[ d[
import matplotlib.pyplot as plt fig = plt.figure(figsize=(4, 5)) if save_file: plt.savefig(save_file) plt.close(fig) else: plt.show()
import matplotlib.pyplot as plt p1 = plt.plot(dates, temp, p2 = plt.plot(dates, psal, plt.legend(loc= plt.savefig( plt.show() f.close() plt.close()
fig, ax = plt.figure(nrows=1, ncols=1) plt.plot(...) plt.show() fig.savefig(
import pandas as pd import numpy as np import matplotlib.pyplot as plt import matplotlib matplotlib.style.use( ts = pd.Series(np.random.randn(1000), index=pd.date_range( ts = ts.cumsum() plt.figure() ts.plot() plt.savefig("foo.png", bbox_inches=
import numpy as np import matplotlib.pyplot as plt def draw_result(lst_iter, lst_loss, lst_acc, title): plt.plot(lst_iter, lst_loss, plt.plot(lst_iter, lst_acc, plt.xlabel("n iteration") plt.legend(loc= plt.title(title) plt.savefig(title+".png") plt.show() def test_draw(): lst_iter = range(100) lst_loss = [0.01 * i + 0.01 * i ** 2 for i in xrange(100)] lst_acc = [0.01 * i - 0.01 * i ** 2 for i in xrange(100)] draw_result(lst_iter, lst_loss, lst_acc, "sgd_method") if __name__ == test_draw()
import matplotlib.pyplot as plt plt.savefig("image.png")
application/app2/some_folder/some_file.py application/app2/another_folder/another_file.py
export PYTHONPATH=$HOME/dirWithScripts/:$PYTHONPATH set PYTHONPATH=C:\path\to\dirWithScripts\;%PYTHONPATH%
import sys sys.path.insert(0, r from application.app.folder.file import func_name func_name()
import sys sys.path.append(pathToFolderContainingScripts) from scriptName import functionName
import sys sys.path.insert(0, sys.path[0]+ import some_file
/home/me/application/app2/some_folder/vanilla.py /home/me/application/app2/another_folder/mango.py
import sys, os.path mango_dir = (os.path.abspath(os.path.join(os.path.dirname(__file__), + sys.path.append(mango_dir) import mango
>>> import os >>> mydir = >>> newdir = os.path.abspath(os.path.join(mydir, >>> newdir >>> newdir = os.path.abspath(os.path.join(mydir, >>> >>> newdir >>>
sys.path.append( sys.path.append( sys.path.append( sys.path.append(
import os, sys from os.path import dirname, join, abspath sys.path.insert(0, abspath(join(dirname(__file__), from root_folder import file_name
import importlib, importlib.util, os.path def module_from_file(module_name, file_path): spec = importlib.util.spec_from_file_location(module_name, file_path) module = importlib.util.module_from_spec(spec) spec.loader.exec_module(module) return module foo = module_from_file("foo", "/path/to/foo.py") if __name__ == "__main__": print(foo) print(dir(foo)) foo.announce()
import importlib, importlib.util, os.path def module_from_file(module_name, file_path): spec = importlib.util.spec_from_file_location(module_name, file_path) module = importlib.util.module_from_spec(spec) spec.loader.exec_module(module) return module baz = module_from_file("bar", "/path/to/foo.py") if __name__ == "__main__": print(baz) print(dir(baz)) baz.announce()
path.append("/opt/path/to/code/") from log_helper import LogHelper
from __future__ import print_function print("hi there", file=f)
Python 2.7.1 (r271:86832, Nov 27 2010, 18:30:46) [MSC v.1500 32 bit (Intel)] on win32 Type "help", "copyright", "credits" or "license" for more information. >>> import os >>> os.linesep >>> f = open( >>> f.write( >>> f.write( >>> f.close() >>> open( >>>
import time start = start = time.time() with open("test.txt", for i in range(10000000): end = time.time() print(end - start)
start = start = time.time() long_line = with open("test.txt", for i in range(1000000): end = time.time() print(end - start, "s")
import io my_string = "hi there" with io.open("output_file.txt", mode= f.write(my_string)
array = [0, 10, 20, 40] for (i = array.length() - 1; i >= 0; i--)
>>> array=[0,10,20,40] >>> for i in reversed(array): ... print(i)
>>> L = [0,10,20,40] >>> L.reverse() >>> L [40, 20, 10, 0]
def reverse_in_place(lst): size = len(lst) hiindex = size - 1 its = size/2 for i in xrange(0, its): temp = lst[hiindex] lst[hiindex] = lst[i] lst[i] = temp hiindex -= 1 print "Done!" array = [2, 5, 8, 9, 12, 19, 25, 27, 32, 60, 65, 1, 7, 24, 124, 654] print array reverse_in_place(array) print array **The result:** [2, 5, 8, 9, 12, 19, 25, 27, 32, 60, 65, 1, 7, 24, 124, 654] Done! [654, 124, 24, 7, 1, 65, 60, 32, 27, 25, 19, 12, 9, 8, 5, 2]
def rev_list1(l): return l[::-1] def rev_list2(l): return list(reversed(l)) def rev_list3(l): l.reverse() return l
timeit(lambda: rev_list1(l), number=1000) timeit(lambda: rev_list2(l), number=1000) timeit(lambda: rev_list3(l), number=1000)
timeit(lambda: rev_list1(l), number=1000) timeit(lambda: rev_list2(l), number=1000) timeit(lambda: rev_list3(l), number=1000)
>>> list1 = [1,2,3] >>> reversed_list = list(reversed(list1)) >>> reversed_list >>> [3, 2, 1]
list1 = [3,4,3,545,6,4,34,243] list1.reverse() list1[::-1]
array=[0,10,20,40] for e in reversed(array): print e
>>> array = [1,2,3,4] >>> for item in reversed(array): >>> print item
def reverse(a): midpoint = len(a)/2 for item in a[:midpoint]: otherside = (len(a) - a.index(item)) - 1 temp = a[otherside] a[otherside] = a[a.index(item)] a[a.index(item)] = temp return a
z = range(1000000) startTimeTic = time.time() y = z[::-1] print("Time: %s s" % (time.time() - startTimeTic)) f = range(1000000) startTimeTic = time.time() g = list(reversed(f)) print("Time: %s s" % (time.time() - startTimeTic))
array=[0,10,20,40] for e in reversed(array): print e
def reverse(text): output = [] for i in range(len(text)-1, -1, -1): output.append(text[i]) return output
>>> array = [0, 10, 20, 40] >>> [array[~i] for i, _ in enumerate(array)] [40, 20, 10, 0]
for i in xrange(len(array) - 1, -1, -1): print i, array[i]
>>> for element in reversed(your_array): ... print element
>>> l = [1,2,3,4,5,6]; nl=[] >>> while l: nl.append(l.pop()) >>> print nl [6, 5, 4, 3, 2, 1]
def reverse(text): lst=[] for i in range(0,len(text)): lst.append(text[(len(text)-1)-i]) return print reverse(
list_data = [1,2,3,4,5] l = len(list_data) i=l+1 rev_data = [] while l>0: j=i-l l-=1 rev_data.append(list_data[-j]) print "After Rev:- %s" %rev_data
def reverse(my_list): L = len(my_list) for i in range(L/2): my_list[i], my_list[L-i - 1] = my_list[L-i-1], my_list[i] return my_list
>>> l = [1, 2, 3, 4, 5] >>> print(reduce(lambda acc, x: [x] + acc, l, [])) [5, 4, 3, 2, 1]
>>> L = [1, 2, 3, 4] >>> L = [L[-i] for i in range(1, len(L) + 1)] >>> L [4, 3, 2, 1]
>>> l = [1,2,3,4,5,6,7] >>> for i in range(len(l) ... l[i], l[-1-i] = l[-1-i], l[i] ... >>> l [7, 6, 5, 4, 3, 2, 1]
>>> l = [1,2,3,4,5] >>> for i in l.__reversed__(): ... print i ... 5 4 3 2 1 >>>
MSC v.1000 -> Visual C++ 4.x MSC v.1100 -> Visual C++ 5 MSC v.1200 -> Visual C++ 6 MSC v.1300 -> Visual C++ .NET MSC v.1310 -> Visual C++ .NET 2003 MSC v.1400 -> Visual C++ 2005 (8.0) MSC v.1500 -> Visual C++ 2008 (9.0) MSC v.1600 -> Visual C++ 2010 (10.0) MSC v.1700 -> Visual C++ 2012 (11.0) MSC v.1800 -> Visual C++ 2013 (12.0) MSC v.1900 -> Visual C++ 2015 (14.0) MSC v.1910 -> Visual C++ 2017 (15.0) MSC v.1911 -> Visual C++ 2017 (15.3) MSC v.1912 -> Visual C++ 2017 (15.5) MSC v.1913 -> Visual C++ 2017 (15.6) MSC v.1914 -> Visual C++ 2017 (15.7) MSC v.1915 -> Visual C++ 2017 (15.8) MSC v.1916 -> Visual C++ 2017 (15.9)
cc1.exe: error: unrecognized command line option error: command
self.set_executables(compiler= compiler_so= compiler_cxx= linker_exe= linker_so= % (self.linker_dll, shared_option, entry_point))
File "numpy\core\setup.py", line 686, in get_mathlib_info raise RuntimeError("Broken toolchain: cannot link a simple C program") RuntimeError: Broken toolchain: cannot link a simple C program
C:\Users\Andreas\AppData\Local\Programs\Common\Microsoft\Visual C++ for Python\9.0
productdir = os.path.join(toolsdir, os.pardir, os.pardir, "VC")
pip install --global-option build_ext --global-option --compiler=mingw32 packagename
> iex ((new-object net.webclient).DownloadString( > choco install python2 -y > choco install vcpython27 -y
import io, json with io.open( f.write(json.dumps(data, ensure_ascii=False))
import json with open( json.dump(data, f, ensure_ascii=False)
import json, codecs with open( json.dump(data, codecs.getwriter(
>>> json.dumps({ >>> json.dumps({ >>> len(json.dumps({ 37 >>> len(json.dumps({ 17
with open( json.dump(jsonData, outfile, sort_keys = True, indent = 4, ensure_ascii = False)
import json import io try: to_unicode = unicode except NameError: to_unicode = str data = { with io.open( str_ = json.dumps(data, indent=4, sort_keys=True, separators=( outfile.write(to_unicode(str_)) with open( data_loaded = json.load(data_file) print(data == data_loaded)
{ "a list":[ 1, 42, 3.141, 1337, "help", "€" ], "a string":"bla", "another dict":{ "foo":"bar", "key":"value", "the answer":42 } }
import codecs, json with codecs.open( f.write(json.dumps(data, sort_keys = True, ensure_ascii=False))
import json data = {u with open( json.dump(data, outfile)
import json data = [1,2,3,4,5] with open( json.dump(data, txtfile)
destination= saveFile = open(destination, saveFile.write(df.to_json()) saveFile.close()
import json outfile = open( json.dump(data, outfile, indent=4)
import json def write_json(): student_data = {"students":[]} data_holder = student_data["students"] counter = 0 while counter < 3: data_holder.append({ data_holder.append({ counter += 1 file_path= with open(file_path, print("writing file to: ",file_path) json.dump(student_data, outfile) outfile.close() print("done") write_json()
import threading import time import sys import os def kenny(num=0): if num > 3: print("Kenny dies and also kills Cartman!") os._exit(1) while True: print("Kenny lives: {0}".format(num)) time.sleep(1) num += 1 kenny(num) def cartman(): i = 0 while True: print("Cartman lives: {0}".format(i)) i += 1 time.sleep(1) if __name__ == daemon_kenny = threading.Thread(name= daemon_cartman = threading.Thread(name= daemon_kenny.setDaemon(True) daemon_cartman.setDaemon(True) daemon_kenny.start() daemon_cartman.start() daemon_kenny.join() daemon_cartman.join()
def main(): try: Answer = 1/0 print Answer except: print return print if __name__ == main()
import sys def main(): try: Answer = 1/0 print Answer except: print sys.exit() print if __name__ == main()
if "ATG" in my_DNA: else: print("Start codon is missing! Check your DNA sequence!"); exit();
if "ATG" in my_DNA: else: raise ValueError("Start codon is missing! Check your DNA sequence!");
$ cd /tmp $ virtualenv test_env New python executable in test_env/bin/python Installing setuptools, pip...done. $ source test_env/bin/activate (test_env) $
(test_env) $ git clone https: Cloning into remote: Reusing existing pack: 4350, done. remote: Total 4350 (delta 0), reused 0 (delta 0) Receiving objects: 100% (4350/4350), 1.85 MiB | 418.00 KiB/s, done. Resolving deltas: 100% (2388/2388), done. Checking connectivity... done.
(test_env) $ ls /tmp/behave/setup.py /tmp/behave/setup.py
(test_env) $ cd /tmp/behave && python setup.py install running install ... Installed /private/tmp/test_env/lib/python2.7/site-packages/enum34-1.0-py2.7.egg Finished processing dependencies for behave==1.2.5a1
>>> import pip >>> sorted(["%s==%s" % (i.key, i.version) for i in pip.get_installed_distributions()]) [ >>> import os >>> os.getcwd()
>>> import pip >>> sorted(["%s==%s" % (i.key, i.version) for i in pip.get_installed_distributions()]) [ >>> import os >>> os.getcwd()
Fabric==0.9.3 apache-libcloud==0.4.0 bzr==2.3b4 distribute==0.6.14 docutils==0.7 greenlet==0.3.1 ipython==0.10.1 iterpipes==0.4 libxml2-python==2.6.21
import pkg_resources installed_packages = pkg_resources.working_set installed_packages_list = sorted(["%s==%s" % (i.key, i.version) for i in installed_packages]) print(installed_packages_list)
from pkgutil import iter_modules a=iter_modules() while True: try: x=a.next() except: break if
import pip for package in pip.get_installed_distributions(): name = package.project_name key = package.key module_name = package._get_metadata("top_level.txt") location = package.location version = package.version
import sys import os import shutil import pkgutil import importlib import collections if sys.version_info.major == 2: raise NotImplementedError( def main(): this_module_name = os.path.basename(__file__).rsplit( loaders = collections.OrderedDict() for module_name in sys.builtin_module_names: module = importlib.util.find_spec(module_name) if module.loader not in loaders: loaders[module.loader] = [] loaders[module.loader].append((module.name, module.origin)) for module_name in pkgutil.iter_modules(): if this_module_name == module_name[1]: continue module = importlib.util.find_spec(module_name[1]) loader = type(module.loader) if loader not in loaders: loaders[loader] = [] loaders[loader].append((module.name, module.origin)) line = for loader, modules in loaders.items(): print( for module in modules: print( if __name__ == main()
$ python3.5 python_modules_info.py ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 30: <class ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ _ast | built-in _codecs | built-in _collections | built-in _functools | built-in _imp | None _io | built-in _locale | built-in _operator | built-in _signal | built-in _sre | built-in _stat | built-in _string | built-in _symtable | built-in _thread | built-in (****************************truncated*******************************) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 227: <class ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ __future__ | /usr/local/lib/python3.5/__future__.py _bootlocale | /usr/local/lib/python3.5/_bootlocale.py _collections_abc | /usr/local/lib/python3.5/_collections_abc.py _compat_pickle | /usr/local/lib/python3.5/_compat_pickle.py _compression | /usr/local/lib/python3.5/_compression.py _dummy_thread | /usr/local/lib/python3.5/_dummy_thread.py _markupbase | /usr/local/lib/python3.5/_markupbase.py _osx_support | /usr/local/lib/python3.5/_osx_support.py _pydecimal | /usr/local/lib/python3.5/_pydecimal.py _pyio | /usr/local/lib/python3.5/_pyio.py _sitebuiltins | /usr/local/lib/python3.5/_sitebuiltins.py (****************************truncated*******************************) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 64: <class ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ _bisect | /usr/local/lib/python3.5/lib-dynload/_bisect.cpython-35m-x86_64-linux-gnu.so _bz2 | /usr/local/lib/python3.5/lib-dynload/_bz2.cpython-35m-x86_64-linux-gnu.so _codecs_cn | /usr/local/lib/python3.5/lib-dynload/_codecs_cn.cpython-35m-x86_64-linux-gnu.so _codecs_hk | /usr/local/lib/python3.5/lib-dynload/_codecs_hk.cpython-35m-x86_64-linux-gnu.so _codecs_iso2022 | /usr/local/lib/python3.5/lib-dynload/_codecs_iso2022.cpython-35m-x86_64-linux-gnu.so (****************************truncated*******************************)
$ python3.4 python_modules_info.py ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 54: <class ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ _ast | built-in _bisect | built-in _codecs | built-in _collections | built-in _datetime | built-in _elementtree | built-in _functools | built-in _heapq | built-in _imp | None _io | built-in _locale | built-in _md5 | built-in _operator | built-in _pickle | built-in _posixsubprocess | built-in _random | built-in (****************************truncated*******************************) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 246: <class ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ __future__ | /usr/lib/python3.4/__future__.py _bootlocale | /usr/lib/python3.4/_bootlocale.py _collections_abc | /usr/lib/python3.4/_collections_abc.py _compat_pickle | /usr/lib/python3.4/_compat_pickle.py _dummy_thread | /usr/lib/python3.4/_dummy_thread.py _markupbase | /usr/lib/python3.4/_markupbase.py _osx_support | /usr/lib/python3.4/_osx_support.py _pyio | /usr/lib/python3.4/_pyio.py (****************************truncated*******************************) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 44: <class ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ _bz2 | /usr/lib/python3.4/lib-dynload/_bz2.cpython-34m-x86_64-linux-gnu.so _codecs_cn | /usr/lib/python3.4/lib-dynload/_codecs_cn.cpython-34m-x86_64-linux-gnu.so _codecs_hk | /usr/lib/python3.4/lib-dynload/_codecs_hk.cpython-34m-x86_64-linux-gnu.so _codecs_iso2022 | /usr/lib/python3.4/lib-dynload/_codecs_iso2022.cpython-34m-x86_64-linux-gnu.so _codecs_jp | /usr/lib/python3.4/lib-dynload/_codecs_jp.cpython-34m-x86_64-linux-gnu.so _codecs_kr | /usr/lib/python3.4/lib-dynload/_codecs_kr.cpython-34m-x86_64-linux-gnu.so _codecs_tw | /usr/lib/python3.4/lib-dynload/_codecs_tw.cpython-34m-x86_64-linux-gnu.so _crypt | /usr/lib/python3.4/lib-dynload/_crypt.cpython-34m-x86_64-linux-gnu.so (****************************truncated*******************************)
import tabulate try: from pip import get_installed_distributions except: from pip._internal.utils.misc import get_installed_distributions tabpackages = [] for _, package in sorted([( tabpackages.append([package.location, package.key, package.version]) print(tabulate.tabulate(tabpackages))
19:33 pi@rpi-v3 [iot-wifi-2] ~/python$ python installed_packages.py ------------------------------------------- -------------- ------ /home/pi/.local/lib/python2.7/site-packages enum-compat 0.0.2 /home/pi/.local/lib/python2.7/site-packages enum34 1.1.6 /home/pi/.local/lib/python2.7/site-packages pexpect 4.2.1 /home/pi/.local/lib/python2.7/site-packages ptyprocess 0.5.2 /home/pi/.local/lib/python2.7/site-packages pygatt 3.2.0 /home/pi/.local/lib/python2.7/site-packages pyserial 3.4 /usr/local/lib/python2.7/dist-packages bluepy 1.1.1 /usr/local/lib/python2.7/dist-packages click 6.7 /usr/local/lib/python2.7/dist-packages click-datetime 0.2 /usr/local/lib/python2.7/dist-packages construct 2.8.21 /usr/local/lib/python2.7/dist-packages pyaudio 0.2.11 /usr/local/lib/python2.7/dist-packages tabulate 0.8.2 ------------------------------------------- -------------- ------
import sys import os for p in sys.path: print os.listdir( p )
def file_len(fname): with open(fname) as f: for i, l in enumerate(f): pass return i + 1
mapcount : 0.465599966049 simplecount : 0.756399965286 bufcount : 0.546800041199 opcount : 0.718600034714
mapcount : 0.471799945831 simplecount : 0.634400033951 bufcount : 0.468800067902 opcount : 0.602999973297
from __future__ import with_statement import time import mmap import random from collections import defaultdict def mapcount(filename): f = open(filename, "r+") buf = mmap.mmap(f.fileno(), 0) lines = 0 readline = buf.readline while readline(): lines += 1 return lines def simplecount(filename): lines = 0 for line in open(filename): lines += 1 return lines def bufcount(filename): f = open(filename) lines = 0 buf_size = 1024 * 1024 read_f = f.read buf = read_f(buf_size) while buf: lines += buf.count( buf = read_f(buf_size) return lines def opcount(fname): with open(fname) as f: for i, l in enumerate(f): pass return i + 1 counts = defaultdict(list) for i in range(5): for func in [mapcount, simplecount, bufcount, opcount]: start_time = time.time() assert func("big_file.txt") == 1209138 counts[func].append(time.time() - start_time) for key, vals in counts.items(): print key.__name__, ":", sum(vals) / float(len(vals))
def rawcount(filename): f = open(filename, lines = 0 buf_size = 1024 * 1024 read_f = f.raw.read buf = read_f(buf_size) while buf: lines += buf.count(b buf = read_f(buf_size) return lines
def _make_gen(reader): b = reader(1024 * 1024) while b: yield b b = reader(1024*1024) def rawgencount(filename): f = open(filename, f_gen = _make_gen(f.raw.read) return sum( buf.count(b
from itertools import (takewhile,repeat) def rawincount(filename): f = open(filename, bufgen = takewhile(lambda x: x, (f.raw.read(1024*1024) for _ in repeat(None))) return sum( buf.count(b
function average, s min, s ratio rawincount 0.0043 0.0041 1.00 rawgencount 0.0044 0.0042 1.01 rawcount 0.0048 0.0045 1.09 bufcount 0.008 0.0068 1.64 wccount 0.01 0.0097 2.35 itercount 0.014 0.014 3.41 opcount 0.02 0.02 4.83 kylecount 0.021 0.021 5.05 simplecount 0.022 0.022 5.25 mapcount 0.037 0.031 7.46
import subprocess def file_len(fname): p = subprocess.Popen([ stderr=subprocess.PIPE) result, err = p.communicate() if p.returncode != 0: raise IOError(err) return int(result.strip().split()[0])
import multiprocessing, sys, time, os, mmap import logging, logging.handlers def init_logger(pid): console_format = logger = logging.getLogger() logger.setLevel( logging.INFO ) logger.handlers.append( logging.StreamHandler() ) logger.handlers[0].setFormatter( logging.Formatter( console_format, def getFileLineCount( queues, pid, processes, file1 ): init_logger(pid) logging.info( physical_file = open(file1, "r") m1 = mmap.mmap( physical_file.fileno(), 0, access=mmap.ACCESS_READ ) fSize = os.stat(file1).st_size chunk = (fSize / processes) + 1 lines = 0 _seedStart = chunk * (pid) _seekEnd = chunk * (pid+1) seekStart = int(_seedStart) seekEnd = int(_seekEnd) if seekEnd < int(_seekEnd + 1): seekEnd += 1 if _seedStart < int(seekStart + 1): seekStart += 1 if seekEnd > fSize: seekEnd = fSize if pid > 0: m1.seek( seekStart ) l1 = m1.readline() seekStart = m1.tell() if pid > 0: queues[pid-1].put( seekStart ) if pid < processes-1: seekEnd = queues[pid].get() m1.seek( seekStart ) l1 = m1.readline() while len(l1) > 0: lines += 1 l1 = m1.readline() if m1.tell() > seekEnd or len(l1) == 0: break logging.info( if pid == 0: for p in range(1,processes): lines += queues[0].get() queues[0].put(lines) else: queues[0].put(lines) m1.close() physical_file.close() if __name__ == init_logger( if len(sys.argv) > 1: file_name = sys.argv[1] else: logging.fatal( exit() t = time.time() processes = multiprocessing.cpu_count() if len(sys.argv) > 2: processes = int(sys.argv[2]) queues=[] for pid in range(processes): queues.append( multiprocessing.Queue() ) jobs=[] prev_pipe = 0 for pid in range(processes): p = multiprocessing.Process( target = getFileLineCount, args=(queues, pid, processes, file_name,) ) p.start() jobs.append(p) jobs[0].join() lines = queues[0].get() logging.info(
with open(input_file) as foo: lines = len(foo.readlines())
lines = 0 buffer = bytearray(2048) with open(filename) as f: while f.readinto(buffer) > 0: lines += buffer.count(
import subprocess def count_file_lines(file_path): num = subprocess.check_output([ num = num.split( return int(num[0])
def file_len(full_path): f = open(full_path) nr_of_lines = sum(1 for line in f) f.close() return nr_of_lines
In [20]: timeit sum(1 for line in open( 100000 loops, best of 3: 9.79 µs per loop In [21]: timeit len(open( 100000 loops, best of 3: 12 µs per loop
0 bar.txt 1000 command.txt 3 test_file.txt 1003 total
from functools import partial buffer=2**16 with open(myfile) as f: print sum(x.count(
import fileinput as fi def filecount(fname): for line in fi.input(fname): pass return fi.lineno()
mapcount : 6.1331050396 simplecount : 4.588793993 opcount : 4.42918205261 filecount : 43.2780818939 bufcount : 0.170812129974
def main(): f = open( lines = 0 buf_size = 1024 * 1024 read_f = f.read buf = read_f(buf_size) while buf: lines += buf.count( buf = read_f(buf_size) print lines if __name__ == main()
def line_count(file): return int(subprocess.check_output(
def CountLines(filename): f = open(filename) try: lines = 1 buf_size = 1024 * 1024 read_f = f.read buf = read_f(buf_size) if not buf: return 0 while buf: lines += buf.count( buf = read_f(buf_size) return lines finally: f.close()
def file_len(fname): counts = itertools.count() with open(fname) as f: for _ in f: counts.next() return counts.next()
import os print os.popen("wc -l file_path").readline().split()[0]
import fileinput import sys counter=0 for line in fileinput.input([sys.argv[1]]): counter+=1 fileinput.close() print counter
def c(): import time s = time.time() file_length = len(open( print time.time() - s
def line_count(path): count = 0 with open(path) as lines: for count, l in enumerate(lines, start=1): pass return count
import os import subprocess Number_lines = int( (subprocess.Popen(
import subprocess def num_lines_in_file(fpath): return int(subprocess.check_output(
def count_text_file_lines(path): with open(path, line_count = sum(1 for _line in file) return line_count
with open(fname) as f: count = len(f.read().split(b
from collections import Counter str = "Mary had a little lamb" counter = Counter(str) print counter[
import re my_string = "Mary had a little lamb" len(re.findall("a", my_string))
from collections import defaultdict text = chars = defaultdict(int) for char in text: chars[char] += 1
class CICounter(defaultdict): def __getitem__(self, k): return super().__getitem__(k.lower()) def __setitem__(self, k, v): super().__setitem__(k.lower(), v) chars = CICounter(int) for char in text: chars[char] += 1 >>>chars[ 4 >>>chars[ 2 >>>chars[ 0
my_string = "Mary had a little lamb" my_string.count("m") import re len(re.findall("m", my_string)) len(re.findall("(?i)m", my_string)) len(re.findall("m|M", my_string)) len(re.findall(re.compile("m",re.IGNORECASE), my_string))
def check_freq(str): freq = {} for c in str: freq[c] = str.count(c) return freq check_freq("abbabcbdbabdbdbabababcbcbab") {
a = symbol = for key in symbol: print key, a.count(key)
str = "count a character occurance" List = list(str) print (List) Uniq = set(List) print (Uniq) for key in Uniq: print (key, str.count(key))
import re def count(s, ch): pass def main(): s = raw_input ("Enter strings what you like, for example, ch = raw_input ("Enter you want count characters, but best result to find one character: " ) print ( len (re.findall ( ch, s ) ) ) main()
spam = var = def count(spam, var): found = 0 for key in spam: if key == var: found += 1 return found count(spam, var) print
def count_letter_in_str(string,letter): return string.count(letter)
string = "count the number of counts in string to count from." x = string.count("count")
def count_char(string1): string2="" lst=[] lst1=[] for i in string1: count=0 if i not in lst: for j in string1: if i==j: count+=1 lst1.append(i) lst1.append(count) lst.append(i) string2= return string2 print count_char("aabbacddaabbdsrchhdsdg")
from werkzeug import BaseRequest class Request(BaseRequest): pass
from werkzeug import BaseRequest, AcceptMixin class Request(AcceptMixin, BaseRequest): pass
from werkzeug import BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthenticationMixin class Request(AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthenticationMixin, BaseRequest): pass
class ComparableMixin(object): def __ne__(self, other): return not (self == other) def __lt__(self, other): return self <= other and (self != other) def __gt__(self, other): return not self <= other def __ge__(self, other): return self == other or self > other class Integer(ComparableMixin): def __init__(self, i): self.i = i def __le__(self, other): return self.i <= other.i def __eq__(self, other): return self.i == other.i assert Integer(0) < Integer(1) assert Integer(0) != Integer(1) assert Integer(1) > Integer(0) assert Integer(1) >= Integer(1) o = ComparableMixin()
import functools @functools.total_ordering class Integer(object): def __init__(self, i): self.i = i def __le__(self, other): return self.i <= other.i def __eq__(self, other): return self.i == other.i assert Integer(0) < Integer(1) assert Integer(0) != Integer(1) assert Integer(1) > Integer(0) assert Integer(1) >= Integer(1)
class HasMethod1(object): def method(self): return 1 class HasMethod2(object): def method(self): return 2 class UsesMethod10(object): def usesMethod(self): return self.method() + 10 class UsesMethod20(object): def usesMethod(self): return self.method() + 20 class C1_10(HasMethod1, UsesMethod10): pass class C1_20(HasMethod1, UsesMethod20): pass class C2_10(HasMethod2, UsesMethod10): pass class C2_20(HasMethod2, UsesMethod20): pass assert C1_10().usesMethod() == 11 assert C1_20().usesMethod() == 21 assert C2_10().usesMethod() == 12 assert C2_20().usesMethod() == 22 class C3_10(UsesMethod10): def method(self): return 3 assert C3_10().usesMethod() == 13
class OrderedCounter(Counter, OrderedDict): def __repr__(self): return def __reduce__(self): return self.__class__, (OrderedDict(self),)
class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass
class ThreadingMixIn: daemon_threads = False def process_request_thread(self, request, client_address): try: self.finish_request(request, client_address) except Exception: self.handle_error(request, client_address) finally: self.shutdown_request(request) def process_request(self, request, client_address): t = threading.Thread(target = self.process_request_thread, args = (request, client_address)) t.daemon = self.daemon_threads t.start()
class SimpleInitReprMixin(object): __slots__ = () def __repr__(self): kwarg_strings = [] d = getattr(self, if d is not None: for k, v in d.items(): kwarg_strings.append( slots = getattr(self, if slots is not None: for k in slots: v = getattr(self, k, None) kwarg_strings.append( return name=type(self).__name__, kwargs= )
class Foo(SimpleInitReprMixin): __slots__ = def __init__(self, foo=None): self.foo = foo super(Foo, self).__init__()
>>> f1 = Foo( >>> f2 = Foo() >>> f1 Foo(foo= >>> f2 Foo(foo=None)
<(other) >(other) ==(other) <=(other) >=(other) between?(other)
module A def a1 end def a2 end end module B def b1 end def b2 end end class Sample include A include B def S1 end end samp = Sample.new samp.a1 samp.a2 samp.b1 samp.b2 samp.s1
class TestMilter(TestBase,spfmilter.spfMilter): def __init__(self): TestBase.__init__(self) spfmilter.config = spfmilter.Config() spfmilter.config.access_file = spfmilter.spfMilter.__init__(self)
def testPass(self): milter = TestMilter() rc = milter.connect( self.assertEqual(rc,Milter.CONTINUE) rc = milter.feedMsg( self.assertEqual(rc,Milter.CONTINUE) milter.close()
template <class T> class ComparableMixin { public: bool operator !=(ComparableMixin &other) { return ~(*static_cast<T*>(this) == static_cast<T&>(other)); } bool operator <(ComparableMixin &other) { return ((*(this) != other) && (*static_cast<T*>(this) <= static_cast<T&>(other))); } bool operator >(ComparableMixin &other) { return ~(*static_cast<T*>(this) <= static_cast<T&>(other)); } bool operator >=(ComparableMixin &other) { return ((*static_cast<T*>(this) == static_cast<T&>(other)) || (*(this) > other)); } }; class Integer: public ComparableMixin<Integer> { public: Integer(int i) { this->i = i; } int i; bool operator <=(Integer &other) { return (this->i <= other.i); } bool operator ==(Integer &other) { return (this->i == other.i); } }; int main() { Integer i(0) ; Integer j(1) ; assert (i < j ); assert (i != j); assert (j > i); assert (j >= i); return 0; }
for tup in somelist: if determine(tup): code_to_remove_tup
somelist = [x for x in somelist if not determine(x)]
somelist[:] = [x for x in somelist if not determine(x)]
from itertools import ifilterfalse somelist[:] = ifilterfalse(determine, somelist)
from itertools import filterfalse somelist[:] = filterfalse(determine, somelist)
somelist[:] = [tup for tup in somelist if determine(tup)]
>>> somelist = range(10) >>> for x in somelist: ... somelist.remove(x) >>> somelist [1, 3, 5, 7, 9] >>> somelist = range(10) >>> for x in somelist[:]: ... somelist.remove(x) >>> somelist []
for i in range(len(somelist) - 1, -1, -1): if some_condition(somelist, i): del somelist[i]
somelist = [tup for tup in somelist if determine(tup)]
newlist = [] for tup in somelist: if determine(tup): newlist.append(tup) somelist = newlist
for tup in somelist[:]: if determine(tup): newlist.append(tup)
somelist[:] = filter(lambda tup: not determine(tup), somelist)
from itertools import ifilterfalse somelist[:] = list(ifilterfalse(determine, somelist))
>>> for w in words[:]: ... if len(w) > 6: ... words.insert(0, w) ... >>> words [
for item in originalList: if (item != badValue): newList.append(item)
array = [lots of stuff] arraySize = len(array) i = 0 while i < arraySize: if someTest(array[i]): del array[i] arraySize -= 1 else: i += 1
>>> L1 = [(1,2), (5,6), (-1,-2), (1,-2)] >>> for (a,b) in L1: ... if a < 0 or b < 0: ... L1.remove(a,b) ... Traceback (most recent call last): File "<stdin>", line 3, in <module> TypeError: remove() takes exactly one argument (2 given)
L1 = [(1,2),(5,6),(-1,-2),(1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)] L1 is now: [(1, 2), (5, 6), (1, -2), (3, 4), (5, 7), (2, 1), (5, -1), (0, 6)]
L2 = L1 for (a,b) in L1: if a < 0 or b < 0 : L2.remove((a,b)) print L2 is L1 del L1 L1 = L2; del L2 print ("L1 is now: ", L1)
import copy L1 = [(1,2), (5,6),(-1,-2), (1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)] L2 = copy.copy(L1) for (a,b) in L1: if a < 0 or b < 0 : L2.remove((a,b)) del L1 L1 = L2; del L2 >>> L1 is now: [(1, 2), (5, 6), (3, 4), (5, 7), (2, 1), (0, 6)]
L1 = [(1,2), (5,6),(-1,-2), (1,-2),(3,4),(5,7),(-4,4),(2,1),(-3,-3),(5,-1),(0,6)] for (a,b) in reversed(L1): if a < 0 or b < 0 : L1.remove((a,b)) print ("L1 is now: ", L1) >>> L1 is now: [(1, 2), (5, 6), (3, 4), (5, 7), (2, 1), (0, 6)]
inlist = [{ for idx, i in enumerate(inlist): do some stuff with i[ if somecondition: xlist.append(idx) for i in reversed(xlist): del inlist[i]
list_len = len(some_list) for i in range(list_len): reverse_i = list_len - 1 - i cur = some_list[reverse_i] if some_condition: some_list.pop(reverse_i)
alist = [ i = 0 for x in alist[:]: if x == alist.pop(i) i -= 1 print(x) i += 1
k = range(5) v = [ d = {key:val for key,val in zip(k, v)} print d for i in range(5): print d[i] d.pop(i) print d
from fluidIter import FluidIterable fSomeList = FluidIterable(someList) for tup in fSomeList: if determine(tup): fSomeList.remove(tup)
from fluidIter import FluidIterable l = [0,1,2,3,4,5,6,7,8] fluidL = FluidIterable(l) for i in fluidL: print( print( print( print( print(
initial state of list on this iteration: [0, 1, 2, 3, 4, 5, 6, 7, 8] current iteration value: 0 popped value: 2 initial state of list on this iteration: [0, 1, 3, 4, 5, 6, 7, 8] current iteration value: 1 popped value: 3 initial state of list on this iteration: [0, 1, 4, 5, 6, 7, 8] current iteration value: 4 popped value: 4 initial state of list on this iteration: [0, 1, 5, 6, 7, 8] current iteration value: 5 popped value: 5 initial state of list on this iteration: [0, 1, 6, 7, 8] current iteration value: 6 popped value: 6 initial state of list on this iteration: [0, 1, 7, 8] current iteration value: 7 popped value: 7 initial state of list on this iteration: [0, 1, 8] current iteration value: 8 popped value: 8 Final List Value: [0, 1]
fluidArr = FluidIterable([0,1,2,3]) fluidArrIter = fluidArr.__iter__() for i, v in enumerate(fluidArrIter): print( print( print( print(fluidArr) fluidArr.insert(0, print( print(
enum: 0 current val: 0 current ind: 0 [0, 1, 2, 3] enum: 1 current val: 1 current ind: 2 [ enum: 2 current val: 2 current ind: 4 [ enum: 3 current val: 3 current ind: 6 [ Final List Value: [
randInts = [70, 20, 61, 80, 54, 18, 7, 18, 55, 9] fRandInts = FluidIterable(randInts) fRandIntsIter = fRandInts.__iter__() for i in fRandIntsIter: print( print( innerIntsIter = fRandInts.__iter__() for j in innerIntsIter: innerIndex = innerIntsIter.currentIndex if not innerIndex == fRandIntsIter.currentIndex: if j%i == 0: print( del fRandInts[innerIndex] print( print(
outer val: 70 outer val: 20 remove val: 80 outer val: 61 outer val: 54 outer val: 18 remove val: 54 remove val: 18 outer val: 7 remove val: 70 outer val: 55 outer val: 9 remove val: 18 final list: [20, 61, 7, 55, 9]
for i, item in enumerate(lst): if item % 4 == 0: foo(item) del lst[i] break
list(filter(lambda x:x%2==1, (1, 2, 4, 5, 6, 9, 10, 15)))
for tup in somelist: if ( sum(tup)==15 ): del somelist[somelist.index(tup)] print somelist >>> [(1, 2, 3), (3, 6, 6), (7, 8, 9), (10, 11, 12)]
newlist1 = [somelist[tup] for tup in range(len(somelist)) if(sum(somelist[tup])!=15)] print newlist1 >>>[(1, 2, 3), (7, 8, 9), (10, 11, 12)]
indices = [i for i in range(len(somelist)) if(sum(somelist[i])==15)] newlist2 = [tup for j, tup in enumerate(somelist) if j not in indices] print newlist2 >>>[(1, 2, 3), (7, 8, 9), (10, 11, 12)]
import numpy as np orig_list = np.array([1, 2, 3, 4, 5, 100, 8, 13]) remove_me = [100, 1] cleaned = np.delete(orig_list, remove_me) print(cleaned)
def generate_primes(n): primes = list(range(2,n)) idx = 0 while idx < len(primes): p = primes[idx] for multiple in range(p+p, n, p): try: primes.remove(multiple) except ValueError: pass idx += 1 yield p
i = 0 while i < len(somelist): if determine(somelist[i]): del somelist[i] else: i += 1
somelist = [x for x in somelist if not determine(x)]
import numpy as np from scipy.ndimage.filters import maximum_filter from scipy.ndimage.morphology import generate_binary_structure, binary_erosion import matplotlib.pyplot as pp paws_data = np.loadtxt("paws.txt").reshape(4,11,14) paws = [p.squeeze() for p in np.vsplit(paws_data,4)] def detect_peaks(image): """ Takes an image and detect the peaks usingthe local maximum filter. Returns a boolean mask of the peaks (i.e. 1 when the pixel """ neighborhood = generate_binary_structure(2,2) local_max = maximum_filter(image, footprint=neighborhood)==image background = (image==0) eroded_background = binary_erosion(background, structure=neighborhood, border_value=1) detected_peaks = local_max ^ eroded_background return detected_peaks for i, paw in enumerate(paws): detected_peaks = detect_peaks(paw) pp.subplot(4,2,(2*i+1)) pp.imshow(paw) pp.subplot(4,2,(2*i+2) ) pp.imshow(detected_peaks) pp.show()
from scipy import * from operator import itemgetter n = 5 d = loadtxt("paw.txt") width, height = d.shape fourSums = d[:-1,:-1] + d[1:,:-1] + d[1:,1:] + d[:-1,1:] pairs = zip(arange(width*height), fourSums.flatten()) def drop_overlapping(pairs): no_overlaps = [] def does_not_overlap(p1, p2): i1, i2 = p1[0], p2[0] r1, col1 = i1 / (width-1), i1 % (width-1) r2, col2 = i2 / (width-1), i2 % (width-1) return (max(abs(r1-r2),abs(col1-col2)) >= 2) for p in pairs: if all(map(lambda prev: does_not_overlap(p,prev), no_overlaps)): no_overlaps.append(p) return no_overlaps pairs2 = drop_overlapping(sorted(pairs, key=itemgetter(1), reverse=True)) positions = pairs2[:n] print d, "\n" for i, val in positions: row = i / (width-1) column = i % (width-1) print "sum = %f @ %d,%d (%d)" % (val, row, column, i) print d[row:row+2,column:column+2], "\n"
>>> a = arange(9).reshape(3,3) ; a array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
>>> a[:-1,:-1] array([[0, 1], [3, 4]]) >>> a[1:,:-1] array([[3, 4], [6, 7]]) >>> a[:-1,1:] array([[1, 2], [4, 5]]) >>> a[1:,1:] array([[4, 5], [7, 8]])
>>> sums = a[:-1,:-1] + a[1:,:-1] + a[:-1,1:] + a[1:,1:]; sums array([[ 8, 12], [20, 24]])
select the top N finger candidates (not too many, 10 or 12) consider all possible combinations of 5 out of N (use itertools.combinations) for each combination of 5 fingers: for each finger out of 5: fit the best circle to the remaining 4 => position of the center, radius check if the selected finger is inside of the circle check if the remaining four are evenly spread (for example, consider angles from the center of the circle) assign some cost (penalty) to this selection of 4 peaks + a rear finger (consider, probably weighted: circle fitting error, if the rear finger is inside, variance in the spreading of the front fingers, total intensity of 5 peaks) choose a combination of 4 peaks + a rear peak with the lowest penalty
<html> <head> <script type="text/javascript" src="http: <script type="text/javascript"> var heatmap = [[[0,0,0,0,0,0,0,4,4,0,0,0,0], [0,0,0,0,0,7,14,22,18,7,0,0,0], [0,0,0,0,11,40,65,43,18,7,0,0,0], [0,0,0,0,14,61,72,32,7,4,11,14,4], [0,7,14,11,7,22,25,11,4,14,65,72,14], [4,29,79,54,14,7,4,11,18,29,79,83,18], [0,18,54,32,18,43,36,29,61,76,25,18,4], [0,4,7,7,25,90,79,36,79,90,22,0,0], [0,0,0,0,11,47,40,14,29,36,7,0,0], [0,0,0,0,4,7,7,4,4,4,0,0,0] ],[ [0,0,0,4,4,0,0,0,0,0,0,0,0], [0,0,11,18,18,7,0,0,0,0,0,0,0], [0,4,29,47,29,7,0,4,4,0,0,0,0], [0,0,11,29,29,7,7,22,25,7,0,0,0], [0,0,0,4,4,4,14,61,83,22,0,0,0], [4,7,4,4,4,4,14,32,25,7,0,0,0], [4,11,7,14,25,25,47,79,32,4,0,0,0], [0,4,4,22,58,40,29,86,36,4,0,0,0], [0,0,0,7,18,14,7,18,7,0,0,0,0], [0,0,0,0,4,4,0,0,0,0,0,0,0], ],[ [0,0,0,4,11,11,7,4,0,0,0,0,0], [0,0,0,4,22,36,32,22,11,4,0,0,0], [4,11,7,4,11,29,54,50,22,4,0,0,0], [11,58,43,11,4,11,25,22,11,11,18,7,0], [11,50,43,18,11,4,4,7,18,61,86,29,4], [0,11,18,54,58,25,32,50,32,47,54,14,0], [0,0,14,72,76,40,86,101,32,11,7,4,0], [0,0,4,22,22,18,47,65,18,0,0,0,0], [0,0,0,0,4,4,7,11,4,0,0,0,0], ],[ [0,0,0,0,4,4,4,0,0,0,0,0,0], [0,0,0,4,14,14,18,7,0,0,0,0,0], [0,0,0,4,14,40,54,22,4,0,0,0,0], [0,7,11,4,11,32,36,11,0,0,0,0,0], [4,29,36,11,4,7,7,4,4,0,0,0,0], [4,25,32,18,7,4,4,4,14,7,0,0,0], [0,7,36,58,29,14,22,14,18,11,0,0,0], [0,11,50,68,32,40,61,18,4,4,0,0,0], [0,4,11,18,18,43,32,7,0,0,0,0,0], [0,0,0,0,4,7,4,0,0,0,0,0,0], ],[ [0,0,0,0,0,0,4,7,4,0,0,0,0], [0,0,0,0,4,18,25,32,25,7,0,0,0], [0,0,0,4,18,65,68,29,11,0,0,0,0], [0,4,4,4,18,65,54,18,4,7,14,11,0], [4,22,36,14,4,14,11,7,7,29,79,47,7], [7,54,76,36,18,14,11,36,40,32,72,36,4], [4,11,18,18,61,79,36,54,97,40,14,7,0], [0,0,0,11,58,101,40,47,108,50,7,0,0], [0,0,0,4,11,25,7,11,22,11,0,0,0], [0,0,0,0,0,4,0,0,0,0,0,0,0], ],[ [0,0,4,7,4,0,0,0,0,0,0,0,0], [0,0,11,22,14,4,0,4,0,0,0,0,0], [0,0,7,18,14,4,4,14,18,4,0,0,0], [0,4,0,4,4,0,4,32,54,18,0,0,0], [4,11,7,4,7,7,18,29,22,4,0,0,0], [7,18,7,22,40,25,50,76,25,4,0,0,0], [0,4,4,22,61,32,25,54,18,0,0,0,0], [0,0,0,4,11,7,4,11,4,0,0,0,0], ],[ [0,0,0,0,7,14,11,4,0,0,0,0,0], [0,0,0,4,18,43,50,32,14,4,0,0,0], [0,4,11,4,7,29,61,65,43,11,0,0,0], [4,18,54,25,7,11,32,40,25,7,11,4,0], [4,36,86,40,11,7,7,7,7,25,58,25,4], [0,7,18,25,65,40,18,25,22,22,47,18,0], [0,0,4,32,79,47,43,86,54,11,7,4,0], [0,0,0,14,32,14,25,61,40,7,0,0,0], [0,0,0,0,4,4,4,11,7,0,0,0,0], ],[ [0,0,0,0,4,7,11,4,0,0,0,0,0], [0,4,4,0,4,11,18,11,0,0,0,0,0], [4,11,11,4,0,4,4,4,0,0,0,0,0], [4,18,14,7,4,0,0,4,7,7,0,0,0], [0,7,18,29,14,11,11,7,18,18,4,0,0], [0,11,43,50,29,43,40,11,4,4,0,0,0], [0,4,18,25,22,54,40,7,0,0,0,0,0], [0,0,4,4,4,11,7,0,0,0,0,0,0], ],[ [0,0,0,0,0,7,7,7,7,0,0,0,0], [0,0,0,0,7,32,32,18,4,0,0,0,0], [0,0,0,0,11,54,40,14,4,4,22,11,0], [0,7,14,11,4,14,11,4,4,25,94,50,7], [4,25,65,43,11,7,4,7,22,25,54,36,7], [0,7,25,22,29,58,32,25,72,61,14,7,0], [0,0,4,4,40,115,68,29,83,72,11,0,0], [0,0,0,0,11,29,18,7,18,14,4,0,0], [0,0,0,0,0,4,0,0,0,0,0,0,0], ] ]; </script> </head> <body> <script type="text/javascript+protovis"> for (var a=0; a < heatmap.length; a++) { var w = heatmap[a][0].length, h = heatmap[a].length; var vis = new pv.Panel() .width(w * 6) .height(h * 6) .strokeStyle(" .lineWidth(4) .antialias(true); vis.add(pv.Image) .imageWidth(w) .imageHeight(h) .image(pv.Scale.linear() .domain(0, 99, 100) .range(" .by(function(i, j) heatmap[a][j][i])); vis.render(); } </script> </body> </html>
E(X_i;S)=-Sum_i(S(X_i))+alfa*Sum_ij (|X_i-Xj|<=2*sqrt(2)?1:0)
import numpy as np grid = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0.4,0.4,0.4,0,0,0], [0,0,0,0,0.4,1.4,1.4,1.8,0.7,0,0,0,0,0], [0,0,0,0,0.4,1.4,4,5.4,2.2,0.4,0,0,0,0], [0,0,0.7,1.1,0.4,1.1,3.2,3.6,1.1,0,0,0,0,0], [0,0.4,2.9,3.6,1.1,0.4,0.7,0.7,0.4,0.4,0,0,0,0], [0,0.4,2.5,3.2,1.8,0.7,0.4,0.4,0.4,1.4,0.7,0,0,0], [0,0,0.7,3.6,5.8,2.9,1.4,2.2,1.4,1.8,1.1,0,0,0], [0,0,1.1,5,6.8,3.2,4,6.1,1.8,0.4,0.4,0,0,0], [0,0,0.4,1.1,1.8,1.8,4.3,3.2,0.7,0,0,0,0,0], [0,0,0,0,0,0.4,0.7,0.4,0,0,0,0,0,0]]) arr = [] for i in xrange(grid.shape[0] - 1): for j in xrange(grid.shape[1] - 1): tot = grid[i][j] + grid[i+1][j] + grid[i][j+1] + grid[i+1][j+1] arr.append([(i,j),tot]) best = [] arr.sort(key = lambda x: x[1]) for i in xrange(5): best.append(arr.pop()) badpos = set([(best[-1][0][0]+x,best[-1][0][1]+y) for x in [-1,0,1] for y in [-1,0,1] if x != 0 or y != 0]) for j in xrange(len(arr)-1,-1,-1): if arr[j][0] in badpos: arr.pop(j) for item in best: print grid[item[0][0]:item[0][0]+2,item[0][1]:item[0][1]+2]
require NUM_PEAKS = 5 NEIGHBOR_DISTANCE = 1 data = [[1,2,3,4,5], [2,6,4,4,6], [3,6,7,4,3], ] def tuples(matrix) tuples = [] matrix.each_with_index { |row, ri| row.each_with_index { |value, ci| tuples << [value, ri, ci] } } tuples end def neighbor?(t1, t2, distance = 1) [1,2].each { |axis| return false if (t1[axis] - t2[axis]).abs > distance } true end sorted = tuples(data).sort_by { |tuple| tuple.first }.reverse non_neighboring_peaks = [] sorted.each { |candidate| if non_neighboring_peaks.empty? non_neighboring_peaks << candidate puts "took the first peak: else is_ok = true non_neighboring_peaks.each { |accepted| if neighbor?(candidate, accepted, NEIGHBOR_DISTANCE) is_ok = false break end } if is_ok non_neighboring_peaks << candidate puts "took else puts "denied end end } pp non_neighboring_peaks
a=[1,2,3,4] try: b=a.index(6) del a[b] except: pass print a
>>> a = [10, 20, 30, 40, 20, 30, 40, 20, 70, 20] >>> a = [x for x in a if x != 20] >>> print a [10, 30, 40, 30, 40, 70]
def remove_all(seq, value): pos = 0 for item in seq: if item != value: seq[pos] = item pos += 1 del seq[pos:]
a = [0, 1, 1, 0, 1, 2, 1, 3, 1, 4] while a.count(1) > 0: a.remove(1)
from contextlib import suppress with suppress(ValueError): a.remove(
>>> a = [1, 2, 3, 4] >>> try: ... a.remove(6) ... except ValueError: ... pass ... >>> print a [1, 2, 3, 4] >>> try: ... a.remove(3) ... except ValueError: ... pass ... >>> print a [1, 2, 4]
def remove_if_exists(L, value): try: L.remove(value) except ValueError: pass
a = [1,2,3,1,2,3,4] while True: try: a.remove(3) except: break print a >>> [1, 2, 1, 2, 4]
c = [1,2,3,4, z = list(set(c) - set([ print z [1, 2, 3, 4, 6, 7, 8, 9]
>>> lst = [23,34,54,45] >>> remove_element = 23 >>> if remove_element in lst: ... lst.pop(lst.index(remove_element)) ... 23 >>> lst [34, 54, 45] >>>
>>> s = [5,4,3,2,1] >>> s[0:2] + s[3:] [5, 4, 2, 1]
def cleaner(seq, value): temp = [] for number in seq: if number != value: temp.append(number) return temp
def cleaner(seq, value, occ): temp = [] for number in seq: if number == value and occ: occ -= 1 continue else: temp.append(number) return temp
list1=[1,2,3,3,4,5,6,1,3,4,5] n=int(input( while n in list1: list1.remove(n) print(list1)
def Function(List, Unwanted): [List.remove(Unwanted) for Item in range(List.count(Unwanted))] return List x = Function(x, 1) print(x)
[x.remove(1) for Item in range(x.count(1))] print(x)
c = len(list)-1 for element in (reversed(list)): if condition(element): del list[c] c -= 1 print(list)
for i, element in enumerate(reversed(list)): if condition(element): del list[(i+1)*-1] print(list)
arr = [1, 1, 3, 4, 5, 2, 4, 3] arr.remove(3) new_arr = [element for element in arr if element!=3] removed_element = arr.pop(4) del arr[4]
$ python speechToText.py -v [ $ python speechToText.py -x [ $ python speechToText.py -v -v [ $ python speechToText.py -v -v -x [
import sys a = [1, 2, 3, 4] y = 0 if y < 1: a.remove(1) print len(a) else: sys.exit()
$ python -mtimeit -s 10000000 loops, best of 3: 0.0983 usec per loop $ python -mtimeit -s 1000000 loops, best of 3: 0.21 usec per loop
ages = {} ages[ ages[ ages[ ages[ if print "Sue is in the dictionary. She is", ages[ else: print "Sue is not in the dictionary"
$ python3.5 -mtimeit -s Traceback (most recent call last): File "/usr/local/Cellar/python3/3.5.2_3/Frameworks/Python.framework/Versions/3.5/lib/python3.5/timeit.py", line 301, in main x = t.timeit(number) File "/usr/local/Cellar/python3/3.5.2_3/Frameworks/Python.framework/Versions/3.5/lib/python3.5/timeit.py", line 178, in timeit timing = self.inner(it, self.timer) File "<timeit-src>", line 6, in inner d.has_key(12) AttributeError: $ python2.7 -mtimeit -s 10000000 loops, best of 3: 0.0872 usec per loop $ python2.7 -mtimeit -s 10000000 loops, best of 3: 0.0858 usec per loop $ python3.5 -mtimeit -s 10000000 loops, best of 3: 0.031 usec per loop $ python3.5 -mtimeit -s 10000000 loops, best of 3: 0.033 usec per loop $ python3.5 -mtimeit -s 10000000 loops, best of 3: 0.115 usec per loop $ python3.5 -mtimeit -s 10000000 loops, best of 3: 0.117 usec per loop
BeautifulSoup==3.2.0 Django==1.3 Fabric==1.2.0 Jinja2==2.5.5 PyYAML==3.09 Pygments==1.4 SQLAlchemy==0.7.1 South==0.7.3 amqplib==0.6.1 anyjson==0.3 ...
source bin/activate pip install -r /path/to/requirements.txt -f file:
Downloading/unpacking Fabric==1.2.0 (from -r ../testing/requirements.txt (line 3)) Running setup.py egg_info for package Fabric warning: no previously-included files matching warning: no files found matching Downloading/unpacking South==0.7.3 (from -r ../testing/requirements.txt (line 8)) Running setup.py egg_info for package South ....
$ pip install -r requirements.txt --no-index --find-links file:
sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk
$ python -c [ $ pip --version pip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)
$ pip --version pip 9.0.1 from /usr/local/lib/python3.6/site-packages (python 3.6) $ python -c [ $ which pip pip2 pip3 /usr/local/bin/pip /usr/local/bin/pip3
$ which -a python python2 python3 /usr/local/bin/python /usr/bin/python /usr/local/bin/python2 /usr/local/bin/python3 $ /usr/bin/python -m pip install -r requirements.txt
def constant(f): def fset(self, value): raise TypeError def fget(self): return f() return property(fget, fset) class _Const(object): @constant def FOO(): return 0xBAADFACE @constant def BAR(): return 0xDEADBEEF CONST = _Const() print CONST.FOO CONST.FOO = 0
class _Const(object): @apply def FOO(): def fset(self, value): raise TypeError def fget(self): return 0xBAADFACE return property(**locals()) CONST = _Const() print CONST.FOO CONST.FOO = 0
>>> from collections import namedtuple >>> Constants = namedtuple( >>> constants = Constants(3.14, 2.718) >>> constants.pi 3.14 >>> constants.pi = 3 Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: can
class CONST(object): FOO = 1234 def __setattr__(self, *_): pass CONST = CONST() print CONST.FOO CONST.FOO = 4321 CONST.BAR = 5678 print CONST.FOO print CONST.BAR
>>> from named_constants import Constants >>> class Colors(Constants): ... black = 0 ... red = 1 ... white = 15 ... >>> c = Colors.black >>> c == 0 True >>> c Colors.black >>> c.name() >>> Colors(0) is c True
class MetaConst(type): def __getattr__(cls, key): return cls[key] def __setattr__(cls, key, value): raise TypeError
class Const(object): __metaclass__ = MetaConst def __getattr__(self, name): return self[name] def __setattr__(self, name, value): raise TypeError
class Const(object, metaclass=MetaConst): def __getattr__(self, name): return self[name] def __setattr__(self, name, value): raise TypeError
MyConst.A my_const = MyConst() my_const.A MyConst.A = my_const.A =
class Constants(object): """ Create objects with read-only (constant) attributes. Example: Nums = Constants(ONE=1, PI=3.14159, DefaultWidth=100.0) print 10 + Nums.PI print Nums.PI = 22 """ def __init__(self, *args, **kwargs): self._d = dict(*args, **kwargs) def __iter__(self): return iter(self._d) def __len__(self): return len(self._d) def __getattr__(self, name): return self._d[name] def __setattr__(self, name, value): if (name[0] == super(Constants, self).__setattr__(name, value) else: raise ValueError("setattr while locked", self) if (__name__ == "__main__"): Nums = Constants(ONE=1, PI=3.14159, DefaultWidth=100.0) print 10 + Nums.PI print Nums.PI = 22
class MyFinalProperty(object): @property def name(self): return "John"
class const(object): def __init__(self, val): super(const, self).__setattr__("value", val) def __setattr__(self, name, val): raise ValueError("Trying to change a constant value", self)
>>> constObj = const("Try to change me") >>> constObj.value >>> constObj.value = "Changed" Traceback (most recent call last): ... ValueError: Trying to change a constant value >>> constObj2 = const(" or not") >>> mutableObj = constObj.value + constObj2.value >>> mutableObj
public class Foo { public static final String CONST_NAME = "Name"; }
from collections import namedtuple Foo = namedtuple(
import collections __all__ = ( class Constant(object): """ Implementation strict constants in Python 3. A constant can be set up, but can not be changed or deleted. Value of constant may any immutable type, as well as list or set. Besides if value of a constant is list or set, it will be converted in an immutable type as next: list -> tuple set -> frozenset Dict as value of a constant has no support. >>> const = Constant() >>> del const.temp Traceback (most recent call last): NameError: name >>> const.temp = 1 >>> const.temp = 88 Traceback (most recent call last): ... TypeError: Constanst can not be changed >>> del const.temp Traceback (most recent call last): ... TypeError: Constanst can not be deleted >>> const.I = [ >>> print(const.I) ( >>> const.F = {1.2} >>> print(const.F) frozenset([1.2]) >>> const.D = dict() Traceback (most recent call last): ... TypeError: dict can not be used as constant >>> del const.UNDEFINED Traceback (most recent call last): ... NameError: name >>> const() { """ def __setattr__(self, name, value): if name in self.__dict__: raise TypeError( if not isinstance(value, collections.Hashable): if isinstance(value, list): value = tuple(value) elif isinstance(value, set): value = frozenset(value) elif isinstance(value, dict): raise TypeError( else: raise ValueError( self.__dict__[name] = value def __delattr__(self, name): if name in self.__dict__: raise TypeError( raise NameError("name def __call__(self): return self.__dict__ const = Constant() if __name__ == import doctest doctest.testmod()
import decimal import uuid import datetime import unittest from ..constants import Constant class TestConstant(unittest.TestCase): def setUp(self): self.const = Constant() def tearDown(self): del self.const def test_create_constant_with_different_variants_of_name(self): self.const.CONSTANT = 1 self.assertEqual(self.const.CONSTANT, 1) self.const.Constant = 2 self.assertEqual(self.const.Constant, 2) self.const.ConStAnT = 3 self.assertEqual(self.const.ConStAnT, 3) self.const.constant = 4 self.assertEqual(self.const.constant, 4) self.const.co_ns_ta_nt = 5 self.assertEqual(self.const.co_ns_ta_nt, 5) self.const.constant1111 = 6 self.assertEqual(self.const.constant1111, 6) def test_create_and_change_integer_constant(self): self.const.INT = 1234 self.assertEqual(self.const.INT, 1234) with self.assertRaisesRegexp(TypeError, self.const.INT = .211 def test_create_and_change_float_constant(self): self.const.FLOAT = .1234 self.assertEqual(self.const.FLOAT, .1234) with self.assertRaisesRegexp(TypeError, self.const.FLOAT = .211 def test_create_and_change_list_constant_but_saved_as_tuple(self): self.const.LIST = [1, .2, None, True, datetime.date.today(), [], {}] self.assertEqual(self.const.LIST, (1, .2, None, True, datetime.date.today(), [], {})) self.assertTrue(isinstance(self.const.LIST, tuple)) with self.assertRaisesRegexp(TypeError, self.const.LIST = .211 def test_create_and_change_none_constant(self): self.const.NONE = None self.assertEqual(self.const.NONE, None) with self.assertRaisesRegexp(TypeError, self.const.NONE = .211 def test_create_and_change_boolean_constant(self): self.const.BOOLEAN = True self.assertEqual(self.const.BOOLEAN, True) with self.assertRaisesRegexp(TypeError, self.const.BOOLEAN = False def test_create_and_change_string_constant(self): self.const.STRING = "Text" self.assertEqual(self.const.STRING, "Text") with self.assertRaisesRegexp(TypeError, self.const.STRING += with self.assertRaisesRegexp(TypeError, self.const.STRING = def test_create_dict_constant(self): with self.assertRaisesRegexp(TypeError, self.const.DICT = {} def test_create_and_change_tuple_constant(self): self.const.TUPLE = (1, .2, None, True, datetime.date.today(), [], {}) self.assertEqual(self.const.TUPLE, (1, .2, None, True, datetime.date.today(), [], {})) with self.assertRaisesRegexp(TypeError, self.const.TUPLE = def test_create_and_change_set_constant(self): self.const.SET = {1, .2, None, True, datetime.date.today()} self.assertEqual(self.const.SET, {1, .2, None, True, datetime.date.today()}) self.assertTrue(isinstance(self.const.SET, frozenset)) with self.assertRaisesRegexp(TypeError, self.const.SET = 3212 def test_create_and_change_frozenset_constant(self): self.const.FROZENSET = frozenset({1, .2, None, True, datetime.date.today()}) self.assertEqual(self.const.FROZENSET, frozenset({1, .2, None, True, datetime.date.today()})) with self.assertRaisesRegexp(TypeError, self.const.FROZENSET = True def test_create_and_change_date_constant(self): self.const.DATE = datetime.date(1111, 11, 11) self.assertEqual(self.const.DATE, datetime.date(1111, 11, 11)) with self.assertRaisesRegexp(TypeError, self.const.DATE = True def test_create_and_change_datetime_constant(self): self.const.DATETIME = datetime.datetime(2000, 10, 10, 10, 10) self.assertEqual(self.const.DATETIME, datetime.datetime(2000, 10, 10, 10, 10)) with self.assertRaisesRegexp(TypeError, self.const.DATETIME = None def test_create_and_change_decimal_constant(self): self.const.DECIMAL = decimal.Decimal(13123.12312312321) self.assertEqual(self.const.DECIMAL, decimal.Decimal(13123.12312312321)) with self.assertRaisesRegexp(TypeError, self.const.DECIMAL = None def test_create_and_change_timedelta_constant(self): self.const.TIMEDELTA = datetime.timedelta(days=45) self.assertEqual(self.const.TIMEDELTA, datetime.timedelta(days=45)) with self.assertRaisesRegexp(TypeError, self.const.TIMEDELTA = 1 def test_create_and_change_uuid_constant(self): value = uuid.uuid4() self.const.UUID = value self.assertEqual(self.const.UUID, value) with self.assertRaisesRegexp(TypeError, self.const.UUID = [] def test_try_delete_defined_const(self): self.const.VERSION = with self.assertRaisesRegexp(TypeError, del self.const.VERSION def test_try_delete_undefined_const(self): with self.assertRaisesRegexp(NameError, "name del self.const.UNDEFINED def test_get_all_defined_constants(self): self.assertDictEqual(self.const(), {}) self.const.A = 1 self.assertDictEqual(self.const(), { self.const.B = "Text" self.assertDictEqual(self.const(), {
>>> constants = {"foo":1, "bar":2} >>> print constants { >>> constants["bar"] = 3 >>> print constants {
from pconst import const const.APPLE_PRICE = 100 const.APPLE_PRICE = 200
def const(func): def fset(self, val): class ConstError(TypeError): pass raise ConstError def fget(self): return func() return property(fget, fset) class Consts(object): @const def C1(): return bytearray.fromhex( @const def pi(): return 3.141592653589793
>>> c = Consts() >>> c.pi = 6.283185307179586 Traceback (most recent call last): File "<stdin>", line 1, in <module> File "consts.py", line 9, in fset raise ConstError __main__.ConstError >>> c.C1[0] = 0 >>> c.C1[0] 222 >>> c.C1 bytearray(b
import sys PY_VER = sys.version.split()[0].split( if int(PY_VER[0]) == 2: if int(PY_VER[1]) < 6: raise NotImplementedError elif int(PY_VER[1]) == 6: memoryview = buffer class ConstArray(object): def __init__(self, init): create a hidden bytearray and expose a memoryview of that bytearray for read-only use if int(PY_VER[1]) == 6: self.__array = bytearray(init.decode( else: self.__array = bytearray.fromhex(init) self.array = memoryview(self.__array) def __str__(self): return str(self.__array) def __getitem__(self, *args, **kwargs): return self.array.__getitem__(*args, **kwargs)
>>> C1 = ConstArray( >>> C1[0] = 0 Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: >>> C1[0] 222
from __future__ import print_function from kkconst import ( BaseConst, ConstFloatField, ) class MathConst(BaseConst): PI = ConstFloatField(3.1415926, verbose_name=u"Pi") E = ConstFloatField(2.7182818284, verbose_name=u"mathematical constant") GOLDEN_RATIO = ConstFloatField(0.6180339887, verbose_name=u"Golden Ratio") magic_num = MathConst.GOLDEN_RATIO assert isinstance(magic_num, ConstFloatField) assert isinstance(magic_num, float) print(magic_num) print(magic_num.verbose_name)
import numpy as np CONSTANT = CONSTANT = np.array([CONSTANT]) CONSTANT.flags.writeable = False print new_value = try: CONSTANT[0] = new_value except: print "cannot change CONSTANT to new_value, CONSTANT[0]) CONSTANT[0] = new_value >>> CONSTANT hello cannot change CONSTANT to Traceback (most recent call last): File "shuffle_test.py", line 15, in <module> CONSTANT[0] = new_value ValueError: assignment destination is read-only
class Constant: def __init__(self,value=None): self.value = value def __get__(self,instance,owner): return self.value def __set__(self,instance,value): raise ValueError("You can class A: NULL = Constant() NUM = Constant(0xFF) class B: NAME = Constant( LISTA = Constant([0,1, >>> obj=A() >>> print(obj.NUM) >>> obj.NUM =100 Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: You can
val = const_val = StringVar(val) const.trace( def reverse(*args): const_val.set(val)
from collections import namedtuple def make_consts(name, **kwargs): return namedtuple(name, kwargs.keys())(**kwargs)
class const(object): def __init__(self, val): super(const, self).__setattr__("value", val) def __setattr__(self, name, val): raise ValueError("Trying to change a constant value", self) def __repr__(self): return ( dt = const(float(0.01)) print dt
class ConstDict(dict): def __init__(self, *args, **kwargs): super(ConstDict, self).__init__(*args, **kwargs) def __setitem__(self, key, value): if key in self: raise ValueError("Value %s already exists" % (key)) super(ConstDict, self).__setitem__(key, value)
const = Const().add(two=2, three=3) print print const.add(four=4) print const.add(six=6) print const2 = Const().add(five=5) print const2.add(five=26)
from copy import copy class Const(object): "A class to create objects with constant fields." def __init__(self): object.__setattr__(self, def add(self, **nameVals): for name, val in nameVals.iteritems(): if hasattr(self, name): raise ConstError( setattr(self, name, copy(val)) self._names.append(name) return self def __setattr__(self, name, val): if name in self._names: raise ConstError( object.__setattr__(self, name, val)
2 0 SETUP_LOOP 20 (to 23) 3 LOAD_GLOBAL 0 (xrange) 6 LOAD_CONST 3 (100000000) 9 CALL_FUNCTION 1 12 GET_ITER >> 13 FOR_ITER 6 (to 22) 16 STORE_FAST 0 (i) 3 19 JUMP_ABSOLUTE 13 >> 22 POP_BLOCK >> 23 LOAD_CONST 0 (None) 26 RETURN_VALUE
1 0 SETUP_LOOP 20 (to 23) 3 LOAD_NAME 0 (xrange) 6 LOAD_CONST 3 (100000000) 9 CALL_FUNCTION 1 12 GET_ITER >> 13 FOR_ITER 6 (to 22) 16 STORE_NAME 1 (i) 2 19 JUMP_ABSOLUTE 13 >> 22 POP_BLOCK >> 23 LOAD_CONST 2 (None) 26 RETURN_VALUE
>> 13 FOR_ITER 6 (to 22) 16 STORE_FAST 0 (x) 19 JUMP_ABSOLUTE 13
import timeit start = timeit.timeit() print "hello" end = timeit.timeit() print end - start
import time start = time.time() print("hello") end = time.time() print(end - start)
from timeit import default_timer as timer start = timer() end = timer() print(end - start)
import time t = time.process_time() elapsed_time = time.process_time() - t
% python -mtimeit -s 1000000 loops, best of 3: 0.254 usec per loop
from datetime import datetime start_time = datetime.now() time_elapsed = datetime.now() - start_time print(
with elapsed_timer() as elapsed: print( "midpoint at %.2f seconds" % elapsed() ) print( "all done at %.2f seconds" % elapsed() )
from contextlib import contextmanager from timeit import default_timer @contextmanager def elapsed_timer(): start = default_timer() elapser = lambda: default_timer() - start yield lambda: elapser() end = default_timer() elapser = lambda: end-start
import time with elapsed_timer() as elapsed: time.sleep(1) print(elapsed()) time.sleep(2) print(elapsed()) time.sleep(3)
class Timer: def __init__(self): self.start = time.time() def restart(self): self.start = time.time() def get_time_hhmmss(self): end = time.time() m, s = divmod(end - self.start, 60) h, m = divmod(m, 60) time_str = "%02d:%02d:%02d" % (h, m, s) return time_str
my_timer = Timer() time_hhmmss = my_timer.get_time_hhmmss() print("Time elapsed: %s" % time_hhmmss ) my_timer.restart() time_hhmmss = my_timer.get_time_hhmmss()
import time def hello(): print "Hello :)" time.sleep(0.1) def thankyou(): print "Thank you!" time.sleep(0.05) for idx in range(10): hello() for idx in range(100): thankyou()
python -m cProfile -o timeStats.profile timeFunctions.py
Welcome to the profile statistics browser. timeStats.profile% stats hello <timestamp> timeStats.profile 224 function calls in 6.014 seconds Random listing order was used List reduced from 6 to 1 due to restriction < ncalls tottime percall cumtime percall filename:lineno(function) 10 0.000 0.000 1.001 0.100 timeFunctions.py:3(hello) timeStats.profile% stats thankyou <timestamp> timeStats.profile 224 function calls in 6.014 seconds Random listing order was used List reduced from 6 to 1 due to restriction < ncalls tottime percall cumtime percall filename:lineno(function) 100 0.002 0.000 5.012 0.050 timeFunctions.py:7(thankyou)
from benchmark import benchmark with benchmark("Test 1+1"): 1+1 => Test 1+1 : 1.41e-06 seconds
with benchmark("Test 1+1") as b: 1+1 print(b.time) => Test 1+1 : 7.05e-07 seconds 7.05233786763e-07
from timeit import default_timer as timer class benchmark(object): def __init__(self, msg, fmt="%0.3g"): self.msg = msg self.fmt = fmt def __enter__(self): self.start = timer() return self def __exit__(self, *args): t = timer() - self.start print(("%s : " + self.fmt + " seconds") % (self.msg, t)) self.time = t
5 function calls in 0.047 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.000 0.000 :0(exec) 1 0.047 0.047 0.047 0.047 :0(setprofile) 1 0.000 0.000 0.000 0.000 <string>:1(<module>) 0 0.000 0.000 profile:0(profiler) 1 0.000 0.000 0.047 0.047 profile:0(main()) 1 0.000 0.000 0.000 0.000 two_sum.py:2(twoSum)
from time import sleep, perf_counter as pc t0 = pc() sleep(1) print(pc()-t0)
import time def timed(fun, *args): s = time.time() r = fun(*args) print( return(r) timed(print, "Hello")
from timeit import timeit def func(): return 1 + 1 time = timeit(func, number=1) print(time)
import time, datetime start = time.clock() def num_multi1(max): result = 0 for num in range(0, 1000): if (num % 3 == 0 or num % 5 == 0): result += num print "Sum is %d " % result num_multi1(1000) end = time.clock() value = end - start timestamp = datetime.datetime.fromtimestamp(value) print timestamp.strftime(
from pythonbenchmark import compare, measure import time a,b,c,d,e = 10,10,10,10,10 something = [a,b,c,d,e] @measure def myFunction(something): time.sleep(0.4) @measure def myOptimizedFunction(something): time.sleep(0.2) myFunction(input) myOptimizedFunction(input)
>>> import timeit >>> def naive_func(x): ... a = 0 ... for i in range(a): ... a += i ... return a >>> def wrapper(func, *args, **kwargs): ... def wrapper(): ... return func(*args, **kwargs) ... return wrapper >>> wrapped = wrapper(naive_func, 1_000) >>> timeit.timeit(wrapped, number=1_000_000) 0.4458435332577161
from functools import wraps import gc import timeit def MeasureTime(f): @wraps(f) def _wrapper(*args, **kwargs): gcold = gc.isenabled() gc.disable() start_time = timeit.default_timer() try: result = f(*args, **kwargs) finally: elapsed = timeit.default_timer() - start_time if gcold: gc.enable() print( return result return _wrapper class MeasureBlockTime: def __init__(self,name="(block)", no_print = False, disable_gc = True): self.name = name self.no_print = no_print self.disable_gc = disable_gc def __enter__(self): if self.disable_gc: self.gcold = gc.isenabled() gc.disable() self.start_time = timeit.default_timer() def __exit__(self,ty,val,tb): self.elapsed = timeit.default_timer() - self.start_time if self.disable_gc and self.gcold: gc.enable() if not self.no_print: print( return False
import utils @utils.MeasureTime def MyBigFunc(): for i in range(10000): print(i)
import utils with utils.MeasureBlockTime("MyBlock"): for i in range(10000): print(i)
import time start = time.time() sleep(5) finish = time.time() elapsed = finish - start print(elapsed)
In [1]: %%timeit ...: complex_func() ...: 2 + 2 == 5 ...: ...: 1 s ± 1.93 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
import os import platform def creation_date(path_to_file): """ Try to get the date that a file was created, falling back to when it was last modified if that isn See http: """ if platform.system() == return os.path.getctime(path_to_file) else: stat = os.stat(path_to_file) try: return stat.st_birthtime except AttributeError: return stat.st_mtime
import os.path, time print("last modified: %s" % time.ctime(os.path.getmtime(file))) print("created: %s" % time.ctime(os.path.getctime(file)))
import os, time (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file) print("last modified: %s" % time.ctime(mtime))
import os import datetime def modification_date(filename): t = os.path.getmtime(filename) return datetime.datetime.fromtimestamp(t)
>>> d = modification_date( >>> print d 2009-10-06 10:50:01 >>> print repr(d) datetime.datetime(2009, 10, 6, 10, 50, 1)
>>> import os >>> statinfo = os.stat( >>> statinfo (33188, 422511L, 769L, 1, 1032, 100, 926L, 1105022698,1105022732, 1105022732) >>> statinfo.st_size 926L >>>
>>> import os >>> os.stat( 1136961142.0 >>> os.stat( 1222664012.233 >>>
>>> import pathlib >>> fname = pathlib.Path( >>> assert fname.exists(), f >>> print(fname.stat()) os.stat_result(st_mode=33206, st_ino=5066549581564298, st_dev=573948050, st_nlink=1, st_uid=0, st_gid=0, st_size=413, st_atime=1523480272, st_mtime=1539787740, st_ctime=1523480272)
>>> import datetime >>> mtime = datetime.datetime.fromtimestamp(fname.stat().st_mtime) >>> print(mtime) datetime.datetime(2018, 10, 17, 10, 49, 0, 249980)
>>> ctime = datetime.datetime.fromtimestamp(fname.stat().st_ctime) >>> print(ctime) datetime.datetime(2018, 4, 11, 16, 57, 52, 151953)
>>> os.lstat("2048.py") posix.stat_result(st_mode=33188, st_ino=4172202, st_dev=16777218L, st_nlink=1, st_uid=501, st_gid=20, st_size=2078, st_atime=1423378041, st_mtime=1423377552, st_ctime=1423377553) >>> os.lstat("2048.py").st_atime 1423378041.0
import os, time, datetime file = "somefile.txt" print(file) print("Modified") print(os.stat(file)[-2]) print(os.stat(file).st_mtime) print(os.path.getmtime(file)) print() print("Created") print(os.stat(file)[-1]) print(os.stat(file).st_ctime) print(os.path.getctime(file)) print() modified = os.path.getmtime(file) print("Date modified: "+time.ctime(modified)) print("Date modified:",datetime.datetime.fromtimestamp(modified)) year,month,day,hour,minute,second=time.localtime(modified)[:-3] print("Date modified: %02d/%02d/%d %02d:%02d:%02d"%(day,month,year,hour,minute,second)) print() created = os.path.getctime(file) print("Date created: "+time.ctime(created)) print("Date created:",datetime.datetime.fromtimestamp(created)) year,month,day,hour,minute,second=time.localtime(created)[:-3] print("Date created: %02d/%02d/%d %02d:%02d:%02d"%(day,month,year,hour,minute,second))
somefile.txt Modified 1429613446 1429613446.0 1429613446.0 Created 1517491049 1517491049.28306 1517491049.28306 Date modified: Tue Apr 21 11:50:46 2015 Date modified: 2015-04-21 11:50:46 Date modified: 21/04/2015 11:50:46 Date created: Thu Feb 1 13:17:29 2018 Date created: 2018-02-01 13:17:29.283060 Date created: 01/02/2018 13:17:29
805306374 3382786932 -rwx------ 1 km staff 0 1098083 "Aug 29 12:02:05 2013" "Aug 29 12:02:05 2013" "Aug 29 12:02:20 2013" "Aug 27 12:35:28 2013" 61440 2150 0 testfile.txt
python -c "import site; print(site.getsitepackages())"
python -c "from distutils.sysconfig import get_python_lib; print(get_python_lib())"
from distutils.sysconfig import get_python_lib print(get_python_lib())
python -c "from distutils.sysconfig import get_python_lib; print get_python_lib()"
>>> import django >>> dir(django) [ >>> print django.__path__ [
import distutils.sysconfig print distutils.sysconfig.get_python_lib()
from distutils.sysconfig import get_python_lib print get_python_lib()
from setuptools.command.easy_install import easy_install class easy_install_default(easy_install): def __init__(self): from distutils.dist import Distribution dist = Distribution() self.distribution = dist self.initialize_options() self._dry_run = None self.verbose = dist.verbose self.force = None self.help = 0 self.finalized = 0 e = easy_install_default() import distutils.errors try: e.finalize_options() except distutils.errors.DistutilsError: pass print e.install_dir
import sys; print [f for f in sys.path if f.endswith(
from distutils.sysconfig import get_python_lib print get_python_lib()
pip install ipython ipython import imaplib imaplib?
Type: module String form: <module File: /usr/lib/python2.7/imaplib.py Docstring: IMAP4 client. Based on RFC 2060. Public class: IMAP4 Public variable: Debug Public functions: Internaldate2tuple Int2AP ParseFlags Time2Internaldate
import sys import os from distutils.command.install import INSTALL_SCHEMES if os.name == scheme_key = else: scheme_key = print(INSTALL_SCHEMES[scheme_key][
>>> l = dir(__builtins__) >>> d = __builtins__.__dict__
>>> from pprint import pprint >>> pprint(l) [ ... >>> pprint(d, indent=2) { ... ...
from pprint import pprint pprint(vars(your_object))
def dump(obj): for attr in dir(obj): print("obj.%s = %r" % (attr, getattr(obj, attr)))
class O: def __init__ (self): self.value = 3 o = O()
>>> import sys >>> dir(sys) [ t__ , ncoding version ache , >>>
>>> help(sys) Help on built-in module sys: NAME sys FILE (built-in) MODULE DOCS http: DESCRIPTION This module provides access to some objects used or maintained by the interpreter and to functions that interact strongly with the interpreter. Dynamic objects: argv -- command line arguments; argv[0] is the script pathname if known
import sys if len(sys.argv) > 2: module, metaklass = sys.argv[1:3] m = __import__(module, globals(), locals(), [metaklass]) __metaclass__ = getattr(m, metaklass) class Data: def __init__(self): self.num = 38 self.lst = [ self.str = dumps = lambda self: repr(self) __str__ = lambda self: self.dumps() data = Data() print data
<?xml version="1.0"?> <!DOCTYPE PyObject SYSTEM "PyObjects.dtd"> <PyObject module="__main__" class="Data" id="11038416"> <attr name="lst" type="list" id="11196136" > <item type="string" value="a" /> <item type="string" value="b" /> <item type="string" value="c" /> </attr> <attr name="num" type="numeric" value="38" /> <attr name="str" type="string" value="spam" /> </PyObject>
import json print(json.dumps(YOUR_OBJECT, default=lambda obj: vars(obj), indent=1))
import jsonpickle import json import yaml serialized = jsonpickle.encode(obj, max_depth=2) print json.dumps(json.loads(serialized), indent=4) print yaml.dump(yaml.load(serialized), indent=4)
DO = DemoObject() itemDir = DO.__dict__ for i in itemDir: print
from bson import json_util import json print(json.dumps(myObject, default=json_util.default, sort_keys=True, indent=4, separators=(
from pprint import pprint def print_r(the_object): print ("CLASS: ", the_object.__class__.__name__, " (BASE CLASS: ", the_object.__class__.__bases__,")") pprint(vars(the_object))
class(NormalClassNewStyle): dicts: { }, lists: [], static_props: 1, tupl: (1, 2)
from ppretty import ppretty class A(object): s = 5 def __init__(self): self._p = 8 @property def foo(self): return range(10) print ppretty(A(), show_protected=True, show_static=True, show_properties=True)
for key,value in obj.__dict__.iteritems(): print key,value
If called without an argument, return the names in the current scope. Else, return an alphabetized list of names comprising (some of) the attributes of the given object, and of attributes reachable from it. If the object supplies a method named __dir__, it will be used; otherwise the default dir() logic is used and returns: for a module object: the module for a class object: its attributes, and recursively the attributes of its bases. for any other object: its attributes, its class recursively the attributes of its class
Without arguments, equivalent to locals(). With an argument, equivalent to object.__dict__.
from flask import Flask from flask_debugtoolbar import DebugToolbarExtension app = Flask(__name__) app.debug = True app.config[ toolbar = DebugToolbarExtension(app)
for attr in dir(obj): try: print("obj.{} = {}".format(attr, getattr(obj, attr))) except AttributeError: print("obj.{} = ?".format(attr))
class C(object): def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, "I
class C(object): def __init__(self): self._x = None @property def x(self): return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x
>>> property().getter <built-in method getter of property object at 0x10ff07998> >>> property().setter <built-in method setter of property object at 0x10ff07940> >>> property().deleter <built-in method deleter of property object at 0x10ff07998>
>>> property().getter(None) <property object at 0x10ff079f0>
def foo(self): return self._foo foo = property(foo)
>>> def getter(self): print ... >>> def setter(self, value): print ... >>> def deleter(self): print ... >>> prop = property(getter) >>> prop.fget is getter True >>> prop.fset is None True >>> prop.fdel is None True
>>> prop = prop.setter(setter) >>> prop.fget is getter True >>> prop.fset is setter True >>> prop.fdel is None True
>>> prop = prop.deleter(deleter) >>> prop.fget is getter True >>> prop.fset is setter True >>> prop.fdel is deleter True
>>> class Foo(object): pass ... >>> prop.__get__(Foo(), Foo) Get! >>> prop.__set__(Foo(), Set to >>> prop.__delete__(Foo()) Delete!
class Property(object): "Emulate PyProperty_Type() in Objects/descrobject.c" def __init__(self, fget=None, fset=None, fdel=None, doc=None): self.fget = fget self.fset = fset self.fdel = fdel if doc is None and fget is not None: doc = fget.__doc__ self.__doc__ = doc def __get__(self, obj, objtype=None): if obj is None: return self if self.fget is None: raise AttributeError("unreadable attribute") return self.fget(obj) def __set__(self, obj, value): if self.fset is None: raise AttributeError("can self.fset(obj, value) def __delete__(self, obj): if self.fdel is None: raise AttributeError("can self.fdel(obj) def getter(self, fget): return type(self)(fget, self.fset, self.fdel, self.__doc__) def setter(self, fset): return type(self)(self.fget, fset, self.fdel, self.__doc__) def deleter(self, fdel): return type(self)(self.fget, self.fset, fdel, self.__doc__)
class Thing: def __init__(self, my_word): self._word = my_word @property def word(self): return self._word >>> print( Thing(
class Thing: def __init__(self, my_word): self._word = my_word def word(self): return self._word >>> print( Thing(
class C(object): def __init__(self): self._x = None @property def x(self): return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x
class C(object): def __init__(self): self._x = None def _x_get(self): return self._x def _x_set(self, value): self._x = value def _x_del(self): del self._x x = property(_x_get, _x_set, _x_del, "I
class C(object): def __init__(self): self._x = None def _x_get(self): return self._x def _x_set(self, value): self._x = value def _x_del(self): del self._x x = property(_x_get, doc="I x = x.setter(_x_set) x = x.deleter(_x_del)
class C(object): def __init__(self): self._x = None def _x_get(self): return self._x x = property(_x_get, doc="I def _x_set(self, value): self._x = value x = x.setter(_x_set) def _x_del(self): del self._x x = x.deleter(_x_del)
class C(object): def __init__(self): self._x = None @property def x(self): return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x
class User(UserMixin, db.Model): __tablename__ = id = db.Column(db.Integer, primary_key=True) email = db.Column(db.String(64), unique=True, index=True) username = db.Column(db.String(64), unique=True, index=True) password_hash = db.Column(db.String(128)) ... @property def password(self): raise AttributeError( @password.setter def password(self, password): self.password_hash = generate_password_hash(password) def verify_password(self, password): return check_password_hash(self.password_hash, password)
... @auth.route( def register(): form = RegisterForm() if form.validate_on_submit(): user = User(email=form.email.data, username=form.username.data, password=form.password.data) db.session.add(user) db.session.commit() ...
class Money: def __init__(self, dollars, cents): self.dollars = dollars self.cents = cents
money = Money(27, 12) print("I have {} dollar and {} cents.".format(money.dollars, money.cents))
class Money: def __init__(self, dollars, cents): self.total_cents = dollars * 100 + cents
money = Money(27, 12) print("I have {} dollar and {} cents.".format(money.dollars, money.cents))
class Money: def __init__(self, dollars, cents): self.total_cents = dollars * 100 + cents @property def dollars(self): return self.total_cents @dollars.setter def dollars(self, new_dollars): self.total_cents = 100 * new_dollars + self.cents @property def cents(self): return self.total_cents % 100 @cents.setter def cents(self, new_cents): self.total_cents = 100 * self.dollars + new_cents
money = Money(27, 12) print("I have {} dollar and {} cents.".format(money.dollars, money.cents))
money.dollars += 2 print("I have {} dollar and {} cents.".format(money.dollars, money.cents)) money.cents += 10 print("I have {} dollar and {} cents.".format(money.dollars, money.cents))
class UtilityMixin(): @property def get_config(self): return "This is property"
def decorator_func(fun): def wrapper_func(): print("Wrapper function started") fun() print("Given function decorated") return wrapper_func def say_bye(): print("bye!!") say_bye = decorator_func(say_bye) say_bye()
def decorator_func(fun): def wrapper_func(): print("Wrapper function started") fun() print("Given function decorated") return wrapper_func @decorator_func def say_bye(): print("bye!!") say_bye()
class Celsius: def __init__(self, temperature = 0): self.set_temperature(temperature) def to_fahrenheit(self): return (self.get_temperature() * 1.8) + 32 def get_temperature(self): return self._temperature def set_temperature(self, value): if value < -273: raise ValueError("Temperature below -273 is not possible") self._temperature = value
class Celsius: def __init__(self, temperature = 0): self.temperature = temperature def to_fahrenheit(self): return (self.temperature * 1.8) + 32 def get_temperature(self): print("Getting value") return self.temperature def set_temperature(self, value): if value < -273: raise ValueError("Temperature below -273 is not possible") print("Setting value") self.temperature = value temperature = property(get_temperature,set_temperature)
temperature = property(get_temperature,set_temperature)
temperature = property() temperature = temperature.getter(get_temperature) temperature = temperature.setter(set_temperature)
class Celsius: def __init__(self, temperature = 0): self.temperature = temperature def to_fahrenheit(self): return (self.temperature * 1.8) + 32 @property def temperature(self): print("Getting value") return self.temperature @temperature.setter def temperature(self, value): if value < -273: raise ValueError("Temperature below -273 is not possible") print("Setting value") self.temperature = value
class OurClass: def __init__(self, a): self.x = a y = OurClass(10) print(y.x)
class OurClass: def __init__(self,x): self.x = x @property def x(self): return self.__x @x.setter def x(self, x): if x < 0: self.__x = 0 elif x > 1000: self.__x = 1000 else: self.__x = x
class GetterSetterExample( object ): __x = None def __init__( self ): self.x = 1234 return None @property def x( self, _default = None ): _value = ( self.__x, _default )[ self.__x == None ] print( return _value @x.setter def x( self, _value = None ): print( if ( _value > 0 ): self.__x = -_value else: self.__x = _value @x.deleter def x( self ): if ( self.__x != None ): del self.__x def __str__( self ): print( return _test = GetterSetterExample( ) print( _test ) del _test.x
[ Test Class ] Set x = 1234 [ Test Class ] Get x = -1234 [ x ] -1234
with open ("data.txt", "r") as myfile: data=myfile.readlines()
LLKKKKKKKKMMMMMMMMNNNNNNNNNNNNN GGGGGGGGGHHHHHHHHHHHHHHHHHHHHEEEEEEEE
file = open( text = file.read().strip() file.close()
with open("data.txt") as myfile: data="".join(line.rstrip() for line in myfile)
with open("myfile.txt") as f: file_content = f.read().rstrip("\n") print file_content
myfile = open("data.txt","r") data = "" lines = myfile.readlines() for line in lines: data = data + line.strip();
f = open( string = "" while 1: line = f.readline() if not line:break string += line f.close() print string
with open( lines = [ line.strip( ) for line in list(f) ]
with open ("data.txt", "r") as myfile: data = myfile.read().splitlines()
LLKKKKKKKKMMMMMMMMNNNNNNNNNNNNN GGGGGGGGGHHHHHHHHHHHHHHHHHHHHEEEEEEEE
file = open("file.txt") line = file.read() words = line.split()
LLKKKKKKKKMMMMMMMMNNNNNNNNNNNNN, GGGGGGGGGHHHHHHHHHHHHHHHHHHHHEEEEEEEE
with open(player_name, data=myfile.readline() list=data.split(" ") word=list[0]
file = open("myfile.txt", "r") lines = file.readlines() str = for i in range(len(lines)): str += lines[i].rstrip( print str
pt1 = (1.0, 5.0) pt2 = (2.5, 1.5) from math import sqrt line_length = sqrt((pt1[0]-pt2[0])**2 + (pt1[1]-pt2[1])**2)
from collections import namedtuple Point = namedtuple( pt1 = Point(1.0, 5.0) pt2 = Point(2.5, 1.5) from math import sqrt line_length = sqrt((pt1.x-pt2.x)**2 + (pt1.y-pt2.y)**2)
Point = namedtuple( pt1 = Point(1.0, 5.0) pt2 = Point(2.5, 1.5) from math import sqrt line_length = sqrt((pt1[0]-pt2[0])**2 + (pt1[1]-pt2[1])**2) x1, y1 = pt1
>>> Point = namedtuple( >>> pt1 = Point(1.0, 5.0) >>> pt1.x = 2.0 AttributeError: can
>>> from rcdtype import * >>> Point = recordtype( >>> pt1 = Point(1.0, 5.0) >>> pt1 = Point(1.0, 5.0) >>> pt1.x = 2.0 >>> print(pt1[0]) 2.0
import collections Row = collections.namedtuple("Row", ["a", "b", "c"], verbose=False, rename=False) row = Row(a=1,b=2,c=3) print row print row.a print row[0] row = Row._make([2, 3, 4]) print row
>>> from collections import namedtuple >>> class_name = >>> fields = >>> ANamedTuple = namedtuple(class_name, fields)
>>> ant ANamedTuple(foo=1, bar= >>> ant.foo 1 >>> ant.bar >>> ant.baz.append( >>> ant.baz [
>>> student_tuple = >>> student_tuple ( >>> student_tuple[0] >>> student_tuple[1] >>> student_tuple[2]
>>> first, last, grade = student_tuple >>> first >>> last >>> grade
>>> from collections import namedtuple >>> Student = namedtuple(
>>> named_student_tuple = Student( >>> named_student_tuple.first >>> named_student_tuple.last >>> named_student_tuple.grade >>> named_student_tuple._asdict() OrderedDict([( >>> vars(named_student_tuple) OrderedDict([( >>> new_named_student_tuple = named_student_tuple._replace(first= >>> new_named_student_tuple Student(first=
>>> from collections import namedtuple >>> NT = namedtuple( >>> nt = NT( >>> import pickle >>> pickle.loads(pickle.dumps(nt)) NT(foo=
>>> def foo(): ... LocalNT = namedtuple( ... return LocalNT( ... >>> pickle.loads(pickle.dumps(foo())) Traceback (most recent call last): File "<stdin>", line 1, in <module> _pickle.PicklingError: Can
class Point(namedtuple( __slots__ = () @property def hypot(self): return (self.x ** 2 + self.y ** 2) ** 0.5 def __str__(self): return
from collections import Sequence class MutableTuple(Sequence): __slots__ = () def __init__(self, *args): for slot, arg in zip(self.__slots__, args): setattr(self, slot, arg) def __repr__(self): return type(self).__name__ + repr(tuple(self)) def __iter__(self): for name in self.__slots__: yield getattr(self, name) def __getitem__(self, index): return getattr(self, self.__slots__[index]) def __len__(self): return len(self.__slots__)
class Student(MutableTuple): __slots__ = >>> student = Student( >>> student Student( >>> first, last, grade = student >>> first >>> last >>> grade >>> student[0] >>> student[2] >>> len(student) 3 >>> True >>> False >>> student.first = >>> for i in student: print(i) ... Bart Simpson A
>>> sys.version_info.major 3 >>> sys.version_info.minor 1
from collections import namedtuple Color = namedtuple( p = Color(170, 0.1, 0.6) if p.saturation >= 0.5: print "Whew, that is bright!" if p.luminosity >= 0.5: print "Wow, that is light"
p = (170, 0.1, 0.6) if p[1] >= 0.5: print "Whew, that is bright!" if p[2]>= 0.5: print "Wow, that is light"
>>>p = dict(hue = 170, saturation = 0.1, luminosity = 0.6) >>>p[ 170 >>>from collections import namedtuple >>>Color = namedtuple( >>>p = Color(170, 0.1, 0.6) >>>p.hue 170
collections.namedtuple(typename, field_names[, verbose=False][, rename=False])
>>>from collections import namedtuple >>>Color = namedtuple( >>>p = Color(170, 0.1, 0.6) >>>p._replace(hue=87) Color(87, 0.1, 0.6) >>>p._replace(hue=87, saturation=0.2) Color(87, 0.2, 0.6)
>>>data = (170, 0.1, 0.6) >>>Color._make(data) Color(hue=170, saturation=0.1, luminosity=0.6) >>>Color._make([170, 0.1, 0.6]) Color(hue=170, saturation=0.1, luminosity=0.6) >>>Color._make((170, 0.1, 0.6)) Color(hue=170, saturation=0.1, luminosity=0.6) >>>Color._make(170, 0.1, 0.6) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 15, in _make TypeError:
>>>from collections import namedtuple >>>saleRecord = namedtuple( >>> >>> >>> >>>shop11=saleRecord(11, >>>shop12=saleRecord(shopId=22,saleDate="2015-01-01",saleAmout=1512,totalCustomers=125)
>>> >>>print("Shop Id =",shop12.shopId) 12 >>>print("Sale Date=",shop12.saleDate) 2015-01-01 >>>print("Sales Amount =",shop12.salesAmount) 1512 >>>print("Total Customers =",shop12.totalCustomers) 125
from csv import reader from collections import namedtuple saleRecord = namedtuple( fileHandle = open("salesRecord.csv","r") csvFieldsList=csv.reader(fileHandle) for fieldsList in csvFieldsList: shopRec = saleRecord._make(fieldsList) overAllSales += shopRec.totalSales; print("Total Sales of The Retail Chain =",overAllSales)
>>> from collections import namedtuple >>> Point = namedtuple( >>> pt1 = Point(1,2) >>> pt2 = Point(3,4) >>> dot_product = ( pt1.x * pt2.x ) +( pt1.y * pt2.y ) >>> print dot_product 11
>>> from collections import namedtuple >>> Car = namedtuple( >>> xyz = Car(Price = 100000, Mileage = 30, Colour = >>> print xyz Car(Price=100000, Mileage=30, Colour= >>> print xyz.Class Y
class Duck: def __init__(self, color, weight): self.color = color self.weight = weight red_duck = Duck( In [50]: red_duck Out[50]: <__main__.Duck at 0x1068e4e10> In [51]: red_duck.color Out[51]:
from collections import namedtuple Duck = namedtuple( red_duck = Duck( In [54]: red_duck Out[54]: Duck(color= In [55]: red_duck.color Out[55]:
import urllib2 response = urllib2.urlopen( html = response.read()
import urllib2 url = "http: file_name = url.split( u = urllib2.urlopen(url) f = open(file_name, meta = u.info() file_size = int(meta.getheaders("Content-Length")[0]) print "Downloading: %s Bytes: %s" % (file_name, file_size) file_size_dl = 0 block_sz = 8192 while True: buffer = u.read(block_sz) if not buffer: break file_size_dl += len(buffer) f.write(buffer) status = r"%10d [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size) status = status + chr(8)*(len(status)+1) print status, f.close()
>>> import requests >>> >>> url = "http: >>> r = requests.get(url) >>> print len(r.content) 10485760
from tqdm import tqdm import requests url = "http: response = requests.get(url, stream=True) with open("10MB", "wb") as handle: for data in tqdm(response.iter_content()): handle.write(data)
import urllib2 mp3file = urllib2.urlopen("http: with open( output.write(mp3file.read())
import urllib.request response = urllib.request.urlopen( html = response.read()
import urllib2 response = urllib2.urlopen( html = response.read()
from __future__ import ( division, absolute_import, print_function, unicode_literals ) import sys, os, tempfile, logging if sys.version_info >= (3,): import urllib.request as urllib2 import urllib.parse as urlparse else: import urllib2 import urlparse def download_file(url, dest=None): u = urllib2.urlopen(url) scheme, netloc, path, query, fragment = urlparse.urlsplit(url) filename = os.path.basename(path) if not filename: filename = if dest: filename = os.path.join(dest, filename) with open(filename, meta = u.info() meta_func = meta.getheaders if hasattr(meta, meta_length = meta_func("Content-Length") file_size = None if meta_length: file_size = int(meta_length[0]) print("Downloading: {0} Bytes: {1}".format(url, file_size)) file_size_dl = 0 block_sz = 8192 while True: buffer = u.read(block_sz) if not buffer: break file_size_dl += len(buffer) f.write(buffer) status = "{0:16}".format(file_size_dl) if file_size: status += " [{0:6.2f}%]".format(file_size_dl * 100 / file_size) status += chr(13) print(status, end="") print() return filename if __name__ == "__main__": print("Testing with 10MB download") url = "http: filename = download_file(url) print(filename)
from six.moves import urllib urllib.request.urlretrieve("http:
import urllib response = urllib.urlopen( mp3 = response.read()
def report(blocknr, blocksize, size): current = blocknr*blocksize sys.stdout.write("\r{0:.2f}%".format(100.0*current/size)) def downloadFile(url): print "\n",url fname = url.split( print fname urllib.urlretrieve(url, fname, report)
from parallel_sync import wget urls = [ wget.download( wget.download(
import urllib.request import shutil url = "http: output_file = "save_this_name.pdf" with urllib.request.urlopen(url) as response, open(output_file, shutil.copyfileobj(response, out_file)
$ python wget_test.py urlretrive_test : starting urlretrive_test : 6.56 ============== wget_no_bar_test : starting wget_no_bar_test : 7.20 ============== wget_with_bar_test : starting 100% [......................................................................] 541335552 / 541335552 wget_with_bar_test : 50.49 ==============
import wget import urllib import time from functools import wraps def profile(func): @wraps(func) def inner(*args): print func.__name__, ": starting" start = time.time() ret = func(*args) end = time.time() print func.__name__, ": {:.2f}".format(end - start) return ret return inner url1 = url2 = url3 = def do_nothing(*args): pass @profile def urlretrive_test(url): return urllib.urlretrieve(url) @profile def wget_no_bar_test(url): return wget.download(url, out= @profile def wget_with_bar_test(url): return wget.download(url, out= urlretrive_test(url1) print time.sleep(1) wget_no_bar_test(url2) print time.sleep(1) wget_with_bar_test(url3) print time.sleep(1)
import os,requests def download(url): get_response = requests.get(url,stream=True) file_name = url.split("/")[-1] with open(file_name, for chunk in get_response.iter_content(chunk_size=1024): if chunk: f.write(chunk) download("https:
import urllib sock = urllib.urlopen("http: htmlSource = sock.read() sock.close() print htmlSource
import pycurl FILE_DEST = FILE_SRC = with open(FILE_DEST, c = pycurl.Curl() c.setopt(c.URL, FILE_SRC) c.setopt(c.WRITEDATA, f) c.perform() c.close()
import sys try: import urllib.request python3 = True except ImportError: import urllib2 python3 = False def progress_callback_simple(downloaded,total): sys.stdout.write( "\r" + (len(str(total))-len(str(downloaded)))*" " + str(downloaded) + "/%d"%total + " [%3.2f%%]"%(100.0*float(downloaded)/float(total)) ) sys.stdout.flush() def download(srcurl, dstfilepath, progress_callback=None, block_size=8192): def _download_helper(response, out_file, file_size): if progress_callback!=None: progress_callback(0,file_size) if block_size == None: buffer = response.read() out_file.write(buffer) if progress_callback!=None: progress_callback(file_size,file_size) else: file_size_dl = 0 while True: buffer = response.read(block_size) if not buffer: break file_size_dl += len(buffer) out_file.write(buffer) if progress_callback!=None: progress_callback(file_size_dl,file_size) with open(dstfilepath,"wb") as out_file: if python3: with urllib.request.urlopen(srcurl) as response: file_size = int(response.getheader("Content-Length")) _download_helper(response,out_file,file_size) else: response = urllib2.urlopen(srcurl) meta = response.info() file_size = int(meta.getheaders("Content-Length")[0]) _download_helper(response,out_file,file_size) import traceback try: download( "https: "output.zip", progress_callback_simple ) except: traceback.print_exc() input()
import urllib.request url_request = urllib.request.Request(url, headers=headers) url_connect = urllib.request.urlopen(url_request) len_content = url_content.length with open(filename, while True: buffer = url_connect.read(buffer_size) if not buffer: break data_wrote = f.write(buffer) url_connect.close()
import urllib2,os url = "http: file_name = url.split( u = urllib2.urlopen(url) f = open(file_name, meta = u.info() file_size = int(meta.getheaders("Content-Length")[0]) print "Downloading: %s Bytes: %s" % (file_name, file_size) os.system( file_size_dl = 0 block_sz = 8192 while True: buffer = u.read(block_sz) if not buffer: break file_size_dl += len(buffer) f.write(buffer) status = r"%10d [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size) status = status + chr(8)*(len(status)+1) print status, f.close()
def remove_duplicates(): t = [ t2 = [ for t in t2: t.append(t.remove()) return t
>>> t = [1, 2, 3, 1, 2, 5, 6, 7, 8] >>> t [1, 2, 3, 1, 2, 5, 6, 7, 8] >>> list(set(t)) [1, 2, 3, 5, 6, 7, 8] >>> s = [1, 2, 3] >>> list(set(t) - set(s)) [8, 5, 6, 7]
>>> from collections import OrderedDict >>> list(OrderedDict.fromkeys(t)) [1, 2, 3, 5, 6, 7, 8]
>>> from collections import OrderedDict >>> list(OrderedDict.fromkeys( [
from collections import OrderedDict OrderedDict((x, True) for x in source_list).keys()
>>> t = [1, 2, 3, 1, 2, 5, 6, 7, 8] >>> t [1, 2, 3, 1, 2, 5, 6, 7, 8] >>> s = [] >>> for i in t: if i not in s: s.append(i) >>> s [1, 2, 3, 5, 6, 7, 8]
def ordered_set(in_list): out_list = [] added = set() for val in in_list: if not val in added: out_list.append(val) added.add(val) return out_list
from random import randint x = [randint(0,100) for _ in xrange(100)] In [131]: len(set(x)) Out[131]: 62
In [129]: %timeit list(OrderedDict.fromkeys(x)) 10000 loops, best of 3: 86.4 us per loop In [130]: %timeit ordered_set(x) 100000 loops, best of 3: 15.1 us per loop
def ordered_set(inlist): out_list = [] for val in inlist: if not val in out_list: out_list.append(val) return out_list
In [136]: %timeit ordered_set(x) 10000 loops, best of 3: 52.6 us per loop
myList = [1, 2, 3, 1, 2, 5, 6, 7, 8] cleanlist = [] [cleanlist.append(x) for x in myList if x not in cleanlist]
import pandas as pd pd.unique(t).tolist() >>>[ pd.unique(t2).tolist() >>>[
import numpy as np np.unique(t).tolist() >>>[ np.unique(t2).tolist() >>>[
_, idx = np.unique(t2, return_index=True) t2[np.sort(idx)].tolist() >>>[
def make_unique(original_list): unique_list = [] [unique_list.append(obj) for obj in original_list if obj not in unique_list] return unique_list
def make_unique(original_list): unique_list = [] map(lambda x: unique_list.append(x) if (x not in unique_list) else False, original_list) return unique_list
def uniq(iterable, key=lambda x: x): """ Remove duplicates from an iterable. Preserves order. :type iterable: Iterable[Ord => A] :param iterable: an iterable of objects of any orderable type :type key: Callable[A] -> (Ord => B) :param key: optional argument; by default an item (A) is discarded if another item (B), such that A == B, has already been encountered and taken. If you provide a key, this condition changes to key(A) == key(B); the callable must return orderable objects. """ def append_unique(acc, item): return acc if key(acc[-1][1]) == key(item[1]) else acc.append(item) or acc srt_enum = sorted(enumerate(iterable), key=lambda item: key(item[1])) return [item[1] for item in sorted(reduce(append_unique, srt_enum, [srt_enum[0]]))]
import sets t = sets.Set([ t1 = sets.Set([ print t | t1 print t - t1
>>> t = [1, 2, 3, 3, 2, 4, 5, 6] >>> s = [x for i, x in enumerate(t) if i == t.index(x)] >>> s [1, 2, 3, 4, 5, 6]
In [2]: some_list = [ In [3]: list(set(some_list)) Out[3]: [
data=[1, 2, 3, 1, 2, 5, 6, 7, 8] uni_data=[] for dat in data: if dat not in uni_data: uni_data.append(dat) print(uni_data)
def remove_duplicates(list): singles_list = [] for element in list: if element not in singles_list: singles_list.append(element) return singles_list
>>> reduce(lambda r, v: v in r and r or r + [v], l, []) [5, 6, 1, 2, 3, 4]
>>> reduce(lambda r, v: v in r[1] and r or (r[0].append(v) or r[1].add(v)) or r, l, ([], set()))[0] [5, 6, 1, 2, 3, 4]
default = (list(), set()) def reducer(result, item): if item not in result[1]: result[0].append(item) result[1].add(item) return result reduce(reducer, l, default)[0]
def remove_duplicates(x): a = [] for i in x: if i not in a: a.append(i) return a print remove_duplicates([1,2,2,3,3,4])
def uniqify(iterable): seen = set() for item in iterable: if item not in seen: seen.add(item) yield item
for unique_item in uniqify([1, 2, 3, 4, 3, 2, 4, 5, 6, 7, 6, 8, 8]): print(unique_item, end= print()
unique_list = list(uniqify([1, 2, 3, 4, 3, 2, 4, 5, 6, 7, 6, 8, 8])) print(unique_list)
def deduplicate(sequence): visited = set() adder = visited.add out = [adder(item) or item for item in sequence if item not in visited] return out
import numpy as np a = [0,1,2,3,4,3,3,4] a = np.unique(a).tolist() print a
>>> n = [1, 2, 3, 4, 1, 1] >>> n [1, 2, 3, 4, 1, 1] >>> m = sorted(list(set(n))) >>> m [1, 2, 3, 4]
import pandas as pd myList = [1, 2, 3, 1, 2, 5, 6, 7, 8] cleanList = pd.Series(myList).drop_duplicates().tolist() print(cleanList)
def GetListWithoutRepetitions(loInput): if loInput==[]: return [] loOutput = [] if loInput[0] is None: oGroupElement=1 else: oGroupElement=None for oElement in loInput: if oElement<>oGroupElement: loOutput.append(oElement) oGroupElement = oElement return loOutput
>>> t = [1, 2, 3, 1, 2, 5, 6, 7, 8] >>> for i in t: ... if i in t[t.index(i)+1:]: ... t.remove(i) ... >>> t [3, 1, 2, 5, 6, 7, 8]
list1 = [1,2,1] list1 = list(set(list1)) print list1
def rem_dupes(dup_list): yooneeks = [] for elem in dup_list: if elem not in yooneeks: yooneeks.append(elem) return yooneeks
a = [1,2,3,4,5,9,11,15] b = [4,5,6,7,8] c=a+b print c print list(set(c))
[1, 2, 3, 4, 5, 9, 11, 15, 4, 5, 6, 7, 8] [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 15]
LIGHT_MESSAGES = { } def lights_message(language, number_of_lights): return LIGHT_MESSAGES[language] % locals() def is_pirate(message): return re.search(r"(?i)(arr|avast|yohoho)!", message) is not None
mystringliteral1="this is a string with mystringliteral2= mystringliteral3="""this is a string with "quotes" and more mystringliteral4= mystringliteral5= mystringliteral6= mystringliteral6= print mystringliteral1 print mystringliteral2 print mystringliteral3 print mystringliteral4 print mystringliteral5 print mystringliteral6
f = open( f = open("c:\word.txt", "r") f = open("c:/word.txt", "r") f = open("c:\\\word.txt", "r")
import os, sys, inspect cmd_folder = os.path.realpath(os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0])) if cmd_folder not in sys.path: sys.path.insert(0, cmd_folder) cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"subfolder"))) if cmd_subfolder not in sys.path: sys.path.insert(0, cmd_subfolder)
import sys sys.path.insert(0, <path to dirFoo>) import Bar
import os import sys lib_path = os.path.abspath(os.path.join(__file__, sys.path.append(lib_path) import mymodule
src\ __init__.py main.py dirFoo\ __init__.py Foo.py dirBar\ __init__.py Bar.py
py_mod = imp.load_source(mod_name,filename_path) py_mod = imp.load_compiled(mod_name,filename_path)
imp.find_module(name[, path]) imp.load_module(name, file, pathname, description)
dirFoo\ __init__.py Foo.py dirBar\ __init__.py Bar.py
if __name__ == sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), import my_module
import sys,site site.addsitedir(sys.path[0] + print (sys.path) import oldies
cwd = os.getcwd() os.chdir("..") below_path = os.getcwd() sys.path.append(below_path) os.chdir(cwd)
from module_1 import func_1 def func_2(): func_1() if __name__ == func_2()
project\ package_1\ module_1.py module_2.py main.py
from package_1.module_2 import func_2 def func_3(): func_2() if __name__ == func_3()
project\ package_1\ module_1.py module_2.py config.py config.ini main.py
project\ package_1\ module_1.py module_2.py config.py config.ini main.py
with open("C:/yourpath/foobar.py") as f: eval(f.read())
import os, sys from subprocess import Popen, PIPE try: path = Popen("find / -name if not sys.path.__contains__(path): sys.path.append(path) except IndexError: raise RuntimeError("You must have FILE to run this program!")
(mysite)zjm1126@zjm1126-G41MT-S2:~/zjm_test/mysite$ pip install mysql-python Downloading/unpacking mysql-python Downloading MySQL-python-1.2.3.tar.gz (70Kb): 70Kb downloaded Running setup.py egg_info for package mysql-python sh: mysql_config: not found Traceback (most recent call last): File "<string>", line 14, in <module> File "/home/zjm1126/zjm_test/mysite/build/mysql-python/setup.py", line 15, in <module> metadata, options = get_config() File "setup_posix.py", line 43, in get_config libs = mysql_config("libs_r") File "setup_posix.py", line 24, in mysql_config raise EnvironmentError("%s not found" % (mysql_config.path,)) EnvironmentError: mysql_config not found Complete output from command python setup.py egg_info: sh: mysql_config: not found Traceback (most recent call last): File "<string>", line 14, in <module> File "/home/zjm1126/zjm_test/mysite/build/mysql-python/setup.py", line 15, in <module> metadata, options = get_config() File "setup_posix.py", line 43, in get_config libs = mysql_config("libs_r") File "setup_posix.py", line 24, in mysql_config raise EnvironmentError("%s not found" % (mysql_config.path,)) EnvironmentError: mysql_config not found ---------------------------------------- Command python setup.py egg_info failed with error code 1 Storing complete log in /home/zjm1126/.pip/pip.log (mysite)zjm1126@zjm1126-G41MT-S2:~/zjm_test/mysite$ pip install mysql-python Downloading/unpacking mysql-python Running setup.py egg_info for package mysql-python sh: mysql_config: not found Traceback (most recent call last): File "<string>", line 14, in <module> File "/home/zjm1126/zjm_test/mysite/build/mysql-python/setup.py", line 15, in <module> metadata, options = get_config() File "setup_posix.py", line 43, in get_config libs = mysql_config("libs_r") File "setup_posix.py", line 24, in mysql_config raise EnvironmentError("%s not found" % (mysql_config.path,)) EnvironmentError: mysql_config not found Complete output from command python setup.py egg_info: sh: mysql_config: not found Traceback (most recent call last): File "<string>", line 14, in <module> File "/home/zjm1126/zjm_test/mysite/build/mysql-python/setup.py", line 15, in <module> metadata, options = get_config() File "setup_posix.py", line 43, in get_config libs = mysql_config("libs_r") File "setup_posix.py", line 24, in mysql_config raise EnvironmentError("%s not found" % (mysql_config.path,)) EnvironmentError: mysql_config not found ---------------------------------------- Command python setup.py egg_info failed with error code 1 Storing complete log in /home/zjm1126/.pip/pip.log
$ sudo apt update $ sudo apt install python-dev $ sudo apt install python-MySQLdb
yum install mysql mysql-devel mysql-common mysql-libs gcc
_mysql.c:29:20: fatal error: Python.h: No such file or directory
sudo ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future pip install mysql-python
ln -s /usr/bin/mariadb_config /usr/bin/mysql_config
sudo su export PATH=$PATH:/usr/local/mysql/bin/ pip install mysql-python exit
pip install mysqlclient sudo apt-get install python3-dev libmysqlclient-dev pip install configparser sudo cp /usr/lib/python3.6/configparser.py /usr/lib/python3.6/ConfigParser.py
import os for root, dirs, files in os.walk(top, topdown=False): for name in files: os.remove(os.path.join(root, name)) for name in dirs: os.rmdir(os.path.join(root, name))
import shutil shutil.rmtree(dest, ignore_errors=True)
import pathlib def delete_folder(pth) : for sub in pth.iterdir() : if sub.is_dir() : delete_folder(sub) else : sub.unlink() pth.rmdir()
import os import stat import shutil def errorRemoveReadonly(func, path, exc): excvalue = exc[1] if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES: os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO) func(path) else: shutil.rmtree(path, ignore_errors=False, onerror=errorRemoveReadonly)
import sys import os mswindows = (sys.platform == "win32") def getstatusoutput(cmd): """Return (status, output) of executing cmd in a shell.""" if not mswindows: return commands.getstatusoutput(cmd) pipe = os.popen(cmd + text = pipe.read() sts = pipe.close() if sts is None: sts = 0 if text[-1:] == return sts, text def deleteDir(path): if mswindows: cmd = "RMDIR "+ path +" /s /q" else: cmd = "rm -rf "+path result = getstatusoutput(cmd) if(result[0]!=0): raise RuntimeError(result[1])
import shutil def remove_folder(path): if os.path.exists(path): shutil.rmtree(path) else: raise XXError("your exception") remove_folder("/folder_name")
import os, stat import shutil def remove_readonly(func, path, _): "Clear the readonly bit and reattempt the removal" os.chmod(path, stat.S_IWRITE) func(path) shutil.rmtree(directory, onerror=remove_readonly)
from os import listdir, rmdir, remove for i in listdir(directoryToRemove): os.remove(os.path.join(directoryToRemove, i)) rmdir(directoryToRemove)
def deleteDir(dirPath): deleteFiles = [] deleteDirs = [] for root, dirs, files in os.walk(dirPath): for f in files: deleteFiles.append(os.path.join(root, f)) for d in dirs: deleteDirs.append(os.path.join(root, d)) for f in deleteFiles: os.remove(f) for d in deleteDirs: os.rmdir(d) os.rmdir(dirPath)
import shutil def ignore_absent_file(func, path, exc_inf): except_instance = exc_inf[1] if isinstance(except_instance, FileNotFoundError): return raise except_instance shutil.rmtree(dir_to_delete, onerror=ignore_absent_file)
import shutil import errno def ignore_absent_file(func, path, exc_inf): except_instance = exc_inf[1] if isinstance(except_instance, OSError) and \ except_instance.errno == errno.ENOENT: return raise except_instance shutil.rmtree(dir_to_delete, onerror=ignore_absent_file)
python -c "import sys; import os; [os.chmod(os.path.join(rs,d), 0o777) for rs,ds,fs in os.walk(_path_) for d in ds]" python -c "import sys; import os; [os.chmod(os.path.join(rs,f), 0o777) for rs,ds,fs in os.walk(_path_) for f in fs]" python -c "import os; import shutil; shutil.rmtree(_path_, ignore_errors=False)"
import subprocess from pathlib import Path path = Path( subprocess.run(["rm", "-rf", str(path)]) path = "/path/to/your/dir" subprocess.run(["rm", "-rf", path)
>>> assert True >>> assert False Traceback (most recent call last): File "<stdin>", line 1, in <module> AssertionError
if __debug__: if not expression: raise AssertionError
>>> assert 5 > 2 >>> assert 2 > 5 Traceback (most recent call last): File "<string>", line 1, in <fragment> builtins.AssertionError:
if __​debug__: if not <expression>: raise AssertionError
if __​debug__: if not <expression1>: raise AssertionError, <expression2>
>>> number = input( Enter a positive number:-1 >>> assert (number > 0), Traceback (most recent call last): File "<stdin>", line 1, in <module> AssertionError: Only positive numbers are allowed! >>>
Assert statements are a convenient way to insert debugging assertions into a program
def chkassert(num): assert type(num) == int chkassert(
Traceback (most recent call last): File "b.py", line 5, in <module> chkassert( File "b.py", line 2, in chkassert assert type(num) == int AssertionError
def calculate_discount(price, discount): discounted_price = price - [discount*price] assert 0 <= discounted_price <= price return discounted_price
def getUser(self, id, Email): user_key = id and id or Email assert user_key
def KelvinToFahrenheit(Temperature): assert (Temperature >= 0),"Colder than absolute zero!" return ((Temperature-273)*1.8)+32 print KelvinToFahrenheit(273) print int(KelvinToFahrenheit(505.78)) print KelvinToFahrenheit(-5)
32.0 451 Traceback (most recent call last): File "test.py", line 9, in <module> print KelvinToFahrenheit(-5) File "test.py", line 4, in KelvinToFahrenheit assert (Temperature >= 0),"Colder than absolute zero!" AssertionError: Colder than absolute zero!
>>>this_is_very_complex_function_result = 9 >>>c = this_is_very_complex_function_result >>>test_us = (c < 4) >>> >>>if test_us == True: print("YES! I am right!") else: print("I am Wrong, but the program still RUNS!") I am Wrong, but the program still RUNS! >>> >>> assert test_us Traceback (most recent call last): File "<pyshell assert test_us AssertionError >>>
package/ |-__init__.py |-module_1/ | |-__init__.py | |-foo_implementation.py |-module_2/ |-__init__.py |-Bar_implementation.py
from Bar_implementation import * from Baz_implementation import * __all__ = [
from module_1 import * from module_2 import * __all__ = [
from module_1 import * from module_2 import * __all__ = [
import sys def export(fn): mod = sys.modules[fn.__module__] if hasattr(mod, mod.__all__.append(fn.__name__) else: mod.__all__ = [fn.__name__] return fn
$ cat > main.py from lib import export __all__ = [] @export def foo(): pass @export def bar(): def main(): print( if __name__ == main()
$ cat > run.py import main main.main() $ python run.py main
$ cat > run.py from main import * foo() bar() main() $ python run.py Traceback (most recent call last): File "run.py", line 4, in <module> main() NameError: name
__all__ = [ swiss = 4.99 cheddar = 3.99 gouda = 10.99
>>> from cheese import * >>> swiss, cheddar (4.99, 3.99) >>> gouda Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name
>>> import cheese >>> cheese.swiss, cheese.cheddar, cheese.gouda (4.99, 3.99, 10.99)
>>> from cheese import swiss, cheddar, gouda >>> swiss, cheddar, gouda (4.99, 3.99, 10.99)
>>> import cheese as ch >>> ch.swiss, ch.cheddar, ch.gouda (4.99, 3.99, 10.99)
In [1]: import collections In [2]: d = {2:3, 1:89, 4:5, 3:0} In [3]: od = collections.OrderedDict(sorted(d.items())) In [4]: od Out[4]: OrderedDict([(1, 89), (2, 3), (3, 0), (4, 5)])
In [11]: od[1] Out[11]: 89 In [12]: od[3] Out[12]: 0 In [13]: for k, v in od.iteritems(): print k, v ....: 1 89 2 3 3 0 4 5
In [13]: for k, v in od.items(): print(k, v) ....: 1 89 2 3 3 0 4 5
mydict = { for key in sorted(mydict): print "%s: %s" % (key, mydict[key])
keylist = mydict.keys() keylist.sort() for key in keylist: print "%s: %s" % (key, mydict[key])
>>> from collections import OrderedDict >>> >>> d = { >>> >>> OrderedDict(sorted(d.items(), key=lambda t: t[0])) OrderedDict([( >>> >>> OrderedDict(sorted(d.items(), key=lambda t: t[1])) OrderedDict([( >>> >>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0]))) OrderedDict([(
>>> d = {2:3, 1:89, 4:5, 3:0} >>> dict(sorted(d.items())) {1: 89, 2: 3, 3: 0, 4: 5}
>>> from sortedcontainers import SortedDict >>> d = {2:3, 1:89, 4:5, 3:0} >>> s = SortedDict(d) >>> s.items() [(1, 89), (2, 3), (3, 0), (4, 5)]
>>> s.iloc[-1] 4 >>> del s.iloc[2] >>> s.keys() SortedSet([1, 2, 4])
d = {2:3, 1:89, 4:5, 3:0} sd = sorted(d.items()) for k,v in sd: print k, v
class SortedDisplayDict(dict): def __str__(self): return "{" + ", ".join("%r: %r" % (key, self[key]) for key in sorted(self)) + "}" >>> d = SortedDisplayDict({2:3, 1:89, 4:5, 3:0}) >>> d {1: 89, 2: 3, 3: 0, 4: 5}
>>> D1 = {2:3, 1:89, 4:5, 3:0} >>> for key in sorted(D1): print (key, D1[key])
test_dict = { def dict_reorder(item): return {k: sort_dict(v) if isinstance(v, dict) else v for k, v in sorted(item.items())} reordered_dict = dict_reorder(test_dict)
c={2:3, 1:89, 4:5, 3:0} y=sorted(c.items()) print y
d={"John":36,"Lucy":24,"Albert":32,"Peter":18,"Bill":41} x=sorted(d.keys()) print x
D1 = {2:3, 1:89, 4:5, 3:0} sort_dic = {} for i in sorted(D1): sort_dic.update({i:D1[i]}) print sort_dic {1: 89, 2: 3, 3: 0, 4: 5}
from collections import OrderedDict sorted_dict = OrderedDict(sorted(D1.items(), key=lambda t: t[0]))
ordered_dict = collections.OrderedDict([(k, d[k]) for k in sorted(d.keys())])
d = {k1:v1, k2:v2,...} for k in sorted(d.keys()): value = d[k] print k, value
dict1 = { dict2 = {} for key in sorted(dict1.keys()): if not key in dict2: dict2[key] = dict1[key]
dict1 = { dict2 = {} for key in sorted(dict1.keys()): if not key in dict2: value = dict1[key] dict2[key] = value
>>> setup_string = "a = sorted(dict({2:3, 1:89, 4:5, 3:0}).items())" >>> timeit.timeit(stmt="[(k, val) for k, val in a]", setup=setup_string, number=10000) 0.003599141953657181 >>> setup_string = "from collections import OrderedDict\n" >>> setup_string += "a = OrderedDict({1:89, 2:3, 3:0, 4:5})\n" >>> setup_string += "b = a.items()" >>> timeit.timeit(stmt="[(k, val) for k, val in b]", setup=setup_string, number=10000) 0.003581275490432745
from operator import itemgetter user = [ { { { ] for k in sorted (user, key=itemgetter ( print (k) for x in sorted (user, key=itemgetter ( print (x)
a1 = { a1_sorted_keys = sorted(a1, key=a1.get, reverse=True) for r in a1_sorted_keys: print r, a1[r]
dictionary = {1:[2],2:[],5:[4,5],4:[5],3:[1]} temp=sorted(dictionary) sorted_dict = dict([(k,dictionary[k]) for i,k in enumerate(temp)]) sorted_dict: {1: [2], 2: [], 3: [1], 4: [5], 5: [4, 5]}
>>> d={ >>> df=pd.DataFrame(d,index=[0]).sort_index(axis=1) A B C 0 2 1 3 >>> df.to_dict( { >>>
>> a = {2:3, 1:89, 4:5, 3:0} >> c = {i:a[i] for i in dict.fromkeys(sorted([i for i in a]))} >> print(c) {1: 89, 2: 3, 3: 0, 4: 5} [Finished in 0.4s]
l = dict.keys() l2 = l l2.append(0) l3 = [] for repeater in range(0, len(l)): smallnum = float("inf") for listitem in l2: if listitem < smallnum: smallnum = listitem l2.remove(smallnum) l3.append(smallnum) l3.remove(0) l = l3 for listitem in l: print(listitem)
not_ordered_dict = {5 : "5555", 9 : "9999", 1 : "1111"} ordered_dict = {} for key in sorted(not_ordered_dict): ordered_dict[key] = not_ordered_dict[key]
class Spam(int): pass x = Spam(0) type(x) == int isinstance(x, int)
>>> float(5).is_integer() True >>> float(5.1).is_integer() False >>> float(5.0).is_integer() True
def is_int(val): if type(val) == int: return True else: if val.is_integer(): return True else: return False
>>> import numbers >>> isinstance(3, numbers.Integral) True
test = input("Enter some text here: ") if test.isdigit() == True: print("This is a number.") else: print("This is not a number.")
>>> i = 12345 >>> type(i) <type >>> type(i) is int True
import re x = "01234" match = re.search("^\d+$", x) try: x = match.group(0) except AttributeError: print("not a valid number") Result: x == "01234"
import re x = "h01234" match = re.search("\D", x) if not match: print("x is a number") else: print("encountered a problem at character:", match.group(0)) Result: "encountered a problem at character: h"
if variable and variable.isdigit(): return variable else: return "Error"
def is_int(x): print round(x), if x == round(x): print else: print is_int(7.0) is_int(7.5) is_int(-1)
import six if isinstance(obj, six.integer_types): print(
import sys PY3 = sys.version_info[0] == 3 if PY3: integer_types = int, else: integer_types = (int, long)
intchecker = float(input( intcheck = 0 while intcheck != 1: if intchecker - int(intchecker) > 0: intchecker = float(input("You didn "Please enter a integer: ")) else: intcheck = 1 print(
if this_variable % 1 == 0: list.append(this_variable) else: print
import math print ("this program will tell you if a number is square") print ("enter an integer") num = float(input()) if num > 0: print ("ok!") num = (math.sqrt(num)) inter = int(num) if num == inter: print ("It print (num) else: print ("It print (num) else: print ("That
import re def is_int(x): if(isinstance(x,(int,long))): return True matchObj = re.match(r if matchObj: x = matchObj.group(1) if int(x)-0==0: return True return False print is_int(6) print is_int(1.0) print is_int(1.1) print is_int(0.1) print is_int(-956.0)
var = 15.4 if(var - int(var) != 0): print "Value is not integer"
def isInt(anyNumberOrString): try: int(anyNumberOrString) return True except ValueError : return False isInt("A") isInt("5") isInt(8) isInt("5.88")
name = int(5) if type(name) == int: print else: print
for a in range(2,100): for b in range(2,100): x = (a**b)**(1.0/b) print a,b, x, str(float(x)).endswith(
def value_is_int(value): try: tempVal = int(value) return True except: return False
if value_is_int(value): print "Integer" else: print "Not integer"
def is_int(x): if x - round(x) == 0 : return True else: return False
models.DateTimeField(blank=True) models.DateTimeField(null=True)
models.CharField(blank=True) models.CharField(null=True)
class Test(models.Model): charNull = models.CharField(max_length=10, null=True) charBlank = models.CharField(max_length=10, blank=True) charNullBlank = models.CharField(max_length=10, null=True, blank=True) intNull = models.IntegerField(null=True) intBlank = models.IntegerField(blank=True) intNullBlank = models.IntegerField(null=True, blank=True) dateNull = models.DateTimeField(null=True) dateBlank = models.DateTimeField(blank=True) dateNullBlank = models.DateTimeField(null=True, blank=True)
CREATE TABLE Test ( id serial NOT NULL, "charNull" character varying(10), "charBlank" character varying(10) NOT NULL, "charNullBlank" character varying(10), "intNull" integer, "intBlank" integer NOT NULL, "intNullBlank" integer, "dateNull" timestamp with time zone, "dateBlank" timestamp with time zone NOT NULL, "dateNullBlank" timestamp with time zone, CONSTRAINT Test_pkey PRIMARY KEY (id) )
CREATE TABLE Test ( `id` INT(11) NOT NULL AUTO_INCREMENT, `charNull` VARCHAR(10) NULL DEFAULT NULL, `charBlank` VARCHAR(10) NOT NULL, `charNullBlank` VARCHAR(10) NULL DEFAULT NULL, `intNull` INT(11) NULL DEFAULT NULL, `intBlank` INT(11) NOT NULL, `intNullBlank` INT(11) NULL DEFAULT NULL, `dateNull` DATETIME NULL DEFAULT NULL, `dateBlank` DATETIME NOT NULL, `dateNullBlank` DATETIME NULL DEFAULT NULL )
models.CharField(blank=True, null=True, unique=True)
>>> def print_keyword_args(**kwargs): ... ... for key, value in kwargs.iteritems(): ... print "%s = %s" % (key, value) ... >>> print_keyword_args(first_name="John", last_name="Doe") first_name = John last_name = Doe
>>> kwargs = { >>> print_keyword_args(**kwargs) first_name = Bobby last_name = Smith
args = { if hasattr(person, "address"): args["address"] = person.address func(**args)
def setstyle(**styles): for key, value in styles.iteritems(): setattr(someobject, key, value)
def myDo(what, where, why): if what == doSwim(where, why) elif what == doWalk(where, why) ...
def myDo(what, where, why, **kwargs): if what == doDrive(where, why, **kwargs) elif what == doSwim(where, why, **kwargs)
def f(a = 0, *args, **kwargs): print("Received by f(a, *args, **kwargs)") print("=> f(a=%s, args=%s, kwargs=%s" % (a, args, kwargs)) print("Calling g(10, 11, 12, *args, d = 13, e = 14, **kwargs)") g(10, 11, 12, *args, d = 13, e = 14, **kwargs) def g(f, g = 0, *args, **kwargs): print("Received by g(f, g = 0, *args, **kwargs)") print("=> g(f=%s, g=%s, args=%s, kwargs=%s)" % (f, g, args, kwargs)) print("Calling f(1, 2, 3, 4, b = 5, c = 6)") f(1, 2, 3, 4, b = 5, c = 6)
Calling f(1, 2, 3, 4, b = 5, c = 6) Received by f(a, *args, **kwargs) => f(a=1, args=(2, 3, 4), kwargs={ Calling g(10, 11, 12, *args, d = 13, e = 14, **kwargs) Received by g(f, g = 0, *args, **kwargs) => g(f=10, g=11, args=(12, 2, 3, 4), kwargs={
def args_kwargs_test(arg1, arg2, arg3): print "arg1:", arg1 print "arg2:", arg2 print "arg3:", arg3
>>> args = ("two", 3, 5) >>> args_kwargs_test(*args)
>>> kwargs = {"arg3":3, "arg2": >>> args_kwargs_test(**kwargs)
def function1(param1,param2="arg2",param3="arg3"): print("\n"+str(param1)+" "+str(param2)+" "+str(param3)+"\n") function1(1) function1(param1=1) function1(1,param2=2) function1(param1=1,param2=2) function1(param2=2, param1=1) function1(1, param3=3, param2=2)
def function2(param1, *tupleParams, param2, param3, **dictionaryParams): print("param1: "+ param1) print("param2: "+ param2) print("param3: "+ param3) print("custom tuple params","-"*10) for p in tupleParams: print(str(p) + ",") print("custom named params","-"*10) for k,v in dictionaryParams.items(): print(str(k)+":"+str(v)) function2("arg1", "custom param1", "custom param2", "custom param3", param3="arg3", param2="arg2", customNamedParam1 = "val1", customNamedParam2 = "val2" ) #
tupleCustomArgs = ("custom param1", "custom param2", "custom param3") dictCustomNamedArgs = {"customNamedParam1":"val1", "customNamedParam2":"val2"} function2("arg1", *tupleCustomArgs, param3="arg3", param2="arg2", **dictCustomNamedArgs )
function2("arg1", tupleCustomArgs, param3="arg3", param2="arg2", **dictCustomNamedArgs )
param1: arg1 param2: arg2 param3: arg3 custom tuple params ---------- ( custom named params ---------- customNamedParam2:val2 customNamedParam1:val1
function2("arg1", *tupleCustomArgs, param3="arg3", param2="arg2", dictCustomNamedArgs )
dictCustomNamedArgs ^ SyntaxError: non-keyword arg after keyword arg
def test(**kwargs): print kwargs[ print kwargs[ print kwargs[ args = { test( a=1, **args )
def print_wrap(arg1, *args, **kwargs): print(arg1) print(args) print(kwargs) print(arg1, *args, **kwargs)
# def g( **kwargs) : print ( "In g ready to print kwargs" ) print kwargs print ( "in g, calling f") f ( **kwargs ) print ( "In g, after returning from f") def f( **kwargs ) : print ( "in f, printing kwargs") print ( kwargs ) print ( "In f, after printing kwargs") g( a="red", b=5, c="Nassau") g( q="purple", w="W", c="Charlie", d=[4, 3, 6] )
$ python kwargs_demo.py In g ready to print kwargs { in g, calling f in f, printing kwargs { In f, after printing kwargs In g, after returning from f In g ready to print kwargs { in g, calling f in f, printing kwargs { In f, after printing kwargs In g, after returning from f
a b c d 2 0.671399 0.101208 -0.181532 0.241273 3 0.446172 -0.243316 0.051767 1.577318 5 0.614758 0.075793 -0.451460 -0.012493
>>> sLength = len(df1[ >>> df1 a b c d 6 -0.269221 -0.026476 0.997517 1.294385 8 0.917438 0.847941 0.034235 -0.448948 >>> df1[ >>> df1 a b c d e 6 -0.269221 -0.026476 0.997517 1.294385 1.757167 8 0.917438 0.847941 0.034235 -0.448948 2.228131 >>> p.version.short_version
>>> df1.loc[:, >>> df1 a b c d e f 6 -0.269221 -0.026476 0.997517 1.294385 1.757167 -0.050927 8 0.917438 0.847941 0.034235 -0.448948 2.228131 0.006109 >>>
df1 = df1.assign(e=p.Series(np.random.randn(sLength)).values)
df = pd.DataFrame({ >>> df.assign(mean_a=df.a.mean(), mean_b=df.b.mean()) a b mean_a mean_b 0 1 3 1.5 3.5 1 2 4 1.5 3.5
np.random.seed(0) df1 = pd.DataFrame(np.random.randn(10, 4), columns=[ mask = df1.applymap(lambda x: x <-0.7) df1 = df1[-mask.any(axis=1)] sLength = len(df1[ e = pd.Series(np.random.randn(sLength)) >>> df1 a b c d 0 1.764052 0.400157 0.978738 2.240893 2 -0.103219 0.410599 0.144044 1.454274 3 0.761038 0.121675 0.443863 0.333674 7 1.532779 1.469359 0.154947 0.378163 9 1.230291 1.202380 -0.387327 -0.302303 >>> e 0 -1.048553 1 -1.420018 2 -1.706270 3 1.950775 4 -0.509652 dtype: float64 df1 = df1.assign(e=e.values) >>> df1 a b c d e 0 1.764052 0.400157 0.978738 2.240893 -1.048553 2 -0.103219 0.410599 0.144044 1.454274 -1.420018 3 0.761038 0.121675 0.443863 0.333674 -1.706270 7 1.532779 1.469359 0.154947 0.378163 1.950775 9 1.230291 1.202380 -0.387327 -0.302303 -0.509652
size name color 0 big rose red 1 small violet blue 2 small tulip red 3 small harebell blue df[ size name color protected 0 big rose red no 1 small violet blue no 2 small tulip red no 3 small harebell blue yes
df.index = [3,2,1,0] df[ size name color protected 3 big rose red no 2 small violet blue no 1 small tulip red no 0 small harebell blue yes
df[ size name color protected 3 big rose red yes 2 small violet blue no 1 small tulip red no 0 small harebell blue no
protected_series = pd.Series([ protected_series.index = df.index 3 no 2 no 1 no 0 yes
df[ size name color protected 3 big rose red no 2 small violet blue no 1 small tulip red no 0 small harebell blue yes
df.reset_index(drop=True) protected_series.reset_index(drop=True) df[ size name color protected 0 big rose red no 1 small violet blue no 2 small tulip red no 3 small harebell blue yes
df.assign(protected=pd.Series([ size name color protected 3 big rose red yes 2 small violet blue no 1 small tulip red no 0 small harebell blue no
df.assign(self=pd.Series([ TypeError: assign() got multiple values for keyword argument
df = pd.DataFrame(data=np.random.randn(20, 4), columns=[ df A B C D 0 -0.761269 0.477348 1.170614 0.752714 1 1.217250 -0.930860 -0.769324 -0.408642 2 -0.619679 -1.227659 -0.259135 1.700294 3 -0.147354 0.778707 0.479145 2.284143 4 -0.529529 0.000571 0.913779 1.395894 5 2.592400 0.637253 1.441096 -0.631468 6 0.757178 0.240012 -0.553820 1.177202 7 -0.986128 -1.313843 0.788589 -0.707836 8 0.606985 -2.232903 -1.358107 -2.855494 9 -0.692013 0.671866 1.179466 -1.180351 10 -1.093707 -0.530600 0.182926 -1.296494 11 -0.143273 -0.503199 -1.328728 0.610552 12 -0.923110 -1.365890 -1.366202 -1.185999 13 -2.026832 0.273593 -0.440426 -0.627423 14 -0.054503 -0.788866 -0.228088 -0.404783 15 0.955298 -1.430019 1.434071 -0.088215 16 -0.227946 0.047462 0.373573 -0.111675 17 1.627912 0.043611 1.743403 -0.012714 18 0.693458 0.144327 0.329500 -0.655045 19 0.104425 0.037412 0.450598 -0.923387 df.drop([3, 5, 8, 10, 18], inplace=True) df A B C D 0 -0.761269 0.477348 1.170614 0.752714 1 1.217250 -0.930860 -0.769324 -0.408642 2 -0.619679 -1.227659 -0.259135 1.700294 4 -0.529529 0.000571 0.913779 1.395894 6 0.757178 0.240012 -0.553820 1.177202 7 -0.986128 -1.313843 0.788589 -0.707836 9 -0.692013 0.671866 1.179466 -1.180351 11 -0.143273 -0.503199 -1.328728 0.610552 12 -0.923110 -1.365890 -1.366202 -1.185999 13 -2.026832 0.273593 -0.440426 -0.627423 14 -0.054503 -0.788866 -0.228088 -0.404783 15 0.955298 -1.430019 1.434071 -0.088215 16 -0.227946 0.047462 0.373573 -0.111675 17 1.627912 0.043611 1.743403 -0.012714 19 0.104425 0.037412 0.450598 -0.923387 df.loc[:, df A B C D NewCol 0 -0.761269 0.477348 1.170614 0.752714 0 1 1.217250 -0.930860 -0.769324 -0.408642 0 2 -0.619679 -1.227659 -0.259135 1.700294 0 4 -0.529529 0.000571 0.913779 1.395894 0 6 0.757178 0.240012 -0.553820 1.177202 0 7 -0.986128 -1.313843 0.788589 -0.707836 0 9 -0.692013 0.671866 1.179466 -1.180351 0 11 -0.143273 -0.503199 -1.328728 0.610552 0 12 -0.923110 -1.365890 -1.366202 -1.185999 0 13 -2.026832 0.273593 -0.440426 -0.627423 0 14 -0.054503 -0.788866 -0.228088 -0.404783 0 15 0.955298 -1.430019 1.434071 -0.088215 0 16 -0.227946 0.047462 0.373573 -0.111675 0 17 1.627912 0.043611 1.743403 -0.012714 0 19 0.104425 0.037412 0.450598 -0.923387 0
import pandas as pd df e = pd.Series([-0.335485, -1.166658, -0.385571]) e df = pd.concat([df, e.rename("e")], axis=1) df
e.index = df.index df = pd.concat([df, e.rename("e")], axis=1)
data.set_index([ "if index is unsorted, assignment of a new column will fail" data.sort_index(inplace = True) data.loc[
data = pd.DataFrame(index=all_possible_values) df1[
col = df = df.assign(**{col:numpy.full(len(df), numpy.nan)})
In [44]: e Out[44]: 0 1.225506 1 -1.033944 2 -0.498953 3 -0.373332 4 0.615030 5 -0.622436 dtype: float64 In [45]: df1 Out[45]: a b c d 0 -0.634222 -0.103264 0.745069 0.801288 4 0.782387 -0.090279 0.757662 -0.602408 5 -0.117456 2.124496 1.057301 0.765466 7 0.767532 0.104304 -0.586850 1.051297 8 -0.103272 0.958334 1.163092 1.182315 9 -0.616254 0.296678 -0.112027 0.679112
In [46]: df1.eval("e = @e.values", inplace=True) In [47]: df1 Out[47]: a b c d e 0 -0.634222 -0.103264 0.745069 0.801288 1.225506 4 0.782387 -0.090279 0.757662 -0.602408 -1.033944 5 -0.117456 2.124496 1.057301 0.765466 -0.498953 7 0.767532 0.104304 -0.586850 1.051297 -0.373332 8 -0.103272 0.958334 1.163092 1.182315 0.615030 9 -0.616254 0.296678 -0.112027 0.679112 -0.622436
df = pd.DataFrame([[1, 2], [3, 4], [5,6]], columns=list( newCol = [3,5,7] newName = values = np.insert(df.values,df.shape[1],newCol,axis=1) header = df.columns.values.tolist() header.append(newName) df = pd.DataFrame(values,columns=header)
>>> import json >>> >>> your_json = >>> parsed = json.loads(your_json) >>> print(json.dumps(parsed, indent=4, sort_keys=True)) [ "foo", { "bar": [ "baz", null, 1.0, 2 ] } ]
import json def pp_json(json_thing, sort=True, indents=4): if type(json_thing) is str: print(json.dumps(json.loads(json_thing), sort_keys=sort, indent=indents)) else: print(json.dumps(json_thing, sort_keys=sort, indent=indents)) return None pp_json(your_json_string_or_dict)
import json import pprint with open( data = f.read() json_data = json.loads(data) pprint.pprint(json_data)
import pprint import json from urllib.request import urlopen r = urlopen("https: text = r.read() pprint.pprint(json.loads(text))
import time start_time = time.time() main() print("--- %s seconds ---" % (time.time() - start_time))
import atexit from time import clock def secondsToStr(t): return "%d:%02d:%02d.%03d" % \ reduce(lambda ll,b : divmod(ll[0],b) + ll[1:], [(t*1000,),1000,60,60]) line = "="*40 def log(s, elapsed=None): print line print secondsToStr(clock()), if elapsed: print "Elapsed time:", elapsed print line print def endlog(): end = clock() elapsed = end-start log("End Program", secondsToStr(elapsed)) def now(): return secondsToStr(clock()) start = clock() atexit.register(endlog) log("Start Program")
import time start_time = time.clock() main() print time.clock() - start_time, "seconds"
import atexit from time import time, strftime, localtime from datetime import timedelta def secondsToStr(elapsed=None): if elapsed is None: return strftime("%Y-%m-%d %H:%M:%S", localtime()) else: return str(timedelta(seconds=elapsed)) def log(s, elapsed=None): line = "="*40 print(line) print(secondsToStr(), if elapsed: print("Elapsed time:", elapsed) print(line) print() def endlog(): end = time() elapsed = end-start log("End Program", secondsToStr(elapsed)) start = time() atexit.register(endlog) log("Start Program")
$ python -m cProfile euler048.py 1007 function calls in 0.061 CPU seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.061 0.061 <string>:1(<module>) 1000 0.051 0.000 0.051 0.000 euler048.py:2(<lambda>) 1 0.005 0.005 0.061 0.061 euler048.py:2(<module>) 1 0.000 0.000 0.061 0.061 {execfile} 1 0.002 0.002 0.053 0.053 {map} 1 0.000 0.000 0.000 0.000 {method 1 0.000 0.000 0.000 0.000 {range} 1 0.003 0.003 0.003 0.003 {sum}
from datetime import datetime start_time = datetime.now() end_time = datetime.now() print(
import time from datetime import timedelta start_time = time.monotonic() end_time = time.monotonic() print(timedelta(seconds=end_time - start_time))
$ /usr/bin/time -v python rhtest2.py Command being timed: "python rhtest2.py" User time (seconds): 4.13 System time (seconds): 0.07 Percent of CPU this job got: 91% Elapsed (wall clock) time (h:mm:ss or m:ss): 0:04.58 Average shared text size (kbytes): 0 Average unshared data size (kbytes): 0 Average stack size (kbytes): 0 Average total size (kbytes): 0 Maximum resident set size (kbytes): 0 Average resident set size (kbytes): 0 Major (requiring I/O) page faults: 15 Minor (reclaiming a frame) page faults: 5095 Voluntary context switches: 27 Involuntary context switches: 279 Swaps: 0 File system inputs: 0 File system outputs: 0 Socket messages sent: 0 Socket messages received: 0 Signals delivered: 0 Page size (bytes): 4096 Exit status: 0
import time from datetime import timedelta start_time = time.time() # # elapsed_time_secs = time.time() - start_time msg = "Execution took: %s secs (Wall clock time)" % timedelta(seconds=round(elapsed_time_secs)) print(msg)
from time import time start_time = time() ... end_time = time() time_taken = end_time - start_time hours, rest = divmod(time_taken,3600) minutes, seconds = divmod(rest, 60)
start = time.process_time() ... do something elapsed = (time.process_time() - start)
$ python -mtimeit -n1 -r1 -t -s "from your_module import main" "main()"
import timeit start = timeit.default_timer() stop = timeit.default_timer() execution_time = stop - start print("Program Executed in "+execution_time)
def sample_function(start,**kwargs): try: Except: stop = timeit.default_timer() execution_time = stop - start print("Program Executed in "+execution_time)
import datetime as dt import timeit class TimingManager(object): """Context Manager used with the statement Example: with TimingManager() as t: """ clock = timeit.default_timer def __enter__(self): self.start = self.clock() self.log( return self def __exit__(self, exc_type, exc_val, exc_tb): self.endlog() return False def log(self, s, elapsed=None): """Log current time and elapsed time if present. :param s: Text to display, use the current time. :param elapsed: Elapsed time to display. Dafault: None, no display. """ print s.format(self._secondsToStr(self.clock())) if(elapsed is not None): print def endlog(self): self.log( def now(self): return str(dt.timedelta(seconds = self.clock() - self.start)) def _secondsToStr(self, sec): return str(dt.datetime.fromtimestamp(sec))
from line_profiler import LineProfiler import random def do_stuff(numbers): s = sum(numbers) l = [numbers[i]/43 for i in range(len(numbers))] m = [ numbers = [random.randint(1,100) for i in range(1000)] lp = LineProfiler() lp_wrapper = lp(do_stuff) lp_wrapper(numbers) lp.print_stats()
Timer unit: 1e-06 s Total time: 0.000649 s File: <ipython-input-2-2e060b054fea> Function: do_stuff at line 4 Line ============================================================== 4 def do_stuff(numbers): 5 1 10 10.0 1.5 s = sum(numbers) 6 1 186 186.0 28.7 l = [numbers[i]/43 for i in range(len(numbers))] 7 1 453 453.0 69.8 m = [
!jupyter nbconvert --to script example_notebook.ipynb %run -t example_notebook
import atexit from time import clock def reduce(function, iterable, initializer=None): it = iter(iterable) if initializer is None: value = next(it) else: value = initializer for element in it: value = function(value, element) return value def secondsToStr(t): return "%d:%02d:%02d.%03d" % \ reduce(lambda ll,b : divmod(ll[0],b) + ll[1:], [(t*1000,),1000,60,60]) line = "="*40 def log(s, elapsed=None): print (line) print (secondsToStr(clock()), if elapsed: print ("Elapsed time:", elapsed) print (line) def endlog(): end = clock() elapsed = end-start log("End Program", secondsToStr(elapsed)) def now(): return secondsToStr(clock()) def main(): start = clock() atexit.register(endlog) log("Start Program")
from timeit import default_timer as timer start= timer() end = timer() print("Time taken:", end-start)
from datetime import timedelta from monotonic import monotonic start_time = monotonic() end_time = monotonic() print(timedelta(seconds=end_time - start_time))
import time now = time.time() future = now + 10 step = 4 while time.time() < future: step += 3 step += 4 print(str(int(step / 10)) + " steps per second")
import atexit from time import time from datetime import timedelta, datetime def seconds_to_str(elapsed=None): if elapsed is None: return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f") else: return str(timedelta(seconds=elapsed)) def log(txt, elapsed=None): colour_cyan = colour_reset = colour_red = print( if elapsed: print("\n " + colour_red + " [TIMING]> Elapsed time ==> " + elapsed + "\n" + colour_reset) def end_log(): end = time() elapsed = end-start log("End Program", seconds_to_str(elapsed)) start = time() atexit.register(end_log) log("Start Program")
my_list = [x for x in my_list if x.attribute == value]
my_list = filter(lambda x: x.attribute == value, my_list)
def filterbyvalue(seq, value): for el in seq: if el.attribute==value: yield el
primes_cubed = [x*x*x for x in range(1000) if prime(x)]
prime_cubes = [x*x*x for x in range(1000) if prime(x*x*x)]
prime_cubes = filter(prime, [x*x*x for x in range(1000)])
lst_a = range(25) lst_b = [num for num in lst_a if num % 2 == 0] lst_c = filter(lambda num: num % 2 == 0, lst_a)
lst_a = range(25) lst_b = [num for num in lst_a if num % 2 == 0] lst_c = list(filter(lambda num: num %2 == 0, lst_a))
return [item.other_attribute for item in my_list if item.attribute==value]
with open( file_contents = [y for y in filter(lambda x: x !=
cursor.execute("SELECT * FROM TABLE1;") data_from_db = cursor.fetchall() processed_data = filter(lambda s:
from timeit import Timer timeMap = Timer(lambda: list(map(lambda x: x*x, range(10**7)))) print(timeMap.timeit(number=100)) timeListComp = Timer(lambda:[(lambda x: x*x) for x in range(10**7)]) print(timeListComp.timeit(number=100))
>>> def f1(seq): ... return list(filter(None, seq)) >>> def f2(seq): ... return [i for i in seq if i is not None] >>> disassemble(f1.__code__) 2 0 LOAD_GLOBAL 0 (list) 2 LOAD_GLOBAL 1 (filter) 4 LOAD_CONST 0 (None) 6 LOAD_FAST 0 (seq) 8 CALL_FUNCTION 2 10 CALL_FUNCTION 1 12 RETURN_VALUE >>> disassemble(f2.__code__) 2 0 LOAD_CONST 1 (<code object <listcomp> at 0x10cfcaa50, file "<stdin>", line 2>) 2 LOAD_CONST 2 ( 4 MAKE_FUNCTION 0 6 LOAD_FAST 0 (seq) 8 GET_ITER 10 CALL_FUNCTION 1 12 RETURN_VALUE
>>> timeit(stmt="f1(range(1000))", setup="from __main__ import f1,f2") 21.177661532000116 >>> timeit(stmt="f2(range(1000))", setup="from __main__ import f1,f2") 42.233950221000214
def filter_list(list, key, value, limit=None): return [i for i in list if i[key] == value][:limit]
my_variable = None def InitMyVariable(): global my_variable if my_variable is None: my_variable = ...
>>> class Something(object): ... pass ... >>> c = Something() >>> c.a = 1 >>> True >>> False
class InitMyVariable(object): my_variable = None def __call__(self): if self.my_variable is None: self.my_variable = ...
def InitMyVariable(): if InitMyVariable.my_variable is None: InitMyVariable.my_variable = ... InitMyVariable.my_variable = None
for x in y: if x == 3: found = x try: print( except NameError: print( else: ...
class First(object): def __init__(self): print "first" class Second(object): def __init__(self): print "second" class Third(First, Second): def __init__(self): super(Third, self).__init__() print "that
class First(object): def __init__(self): print "first" class Second(First): def __init__(self): print "second" class Third(First): def __init__(self): print "third" class Fourth(Second, Third): def __init__(self): super(Fourth, self).__init__() print "that
class First(object): def __init__(self): print "first" class Second(First): def __init__(self): print "second" class Third(First, Second): def __init__(self): print "third"
TypeError: Error when calling the metaclass bases Cannot create a consistent method resolution order (MRO) for bases Second, First
class First(object): def __init__(self): super(First, self).__init__() print("first") class Second(object): def __init__(self): super(Second, self).__init__() print("second") class Third(First, Second): def __init__(self): super(Third, self).__init__() print("third")
class First(object): def __init__(self): super(First, self).__init__() print "first" class Second(object): def __init__(self): super(Second, self).__init__() print "second" class Third(First, Second): def __init__(self): super(Third, self).__init__() print "that
class A(object): def __init__(self, v, *args, **kwargs): print "A:init:v[{0}]".format(v) kwargs[ super(A, self).__init__(*args, **kwargs) self.v = v class MixInF(object): def __init__(self, *args, **kwargs): print "IObject:init" def f(self, y): print "IObject:y[{0}]".format(y) class B(MixInF): def __init__(self, v, *args, **kwargs): print "B:init:v[{0}]".format(v) kwargs[ super(B, self).__init__(*args, **kwargs) self.v = v def f(self, y): print "B:f:v[{0}]:y[{1}]".format(self.v, y) super(B, self).f(y) class C(MixInF): def __init__(self, w, *args, **kwargs): print "C:init:w[{0}]".format(w) kwargs[ super(C, self).__init__(*args, **kwargs) self.w = w def f(self, y): print "C:f:w[{0}]:y[{1}]".format(self.w, y) super(C, self).f(y) class Q(C,B,A): def __init__(self, v, w): super(Q, self).__init__(v=v, w=w) def f(self, y): print "Q:f:y[{0}]".format(y) super(Q, self).f(y)
class First(object): def __init__(self): print class Second(object): def __init__(self): print class Third(First, Second): def __init__(self): Second.__init__(self)
class A(object): def __init__(self, a, *args, **kwargs): print("A", a) class B(A): def __init__(self, b, *args, **kwargs): super(B, self).__init__(*args, **kwargs) print("B", b) class A1(A): def __init__(self, a1, *args, **kwargs): super(A1, self).__init__(*args, **kwargs) print("A1", a1) class B1(A1, B): def __init__(self, b1, *args, **kwargs): super(B1, self).__init__(*args, **kwargs) print("B1", b1) B1(a1=6, b1=5, b="hello", a=None)
class Parent(object): def __init__(self): super(Parent, self).__init__() print "parent" class Left(Parent): def __init__(self): super(Left, self).__init__() print "left" class Right(Parent): def __init__(self): super(Right, self).__init__() print "right" class Child(Left, Right): def __init__(self): super(Child, self).__init__() print "child"
class Parent(object): def __init__(self): print "parent" super(Parent, self).__init__() class Left(Parent): def __init__(self): print "left" super(Left, self).__init__() class Right(Parent): def __init__(self): print "right" super(Right, self).__init__() class Child(Left, Right): def __init__(self): print "child" super(Child, self).__init__()
class A(object): def __init__(self, **kwargs): print( super().__init__() class B(A): def __init__(self, **kwargs): print( super().__init__(**kwargs) class C(A): def __init__(self, **kwargs): print( super().__init__(**kwargs) class D(B, C): def __init__(self): print( super().__init__(a=1, b=2, x=3) print(D.mro()) D()
[<class D.__init__ B.__init__ 3 C.__init__ with 1, 2 A.__init__
class First(object): def __init__(self, a): print "first", a super(First, self).__init__(20) class Second(object): def __init__(self, a): print "second", a super(Second, self).__init__() class Third(First, Second): def __init__(self): super(Third, self).__init__(10) print "that t = Third()
L(O) := [O] L(First) := [First] + merge(L(O), [O]) = [First] + merge([O], [O]) = [First, O] L(Second) := [Second, O] L(Third) := [Third] + merge(L(First), L(Second), [First, Second]) = [Third] + merge([First, O], [Second, O], [First, Second]) = [Third, First] + merge([O], [Second, O], [Second]) = [Third, First, Second] + merge([O], [O]) = [Third, First, Second, O]
class First(object): def __init__(self): super(First, self).__init__() print "first" class Second(object): def __init__(self): super(Second, self).__init__() print "second" class Third(First, Second): def __init__(self): super(Third, self).__init__() print "that
Third.__init__() ---> First.__init__() ---> Second.__init__() ---> Object.__init__() ---> returns ---> Second.__init__() - prints "second" - returns ---> First.__init__() - prints "first" - returns ---> Third.__init__() - prints "that
class First(object): def __init__(self): print("first") class Second(First): def __init__(self): print("second (before)") super(Second, self).__init__() print("second (after)") class Third(First): def __init__(self): print("third (before)") super(Third, self).__init__() print("third (after)") class Fourth(First): def __init__(self): print("fourth (before)") super(Fourth, self).__init__() print("fourth (after)") class Fifth(Second, Third, Fourth): def __init__(self): print("fifth (before)") super(Fifth, self).__init__() print("fifth (after)") Fifth()
1.) print("fifth (before)") 2.) super()>[Second, Third, Fourth] (Left to right) 3.) print("second (before)") 4.) super()> First (First is the Parent which inherit from object)
5.) print("third (before)") 6.) super()> First (Parent class) 7.) print ("Fourth (before)") 8.) super()> First (Parent class)
9.) print("first") (Parent) 10.) print ("Fourth (after)") (Class Fourth un-box) 11.) print("third (after)") (Class Third un-box) 12.) print("second (after)") (Class Second un-box) 13.) print("fifth (after)") (Class Fifth un-box) 14.) Fifth() executed
fifth (before) second (before third (before) fourth (before) first fourth (after) third (after) second (after) fifth (after)
from matplotlib.font_manager import FontProperties fontP = FontProperties() fontP.set_size( legend([plot1], "title", prop=fontP)
import matplotlib.pyplot as plt import numpy as np x = np.arange(10) fig = plt.figure() ax = plt.subplot(111) for i in xrange(5): ax.plot(x, i * x, label= ax.legend() plt.show()
import matplotlib.pyplot as plt import numpy as np x = np.arange(10) fig = plt.figure() ax = plt.subplot(111) for i in xrange(5): ax.plot(x, i * x, label= ax.legend(bbox_to_anchor=(1.1, 1.05)) plt.show()
import matplotlib.pyplot as plt import numpy as np x = np.arange(10) fig = plt.figure() ax = plt.subplot(111) for i in xrange(5): line, = ax.plot(x, i * x, label= ax.legend(loc= ncol=3, fancybox=True, shadow=True) plt.show()
import matplotlib.pyplot as plt import numpy as np x = np.arange(10) fig = plt.figure() ax = plt.subplot(111) for i in xrange(5): ax.plot(x, i * x, label= box = ax.get_position() ax.set_position([box.x0, box.y0, box.width * 0.8, box.height]) ax.legend(loc= plt.show()
import matplotlib.pyplot as plt import numpy as np x = np.arange(10) fig = plt.figure() ax = plt.subplot(111) for i in xrange(5): line, = ax.plot(x, i * x, label= box = ax.get_position() ax.set_position([box.x0, box.y0 + box.height * 0.1, box.width, box.height * 0.9]) ax.legend(loc= fancybox=True, shadow=True, ncol=5) plt.show()
l1 = plt.legend(bbox_to_anchor=(1.04,1), borderaxespad=0) l2 = plt.legend(bbox_to_anchor=(1.04,0), loc="lower left", borderaxespad=0) l3 = plt.legend(bbox_to_anchor=(1.04,0.5), loc="center left", borderaxespad=0) l4 = plt.legend(bbox_to_anchor=(0,1.02,1,0.2), loc="lower left", mode="expand", borderaxespad=0, ncol=3) l5 = plt.legend(bbox_to_anchor=(1,0), loc="lower right", bbox_transform=fig.transFigure, ncol=3) l6 = plt.legend(bbox_to_anchor=(0.4,0.8), loc="upper right")
import numpy as np import matplotlib.pyplot as plt x = np.linspace(0,2*np.pi) colors=[" fig, axes = plt.subplots(ncols=2) for i in range(4): axes[i fig.legend(loc=7) fig.tight_layout() fig.subplots_adjust(right=0.75) plt.show()
import matplotlib.pyplot as plt plt.rcParams["figure.figsize"] = 6,2 fig, (ax,lax) = plt.subplots(ncols=2, gridspec_kw={"width_ratios":[4,1]}) ax.plot(x,y, label="y=sin(x)") .... h,l = ax.get_legend_handles_labels() lax.legend(h,l, borderaxespad=0) lax.axis("off") plt.tight_layout() plt.show()
ax.legend(bbox_to_anchor=(0,0,1,1), bbox_transform=lax.transAxes) lax.axis("off")
plt.plot(...) plt.legend(loc= df.myCol.plot().legend(loc=
import matplotlib.pyplot as plt all_x = [10,20,30] all_y = [[1,3], [1.5,2.9],[3,2]] fig = plt.figure(1) ax = fig.add_subplot(111) ax.plot(all_x, all_y) lgd = ax.legend( [ ax.set_title( ax.set_xlabel( ax.set_ylabel( fig.savefig(
import matplotlib.pyplot as plt all_x = [10,20,30] all_y = [[1,3], [1.5,2.9],[3,2]] fig = plt.figure(1) ax = fig.add_subplot(111) ax.plot(all_x, all_y) lgd = ax.legend( [ ax.set_title( ax.set_xlabel( ax.set_ylabel( fig.savefig(
figure x = 0:.2:12; plot(x,besselj(1,x),x,besselj(2,x),x,besselj(3,x)); hleg = legend( % Make the text of the legend italic and color it brown set(hleg,
import matplotlib.pylab as plt import numpy as np fig = plt.figure() ax = fig.add_subplot(111) x = np.arange(-5, 6) ax.plot(x, x*x, label= ax.plot(x, x*x*x, label= ax.legend().draggable() plt.show()
fig = pylab.figure() ax = fig.add_subplot(111) ax.plot(x,y,label=label,color=color) ax.legend(loc=2,fontsize=10,fancybox=True).get_frame().set_alpha(0.5) ax.text(0.02,0.02,yourstring, verticalalignment= horizontalalignment= fontsize=10, bbox={ transform=self.ax.transAxes)
import plotly import math import random import numpy as np
un= k= py = plotly.plotly(username=un, key=k) def sin(x,n): sine = 0 for i in range(n): sign = (-1)**i sine = sine + ((x**(2.0*i+1))/math.factorial(2*i+1))*sign return sine x = np.arange(-12,12,0.1) anno = { } l = { } py.iplot([{ { { {
import matplotlib.pyplot as plt import numpy as np plt.ion() x = np.arange(10) fig = plt.figure() ax = plt.subplot(111) for i in xrange(5): ax.plot(x, i * x, label= leg = ax.legend(loc= plt.draw() box = ax.get_position() xlocs = (box.x0,box.x1) ylocs = (box.y0,box.y1) w, h = fig.get_size_inches() dpi = fig.get_dpi() legWidth = leg.get_window_extent().width winWidthNew = w*dpi+legWidth fig.set_size_inches(winWidthNew/dpi,h) mgr = plt.get_current_fig_manager() mgr.window.wm_geometry("%ix%i"%(winWidthNew,mgr.window.winfo_height())) factor = w*dpi/winWidthNew x0 = xlocs[0]*factor x1 = xlocs[1]*factor width = box.width*factor ax.set_position([x0,ylocs[0],x1-x0,ylocs[1]-ylocs[0]]) plt.draw()
import matplotlib.pyplot as plt p1, = plt.plot([1, 2, 3]) p2, = plt.plot([3, 2, 1]) p3, = plt.plot([2, 3, 1]) plt.legend([p2, p1, p3], ["line 1", "line 2", "line 3"]).get_frame().set_alpha(0.5) plt.show()
f = plt.figure() ax = f.add_subplot(414) lgd = ax.legend(loc= ax.autoscale_view() plt.savefig(fig_name, format=
import matplotlib.pyplot as plt all_x = [10,20,30] all_y = [[1,3], [1.5,2.9],[3,2]] def gen_plot(x, y): fig = plt.figure(1) ax = fig.add_subplot(111) ax.plot(all_x, all_y) lgd = ax.legend( [ "Lag " + str(lag) for lag in all_x], loc="center right", bbox_to_anchor=(1.3, 0.5)) fig.artists.append(lgd) ax.set_title("Title") ax.set_xlabel("x label") ax.set_ylabel("y label") return fig fig = gen_plot(all_x, all_y) fig.savefig("image_output.png", dpi=300, format="png", bbox_inches="tight")
from matplotlib as plt from matplotlib.font_manager import FontProperties ... ... t = A[:,0] sensors = A[:,index_lst] for i in range(sensors.shape[1]): plt.plot(t,sensors[:,i]) plt.xlabel( plt.ylabel( lgd = plt.legend(b,loc=
Get-Content files.txt | ForEach-Object {Remove-Item $_ -Recurse -Force}
>>> import my_module Traceback (most recent call last): File "<stdin>", line 1, in <module> ModuleNotFoundError: No module named
$ pip freeze |grep ttr ttr.aws.s3==0.1.1dev ttr.aws.utils.s3==0.3.0 ttr.utcutils==0.1.1dev $ python setup.py develop ..... ..... Finished processing dependencies for ttr.rdstmc==0.0.1dev $ pip freeze |grep ttr ttr.aws.s3==0.1.1dev ttr.aws.utils.s3==0.3.0 -e hg+https: ttr.utcutils==0.1.1dev $ pip uninstall ttr.rdstmc Uninstalling ttr.rdstmc: c:\python27\lib\site-packages\ttr.rdstmc.egg-link Proceed (y/n)? y Successfully uninstalled ttr.rdstmc $ pip freeze |grep ttr ttr.aws.s3==0.1.1dev ttr.aws.utils.s3==0.3.0 ttr.utcutils==0.1.1dev
python setup.py bdist_wininst dist/foo-1.0.win32.exe
python setup.py bdist_wininst dist/foo-1.0.win32.exe
[linux machine] python: /usr/bin/python /usr/bin/python2.4 /usr/lib/python2.4 /usr/local/bin/python2.5 /usr/include/python2.4 /usr/share/man/man1/python.1.gz
pip uninstall $(python -c "from setup import METADATA; print METADATA[
sudo python setup.py install --record files.txt sudo bash -c "cat files.txt | xargs rm -rf"
pip install --use-wheel --no-index --find-links=/where/its/downloaded package_name
assoc .whl=pythonwheel ftype pythonwheel=cmd /c pip.exe install "%1" ^& pause
assoc .whl=pythonwheel& ftype pythonwheel=cmd /c pip.exe install -U "%1" ^& pause
assoc .whl=pythonwheel& ftype pythonwheel=cmd /c pip.exe install -U "%%1" ^& pause
@assoc .whl=pythonwheel|| echo Run me with administrator rights! && pause && exit 1 @ftype pythonwheel=cmd /c pip.exe install -U "%%1" ^& pause || echo Installation error && pause && exit 1 @echo Installation successfull & pause
PS C:\Program Files (x86)\Python35-32> .\python -m pip install C:/Users/MyUsername/Documents/Programs/Python/numpy-1.11.2-cp35-none-win32.whl Processing c:\users\MyUsername\documents\programs\numpy-1.11.2-cp35-none-win32.whl Installing collected packages: numpy Successfully installed numpy-1.11.2 PS C:\Program Files (x86)\Python35-32>
>py -3.7(version name) -m pip install (file name).whl
print str(1).zfill(2) print str(10).zfill(2) print str(100).zfill(2)
a = [1, 10, 100] for num in a: print str(num).rjust(2,
width = 5 num = 3 formatted = (width - len(str(num))) * "0" + str(num) print formatted
def number2binlist(number, leading = 8): bin2dec = int(str(bin(number))[2:]) theformat = "{:0"+str(leading)+"d}" dec2str = list(theformat.format(bin2dec)) output = [int(z) for z in dec2str] output.reverse() return output
x = 5 while (x <= 15): a = str("{:04}".format(x)) print(a) x = x + 1;
>>> my_dataframe y gdp cap 0 1 2 5 1 2 3 9 2 8 7 2 3 3 4 7 4 6 7 7 5 4 8 3 6 8 2 8 7 9 9 10 8 6 6 4 9 10 10 7
In [1]: %timeit [column for column in df] 1000 loops, best of 3: 81.6 µs per loop In [2]: %timeit df.columns.values.tolist() 10000 loops, best of 3: 16.1 µs per loop In [3]: %timeit list(df) 10000 loops, best of 3: 44.9 µs per loop In [4]: % timeit list(df.columns.values) 10000 loops, best of 3: 38.4 µs per loop
In [97]: %timeit df.columns.values.tolist() 100000 loops, best of 3: 2.97 µs per loop In [98]: %timeit df.columns.tolist() 10000 loops, best of 3: 9.67 µs per loop
my_dataframe.keys().to_list() list(my_dataframe.keys())
xlarge = pd.DataFrame(np.arange(100000000).reshape(10000,10000)) list(xlarge) list(xlarge.keys())
n = [] for i in my_dataframe.columns: n.append(i) print n
import matplotlib import numpy as np import matplotlib.pyplot as plt %matplotlib inline
x = np.linspace(0, 3*np.pi, 500) plt.plot(x, np.sin(x**2)) plt.title( plt.show()
%matplotlib inline import matplotlib import numpy as np import matplotlib.pyplot as plt
c.IPKernelApp.matplotlib=<CaselessStrEnum> Default: None Choices: [ Configure matplotlib for interactive use with the default matplotlib backend.
%matplotlib notebook import matplotlib.pyplot as plt
import matplotlib import numpy as np import matplotlib.pyplot as plt %matplotlib inline
df_randNumbers1 = pd.DataFrame(np.random.randint(0,100,size=(100, 6)), columns=list( df_randNumbers1.ix[:,["A","B"]].plot.kde()
<bound method FramePlotMethods.kde of <pandas.tools.plotting.FramePlotMethods object at 0x000001DDAF029588>>
$ sudo rm -rf /usr/local/lib/python2.X/site-packages/[PACKAGE].egg
yolk -l | cut -f 1 -d " " | grep -v "setuptools|pip|ETC.." | xargs -n1 pip uninstall -y
sudo port install python26 sudo port install python_select sudo python_select python26 sudo port install py26-mysql
>>> import array >>> arr = array.array( >>> arr.append( >>> arr.__len__() 1 >>> len(arr) 1
if foo.py has changed: unimport foo <-- How do I do this? import foo myfoo = foo.Foo()
from importlib import reload import foo while True: if is_changed(foo): foo = reload(foo)
>>> import sys, empty, os >>> sys.getrefcount(sys) 9 >>> sys.getrefcount(os) 6 >>> sys.getrefcount(empty) 3
try: reload except NameError: from imp import reload
def importOrReload(module_name, *names): import sys if module_name in sys.modules: reload(sys.modules[module_name]) else: __import__(module_name, fromlist=names) for name in names: globals()[name] = getattr(sys.modules[module_name], name) importOrReload("dfly_parser", "parseMessages")
%autoreload Reload all modules (except those excluded by %aimport) automatically now. %autoreload 0 Disable automatic reloading. %autoreload 1 Reload all modules imported with %aimport every time before executing the Python code typed. %autoreload 2 Reload all modules (except those excluded by %aimport) every time before executing the Python code typed.
from IPython.lib.deepreload import reload as dreload dreload(foo)
sys.path.append( if del sys.modules[ print from Class_VerticesEdges import * reload(sys.modules[
def reload_module(full_module_name): import imp import sys import importlib if full_module_name in sys.modules: module_object = sys.modules[full_module_name] module_object = imp.reload( module_object ) else: importlib.import_module( full_module_name ) def run_tests(): print( "\n\n" ) reload_module( "Path With Spaces.tests.semantic_linefeed_unit_tests" ) reload_module( "Path With Spaces.tests.semantic_linefeed_manual_tests" ) from .tests import semantic_linefeed_unit_tests from .tests import semantic_linefeed_manual_tests semantic_linefeed_unit_tests.run_unit_tests() semantic_linefeed_manual_tests.run_manual_tests() if __name__ == "__main__": run_tests()
class MyClass(object): ... def get_my_attr(self): ... def set_my_attr(self, value): ...
class MyClass(object): ... @property def my_attr(self): ... @my_attr.setter def my_attr(self, value): ...
def set_email(self, value): if raise Exception("This doesn self._email = value def get_email(self): return self._email email = property(get_email, set_email)
class Example(object): def __init__(self, x=None, y=None): self.x = x self.y = y def getX(self): return self.x or self.defaultX() def getY(self): return self.y or self.defaultY() def setX(self, x): self.x = x def setY(self, y): self.y = y def defaultX(self): return someDefaultComputationForX() def defaultY(self): return someDefaultComputationForY()
class Example(object): def __init__(self, x=None, y=None): self._x = x self._y = y @property def x(self): return self.x or self.defaultX() @x.setter def x(self, value): self._x = value @property def y(self): return self.y or self.defaultY() @y.setter def y(self, value): self._y = value
print e.x -> The default at time T0 e.x = 1 print e.x -> 1 e.x = None print e.x -> The default at time T1
class UberProperty(object): def __init__(self, method): self.method = method self.value = None self.isSet = False def setValue(self, value): self.value = value self.isSet = True def clearValue(self): self.value = None self.isSet = False
class Example(object): @uberProperty def x(self): return defaultX()
class UberProperty(object): def __init__(self, method): self.method = method
class Example(object): @uberProperty def x(self): return defaultX() print Example.x <__main__.UberProperty object at 0x10e1fb8d0> print Example().x <__main__.UberProperty object at 0x10e1fb8d0>
class BoundUberProperty(object): def __init__(self, obj, uberProperty): self.obj = obj self.uberProperty = uberProperty self.isSet = False def setValue(self, value): self.value = value self.isSet = True def getValue(self): return self.value if self.isSet else self.uberProperty.method(self.obj) def clearValue(self): del self.value self.isSet = False
class UberObject(object): def __init__(self): for k in dir(self): v = getattr(self, k) if isinstance(v, UberProperty): v = BoundUberProperty(self, v) setattr(self, k, v)
e = Example() print e.x -> <__main__.BoundUberProperty object at 0x104604c90>
@uberProperty def x(self): return *datetime.datetime.now()*
print e.x.getValue() print e.x.getValue() e.x.setValue(datetime.date(2013, 5, 31)) print e.x.getValue() e.x.clearValue() print e.x.getValue()
class Example(object): @uberProperty def x(self): ... y = x
import datetime class UberObject(object): def uberSetter(self, value): print def uberGetter(self): return self def __init__(self): for k in dir(self): v = getattr(self, k) if isinstance(v, UberProperty): v = BoundUberProperty(self, v) setattr(self, k, v) class UberProperty(object): def __init__(self, method): self.method = method class BoundUberProperty(object): def __init__(self, obj, uberProperty): self.obj = obj self.uberProperty = uberProperty self.isSet = False def setValue(self, value): self.value = value self.isSet = True def getValue(self): return self.value if self.isSet else self.uberProperty.method(self.obj) def clearValue(self): del self.value self.isSet = False def uberProperty(f): return UberProperty(f) class Example(UberObject): @uberProperty def x(self): return datetime.datetime.now()
class C(object): _p = 1 @property def p(self): return self._p @p.setter def p(self, val): self._p = val
class D(C): @property def p(self): return super(D,D).p.fget(self) @p.setter def p(self, val): print super(D,D).p.fset(self, val) class E(C): p = C.p @p.setter def p(self, val): print C.p.fset(self, val)
class Account(object): @property def email(self): return self._email @email.setter def email(self, value): if raise ValueError( self._email = value
a = Account() a.email = --> ValueError: Invalid email address.
class Account(object): ... def validate(self): if raise ValueError(
class MyClass(object): ... @property def my_attr(self): ... def set_my_attr(self, value): ...
def slow_function(my_object): my_object.my_attr = 4. my_object.do_something()
class Foo: def __init__(self): self.__num = 0 @property def num(self): return self.__num @num.setter def num(self, num): self.__num = num def get_num(self): return self.__num def set_num(self, num): self.__num = num foo = Foo() print(foo.num) print(foo.get_num()) print(foo._Foo__num)
$ git clone https: $ cd foo $ python setup.py install
foo ├── foo │ ├── data_struct.py │ ├── __init__.py │ └── internals.py ├── README ├── requirements.txt └── setup.py
from setuptools import setup setup( name= version= description= author= author_email= packages=[ install_requires=[ )
foo ├── foo │ ├── data_struct.py │ ├── __init__.py │ └── internals.py ├── README ├── requirements.txt ├── scripts │ ├── cool │ └── skype └── setup.py
from setuptools import setup setup( name= version= description= author= author_email= packages=[ install_requires=[ scripts=[ ] )
from setuptools import setup with open("README", long_description = f.read() setup( name= version= description= license="MIT", long_description=long_description, author= author_email= url="http: packages=[ install_requires=[ scripts=[ ] )
python setup.py build python setup.py install python setup.py sdist <distname> upload [-r urltorepo] (to upload package to pypi or local repo)
iMac:pakagefolderwithsetupfile user$ python setup.py install
from distutils.core import setup from Cython.Build import cythonize setup( name = ext_modules = cythonize("hello.pyx"), )
import sys from cx_Freeze import setup, Executable build_exe_options = {"packages": ["os"], "excludes": ["tkinter"]} base = None if sys.platform == "win32": base = "Win32GUI" setup( name = "guifoo", version = "0.1", description = "My GUI application!", options = {"build_exe": build_exe_options}, executables = [Executable("guifoo.py", base=base)])
x = [ y = list(x) y[0] = y[1][0] = 4 print x print y
def apprentice(): read(diveintopython) experiment(interpreter) read(python_tutorial) experiment(interpreter, modules/files) watch(pycon) def master(): refer(python-essential-reference) refer(PEPs/language reference) experiment() read(good_python_code) write(basic_library) if have_interesting_ideas: give_talk(pycon) def guru(): pass
def singleton(class_): instances = {} def getinstance(*args, **kwargs): if class_ not in instances: instances[class_] = class_(*args, **kwargs) return instances[class_] return getinstance @singleton class MyClass(BaseClass): pass
class Singleton(object): _instance = None def __new__(class_, *args, **kwargs): if not isinstance(class_._instance, class_): class_._instance = object.__new__(class_, *args, **kwargs) return class_._instance class MyClass(Singleton, BaseClass): pass
class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class MyClass(BaseClass): __metaclass__ = Singleton class MyClass(BaseClass, metaclass=Singleton): pass
def singleton(class_): class class_w(class_): _instance = None def __new__(class_, *args, **kwargs): if class_w._instance is None: class_w._instance = super(class_w, class_).__new__(class_, *args, **kwargs) class_w._instance._sealed = False return class_w._instance def __init__(self, *args, **kwargs): if self._sealed: return super(class_w, self).__init__(*args, **kwargs) self._sealed = True class_w.__name__ = class_.__name__ return class_w @singleton class MyClass(BaseClass): pass
class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class Logger(object): __metaclass__ = Singleton
else: cls._instances[cls].__init__(*args, **kwargs)
class _Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(_Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class Singleton(_Singleton( class Logger(Singleton): pass
class Singleton(object): _instances = {} def __new__(class_, *args, **kwargs): if class_ not in class_._instances: class_._instances[class_] = super(Singleton, class_).__new__(class_, *args, **kwargs) return class_._instances[class_] class MyClass(Singleton): pass c = MyClass()
class Foo(object): pass some_global_variable = Foo()
class My_Singleton(object): def foo(self): pass my_singleton = My_Singleton()
from mysingleton import my_singleton my_singleton.foo()
@singleton class wat(object): def __init__(self): self.x = 1 def get_x(self): return self.x assert wat.get_x() == 1
@Singleton class Foo: def __init__(self): print f = Foo() f = Foo.Instance() g = Foo.Instance() print f is g
class Singleton: def __init__(self, decorated): self._decorated = decorated def Instance(self): try: return self._instance except AttributeError: self._instance = self._decorated() return self._instance def __call__(self): raise TypeError( def __instancecheck__(self, inst): return isinstance(inst, self._decorated)
class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] MC = Singleton( class MyClass(MC): pass
def singleton(class_): class class_w(class_): _instance = None def __new__(class2, *args, **kwargs): if class_w._instance is None: class_w._instance = super(class_w, class2).__new__(class2, *args, **kwargs) class_w._instance._sealed = False return class_w._instance def __init__(self, *args, **kwargs): if self._sealed: return super(class_w, self).__init__(*args, **kwargs) self._sealed = True class_w.__name__ = class_.__name__ return class_w @singleton class MyClass(object): def __init__(self, text): print text @classmethod def name(class_): print class_.__name__ x = MyClass(111) x.name() y = MyClass(222) print id(x) == id(y)
def singleton(cls): instance=cls() cls.__new__ = cls.__call__= lambda cls: instance cls.__init__ = lambda self: None return instance
def singleton(cls): instances = {} def getinstance(anyArgs=None): if cls not in instances: instances[cls] = cls(anyArgs) return instances[cls] return getinstance @singleton class MyClass: def __init__(self,count=None): print("print argument if any exists",count) def test(self, counter): print("-->",counter) return counter a = MyClass(10000) a.test(1) b = MyClass() b.test(2) if a != b: print("this is not a singleton") if a!=b: print("error")
from functools import wraps def singleton(cls): instances = {} def getinstance(anyArgs=None): if cls not in instances: instances[cls] = cls(anyArgs) return instances[cls] return getinstance def add_function(cls): def outer_decorate_it(somefunction): @wraps(somefunction) def wrapper( *args, **kwargs): return somefunction(*args, **kwargs) setattr(cls, somefunction.__name__, wrapper) return somefunction return outer_decorate_it @singleton class MyClass(): def __init__(self,count=None): print("print argument if any exists",count) @add_function(MyClass) def testit(): print("It MyClass.testit()
def _singleton(new_cls): instance = new_cls() def new(cls): if isinstance(instance, cls): return instance else: raise TypeError("I can only return instance of {}, caller wanted {}".format(new_cls, cls)) new_cls.__new__ = new new_cls.__init__ = lambda self: None return new_cls def singleton(cls): new_cls = type( return _singleton(new_cls) def meta_singleton(name, bases, attrs): new_cls = type(name, bases, attrs) return _singleton(new_cls)
class Elvis(): def __init__(self): if hasattr(self.__class__, raise Exception() self.__class__.instance = self @staticmethod def the(): if hasattr(Elvis, return Elvis.instance return Elvis()
try: from synchronize import make_synchronized except ImportError: def make_synchronized(func): import threading func.__lock__ = threading.Lock() def synced_func(*args, **kws): with func.__lock__: return func(*args, **kws) return synced_func class Elvis(object): instance = None @classmethod @make_synchronized def __new__(cls, *args, **kwargs): if cls.instance is not None: raise Exception() cls.instance = object.__new__(cls, *args, **kwargs) return cls.instance def __init__(self): pass @classmethod @make_synchronized def the(cls): if cls.instance is not None: return cls.instance return cls()
class Myclass: def __init__(self): globals()[type(self).__name__] = lambda: self
class SomeSingleton(dict): __instance__ = None def __new__(cls, *args,**kwargs): if SomeSingleton.__instance__ is None: SomeSingleton.__instance__ = dict.__new__(cls) return SomeSingleton.__instance__ def __init__(self): pass def some_func(self,arg): pass
from abc import ABC def singleton(real_cls): class SingletonFactory(ABC): instance = None def __new__(cls, *args, **kwargs): if not cls.instance: cls.instance = real_cls(*args, **kwargs) return cls.instance SingletonFactory.register(real_cls) return SingletonFactory @singleton class YourClass: ...
def unique(real_cls): class UniqueFactory(ABC): @functools.lru_cache(None) def __new__(cls, *args, **kwargs): return real_cls(*args, **kwargs) UniqueFactory.register(real_cls) return UniqueFactory
class Test(object): obj = None def __init__(self): if Test.obj is not None: raise Exception( @classmethod def get_instance(cls): if cls.obj is None: cls.obj = Test() return cls.obj @classmethod def custom_method(cls): obj = cls.get_instance()
MyNone = object() for item in my_list: if item is MyNone: raise StopIteration
class Foo(object): instance = None def __new__(cls): if cls.instance is None: cls.instance = object() cls.instance.__class__ = Foo return cls.instance
import random class FooMaker(object): def __init__(self, *args): self._count = random.random() self._args = args class Foo(object): def __new__(self): return foo_instance foo_instance = FooMaker() foo_instance.__class__ = Foo
import random class FooMaker(object): def __init__(self, *args): self._count = random.random() self._args = args class Foo(object): def __new__(self): global foo_instance if foo_instance is None: foo_instance = FooMaker() return foo_instance foo_instance = None
""" My numpydoc description of a kind of very exhautive numpydoc format docstring. Parameters ---------- first : array_like the 1st param name `first` second : the 2nd param third : { the 3rd param, by default Returns ------- string a value in a string Raises ------ KeyError when a key error OtherError when an other error """
def add_value(self, value): """Add a new value. Args: value (str): the value to add. """ pass
def sq(n): """ Return the square of n, accepting all numeric types: >>> sq(10) 100 >>> sq(10.434) 108.86835599999999 Raises a TypeError when input is invalid: >>> sq(4* Traceback (most recent call last): ... TypeError: can """ return n*n
def func(arg1, arg2): """Summary line. Extended description of function. Parameters ---------- arg1 : int Description of arg1 arg2 : str Description of arg2 Returns ------- bool Description of return value See Also -------- otherfunc : some related other function Examples -------- These are written in doctest format, and should illustrate how to use the function. >>> a=[1,2,3] >>> print [x + 3 for x in a] [4, 5, 6] """ return True
import os print(os.path.splitext("path_to_file")[0])
>>> import os >>> base=os.path.basename( >>> base >>> os.path.splitext(base) ( >>> os.path.splitext(base)[0]
>>> print(os.path.splitext(os.path.basename("hemanth.txt"))[0]) hemanth
from pathlib import Path print(Path(your_path).resolve().stem)
>>> file = >>> print ( /root/dir/sub.exten/file.data.1.2
>>> import os >>> file_path = >>> file_name = os.path.basename(file_path) >>> print os.path.splitext(file_name)[0] images.tar
>>> import os >>> file_path = >>> file_name = os.path.basename(file_path) >>> index_of_dot = file_name.index( >>> file_name_without_extension = file_name[:index_of_dot] >>> print file_name_without_extension images
>>> from pathlib import Path >>> p = Path("/a/b/c.txt") >>> print(p.with_suffix( \a\b\c >>> print(p.stem) c
>>> import os >>> path = >>> root, ext = os.path.splitext(path) >>> root >>> ext
filename = C:\\Users\\Public\\Videos\\Sample Videos\\wildlife.wmv
import os def file_base_name(file_name): if separator_index = file_name.index( base_name = file_name[:separator_index] return base_name else: return file_name def path_base_name(path): file_name = os.path.basename(path) return file_base_name(file_name)
>>> path_base_name( >>> path_base_name(u u >>> path_base_name( >>> path_base_name(u u >>> path_base_name( >>> path_base_name( >>> path_base_name( >>> path_base_name( >>> path_base_name( >>> path_base_name( >>> path_base_name( >>> path_base_name( >>> path_base_name(
>>> s = >>> print(os.path.splitext(s)[0]) c:\temp\akarmi
>>> print(os.path.splitext(os.path.basename(s))[0]) akarmi
import os path = "a/b/c/abc.txt" print os.path.splitext(os.path.basename(path))[0]
def getFileNameWithoutExtension(path): return path.split( getFileNameWithoutExtension( getFileNameWithoutExtension(
import os list = [] def getFileName( path ): for file in os.listdir(path): try: base=os.path.basename(file) splitbase=os.path.splitext(base) ext = os.path.splitext(base)[1] if(ext): list.append(base) else: newpath = path+"/"+file getFileName(newpath) except: pass return list getFileName("/home/weexcel-java3/Desktop/backup") print list
def filename(path): """Return file name without extension from path. See https: """ import os.path b = os.path.split(path)[1] f = os.path.splitext(b)[0] return f
import errno import os def mkdir_p(path): try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise
import pathlib pathlib.Path("/tmp/path/to/desired/directory").mkdir(parents=True, exist_ok=True)
import os if not os.path.exists(...): os.makedirs(...)
In [17]: from distutils.dir_util import mkpath In [18]: mkpath( Out[18]: [
$ touch /tmp/foo $ mkdir -p /tmp/foo mkdir: cannot create directory `/tmp/foo
import os def mkdirp(directory): if not os.path.isdir(directory): os.makedirs(directory)
import os import errno def mkdir_p(path): try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise
$ touch /tmp/foo $ mkdir -p /tmp/foo mkdir: cannot create directory
import os def mkdir_path(path): if not os.access(path, os.F_OK): os.mkdirs(path)
import os import errno def mkdir_path(path): try: os.mkdirs(path) except os.error, e: if e.errno != errno.EEXIST: raise
import os def mkdir_p(filename): try: folder=os.path.dirname(filename) if not os.path.exists(folder): os.makedirs(folder) return True except: return False
filename = "./download/80c16ee665c8/upload/backup/mysql/2014-12-22/adclient_sql_2014-12-22-13-38.sql.gz" if (mkdir_p(filename): print "Created dir :%s" % (os.path.dirname(filename))
def mkdirRecursive(dirpath): import os if os.path.isdir(dirpath): return h,t = os.path.split(dirpath) if not os.path.isdir(h): mkdirRecursive(h) os.mkdir(join(h,t))
import os import tempfile path = tempfile.mktemp(dir=path) os.makedirs(path) os.rmdir(path)
import os from os.path import join as join_paths def mk_dir_recursive(dir_path): if os.path.isdir(dir_path): return h, t = os.path.split(dir_path) if not os.path.isdir(h): mk_dir_recursive(h) new_path = join_paths(h, t) if not os.path.isdir(new_path): os.mkdir(new_path)
>>> b = 5 >>> a = 5 >>> id(a) 162334512 >>> id(b) 162334512 >>> a is b True
class ValueKeeper(object): def __init__(self, value): self.value = value def __str__(self): return str(self.value) class A(ValueKeeper): def __pos__(self): print return B(self.value - 3) class B(ValueKeeper): def __pos__(self): print return A(self.value + 19) x = A(430) print x, type(x) print +x, type(+x) print ++x, type(++x) print +++x, type(+++x)
def PreIncrement(name, local={}): if name in local: local[name]+=1 return local[name] globals()[name]+=1 return globals()[name] def PostIncrement(name, local={}): if name in local: local[name]+=1 return local[name]-1 globals()[name]+=1 return globals()[name]-1
x = 1 def test(): x = 10 y = PreIncrement( z = PreIncrement( test()
def PreDecrement(name, local={}): if name in local: local[name]-=1 return local[name] globals()[name]-=1 return globals()[name] def PostDecrement(name, local={}): if name in local: local[name]-=1 return local[name]+1 globals()[name]-=1 return globals()[name]+1
pre- and post-increment, pre- and post-decrement, addition, subtraction, multiplication, division, results assignable as integer, printable, settable.
class counter(object): def __init__(self,v=0): self.set(v) def preinc(self): self.v += 1 return self.v def predec(self): self.v -= 1 return self.v def postinc(self): self.v += 1 return self.v - 1 def postdec(self): self.v -= 1 return self.v + 1 def __add__(self,addend): return self.v + addend def __sub__(self,subtrahend): return self.v - subtrahend def __mul__(self,multiplier): return self.v * multiplier def __div__(self,divisor): return self.v / divisor def __getitem__(self): return self.v def __str__(self): return str(self.v) def set(self,v): if type(v) != int: v = 0 self.v = v
c = counter() for listItem in myList: doSomething(c.postinc(),listItem)
c = counter(100) d = c + 223 c = c + 223 print type(c),c
>>> import math >>> x=float( >>> math.isnan(x) True >>>
import numpy as np def is_nan(x): return (x is np.nan or x != x)
values = [float( for value in values: print "{:<8} : {}".format(repr(value), is_nan(value))
nan : True nan : True 55 : False <function <lambda> at 0x000000000927BF28> : False
def is_nan(x): return isinstance(x, float) and math.isnan(x)
def isnan(value): try: import math return math.isnan(float(value)) except: return False
In [1]: from numpy import math In [2]: a = None In [3]: not a Out[3]: True In [4]: len(a or ()) == 0 Out[4]: True In [5]: a == None Out[5]: True In [6]: a is None Out[6]: True In [7]: a != a Out[7]: False In [9]: math.isnan(a) Traceback (most recent call last): File "<ipython-input-9-6d4d8c26d370>", line 1, in <module> math.isnan(a) TypeError: a float is required In [10]: len(a) == 0 Traceback (most recent call last): File "<ipython-input-10-65b72372873e>", line 1, in <module> len(a) == 0 TypeError: object of type
In [11]: b = float( In [12]: b Out[12]: nan In [13]: not b Out[13]: False In [14]: b != b Out[14]: True In [15]: math.isnan(b) Out[15]: True
>>> import pandas as pd >>> value = float(nan) >>> type(value) >>> <class >>> pd.isnull(value) True >>> >>> value = >>> type(value) >>> <class >>> pd.isnull(value) False
if not pd.isnull(atext): for word in nltk.word_tokenize(atext):
def act_features(atext): features = {} if not pd.isnull(atext): for word in nltk.word_tokenize(atext): if word not in default_stopwords: features[ return features
from datetime import datetime ts = int("1284101485") print(datetime.utcfromtimestamp(ts).strftime(
>>> from datetime import datetime >>> datetime.fromtimestamp(1172969203.1) datetime.datetime(2007, 3, 4, 0, 46, 43, 100000)
datetime.datetime.utcfromtimestamp(posix_time).strftime(
>>> import time >>> time.ctime(int("1284101485")) >>> time.strftime("%D %H:%M", time.localtime(int("1284101485")))
from datetime import datetime import tzlocal unix_timestamp = float("1284101485") local_timezone = tzlocal.get_localzone() local_time = datetime.fromtimestamp(unix_timestamp, local_timezone)
print(local_time.strftime("%Y-%m-%d %H:%M:%S.%f%z (%Z)")) print(local_time.strftime("%B %d %Y"))
utc_time = datetime.utcfromtimestamp(unix_timestamp) print(utc_time.strftime("%Y-%m-%d %H:%M:%S.%f+00:00 (UTC)"))
local_time = datetime.fromtimestamp(unix_timestamp) print(local_time.strftime("%Y-%m-%d %H:%M:%S.%f"))
from datetime import datetime, timezone utc_time = datetime.fromtimestamp(unix_timestamp, timezone.utc) local_time = utc_time.astimezone() print(local_time.strftime("%Y-%m-%d %H:%M:%S.%f%z (%Z)"))
import time unix_timestamp = int("1284101485") utc_time = time.gmtime(unix_timestamp) local_time = time.localtime(unix_timestamp) print(time.strftime("%Y-%m-%d %H:%M:%S", local_time)) print(time.strftime("%Y-%m-%d %H:%M:%S+00:00 (UTC)", utc_time))
import os, datetime datetime.datetime.fromtimestamp(float(os.path.getmtime("FILE"))).strftime("%B %d, %Y")
import datetime,time def createDateObject(str_date,strFormat="%Y-%m-%d"): timeStamp = time.mktime(time.strptime(str_date,strFormat)) return datetime.datetime.fromtimestamp(timeStamp) def FormatDate(objectDate,strFormat="%Y-%m-%d"): return objectDate.strftime(strFormat) Usage ===== o=createDateObject( print FormatDate(o, Output 03-03-2013
import pandas result_ms=pandas.to_datetime( str(result_ms) Output:
import pandas result_s=pandas.to_datetime( str(result_s) Output:
import datetime temp = datetime.datetime.fromtimestamp(1386181800).strftime( print temp
>>> type(tstamp) pandas.tslib.Timestamp >>> newDt = tstamp.date() >>> type(newDt) datetime.date
import date_converter my_date_string = date_converter.timestamp_to_string(1284101485, "%B %d, %Y")
import datetime def xldate_to_datetime(xldate): temp = datetime.datetime(1899, 12, 30) delta = datetime.timedelta(days=xldate) return temp+delta ts = "1284101485" tsxl = ((int(ts)/60)/60)/24 + 25569 readabledate = xldate_to_datetime(tsxl) print(readabledate)
def uniq(input): output = [] for x in input: if x not in output: output.append(x) return output
def f7(seq): seen = set() seen_add = seen.add return [x for x in seq if not (x in seen or seen_add(x))]
>>> from more_itertools import unique_everseen >>> items = [1, 2, 0, 1, 3, 2] >>> list(unique_everseen(items)) [1, 2, 0, 3]
def unique_everseen(iterable, key=None): "List unique elements, preserving order. Remember all elements ever seen." seen = set() seen_add = seen.add if key is None: for element in filterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element
>>> from collections import OrderedDict >>> items = [1, 2, 0, 1, 3, 2] >>> list(OrderedDict.fromkeys(items)) [1, 2, 0, 3]
seen = set() [x for x in seq if x not in seen and not seen.add(x)]
>>> from collections import OrderedDict >>> list(OrderedDict.fromkeys( [
sequence = [ unique = [] [unique.append(item) for item in sequence if item not in unique]
from itertools import groupby [ key for key,_ in groupby(sortedList)]
list1 = [ list2 = list(set(list1)) list2.sort(key=list1.index) print list2
list1 = [ list2 = sorted(set(list1),key=list1.index) print list2
list1 = [ list2 = [] for i in list1: if not i in list2: list2.append(i)` print list2
list1 = [ list2 = [] [list2.append(i) for i in list1 if not i in list2] print list2
import pandas as pd my_list = [0, 1, 2, 3, 4, 1, 2, 3, 5] >>> pd.Series(my_list).drop_duplicates().tolist()
def unique(iterable): seen = set() seen_add = seen.add for element in itertools.ifilterfalse(seen.__contains__, iterable): seen_add(element) yield element
>>> from iteration_utilities import unique_everseen >>> lst = [1,1,1,2,3,2,2,2,1,3,4] >>> list(unique_everseen(lst)) [1, 2, 3, 4]
%matplotlib notebook from iteration_utilities import unique_everseen from collections import OrderedDict from more_itertools import unique_everseen as mi_unique_everseen def f7(seq): seen = set() seen_add = seen.add return [x for x in seq if not (x in seen or seen_add(x))] def iteration_utilities_unique_everseen(seq): return list(unique_everseen(seq)) def more_itertools_unique_everseen(seq): return list(mi_unique_everseen(seq)) def odict(seq): return list(OrderedDict.fromkeys(seq)) from simple_benchmark import benchmark b = benchmark([f7, iteration_utilities_unique_everseen, more_itertools_unique_everseen, odict], {2**i: list(range(2**i)) for i in range(1, 20)}, b.plot()
import random b = benchmark([f7, iteration_utilities_unique_everseen, more_itertools_unique_everseen, odict], {2**i: [random.randint(0, 2**(i-1)) for _ in range(2**i)] for i in range(1, 20)}, b.plot()
b = benchmark([f7, iteration_utilities_unique_everseen, more_itertools_unique_everseen, odict], {2**i: [1]*(2**i) for i in range(1, 20)}, b.plot()
>>> lst = [{1}, {1}, {2}, {1}, {3}] >>> list(unique_everseen(lst)) [{1}, {2}, {3}]
def f7_noHash(seq) seen = set() return [ x for x in seq if str( x ) not in seen and not seen.add( str( x ) )]
def unique(lst): return [] if lst==[] else [lst[0]] + unique(filter(lambda x: x!= lst[0], lst[1:]))
In [118]: unique([1,5,1,1,4,3,4]) Out[118]: [1, 5, 4, 3]
In [122]: %timeit unique(np.random.randint(5, size=(1))) 10000 loops, best of 3: 25.3 us per loop In [123]: %timeit unique(np.random.randint(5, size=(10))) 10000 loops, best of 3: 42.9 us per loop In [124]: %timeit unique(np.random.randint(5, size=(100))) 10000 loops, best of 3: 132 us per loop In [125]: %timeit unique(np.random.randint(5, size=(1000))) 1000 loops, best of 3: 1.05 ms per loop In [126]: %timeit unique(np.random.randint(5, size=(10000))) 100 loops, best of 3: 11 ms per loop
import operator def unique(lst, cmp_op=operator.ne): return [] if lst==[] else [lst[0]] + unique(filter(lambda x: cmp_op(x, lst[0]), lst[1:]), cmp_op)
In [6]: unique([1.2, 5, 1.9, 1.1, 4.2, 3, 4.8], test_round) Out[6]: [1.2, 5, 1.9, 4.2, 3]
>>> l = [5, 6, 6, 1, 1, 2, 2, 3, 4] >>> reduce(lambda r, v: v in r[1] and r or (r[0].append(v) or r[1].add(v)) or r, l, ([], set()))[0] [5, 6, 1, 2, 3, 4]
default = (list(), set()) def reducer(result, item): if item not in result[1]: result[0].append(item) result[1].add(item) return result >>> reduce(reducer, l, default)[0] [5, 6, 1, 2, 3, 4]
>>> lst = [1, 2, 1, 3, 3, 2, 4] >>> list(dict.fromkeys(lst)) [1, 2, 3, 4]
mylist = [x for i,x in enumerate(mylist) if x not in mylist[i+1:]]
def unique(my_list): return [x for x in my_list if x not in locals()[
l1 = [1, 2, 3, 4, 1, 2, 3, 4, 5] l2 = [x for x in l1 if x not in locals()[ print l2
[l[i] for i in range(len(l)) if l.index(l[i]) == i]
b = np.array([1,3,3, 8, 12, 12,12]) numpy.hstack([b[0], [x[0] for x in zip(b[1:], b[:-1]) if x[0]!=x[1]]])
l = [1,2,2,3,3,...] n = [] n.extend(ele for ele in l if ele not in set(n))
def uniquefy_list(a): return uniquefy_list(a[1:]) if a[0] in a[1:] else [a[0]]+uniquefy_list(a[1:]) if len(a)>1 else [a[0]]
reduce(lambda x, y: x + y if y[0] not in x else x, map(lambda x: [x],lst))
import pandas as pd import numpy as np uniquifier = lambda alist: pd.Series(alist).drop_duplicates().tolist() def f7(seq): seen = set() seen_add = seen.add return [ x for x in seq if not (x in seen or seen_add(x))] alist = np.random.randint(low=0, high=1000, size=10000).tolist() print uniquifier(alist) == f7(alist)
In [104]: %timeit f7(alist) 1000 loops, best of 3: 1.3 ms per loop In [110]: %timeit uniquifier(alist) 100 loops, best of 3: 4.39 ms per loop
def deduplicate(l): count = {} (read,write) = (0,0) while read < len(l): if l[read] in count: read += 1 continue count[l[read]] = True l[write] = l[read] read += 1 write += 1 return l[0:write]
text = "ask not what your country can do for you ask what you can do for your country" sentence = text.split(" ") noduplicates = [(sentence[i]) for i in range (0,len(sentence)) if sentence[i] not in sentence[:i]] print(noduplicates)
for i in range(len(l)-1,0,-1): if l[i] in l[:i]: del l[i]
In [91]: from random import randint, seed In [92]: seed( In [93]: for i in range(len(l)-1,0,-1): ...: print(l) ...: print(i, l[i], l[:i], end= ...: if l[i] in l[:i]: ...: print( ...: del l[i] ...: else: ...: print() ...: print(l) [6, 5, 1, 4, 6, 1, 6, 2, 2, 4, 5, 2] 11 2 [6, 5, 1, 4, 6, 1, 6, 2, 2, 4, 5]: remove 2 [6, 5, 1, 4, 6, 1, 6, 2, 2, 4, 5] 10 5 [6, 5, 1, 4, 6, 1, 6, 2, 2, 4]: remove 5 [6, 5, 1, 4, 6, 1, 6, 2, 2, 4] 9 4 [6, 5, 1, 4, 6, 1, 6, 2, 2]: remove 4 [6, 5, 1, 4, 6, 1, 6, 2, 2] 8 2 [6, 5, 1, 4, 6, 1, 6, 2]: remove 2 [6, 5, 1, 4, 6, 1, 6, 2] 7 2 [6, 5, 1, 4, 6, 1, 6] [6, 5, 1, 4, 6, 1, 6, 2] 6 6 [6, 5, 1, 4, 6, 1]: remove 6 [6, 5, 1, 4, 6, 1, 2] 5 1 [6, 5, 1, 4, 6]: remove 1 [6, 5, 1, 4, 6, 2] 4 6 [6, 5, 1, 4]: remove 6 [6, 5, 1, 4, 2] 3 4 [6, 5, 1] [6, 5, 1, 4, 2] 2 1 [6, 5] [6, 5, 1, 4, 2] 1 5 [6] [6, 5, 1, 4, 2] In [94]:
def front_back(a, b): if len(a) % 2 == 0 && len(b) % 2 == 0: return a[:(len(a)/2)] + b[:(len(b)/2)] + a[(len(a)/2):] + b[(len(b)/2):] else: return
>>> def print_and_return(value): ... print(value) ... return value >>> res = print_and_return(False) and print_and_return(True) False
>>> res = print_and_return(False) & print_and_return(True); False True
>>> res = print_and_return(True) and print_and_return(False); True False
class Test(object): def __init__(self, value): self.value = value def __bool__(self): print( return bool(self.value) __nonzero__ = __bool__ def __repr__(self): return "{self.__class__.__name__}({self.value})".format(self=self)
>>> if Test(True) and Test(False): ... pass __bool__ called on Test(True) __bool__ called on Test(False) >>> if Test(False) or Test(False): ... pass __bool__ called on Test(False) __bool__ called on Test(False) >>> if not Test(True): ... pass __bool__ called on Test(True)
>>> import numpy as np >>> arr = np.array([1,2,3]) >>> bool(arr) ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all() >>> arr and arr ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all() >>> import pandas as pd >>> s = pd.Series([1,2,3]) >>> bool(s) ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all(). >>> s and s ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
>>> np.logical_and(np.array([False,False,True,True]), np.array([True, False, True, False])) array([False, False, True, False]) >>> np.logical_or(np.array([False,False,True,True]), np.array([True, False, True, False])) array([ True, False, True, True])
>>> np.array([False,False,True,True]) & np.array([True, False, True, False]) array([False, False, True, False]) >>> np.array([False,False,True,True]) | np.array([True, False, True, False]) array([ True, False, True, True])
class Test(object): def __init__(self, value): self.value = value def __bool__(self): return self.value __nonzero__ = __bool__ def __repr__(self): return "{self.__class__.__name__}({self.value})".format(self=self) >>> x = Test(10) and Test(10) TypeError: __bool__ should return bool, returned int >>> x1 = Test(True) and Test(10) >>> x2 = Test(False) and Test(10)
>>> Test(True) or Test(10) Test(True) >>> Test(False) or Test(10) Test(10)
def AND(a,b): return (a and b) def OR(a,b): return (a or b)
def front_back(a, b): if len(a) % 2 == 0 and len(b) % 2 == 0: print a[:(len(a)/2)] + b[:(len(b)/2)] + a[(len(a)/2):] + b[(len(b)/2):] elif len(a) % 2 == 1 and len(b) % 2 == 0: print a[:(len(a)/2)+1] + b[:(len(b)/2)] + a[(len(a)/2)+1:] + b[(len(b)/2):] elif len(a) % 2 == 0 and len(b) % 2 == 1: print a[:(len(a)/2)] + b[:(len(b)/2)+1] + a[(len(a)/2):] + b[(len(b)/2)+1:] else : print a[:(len(a)/2)+1] + b[:(len(b)/2)+1] + a[(len(a)/2)+1:] + b[(len(b)/2)+1:]
def find_local_py_scripts(): import os for entry in os.scandir( if entry.is_file() and entry.name.endswith(".py") : print("- ", entry.name) find_local_py_scripts() - googlenet_custom_layers.py - GoogLeNet_Inception_v1.py
def front_back(a, b): if not len(a) & 1 and not len(b) & 1: return a[:(len(a)/2)] + b[:(len(b)/2)] + a[(len(a)/2):] + b[(len(b)/2):] else: return
>>> from __future__ import division >>> a = 4 >>> b = 6 >>> c = a / b >>> c 0.66666666666666663
>>> from __future__ import division >>> 1/2 0.5 >>> 1 0 >>> 1 0.0
>>> from operator import truediv >>> truediv(1, 2) 0.5
>>> 1 / float(2) 0.5 >>> 1 / float(2j) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can
>>> from __future__ import division >>> 4/3 1.3333333333333333
aa = 2 bb = 3 aa / bb = 0 1. * aa / bb = 0.6666666666666666
pkg/ __init__.py components/ core.py __init__.py tests/ core_test.py __init__.py
tests$ python core_test.py Traceback (most recent call last): File "core_test.py", line 3, in <module> from ..components.core import GameLoopEvents ValueError: Attempted relative import in non-package
if __name__ == from os import sys, path sys.path.append(path.dirname(path.dirname(path.abspath(__file__))))
import sys from os import path sys.path.append( path.dirname( path.dirname( path.abspath(__file__) ) ) ) from components.core import GameLoopEvents
if __name__ == if __package__ is None: import sys from os import path sys.path.append( path.dirname( path.dirname( path.abspath(__file__) ) ) ) from components.core import GameLoopEvents else: from ..components.core import GameLoopEvents
import sys sys.path.append( from core import GameLoopEvents
1) python -m tests.core_test 2) python tests/core_test.py
if __name__ == import sys from pathlib import Path sys.path.insert(0, str(Path(__file__).resolve().parent.parent)) from components import core <other stuff>
cd tests python core_test.py python -m core_test ...
>>> shutil.rmtree("/fake/dir") Traceback (most recent call last): [...] OSError: [Errno 2] No such file or directory:
>>> try: ... sys.exit(1) ... except: ... pass ... >>>
>>> try: ... sys.exit(1) ... except Exception: ... pass ... shell:~$
try: shutil.rmtree(path) except OSError, e: if e.errno == 2: pass else: raise
try: do_something() except: handle_exception() raise
from contextlib import suppress with suppress(Exception):
from contextlib import contextmanager @contextmanager def ignored(*exceptions): try: yield except exceptions: pass
>>> def divide(x, y): ... try: ... result = x / y ... except ZeroDivisionError: ... print "division by zero!" ... else: ... print "result is", result ... finally: ... print "executing finally clause"
>>> try: ... this_fails() ... except ZeroDivisionError as detail: ... print
with suppress(FileNotFoundError): shutil.rmtree(path)
>>> with suppress(FileNotFoundError): ... shutil.rmtree( ... >>>
BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StandardError | +-- BufferError | +-- ArithmeticError | | +-- FloatingPointError | | +-- OverflowError | | +-- ZeroDivisionError | +-- AssertionError | +-- AttributeError | +-- EnvironmentError | | +-- IOError | | +-- OSError | | +-- WindowsError (Windows) | | +-- VMSError (VMS) | +-- EOFError ... and so on
import errno try: shutil.rmtree(path) except OSError as error: if error.errno == errno.ENOENT: pass else: raise
try: shutil.rmtree(path) except OSError as error: if error.errno != errno.ENOENT: raise
try: doSomething() except Exception: pass else: stuffDoneIf() TryClauseSucceeds()
try: except <here we can put in a particular exception name>: finally:
import fuckit @fuckit def helper(): print( 1/0 print( 1/0 print( helper()
try: raise NameError( except NameError: print raise
from os.path import expanduser home = expanduser("~")
$ python -m timeit 10 loops, best of 3: 90.5 msec per loop $ python -m timeit 10 loops, best of 3: 51.1 msec per loop
import timeit t1 = timeit.default_timer() a = 0 for i in xrange(1, 100000000): pass t2 = timeit.default_timer() print "time taken: ", (t2-t1) t1 = timeit.default_timer() a = 0 for i in range(1, 100000000): pass t2 = timeit.default_timer() print "time taken: ", (t2-t1)
import timeit t1 = timeit.default_timer() a = 0 for i in xrange(1, 100000000): if i == 10000: break t2 = timeit.default_timer() print "time taken: ", (t2-t1) t1 = timeit.default_timer() a = 0 for i in range(1, 100000000): if i == 10000: break t2 = timeit.default_timer() print "time taken: ", (t2-t1)
In [1]: range(1,10) Out[1]: [1, 2, 3, 4, 5, 6, 7, 8, 9] In [2]: xrange(10) Out[2]: xrange(10) In [3]: print xrange.__doc__ xrange([start,] stop[, step]) -> xrange object
[In] range(1,10) [Out] [1, 2, 3, 4, 5, 6, 7, 8, 9] [In] xrange(1,10) [Out] xrange(1,10)
[In] for i in range(1,10): print i [Out] 1 2 3 4 5 6 7 8 9 [In] for i in xrange(1,10): print i [Out] 1 2 3 4 5 6 7 8 9
import time for x in range(1, 10): t = time.time() [v*10 for v in range(1, 10000)] print "range: %.4f" % ((time.time()-t)*100) t = time.time() [v*10 for v in xrange(1, 10000)] print "xrange: %.4f" % ((time.time()-t)*100)
$python range_tests.py range: 0.4273 xrange: 0.3733 range: 0.3881 xrange: 0.3507 range: 0.3712 xrange: 0.3565 range: 0.4031 xrange: 0.3558 range: 0.3714 xrange: 0.3520 range: 0.3834 xrange: 0.3546 range: 0.3717 xrange: 0.3511 range: 0.3745 xrange: 0.3523 range: 0.3858 xrange: 0.3997 <- garbage collection?
range: 0.4172 xrange: 0.3701 range: 0.3840 xrange: 0.3547 range: 0.3830 xrange: 0.3862 <- garbage collection? range: 0.4019 xrange: 0.3532 range: 0.3738 xrange: 0.3726 range: 0.3762 xrange: 0.3533 range: 0.3710 xrange: 0.3509 range: 0.3738 xrange: 0.3512 range: 0.3703 xrange: 0.3509
$ python -m timeit "for i in xrange(10111):" " for k in range(100):" " pass" 10 loops, best of 3: 59.4 msec per loop $ python -m timeit "for i in xrange(10111):" " for k in xrange(100):" " pass" 10 loops, best of 3: 46.9 msec per loop
>>> print range.__doc__ range(stop) -> list of integers range(start, stop[, step]) -> list of integers Return a list containing an arithmetic progression of integers. range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0. When step is given, it specifies the increment (or decrement). For example, range(4) returns [0, 1, 2, 3]. The end point is omitted! These are exactly the valid indices for a list of 4 elements. >>> print xrange.__doc__ xrange(stop) -> xrange object xrange(start, stop[, step]) -> xrange object Like range(), but instead of returning a list, returns an object that generates the numbers in the range on demand. For looping, this is slightly faster than range() and more memory efficient.
>>> print(range.__doc__) range(stop) -> range object range(start, stop[, step]) -> range object Return an object that produces a sequence of integers from start (inclusive) to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. These are exactly the valid indices for a list of 4 elements. When step is given, it specifies the increment (or decrement). >>> print(xrange.__doc__) Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name
import pandas as pd import numpy as np np.random.seed(5) df = pd.DataFrame(np.random.randint(100, size=(100, 6)), columns=list( index=[ df.head() Out: A B C D E F R0 99 78 61 16 73 8 R1 62 27 30 80 7 76 R2 15 53 80 27 44 77 R3 75 65 47 30 84 86 R4 18 9 41 62 1 82
df.loc[:, Out: C D E R0 61 16 73 R1 30 80 7 R2 80 27 44 R3 47 30 84 R4 41 62 1 R5 5 58 0 ...
df.loc[ Out: C D E R6 51 27 31 R7 83 19 18 R8 11 67 65 R9 78 27 29 R10 7 16 94
df.loc[:, df.columns.isin(list( Out: B C D R0 78 61 16 R1 27 30 80 R2 53 80 27 R3 65 47 30 R4 9 41 62 R5 78 5 58 ...
In [39]: df Out[39]: index a b c 0 1 2 3 4 1 2 3 4 5 In [40]: df1 = df[[ In [41]: df1 Out[41]: b c 0 3 4 1 4 5
columns = [ df1 = pd.DataFrame(df, columns=columns)
df = pd.DataFrame([[2,3,4],[3,4,5]],columns=[ columns_for_differencing = [ df1 = df.copy()[df.columns.difference(columns_for_differencing)] print(df1)
import pandas as pd df = pd.read_excel("data.xlsx", sheet_name = 2) print df df1 = df[[ print df1
emp_id date count 0 1001 11/1/2018 3 1 1002 11/1/2018 4 2 11/2/2018 2 3 11/3/2018 4 emp_id date 0 1001 11/1/2018 1 1002 11/1/2018 2 11/2/2018 3 11/3/2018
`df1= pd.DataFrame() for index,i in df.iterrows(): df1.loc[index, df1.loc[index, df1.head()
inverse = [(value, key) for key, value in stats.items()] print max(inverse)[1]
import operator stats = { max(stats.iteritems(), key=operator.itemgetter(1))[0]
>>> import operator >>> stats = { >>> max(stats.iteritems(), key=operator.itemgetter(1))[0]
>>> max(stats.items(), key=operator.itemgetter(1))[0]
def keywithmaxval(d): """ a) create a list of the dict b) return the key with the max value""" v=list(d.values()) k=list(d.keys()) return k[v.index(max(v))]
def f1(): v=list(d1.values()) k=list(d1.keys()) return k[v.index(max(v))] def f2(): d3={v:k for k,v in d1.items()} return d3[max(d3)] def f3(): return list(filter(lambda t: t[1]==max(d1.values()), d1.items()))[0][0] def f3b(): m=max(d1.values()) return list(filter(lambda t: t[1]==m, d1.items()))[0][0] def f4(): return [k for k,v in d1.items() if v==max(d1.values())][0] def f4b(): m=max(d1.values()) return [k for k,v in d1.items() if v==m][0] def f5(): return max(d1.items(), key=operator.itemgetter(1))[0] def f6(): return max(d1,key=d1.get) def f7(): """ a) create a list of the dict b) return the key with the max value""" v=list(d1.values()) return list(d1.keys())[v.index(max(v))] def f8(): return max(d1, key=lambda k: d1[k]) tl=[f1,f2, f3b, f4b, f5, f6, f7, f8, f4,f3] cmpthese.cmpthese(tl,c=100)
d1={1: 1, 2: 2, 3: 8, 4: 3, 5: 6, 6: 9, 7: 17, 8: 4, 9: 20, 10: 7, 11: 15, 12: 10, 13: 10, 14: 18, 15: 18, 16: 5, 17: 13, 18: 21, 19: 21, 20: 8, 21: 8, 22: 16, 23: 16, 24: 11, 25: 24, 26: 11, 27: 112, 28: 19, 29: 19, 30: 19, 3077: 36, 32: 6, 33: 27, 34: 14, 35: 14, 36: 22, 4102: 39, 38: 22, 39: 35, 40: 9, 41: 110, 42: 9, 43: 30, 44: 17, 45: 17, 46: 17, 47: 105, 48: 12, 49: 25, 50: 25, 51: 25, 52: 12, 53: 12, 54: 113, 1079: 50, 56: 20, 57: 33, 58: 20, 59: 33, 60: 20, 61: 20, 62: 108, 63: 108, 64: 7, 65: 28, 66: 28, 67: 28, 68: 15, 69: 15, 70: 15, 71: 103, 72: 23, 73: 116, 74: 23, 75: 15, 76: 23, 77: 23, 78: 36, 79: 36, 80: 10, 81: 23, 82: 111, 83: 111, 84: 10, 85: 10, 86: 31, 87: 31, 88: 18, 89: 31, 90: 18, 91: 93, 92: 18, 93: 18, 94: 106, 95: 106, 96: 13, 9232: 35, 98: 26, 99: 26, 100: 26, 101: 26, 103: 88, 104: 13, 106: 13, 107: 101, 1132: 63, 2158: 51, 112: 21, 113: 13, 116: 21, 118: 34, 119: 34, 7288: 45, 121: 96, 122: 21, 124: 109, 125: 109, 128: 8, 1154: 32, 131: 29, 134: 29, 136: 16, 137: 91, 140: 16, 142: 104, 143: 104, 146: 117, 148: 24, 149: 24, 152: 24, 154: 24, 155: 86, 160: 11, 161: 99, 1186: 76, 3238: 49, 167: 68, 170: 11, 172: 32, 175: 81, 178: 32, 179: 32, 182: 94, 184: 19, 31: 107, 188: 107, 190: 107, 196: 27, 197: 27, 202: 27, 206: 89, 208: 14, 214: 102, 215: 102, 220: 115, 37: 22, 224: 22, 226: 14, 232: 22, 233: 84, 238: 35, 242: 97, 244: 22, 250: 110, 251: 66, 1276: 58, 256: 9, 2308: 33, 262: 30, 263: 79, 268: 30, 269: 30, 274: 92, 1300: 27, 280: 17, 283: 61, 286: 105, 292: 118, 296: 25, 298: 25, 304: 25, 310: 87, 1336: 71, 319: 56, 322: 100, 323: 100, 325: 25, 55: 113, 334: 69, 340: 12, 1367: 40, 350: 82, 358: 33, 364: 95, 376: 108, 377: 64, 2429: 46, 394: 28, 395: 77, 404: 28, 412: 90, 1438: 53, 425: 59, 430: 103, 1456: 97, 433: 28, 445: 72, 448: 23, 466: 85, 479: 54, 484: 98, 485: 98, 488: 23, 6154: 37, 502: 67, 4616: 34, 526: 80, 538: 31, 566: 62, 3644: 44, 577: 31, 97: 119, 592: 26, 593: 75, 1619: 48, 638: 57, 646: 101, 650: 26, 110: 114, 668: 70, 2734: 41, 700: 83, 1732: 30, 719: 52, 728: 96, 754: 65, 1780: 74, 4858: 47, 130: 29, 790: 78, 1822: 43, 2051: 38, 808: 29, 850: 60, 866: 29, 890: 73, 911: 42, 958: 55, 970: 99, 976: 24, 166: 112}
rate/sec f4 f3 f3b f8 f5 f2 f4b f6 f7 f1 f4 454 -- -2.5% -96.9% -97.5% -98.6% -98.6% -98.7% -98.7% -98.9% -99.0% f3 466 2.6% -- -96.8% -97.4% -98.6% -98.6% -98.6% -98.7% -98.9% -99.0% f3b 14,715 3138.9% 3057.4% -- -18.6% -55.5% -56.0% -56.4% -58.3% -63.8% -68.4% f8 18,070 3877.3% 3777.3% 22.8% -- -45.4% -45.9% -46.5% -48.8% -55.5% -61.2% f5 33,091 7183.7% 7000.5% 124.9% 83.1% -- -1.0% -2.0% -6.3% -18.6% -29.0% f2 33,423 7256.8% 7071.8% 127.1% 85.0% 1.0% -- -1.0% -5.3% -17.7% -28.3% f4b 33,762 7331.4% 7144.6% 129.4% 86.8% 2.0% 1.0% -- -4.4% -16.9% -27.5% f6 35,300 7669.8% 7474.4% 139.9% 95.4% 6.7% 5.6% 4.6% -- -13.1% -24.2% f7 40,631 8843.2% 8618.3% 176.1% 124.9% 22.8% 21.6% 20.3% 15.1% -- -12.8% f1 46,598 10156.7% 9898.8% 216.7% 157.9% 40.8% 39.4% 38.0% 32.0% 14.7% --
rate/sec f3 f4 f8 f3b f6 f5 f2 f4b f7 f1 f3 384 -- -2.6% -97.1% -97.2% -97.9% -97.9% -98.0% -98.2% -98.5% -99.2% f4 394 2.6% -- -97.0% -97.2% -97.8% -97.9% -98.0% -98.1% -98.5% -99.1% f8 13,079 3303.3% 3216.1% -- -5.6% -28.6% -29.9% -32.8% -38.3% -49.7% -71.2% f3b 13,852 3504.5% 3412.1% 5.9% -- -24.4% -25.8% -28.9% -34.6% -46.7% -69.5% f6 18,325 4668.4% 4546.2% 40.1% 32.3% -- -1.8% -5.9% -13.5% -29.5% -59.6% f5 18,664 4756.5% 4632.0% 42.7% 34.7% 1.8% -- -4.1% -11.9% -28.2% -58.8% f2 19,470 4966.4% 4836.5% 48.9% 40.6% 6.2% 4.3% -- -8.1% -25.1% -57.1% f4b 21,187 5413.0% 5271.7% 62.0% 52.9% 15.6% 13.5% 8.8% -- -18.5% -53.3% f7 26,002 6665.8% 6492.4% 98.8% 87.7% 41.9% 39.3% 33.5% 22.7% -- -42.7% f1 45,354 11701.5% 11399.0% 246.8% 227.4% 147.5% 143.0% 132.9% 114.1% 74.4% --
lambda <item>: return <a result of operation with item>
stats = { max(stats.iterkeys(), key=lambda k: stats[k])
key, value = max(stats.iteritems(), key=lambda x:x[1])
>>> stats = { >>> [key for m in [max(stats.values())] for key,val in stats.iteritems() if val == m] [
d = { min_v = min(zip(d.values(), d.keys())) max_v = max(zip(d.values(), d.keys()))
>>> import collections >>> stats = { >>> stats = collections.Counter(stats) >>> stats.most_common(1) [(
>>> stats = collections.Counter() >>> stats[ : etc.
import operator stats = { max(stats.iteritems(), key=operator.itemgetter(1))[0]
stats = { x = sorted(stats, key=(lambda key:stats[key]), reverse=True) [
Counter = 0 for word in stats.keys(): if stats[word]> counter: Counter = stats [word] print Counter
stats = { import random maxV = max(stats.values()) choice = random.choice([key for key, value in stats.items() if value == maxV])
import time import operator d = {"a"+str(i): i for i in range(1000000)} def t1(dct): mx = float("-inf") key = None for k,v in dct.items(): if v > mx: mx = v key = k return key def t2(dct): v=list(dct.values()) k=list(dct.keys()) return k[v.index(max(v))] def t3(dct): return max(dct.items(),key=operator.itemgetter(1))[0] start = time.time() for i in range(25): m = t1(d) end = time.time() print ("Iterating: "+str(end-start)) start = time.time() for i in range(25): m = t2(d) end = time.time() print ("List creating: "+str(end-start)) start = time.time() for i in range(25): m = t3(d) end = time.time() print ("Accepted answer: "+str(end-start))
Iterating: 3.8201940059661865 List creating: 6.928712844848633 Accepted answer: 5.464320182800293
max(zip(stats.keys(), stats.values()), key=lambda t : t[1])[0]
from heapq import nlargest stats = { res1 = nlargest(1, stats, key=stats.__getitem__) res2 = nlargest(2, stats, key=stats.__getitem__) res1_val = next(iter(res1))
Project/ |-- bin/ | |-- project | |-- project/ | |-- test/ | | |-- __init__.py | | |-- test_main.py | | | |-- __init__.py | |-- main.py | |-- setup.py |-- README
$ pwd ~/code/sandman $ tree . |- LICENSE |- README.md |- TODO.md |- docs | |-- conf.py | |-- generated | |-- index.rst | |-- installation.rst | |-- modules.rst | |-- quickstart.rst | |-- sandman.rst |- requirements.txt |- sandman | |-- __init__.py | |-- exception.py | |-- model.py | |-- sandman.py | |-- test | |-- models.py | |-- test_sandman.py |- setup.py
class A(object): def __init__(self): self.x = def method_a(self, foo): print self.x +
class Point: def __init__(self, x, y): self._x = x self._y = y
class Point: def __init__(self, x, y): _x = x _y = y
class MyClass(object): i = 123 def __init__(self): self.i = 345 a = MyClass() print a.i 345 print MyClass.i 123
class Person: def __init__(self, name): self.n_name = name def show(self, n1, n2): print self.n_name print def __del__(self): print p=Person( p.show(2, 3) print p.__doc__ print p.__init__.__doc__ print p.show.__doc__
class A(object): def __init__(foo): foo.x = def method_a(bar, foo): print bar.x +
class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5) x.r, x.i
class Bill(): def __init__(self,apples,figs,dates): self.apples = apples self.figs = figs self.dates = dates self.bill = apples + figs + dates print ("Buy",self.apples,"apples", self.figs,"figs and",self.dates,"dates. Total fruitty bill is",self.bill," pieces of fruit :)")
> Buy 5 apples 6 figs and 7 dates. Total fruitty bill is 18 pieces of > fruit :)
class MyClass(object): my_CLS_var = 10 def __init__(self): self.my_OBJ_var = 15 MyClass.my_CLS_var = 20 def run_example_func(): print MyClass.my_CLS_var obj1 = MyClass() print obj1.my_OBJ_var print MyClass.my_CLS_var run_example_func()
class Cat: def __init__(self, name): self.name = name def info(self): print
class SomeObject(object): def __init__(self, blah): self.blah = blah def method(self): return self.blah
class MyClass: def __init__(self): print( def __del__(self): print( def __enter__(self): print( return self def __exit__(self, exc_type, exc_value, traceback): print( def greeting(self): print( if __name__ == with MyClass() as mycls: mycls.greeting()
$ python3 class.objects_instantiation.py __init__ is the constructor for a class __enter__ is for context manager hello python __exit__ is for context manager __del__ is the destructor for a class
TypeError: __init___() takes no arguments (1 given)
foo = (1, 2, 3) bar = (4, 5, 6) for (f, b) in some_iterator(foo, bar): print "f: ", f, "; b: ", b
for i in xrange(len(foo)): print "f: ", foo[i], "; b: ", b[i]
import itertools for f,b in itertools.izip(foo,bar): print(f,b) for f,b in itertools.izip_longest(foo,bar): print(f,b)
for (f,b) in zip(foo, bar): print "f: ", f ,"; b: ", b
def custom_zip(seq1, seq2): it1 = iter(seq1) it2 = iter(seq2) while True: yield next(it1), next(it2)
value1 = driver.find_elements_by_class_name("review-text") value2 = driver.find_elements_by_class_name("review-date") for val1 in value1: print(val1.text) print "\n" for val2 in value2: print(val2.text) print "\n"
for val1, val2 in zip(value1,value2): print (val1.text+ print "\n"
def construct_dictionary_from_lists(names, ages, scores): end_str_dic = {} for item_name, item_age, score_item in zip(names, ages, scores): end_str_dic[item_name] = item_age, score_item return end_str_dic print( construct_dictionary_from_lists( ["paul", "saul", "steve", "chimpy"], [28, 59, 22, 5], [59, 85, 55, 60] ) )
def ncustom_zip(seq1,seq2,max_length): length= len(seq1) if len(seq1)>len(seq2) else len(seq2) if max_length else len(seq1) if len(seq1)<len(seq2) else len(seq2) for i in range(length): x= seq1[i] if len(seq1)>i else None y= seq2[i] if len(seq2)>i else None yield x,y l=[12,2,3,9] p=[89,8,92,5,7] for i,j in ncustom_zip(l,p,True): print i,j for i,j in ncustom_zip(l,p,False): print i,j
C:\Users\User>python -m timeit -n10 -s"from sympy import isprime" "isprime(2**521-1);isprime(2**1279-1)" 10 loops, best of 3: 294 msec per loop C:\Users\User>pypy -m timeit -n10 -s"from sympy import isprime" "isprime(2**521-1);isprime(2**1279-1)" 10 loops, best of 3: 1.33 sec per loop
from sympy import sieve primes = list(sieve.primerange(1, 10**6))
list_of_ints = [ 1, 2, 3 ] iterator = list_of_ints.__iter__() element = None while True: if element: print element try: element = iterator.next() except StopIteration: break print "done"
[stdout:]1 [stdout:]2 [stdout:]3 None[ s = i.next()
s = "" while True : if state is STATE_CODE : if " tokens.add( TOKEN_COMMENT, s.split( " state = STATE_COMMENT else : tokens.add( TOKEN_CODE, s ) if state is STATE_COMMENT : if " tokens.append( TOKEN_COMMENT, s.split( " else state = STATE_CODE continue try : s = i.next() except StopIteration : break
for s in some_list: while True: if state is STATE_CODE: if " tokens.add( TOKEN_COMMENT, s.split( " state = STATE_COMMENT else : tokens.add( TOKEN_CODE, s ) if state is STATE_COMMENT: if " tokens.append( TOKEN_COMMENT, s.split( " break else: state = STATE_CODE
condition = True while condition: condition = test_loop_condition()
first_pass = True while first_pass or condition: first_pass = False do_stuff()
try: while True: if s: print s s = i.next() except StopIteration: pass
def do_while(stuff, condition): while condition(stuff()): pass
def coroutine(func): """Coroutine decorator Coroutines must be started, advanced to their first "yield" point, and this decorator does this automatically. """ def startcr(*ar, **kw): cr = func(*ar, **kw) cr.next() return cr return startcr @coroutine def collector(storage): """Act as "sink" and collect all sent in @storage""" while True: storage.append((yield)) @coroutine def state_machine(sink): """ .send() new parts to be tokenized by the state machine, tokens are passed on to @sink """ s = "" state = STATE_CODE while True: if state is STATE_CODE : if " sink.send((TOKEN_COMMENT, s.split( " state = STATE_COMMENT else : sink.send(( TOKEN_CODE, s )) if state is STATE_COMMENT : if " sink.send(( TOKEN_COMMENT, s.split( " else state = STATE_CODE continue s = (yield) tokens = [] sm = state_machine(collector(tokens)) for piece in i: sm.send(piece)
loop = True while loop: generic_stuff() try: questionable_stuff() except: optional_stuff() loop = False finally: more_generic_stuff()
while True: generic_stuff() try: questionable_stuff() except: optional_stuff() break
def dowhile(func = None, condition = None): if not func or not condition: return else: func() while condition(): func()
>>> x = 10 >>> def f(): ... global x ... x = x - 1 >>> def c(): global x return x > 0 >>> dowhile(f, c) >>> print x 0
condition = True while condition: do_stuff() condition = (<something that evaluates to True or False>)
flagBreak = false; while True : if flagBreak : break if s : print s try : s = i.next() except StopIteration : flagBreak = true print "done"
import time while True: try: f = open( except IOError: print( time.sleep(5) else: break
>>> print int("0xdeadbeef", 0) 3735928559 >>> print int("10", 0) 10
>>> string_1 = "0xffff" >>> string_2 = "ffff" >>> int(string_1, 16) 65535 >>> int(string_2, 16) 65535
>>> int(string_2, 0) Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: invalid literal for int() with base 0:
>>> integer = ffff Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name
print int(0xdeadbeef) myHex = "0xdeadbeef" print int(myHex) print int(myHex , 16)
>>> def hex_to_int(x): return eval("0x" + x) >>> hex_to_int("c0ffee") 12648430
a = int( print(a) print( b = a print(b) c = print(c)
>>> import ast >>> ast.literal_eval("0xffff") 65535 >>>
import threading class StoppableThread(threading.Thread): """Thread class with a stop() method. The thread itself has to check regularly for the stopped() condition.""" def __init__(self): super(StoppableThread, self).__init__() self._stop_event = threading.Event() def stop(self): self._stop_event.set() def stopped(self): return self._stop_event.is_set()
def _async_raise(tid, exctype): if not inspect.isclass(exctype): raise TypeError("Only types can be raised (not instances)") res = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid), ctypes.py_object(exctype)) if res == 0: raise ValueError("invalid thread id") elif res != 1: ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid), None) raise SystemError("PyThreadState_SetAsyncExc failed") class ThreadWithExc(threading.Thread): another thread. def _get_my_tid(self): """determines this (self CAREFUL : this function is executed in the context of the caller thread, to get the identity of the thread represented by this instance. """ if not self.isAlive(): raise threading.ThreadError("the thread is not active") if hasattr(self, "_thread_id"): return self._thread_id for tid, tobj in threading._active.items(): if tobj is self: self._thread_id = tid return tid raise AssertionError("could not determine the thread def raiseExc(self, exctype): """Raises the given exception type in the context of this thread. If the thread is busy in a system call (time.sleep(), socket.accept(), ...), the exception is simply ignored. If you are sure that your exception should terminate the thread, one way to ensure that it works is: t = ThreadWithExc( ... ) ... t.raiseExc( SomeException ) while t.isAlive(): time.sleep( 0.1 ) t.raiseExc( SomeException ) If the exception is to be caught by the thread, you need a way to check that your thread has caught it. CAREFUL : this function is executed in the context of the caller thread, to raise an excpetion in the context of the thread represented by this instance. """ _async_raise( self._get_my_tid(), exctype )
import ctypes def terminate_thread(thread): if not thread.isAlive(): return exc = ctypes.py_object(SystemExit) res = ctypes.pythonapi.PyThreadState_SetAsyncExc( ctypes.c_long(thread.ident), exc) if res == 0: raise ValueError("nonexistent thread id") elif res > 1: ctypes.pythonapi.PyThreadState_SetAsyncExc(thread.ident, None) raise SystemError("PyThreadState_SetAsyncExc failed")
import threading import time def do_work(id, stop): print("I am thread", id) while True: print("I am thread {} doing something".format(id)) if stop(): print(" Exiting loop.") break print("Thread {}, signing off".format(id)) def main(): stop_threads = False workers = [] for id in range(0,3): tmp = threading.Thread(target=do_work, args=(id, lambda: stop_threads)) workers.append(tmp) tmp.start() time.sleep(3) print( stop_threads = True for worker in workers: worker.join() print( if __name__ == main()
import sys import threading import time class StopThread(StopIteration): pass threading.SystemExit = SystemExit, StopThread class Thread2(threading.Thread): def stop(self): self.__stop = True def _bootstrap(self): if threading._trace_hook is not None: raise ValueError( self.__stop = False sys.settrace(self.__trace) super()._bootstrap() def __trace(self, frame, event, arg): if self.__stop: raise StopThread() return self.__trace class Thread3(threading.Thread): def _bootstrap(self, stop_thread=False): def stop(): nonlocal stop_thread stop_thread = True self.stop = stop def tracer(*_): if stop_thread: raise StopThread() return tracer sys.settrace(tracer) super()._bootstrap() def main(): test1 = Thread2(target=printer) test1.start() time.sleep(1) test1.stop() test1.join() test2 = Thread2(target=speed_test) test2.start() time.sleep(1) test2.stop() test2.join() test3 = Thread3(target=speed_test) test3.start() time.sleep(1) test3.stop() test3.join() def printer(): while True: print(time.time() % 1) time.sleep(0.1) def speed_test(count=0): try: while True: count += 1 except StopThread: print( if __name__ == main()
from ctypes import * pthread = cdll.LoadLibrary("libpthread-2.15.so") pthread.pthread_cancel(c_ulong(t.ident))
import threading import time import atexit def do_work(): i = 0 @atexit.register def goodbye(): print (" (i, threading.currentThread().ident)) while True: print i i += 1 time.sleep(1) t = threading.Thread(target=do_work) t.daemon = True t.start() def after_timeout(): print "KILL MAIN THREAD: %s" % threading.currentThread().ident raise SystemExit threading.Timer(2, after_timeout).start()
kill_threads = False def doSomething(): global kill_threads while True: if kill_threads: thread.exit() ...... ...... thread.start_new_thread(doSomething, ())
import threading class KillableThread(threading.Thread): def __init__(self, sleep_interval=1): super().__init__() self._kill = threading.Event() self._interval = sleep_interval def run(self): while True: print("Do Something") is_killed = self._kill.wait(self._interval) if is_killed: break print("Killing Thread") def kill(self): self._kill.set()
t = KillableThread(sleep_interval=5) t.start() t.kill()
from threading import * ... for thread in enumerate(): if thread.isAlive(): try: thread._Thread__stop() except: print(str(thread.getName()) +
my_thread = threading.Thread() my_thread.start() my_thread._Thread__stop()
def bootstrap(_filename): mb = ModelBootstrap(filename=_filename) t = threading.Thread(target=bootstrap,args=( t.setDaemon(False) while True: t.start() time.sleep(10) print( break
import threading import ctypes def _async_raise(tid, excobj): res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(excobj)) if res == 0: raise ValueError("nonexistent thread id") elif res > 1: ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, 0) raise SystemError("PyThreadState_SetAsyncExc failed") class Thread(threading.Thread): def raise_exc(self, excobj): assert self.isAlive(), "thread must be started" for tid, tobj in threading._active.items(): if tobj is self: _async_raise(tid, excobj) return def terminate(self): self.raise_exc(SystemExit)
processIds = [] def executeRecord(command): print(command) process = subprocess.Popen(command, stdout=subprocess.PIPE) processIds.append(process.pid) print(processIds[0]) process.stdout.read().decode("utf-8") return; def recordThread(command, timeOut): thread = Thread(target=executeRecord, args=(command,)) thread.start() thread.join(timeOut) os.kill(processIds.pop(), signal.SIGINT) return;
>>> import dis >>> dis.dis(compile( 1 0 BUILD_LIST 0 3 RETURN_VALUE >>> dis.dis(compile( 1 0 BUILD_MAP 0 3 RETURN_VALUE
>>> dis.dis(compile( 1 0 LOAD_NAME 0 (list) 3 CALL_FUNCTION 0 6 RETURN_VALUE >>> dis.dis(compile( 1 0 LOAD_NAME 0 (dict) 3 CALL_FUNCTION 0 6 RETURN_VALUE
>>> import timeit >>> timeit.timeit( 0.30749011039733887 >>> timeit.timeit( 0.4215109348297119
>>> timeit.timeit( 0.30478692054748535 >>> timeit.timeit( 0.31482696533203125 >>> timeit.timeit( 0.9991960525512695 >>> timeit.timeit( 1.0200958251953125
>>> timeit.timeit( 0.1866450309753418 >>> timeit.timeit( 0.19016098976135254 >>> timeit.timeit( 0.841480016708374 >>> timeit.timeit( 0.7233691215515137
Python 2.7.3 >>> import dis >>> print dis.dis(lambda: list()) 1 0 LOAD_GLOBAL 0 (list) 3 CALL_FUNCTION 0 6 RETURN_VALUE None >>> print dis.dis(lambda: []) 1 0 BUILD_LIST 0 3 RETURN_VALUE None
x = "wham bam" a = list(x) >>> a ["w", "h", "a", "m", ...]
list_display ::= "[" [starred_list | comprehension] "]"
class List(list): def __init__(self, iterable=None): if iterable is None: super().__init__() else: super().__init__(iterable) print(
>>> list = List >>> a_list = list() List initialized. >>> type(a_list) <class
>>> list_0 = list() List initialized. >>> type(list_0) <class
>>> del builtins.list >>> builtins.list Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: module >>> list() Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name
call ::= primary "(" [argument_list [","] | comprehension] ")"
>>> import dis >>> dis.dis( 1 0 LOAD_NAME 0 (list) 2 CALL_FUNCTION 0 4 RETURN_VALUE >>> dis.dis( 1 0 LOAD_NAME 0 (doesnotexist) 2 CALL_FUNCTION 0 4 RETURN_VALUE
import math def factorCount (n): square = math.sqrt (n) isquare = int (square) count = -1 if isquare == square else 0 for candidate in range (1, isquare + 1): if not n % candidate: count += 2 return count triangle = 1 index = 1 while factorCount (triangle) < 1001: index += 1 triangle += index print (triangle)
Partition of a set of 132527 objects. Total size = 8301532 bytes. Index Count % Size % Cumulative % Kind (class / dict of class) 0 35144 27 2140412 26 2140412 26 str 1 38397 29 1309020 16 3449432 42 tuple 2 530 0 739856 9 4189288 50 dict (no owner)
Line ============================================== 3 @profile 4 5.97 MB 0.00 MB def my_func(): 5 13.61 MB 7.64 MB a = [1] * (10 ** 6) 6 166.20 MB 152.59 MB b = [2] * (2 * 10 ** 7) 7 13.61 MB -152.59 MB del b 8 13.61 MB 0.00 MB return a
import cherrypy import dowser def start(port): cherrypy.tree.mount(dowser.Root()) cherrypy.config.update({ }) cherrypy.server.quickstart() cherrypy.engine.start(blocking=False)
import cherrypy import dowser def start(port): cherrypy.tree.mount(dowser.Root()) cherrypy.config.update({ }) cherrypy.engine.start()
string thisIsMyVariable = "a" public void ThisIsMyMethod()
import os import shutil os.rename("path/to/current/file.foo", "path/to/new/destination/for/file.foo") shutil.move("path/to/current/file.foo", "path/to/new/destination/for/file.foo")
in /opt/awesome ○ → ls source ○ → ls source awesome.txt python >>> source = >>> destination = >>> import os >>> os.rename(source, destination) >>> os.listdir( [
>>> import shutil >>> shutil.move(destination, source) >>> os.listdir( [
import os, shutil path = "/volume1/Users/Transfer/" moveto = "/volume1/Users/Drive_Transfer/" files = os.listdir(path) files.sort() for f in files: src = path+f dst = moveto+f shutil.move(src,dst)
import subprocess source = destination = p = subprocess.Popen([ res = p.communicate()[0].decode( if p.returncode: print
import os,shutil current_path = "" new_path = "" os.chdir(current_path) for files in os.listdir(): os.rename(files, new_path+ shutil.move(files, new_path+
subprocess.call("mv %s %s" % (source_files, destination_folder), shell=True)
field_plural = None if field_plural is not None: print("insert into testtable(plural)
[lambda: value_false, lambda: value_true][<test>]()
<execute-test-successful-condition> if <test> else <execute-test-fail-condition>
d={1: print for k,v in d.items(): if d[k] is v: print else: print print for k,v in d.iteritems(): if d[k] is v: print else: print
d.items(): they are the same object they are the same object they are the same object d.iteritems(): they are the same object they are the same object they are the same object
$ python2.7 >>> d = { >>> type(d.items()) <type >>> type(d.keys()) <type >>> >>> >>> type(d.iteritems()) <type >>> type(d.iterkeys()) <type >>> >>> >>> type(d.viewitems()) <type >>> type(d.viewkeys()) <type
$ python3.3 >>> d = { >>> type(d.items()) <class >>> >>> type(d.keys()) <class >>> >>> >>> ii = iter(d.items()) >>> type(ii) <class >>> >>> ik = iter(d.keys()) >>> type(ik) <class
>>> d={1: >>> type(d.items()) <type >>> type(d.iteritems()) <type
>>> next(d.items()) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: list object is not an iterator
>>> i1=d.iteritems()[0] Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError:
import timeit d = {i:i*2 for i in xrange(10000000)} start = timeit.default_timer() for key,value in d.items(): tmp = key + value t1 = timeit.default_timer() - start start = timeit.default_timer() for key,value in d.iteritems(): tmp = key + value t2 = timeit.default_timer() - start
Time with d.items(): 9.04773592949 Time with d.iteritems(): 2.17707300186
dict = {i: i * 2 for i in xrange(10000000)} for key, value in dict.items(): print(key,":",value)
dict = {i: i * 2 for i in xrange(10000000)} for key, value in dict.iteritems(): print(key,":",value)
student = {"name": "Daniel", "student_id": 2222} for key,value in student.items(): print(key,value) ( ( for key,value in student.iteritems(): print(key,value) ( ( studentIterator = student.iteritems() print(studentIterator.next()) ( print(studentIterator.next()) (
DICT_ITER_ITEMS = (lambda d: d.iteritems()) if hasattr(dict,
$ python -mtimeit -s 100000 loops, best of 3: 4.86 usec per loop $ python -mtimeit -s 100000 loops, best of 3: 5.58 usec per loop
$ python -mtimeit -s 100000 loops, best of 3: 4.24 usec per loop $ python -mtimeit -s 100000 loops, best of 3: 2.32 usec per loop
def sumEach(myLists): return [sum(_) for _ in myLists]
>>> map(str, range(10**100)) <map object at 0x2201d50>
>>> (str(n) for n in range(10**100)) <generator object <genexpr> at 0xacbdef>
from operator import neg print({x:x**2 for x in map(neg,range(5))}) print({x:x**2 for x in [-y for y in range(5)]}) print({x:x**2 for x in (-y for y in range(5))})
rangeNeg5 = (-y for y in range(5)) print( {x:x**2 for x in rangeNeg5} )
% python3 -mtimeit -s 1000000 loops, best of 3: 0.336 usec per loop ^^^^^^^^^
% python3 -mtimeit -s 10000 loops, best of 3: 165/124/135 usec per loop ^^^^^^^^^^^^^^^ for list(<map object>) % python3 -mtimeit -s 10000 loops, best of 3: 181/118/123 usec per loop ^^^^^^^^^^^^^^^^^^ for list(<generator>), probably optimized % python3 -mtimeit -s 1000 loops, best of 3: 215/150/150 usec per loop ^^^^^^^^^^^^^^^^^^^^^^ for list(<generator>)
>>> listComp = compile( >>> dis.dis(listComp) 1 0 LOAD_CONST 0 (<code object <listcomp> at 0x2511a48, file "listComp", line 1>) 3 MAKE_FUNCTION 0 6 LOAD_NAME 0 (xs) 9 GET_ITER 10 CALL_FUNCTION 1 13 RETURN_VALUE >>> listComp.co_consts (<code object <listcomp> at 0x2511a48, file "listComp", line 1>,) >>> dis.dis(listComp.co_consts[0]) 1 0 BUILD_LIST 0 3 LOAD_FAST 0 (.0) >> 6 FOR_ITER 18 (to 27) 9 STORE_FAST 1 (x) 12 LOAD_GLOBAL 0 (f) 15 LOAD_FAST 1 (x) 18 CALL_FUNCTION 1 21 LIST_APPEND 2 24 JUMP_ABSOLUTE 6 >> 27 RETURN_VALUE
>>> listComp2 = compile( >>> dis.dis(listComp2) 1 0 LOAD_NAME 0 (list) 3 LOAD_CONST 0 (<code object <genexpr> at 0x255bc68, file "listComp2", line 1>) 6 MAKE_FUNCTION 0 9 LOAD_NAME 1 (xs) 12 GET_ITER 13 CALL_FUNCTION 1 16 CALL_FUNCTION 1 19 RETURN_VALUE >>> listComp2.co_consts (<code object <genexpr> at 0x255bc68, file "listComp2", line 1>,) >>> dis.dis(listComp2.co_consts[0]) 1 0 LOAD_FAST 0 (.0) >> 3 FOR_ITER 17 (to 23) 6 STORE_FAST 1 (x) 9 LOAD_GLOBAL 0 (f) 12 LOAD_FAST 1 (x) 15 CALL_FUNCTION 1 18 YIELD_VALUE 19 POP_TOP 20 JUMP_ABSOLUTE 3 >> 23 LOAD_CONST 0 (None) 26 RETURN_VALUE
>>> evalledMap = compile( >>> dis.dis(evalledMap) 1 0 LOAD_NAME 0 (list) 3 LOAD_NAME 1 (map) 6 LOAD_NAME 2 (f) 9 LOAD_NAME 3 (xs) 12 CALL_FUNCTION 2 15 CALL_FUNCTION 1 18 RETURN_VALUE
for x, y in somePoints: squared = [x ** 2 for x in numbers]
for x, y in somePoints: squared = map(lambda x: x ** 2, numbers)
def square(x): return x*x squares = map(square, [1, 2, 3]) print(list(squares)) print(list(squares))
x_list = [(i, i+1, i+2, i*2, i-9) for i in range(1000)] i_list = list(range(1000))
%timeit map(sum, x_list) %timeit list(map(sum, x_list)) %timeit [sum(x) for x in x_list]
%timeit map(lambda i: i+1, i_list) %timeit list(map(lambda i: i+1, i_list)) %timeit [i+1 for i in i_list]
%timeit (sum(i) for i in x_list) %timeit list((sum(x) for x in x_list)) %timeit (i+1 for i in i_list) %timeit list((i+1 for i in i_list))
In [1]: odd_cubes = [x ** 3 for x in range(10) if x % 2 == 1] In [2]: odd_cubes_alt = list(map(lambda x: x ** 3, filter(lambda x: x % 2 == 1, range(10)))) In [3]: odd_cubes == odd_cubes_alt Out[3]: True
row = [unicode(x.strip()) for x in row if x is not None else
def change(f): if f is None: return unicode(f.strip()) else: return row = [change(x) for x in row]
>>> print(", ".join(["ha" if i else "Ha" for i in range(3)]) + "!") Ha, ha, ha!
X = [1.5, 2.3, 4.4, 5.4, X_non_str = [el for el in X if not isinstance(el, str)] X_str_changed = [
row = [None, d = {None: res = [d.get(x, x) for x in row] print(res) [
>>> ut [<Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag: actionscript>, <Tag: addresses>, <Tag: aes>, <Tag: ajax> ...]
ut.sort(key=lambda x: x.count, reverse=True) newlist = sorted(ut, key=lambda x: x.count, reverse=True)
try: import operator except ImportError: keyfun= lambda x: x.count else: keyfun= operator.attrgetter("count") ut.sort(key=keyfun, reverse=True)
import random class C: def __init__(self,count): self.count = count def __cmp__(self,other): return cmp(self.count,other.count) longList = [C(random.random()) for i in xrange(1000000)] longList2 = longList[:] longList.sort() longList2.sort(key = lambda c: c.count)
from operator import attrgetter ut.sort(key = attrgetter(
class Card(object): def __init__(self, rank, suit): self.rank = rank self.suit = suit def __eq__(self, other): return self.rank == other.rank and self.suit == other.suit def __lt__(self, other): return self.rank < other.rank hand = [Card(10, hand_order = [c.rank for c in hand] hand_sorted = sorted(hand) hand_sorted_order = [c.rank for c in hand_sorted]
import random class a: foo = "bar" a1 = a() a2 = a() b = [a1,a2] print random.shuffle(b)
from random import shuffle x = [[i] for i in range(10)] shuffle(x)
import random a = range(5) b = random.sample(a, len(a)) print a, b, "two list same:", a == b a = range(555) b = random.sample(a, len(a)) print "no duplicates:", a == list(set(b)) try: random.sample(a, len(a) + 1) except ValueError as e: print "Nope!", e
import random s=list(range(5)) random.shuffle(s) print(s)
>>> import random >>> a = [ >>> random.shuffle(a,random.random) >>> a [
import random perm = list(range(len(list_one))) random.shuffle(perm) list_one = [list_one[index] for index in perm] list_two = [list_two[index] for index in perm]
import numpy as np perm = np.random.permutation(len(list_one)) list_one = list_one[perm] list_two = list_two[perm]
import mpu import random random.seed(8) list_one = [1,2,3] list_two = [ list_one, list_two = mpu.consistent_shuffle(list_one, list_two)
from random import random my_list = range(10) shuffled_list = sorted(my_list, key=lambda x: random())
>>> foo = np.array([[1,2,3],[4,5,6],[7,8,9]]) >>> foo array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> random.shuffle(foo) >>> foo array([[1, 2, 3], [1, 2, 3], [4, 5, 6]])
>>> foo = np.array([[1,2,3],[4,5,6],[7,8,9]]) >>> foo array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> np.random.shuffle(foo) >>> foo array([[1, 2, 3], [7, 8, 9], [4, 5, 6]])
def shuffled(x): import random y = x[:] random.shuffle(y) return y x = shuffled([1, 2, 3, 4]) print x
import random class a: foo = "bar" a1 = a() a2 = a() a3 = a() a4 = a() b = [a1,a2,a3,a4] random.shuffle(b) print(b)
>>> A = [ >>> B = [1,2,3,4,5,6] >>> import random >>> random.sample(A+B, len(A+B)) [3,
def shuffle(_list): if not _list == []: import random list2 = [] while _list != []: card = random.choice(_list) _list.remove(card) list2.append(card) while list2 != []: card1 = list2[0] list2.remove(card1) _list.append(card1) return _list
from random import * def listshuffler(inputlist): for i in range(len(inputlist)): swap = randint(0,len(inputlist)-1) temp = inputlist[swap] inputlist[swap] = inputlist[i] inputlist[i] = temp return inputlist
def shuffle(x,random=False): shuffled = [] ma = x if random == True: rando = [ma[i] for i in np.random.randint(0,len(ma),len(ma))] return rando if random == False: for i in range(len(ma)): ave = len(ma) if i < ave: shuffled.append(ma[i+ave]) else: shuffled.append(ma[i-ave]) return shuffled
import random def shuffle(arr1): n=len(arr1) b=random.sample(arr1,n) return b
import random def shuffle(arr1): random.shuffle(arr1) return arr1
import random class a: foo = "bar" a1 = a() a2 = a() b = [a1.foo,a2.foo] random.shuffle(b)
import random iteration = random.randint(2, 100) temp_var = 0 while iteration > 0: for i in range(1, len(my_list)): for j in range(1, len(my_list) - i): temp_var = my_list[i] my_list[i] = my_list[j] my_list[j] = temp_var iteration -= 1
from random import shuffle def foo1(): print "foo1", def foo2(): print "foo2", def foo3(): print "foo3", A=[foo1,foo2,foo3] for x in A: x() print "\r" shuffle(A) for y in A: y()
Traceback (most recent call last): File "<console>", line 1, in <module> AttributeError:
s = print (s.upper()) upper = raw_input( lower = raw_input( print upper.upper() print lower.lower()
Running virtualenv with interpreter /usr/local/bin/python3 Using base prefix New python executable in test/bin/python3.4 Also creating executable in test/bin/python Failed to import the site module Traceback (most recent call last): File "/Users/user/Documents/workspace/test/test/bin/../lib/python3.4/site.py", line 67, in <module> import os File "/Users/user/Documents/workspace/test/test/bin/../lib/python3.4/os.py", line 634, in <module> from _collections_abc import MutableMapping ImportError: No module named ERROR: The executable test/bin/python3.4 is not functioning ERROR: It thinks sys.prefix is ERROR: virtualenv is not compatible with this system or executable
sudo apt-get install python3 python3-pip virtualenvwrapper
pip install -r requirements.txt pip install <package_name>
sudo -H pip3 -v install pdbpp mkvirtualenv -p $(which python3) --system-site-packages <venv-name>
virtualenv -p /Users/johnny/.pyenv/versions/3.5.0/bin/python3.5 myenv
virtualenv --python=/Users/username/.pyenv/versions/3.6.0/bin/python3.6 envname
mkvirtualenv --python=/usr/bin/python3 YourEnvNameHere
virtualenv --no-site-packages --distribute -p /usr/bin/python3 ~/.virtualenvs/py3
conda create -n name_of_your_virtualenv python=python_version
Amans-MacBook-Pro:~ amanmadan$ pip install virtualenv You are using pip version 6.1.1, however version 8.1.2 is available. You should consider upgrading via the Collecting virtualenv Downloading virtualenv-15.0.3-py2.py3-none-any.whl (3.5MB) 100% |████████████████████████████████| 3.5MB 114kB/s Installing collected packages: virtualenv Successfully installed virtualenv-15.0.3 Amans-MacBook-Pro:python amanmadan$ virtualenv my_env New python executable in /Users/amanmadan/Documents/HadoopStuff/python/my_env/bin/python Installing setuptools, pip, wheel...done. Amans-MacBook-Pro:python amanmadan$
>>> eval("shutil.rmtree( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1, in <module> File "/opt/Python-2.6.1/lib/python2.6/shutil.py", line 208, in rmtree onerror(os.listdir, path, sys.exc_info()) File "/opt/Python-2.6.1/lib/python2.6/shutil.py", line 206, in rmtree names = os.listdir(path) OSError: [Errno 2] No such file or directory: >>> ast.literal_eval("shutil.rmtree( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "/opt/Python-2.6.1/lib/python2.6/ast.py", line 68, in literal_eval return _convert(node_or_string) File "/opt/Python-2.6.1/lib/python2.6/ast.py", line 67, in _convert raise ValueError( ValueError: malformed string
import json s = "{ json_acceptable_string = s.replace(" d = json.loads(json_acceptable_string)
>>> import json >>> h = >>> type(h) <type >>> d = json.loads(h) >>> d {u >>> type(d) <type
>>> import yaml >>> s = "{ >>> s "{ >>> yaml.load(s) {
>>> import ast >>> data = "{ >>> ast.literal_eval(data) O/P: { >>> user = ast.literal_eval(data) >>> user[ O/P: 10 >>> user[ O/P: [ >>> user[ O/P:
string = "{ s = string.replace("{" ,"") finalstring = s.replace("}" , "") list = finalstring.split(",") dictionary ={} for i in list: keyvalue = i.split(":") m= keyvalue[0].strip( m = m.replace("\"", "") dictionary[m] = keyvalue[1].strip( print dictionary
dict_format_string = "{ d = {} elems = filter(str.isalnum,dict_format_string.split(" values = elems[1::2] keys = elems[0::2] d.update(zip(keys,values))
import ast, yaml, json, timeit descs=[ strings=[ funcs=[json.loads,eval,ast.literal_eval,yaml.load] for desc,string in zip(descs,strings): print( print( for func in funcs: print(func.__module__+ %timeit func(string) print(
*** short string *** json loads: 4.47 µs ± 33.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) builtins eval: 24.1 µs ± 163 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) ast literal_eval: 30.4 µs ± 299 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) yaml load: 504 µs ± 1.29 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) *** long string *** json loads: 29.6 µs ± 230 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) builtins eval: 219 µs ± 3.92 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) ast literal_eval: 331 µs ± 1.89 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) yaml load: 9.02 ms ± 92.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
s = set(temp2) temp3 = [x for x in temp1 if x not in s]
import timeit init = print timeit.timeit( print timeit.timeit( print timeit.timeit(
init = temp1 = [str(i) for i in range(100000)] temp2 = [str(i * 2) for i in range(50)]
temp3 = [item for item in temp1 if item not in temp2]
def diff(list1, list2): c = set(list1).union(set(list2)) d = set(list1).intersection(set(list2)) return list(c - d)
def diff(list1, list2): return list(set(list1).symmetric_difference(set(list2)))
>>> from deepdiff import DeepDiff >>> from pprint import pprint >>> from __future__ import print_function
>>> t1 = {1:1, 2:2, 3:3} >>> t2 = t1 >>> print(DeepDiff(t1, t2)) {}
>>> t1 = {1:1, 2:2, 3:3} >>> t2 = {1:1, 2:"2", 3:3} >>> pprint(DeepDiff(t1, t2), indent=2) {
>>> t1 = {1:1, 2:2, 3:3} >>> t2 = {1:1, 2:4, 3:3} >>> pprint(DeepDiff(t1, t2), indent=2) {
>>> t1 = {1:1, 2:2, 3:3, 4:4} >>> t2 = {1:1, 2:4, 3:3, 5:5, 6:6} >>> ddiff = DeepDiff(t1, t2) >>> pprint (ddiff) {
>>> t1 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":"world"}} >>> t2 = {1:1, 2:4, 3:3, 4:{"a":"hello", "b":"world!"}} >>> ddiff = DeepDiff(t1, t2) >>> pprint (ddiff, indent = 2) { "root[4][
>>> t1 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":"world!\nGoodbye!\n1\n2\nEnd"}} >>> t2 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":"world\n1\n2\nEnd"}} >>> ddiff = DeepDiff(t1, t2) >>> pprint (ddiff, indent = 2) { >>> >>> print (ddiff[ --- +++ @@ -1,5 +1,4 @@ -world! -Goodbye! +world 1 2 End
>>> t1 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 2, 3]}} >>> t2 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":"world\n\n\nEnd"}} >>> ddiff = DeepDiff(t1, t2) >>> pprint (ddiff, indent = 2) {
>>> t1 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 2, 3, 4]}} >>> t2 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 2]}} >>> ddiff = DeepDiff(t1, t2) >>> pprint (ddiff, indent = 2) {
>>> t1 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 2, 3]}} >>> t2 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 3, 2, 3]}} >>> ddiff = DeepDiff(t1, t2) >>> pprint (ddiff, indent = 2) { "root[4][
>>> t1 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 2, 3]}} >>> t2 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 3, 2, 3]}} >>> ddiff = DeepDiff(t1, t2, ignore_order=True) >>> print (ddiff) {}
>>> t1 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 2, {1:1, 2:2}]}} >>> t2 = {1:1, 2:2, 3:3, 4:{"a":"hello", "b":[1, 2, {1:3}]}} >>> ddiff = DeepDiff(t1, t2) >>> pprint (ddiff, indent = 2) {
>>> t1 = {1, 2, 8} >>> t2 = {1, 2, 3, 5} >>> ddiff = DeepDiff(t1, t2) >>> pprint (DeepDiff(t1, t2)) {
>>> from collections import namedtuple >>> Point = namedtuple( >>> t1 = Point(x=11, y=22) >>> t2 = Point(x=11, y=23) >>> pprint (DeepDiff(t1, t2)) {
>>> class ClassA(object): ... a = 1 ... def __init__(self, b): ... self.b = b ... >>> t1 = ClassA(1) >>> t2 = ClassA(2) >>> >>> pprint(DeepDiff(t1, t2)) {
>>> t2.c = "new attribute" >>> pprint(DeepDiff(t1, t2)) {
temp3 = tuple(x for x in temp1 if x not in set(temp2))
list_a = [1,2,3] list_b = [2,3] print set(list_a).difference(set(list_b))
list(itertools.filterfalse(set(temp2).__contains__, temp1))
a = b = from difflib import SequenceMatcher for tag, i, j, k, l in SequenceMatcher(None, a, b).get_opcodes(): if tag == if tag in ( if tag in (
both have [ 1st has [ 2nd has [ both have [ 2nd has [ both have [ 1st has [ both have [
2nd has [5, 4, 3, 2] both have [1] 1st has [2, 3, 4, 5]
list1=[1,2,3,4,5] list2=[1,2,3] print list1[len(list2):]
subset=set(list1).difference(list2) print subset import timeit init = print "Naive solution: ", timeit.timeit( print "Native set solution: ", timeit.timeit(
from collections import Counter lst1 = [ lst2 = [ c1 = Counter(lst1) c2 = Counter(lst2) diff = list((c1 - c2).elements())
diff = list((Counter(lst1) - Counter(lst2)).elements())
set(map(tuple, list_of_lists1)).symmetric_difference(set(map(tuple, list_of_lists2)))
list(set(x).symmetric_difference(set(y))) list(set(x) ^ set(y))
import time import random from itertools import filterfalse performance = 1 numberoftests = 7 def answer(x,y,z): if z == 0: start = time.clock() lists = (str(list(set(x)-set(y))+list(set(y)-set(y)))) times = ("1 = " + str(time.clock() - start)) return (lists,times) elif z == 1: start = time.clock() lists = (str(list(set(x).symmetric_difference(set(y))))) times = ("2 = " + str(time.clock() - start)) return (lists,times) elif z == 2: start = time.clock() lists = (str(list(set(x) ^ set(y)))) times = ("3 = " + str(time.clock() - start)) return (lists,times) elif z == 3: start = time.clock() lists = (filterfalse(set(y).__contains__, x)) times = ("4 = " + str(time.clock() - start)) return (lists,times) elif z == 4: start = time.clock() lists = (tuple(set(x) - set(y))) times = ("5 = " + str(time.clock() - start)) return (lists,times) elif z == 5: start = time.clock() lists = ([tt for tt in x if tt not in y]) times = ("6 = " + str(time.clock() - start)) return (lists,times) else: start = time.clock() Xarray = [iDa for iDa in x if iDa not in y] Yarray = [iDb for iDb in y if iDb not in x] lists = (str(Xarray + Yarray)) times = ("7 = " + str(time.clock() - start)) return (lists,times) n = numberoftests if performance == 2: a = [1,2,3,4,5] b = [3,2,6] for c in range(0,n): d = answer(a,b,c) print(d[0]) elif performance == 1: for tests in range(0,10): print("Test Number" + str(tests + 1)) a = random.sample(range(1, 900000), 9999) b = random.sample(range(1, 900000), 9999) for c in range(0,n): d = answer(a,b,c) print(d[1])
def diff(a, b): xa = [i for i in set(a) if i not in b] xb = [i for i in set(b) if i not in a] return xa + xb
def diff(listA, listB): return set(listA) - set(listB) | set(listA) -set(listB)
from collections import Counter def diff(a, b): ca, cb = Counter(a), Counter(b) to_add = cb - ca to_remove = ca - cb changes = Counter(to_add) changes.subtract(to_remove) return changes lista = [ listb = [ In [127]: diff(lista, listb) Out[127]: Counter({ In [128]: diff(listb, lista) Out[128]: Counter({
temp1 = [ temp2 = [ set(temp1+temp2)-(set(temp1)&set(temp2)) Out: set([
import pathlib temp1 = ["One", "Two", "Three", "Four"] temp2 = ["One", "Two"] p = pathlib.Path(*temp1) r = p.relative_to(*temp2) list(r.parts)
import itertools as it [x for x, y in it.zip_longest(temp1, temp2) if x != y]
>>> from sets import Set >>> >>> l1 = [ >>> l2 = [ >>> >>> Set(l1).symmetric_difference(Set(l2)) Set([False,
def difference(list1, list2): new_list = [] for i in list1: if i not in list2: new_list.append(i) for j in list2: if j not in list1: new_list.append(j) return new_list
def sym_diff(list1, list2): return list(set(list1).symmetric_difference(set(list2)))
t1 = timeit.Timer("difference(list1, list2)", "from __main__ import difference, list1, list2") t2 = timeit.Timer("sym_diff(list1, list2)", "from __main__ import sym_diff, list1, list2") print( print(
[7, 9, 2, 4] Using two for loops 0.11572412995155901 Milliseconds Using symmetric_difference 0.11285737506113946 Milliseconds Process finished with exit code 0
a = [4,2,3,1,5,6] if a.count(7) == 1: b=a.index(7) "Do something with variable b"
a = [4,2,3,1,5,6] try: b=a.index(7) except ValueError: "Do nothing" else: "Do something with variable b"
if [x+1,y,z] in particles.location "find the identity of this neighbour particles in x:the index of the particles array" particles.index([x+1,y,z])
import random import bisect import matplotlib.pyplot as plt import math import time def method_in(a,b,c): start_time = time.time() for i,x in enumerate(a): if x in b: c[i] = 1 return(time.time()-start_time) def method_set_in(a,b,c): start_time = time.time() s = set(b) for i,x in enumerate(a): if x in s: c[i] = 1 return(time.time()-start_time) def method_bisect(a,b,c): start_time = time.time() b.sort() for i,x in enumerate(a): index = bisect.bisect_left(b,x) if index < len(a): if x == b[index]: c[i] = 1 return(time.time()-start_time) def profile(): time_method_in = [] time_method_set_in = [] time_method_bisect = [] Nls = [x for x in range(1000,20000,1000)] for N in Nls: a = [x for x in range(0,N)] random.shuffle(a) b = [x for x in range(0,N)] random.shuffle(b) c = [0 for x in range(0,N)] time_method_in.append(math.log(method_in(a,b,c))) time_method_set_in.append(math.log(method_set_in(a,b,c))) time_method_bisect.append(math.log(method_bisect(a,b,c))) plt.plot(Nls,time_method_in,marker= plt.plot(Nls,time_method_set_in,marker= plt.plot(Nls,time_method_bisect,marker= plt.xlabel( plt.ylabel( plt.legend(loc = plt.show()
def check_availability(element, collection: iter): return element in collection
a = [4,2,3,1,5,6] index = dict((y,x) for x,y in enumerate(a)) try: a_index = index[7] except KeyError: print "Not found" else: print "found"
for element in s: if element is target: return True if element == target: return True return False
>>> import numpy >>> numpy.NAN == numpy.NAN False >>> numpy.NAN is numpy.NAN True >>> numpy.NAN in [numpy.NAN] True
>>> lst = [numpy.NAN, 1 , 2] >>> any(element == numpy.NAN for element in lst) False >>> any(element is numpy.NAN for element in lst) True
any(element is target or element == target for element in lst)
try: print("Started") x = ["a", "b", "c", "d", "e", "f"] i = 0 while i < len(x): i += 1 if x[i] == "e": print("Found") except IndexError: pass
present = False searchItem = myList = [ if searchItem in myList: present = True print( else: print(
import re pattern = re.compile(r sentence = re.sub(pattern,
import re sentence = re.sub(r"\s+", "", sentence, flags=re.UNICODE)
import re sentence = re.sub(r"^\s+", "", sentence, flags=re.UNICODE)
import re sentence = re.sub(r"\s+$", "", sentence, flags=re.UNICODE)
import re sentence = re.sub("^\s+|\s+$", "", sentence, flags=re.UNICODE)
import re sentence = " ".join(re.split("\s+", sentence, flags=re.UNICODE))
class Cheese(): def __init__(self, num_holes = 0): if (num_holes == 0): else: number_of_holes = num_holes
class Cheese(): def __init__(self, num_holes = None): if num_holes is None: ...
class Cheese(): def __init__(self, *args, **kwargs): self.num_holes = kwargs.get(
def f(*args, **kwargs): print >>> f( args: ( >>> f(ar= args: () kwargs: { >>> f(1,2,param=3) args: (1, 2) kwargs: {
class Cheese(object): def __init__(self, num_holes=0): "defaults to a solid cheese" self.number_of_holes = num_holes @classmethod def random(cls): return cls(randint(0, 100)) @classmethod def slightly_holey(cls): return cls(randint(0, 33)) @classmethod def very_holey(cls): return cls(randint(66, 100))
gouda = Cheese() emmentaler = Cheese.random() leerdammer = Cheese.slightly_holey()
def __init__(self, num_holes): @classmethod def fromRandom(cls): return cls(
def __init__(self, num_holes=None): if num_holes is None: else:
@classmethod def create_gouda(cls): c = Cheese() return c @classmethod def create_cheddar(cls):
from cheeses import make_gouda, make_parmesean gouda = make_gouda() paremesean = make_parmesean()
class Cheese(object): def __init__(self, *args, **kwargs): self.num_holes = kwargs.get( def make_gouda(): return Cheese() def make_paremesean(): return Cheese(num_holes=15)
class MyClass(set): def __init__(self, filename): self._value = load_from_file(filename) @classmethod def from_somewhere(cls, somename): obj = cls.__new__(cls) obj._value = load_from_somewhere(somename) return obj
class Cheese(object): def __new__(cls, *args, **kwargs): obj = super(Cheese, cls).__new__(cls) num_holes = kwargs.get( if num_holes == 0: cls.__init__ = cls.foomethod else: cls.__init__ = cls.barmethod return obj def foomethod(self, *args, **kwargs): print "foomethod called as __init__ for Cheese" def barmethod(self, *args, **kwargs): print "barmethod called as __init__ for Cheese" if __name__ == "__main__": parm = Cheese(num_holes=5)
class Gouda(Cheese): def __init__(self): super(Gouda).__init__(num_holes=10) class Parmesan(Cheese): def __init__(self): super(Parmesan).__init__(num_holes=15)
>>> temp = YearQuarter(datetime.date(2017, 1, 18)) >>> print temp 2017-Q1 >>> temp = YearQuarter((2017, 1)) >>> print temp 2017-Q1
import datetime class YearQuarter: def __init__(self, value): if type(value) is datetime.date: self._year = value.year self._quarter = (value.month + 2) / 3 elif type(value) is tuple: self._year = int(value[0]) self._quarter = int(value[1]) def __str__(self): return
class A(object): def __init__(self,e,f,g): self.__dict__.update({k: v for k,v in locals().items() if k!= def bc(self): print(self.f) k=A(e=5,f=6,g=12) k.bc()
class Cheese: def __init__(self, *args, **kwargs): ... def _init_parmesan(self, *args, **kwargs): ... def _init_gauda(self, *args, **kwargs): ... @classmethod def make_parmesan(cls, *args, **kwargs): new = cls.__new__(cls) new._init_parmesan(*args, **kwargs) return new @classmethod def make_gauda(cls, *args, **kwargs): new = cls.__new__(cls) new._init_gauda(*args, **kwargs) return new
import requests ... resp = requests.get( resp = requests.post( resp = requests.put( resp = requests.delete(
userdata = {"firstname": "John", "lastname": "Doe", "password": "jdoe123"} resp = requests.post(
r = Request(url= r.add_header( r.add_data(urllib.urlencode({ response = urlopen(r)
try: import requests except ImportError: try: import urllib.request except AttributeError: import urllib def get_content(url): try: return requests.get(url).content except NameError: try: with urllib.request.urlopen(index_url) as response: return response.read() except AttributeError: return urllib.urlopen(url).read()
w, h = 8, 5; Matrix = [[0 for x in range(w)] for y in range(h)]
Matrix[0][0] = 1 Matrix[6][0] = 3 Matrix[0][6] = 3 print Matrix[0][0] x, y = 0, 6 print Matrix[x][y]
>>> import numpy >>> numpy.zeros((5, 5)) array([[ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.]])
>>> numpy.matrix([[1, 2], [3, 4]]) matrix([[1, 2], [3, 4]])
numpy.matrix( numpy.arange(25).reshape((5, 5)) numpy.array(range(25)).reshape((5, 5)) numpy.array([5] * 25).reshape((5, 5)) numpy.empty((5, 5)) numpy.ones((5, 5)) numpy.ndarray((5, 5))
>>> matrix = 5*[5*[0]] >>> matrix [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] >>> matrix[4][4] = 2 >>> matrix [[0, 0, 0, 0, 2], [0, 0, 0, 0, 2], [0, 0, 0, 0, 2], [0, 0, 0, 0, 2], [0, 0, 0, 0, 2]]
matrix = [[0 for i in xrange(5)] for i in xrange(5)]
matrix = [] matrix.append([]) matrix.append([]) matrix[0].append(2) matrix[1].append(3)
from itertools import count, takewhile matrix = [[i for i in takewhile(lambda j: j < (k+1) * 10, count(k*10))] for k in range(10)]
>>> matrix = [[0 for i in range(5)] for j in range(5)] >>> pprint.pprint(matrix) [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
>>> l = [5] >>> l[5] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: list index out of range
>>> numpy.zeros((3, 5)) array([[ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.]])
>>> np.ones((3, 5)) array([[ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.]])
rows_count = 5 cols_count = 5 two_d_array = [[0 for j in range(cols_count)] for i in range(rows_count)] two_d_array[0][0] = 1 print two_d_array[0][0] two_d_array[1][0] = 2 print two_d_array[1][0] two_d_array[1][4] = 3 print two_d_array[1][4] two_d_array[4][4] = 4 print two_d_array[4][4]
Matrix = [[0 for y in xrange(5)] for x in xrange(2)]
rows = int(input()) cols = int(input()) matrix = [] for i in range(rows): row = [] for j in range(cols): row.append(0) matrix.append(row) print(matrix)
col = 3 row = 4 array = [[0] * col for _ in range(row)]
import copy def ndlist(*args, init=0): dp = init for x in reversed(args): dp = [copy.deepcopy(dp) for _ in range(x)] return dp l = ndlist(1,2,3,4) l[0][1][2][3] = 1
import numpy Nx=3; Ny=4 my2Dlist= numpy.zeros((Nx,Ny)).tolist()
[ value, value, value, value, value], [ value, value, value, value, value], ...
from random import randint coordinates=[] temp=[] points=int(raw_input("Enter No Of Coordinates >")) for i in range(0,points): randomx=randint(0,1000) randomy=randint(0,1000) temp=[] temp.append(randomx) temp.append(randomy) coordinates.append(temp) print coordinates
Enter No Of Coordinates >4 [[522, 96], [378, 276], [349, 741], [238, 439]]
rows = int(input( my_list = [] for i in range(rows): my_list.append(list(map(int, input().split())))
Python 2.6.2 (r262:71600, Apr 15 2009, 07:20:39) >>> import dis >>> def f(x): ... return x is not None ... >>> dis.dis(f) 2 0 LOAD_FAST 0 (x) 3 LOAD_CONST 0 (None) 6 COMPARE_OP 9 (is not) 9 RETURN_VALUE >>> def g(x): ... return not x is None ... >>> dis.dis(g) 2 0 LOAD_FAST 0 (x) 3 LOAD_CONST 0 (None) 6 COMPARE_OP 9 (is not) 9 RETURN_VALUE
>>> x = 1 >>> not x False >>> x = [1] >>> not x False >>> x = 0 >>> not x True >>> x = [0] >>> not x False
>>> x [0] >>> not x is None True >>> not (x is None) True >>> (not x) is None False
>>> import ast >>> ast.dump(ast.parse( "Compare(left=Name(id= >>> ast.dump(ast.parse( "UnaryOp(op=Not(), operand=Compare(left=Name(id=
>>> import dis >>> dis.dis(lambda x, y: x is not y) 1 0 LOAD_FAST 0 (x) 3 LOAD_FAST 1 (y) 6 COMPARE_OP 9 (is not) 9 RETURN_VALUE >>> dis.dis(lambda x, y: not x is y) 1 0 LOAD_FAST 0 (x) 3 LOAD_FAST 1 (y) 6 COMPARE_OP 9 (is not) 9 RETURN_VALUE
from datetime import datetime, timedelta d = datetime.today() - timedelta(days=days_to_subtract)
from datetime import datetime, timedelta from tzlocal import get_localzone DAY = timedelta(1) local_tz = get_localzone() now = datetime.now(local_tz) day_ago = local_tz.normalize(now - DAY) naive = now.replace(tzinfo=None) - DAY yesterday = local_tz.localize(naive, is_dst=None)
import pytz local_tz = pytz.timezone( now = local_tz.localize(datetime(2014, 11, 2, 10), is_dst=None)
>>> import pendulum >>> now = pendulum.create(2014, 11, 2, 10, tz= >>> day_ago = now.subtract(hours=24) >>> yesterday = now.subtract(days=1) >>> (now - day_ago).in_hours() 24 >>> (now - yesterday).in_hours() 25 >>> now <Pendulum [2014-11-02T10:00:00-08:00]> >>> day_ago <Pendulum [2014-11-01T11:00:00-07:00]> >>> yesterday <Pendulum [2014-11-01T10:00:00-07:00]>
from datetime import datetime, timedelta print datetime.now() + timedelta(days=-1)
from datetime import datetime, timedelta print datetime.now() + timedelta(days=5, hours=-5)
import datetime as dt from dateutil.relativedelta import relativedelta today = dt.date.today() first_day_this_month = dt.date(day=1, month=today.month, year=today.year) last_day_last_month = first_day_this_month - relativedelta(days=1) print (first_day_this_month, last_day_last_month) >2015-03-01 2015-02-28
import arrow utc = arrow.utcnow() utc_yesterday = utc.shift(days=-1) print(utc,
2017-04-06T11:17:34.431397+00:00 2017-04-05T11:17:34.431397+00:00
output = [] for x in trends: if x not in output: output.append(x) print output
output = set() for x in trends: output.add(x) print output
used = set() mylist = [u unique = [x for x in mylist if x not in used and (used.add(x) or True)]
mylist = [u unique = reduce(lambda l, x: l.append(x) or l if x not in l else l, mylist, [])
mylist = [u unique = reduce(lambda l, x: l+[x] if x not in l else l, mylist, []) unique = reduce(lambda l, x: l if x in l else l+[x], mylist, [])
import timeit setup = "mylist = [u timeit.timeit( 0.4188511371612549 timeit.timeit( 0.8063139915466309 timeit.timeit( 2.216820001602173 timeit.timeit( 2.948796033859253 timeit.timeit( 2.9785239696502686
>>> used = [] >>> mylist = [u >>> unique = [used.append(x) for x in mylist if x not in used] >>> print used [u >>> print unique [None, None, None, None, None]
>>> unique = [x for x in mylist if x not in used and used.append(x)] >>> print unique []
(l.append(x) or l) if x not in l else l l if x in l else (l.append(x) or l)
[x for i, x in enumerate(array) if x not in array[0:i]] [x for i, x in enumerate(array) if array.index(x) == i] uniq = [] [uniq.append(x) for x in array if x not in uniq] uniq
mylist=list(set(mylist)) In [0]: mylist Out[0]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
newList=[] for i in mylist: if i not in newList: newList.append(i) In [0]: mylist Out[0]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
k=0 while k < len(mylist): if mylist[k] in mylist[k+1:]: mylist.pop(mylist[k]) else: k=k+1 In [0]: mylist Out[0]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
import numpy as np np.unique(mylist) In [0]: mylist Out[0]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> import numpy as np >>> wordsList = [u >>> np.unique(wordsList) array([u dtype=
>>> for word in np.unique(wordsList): ... print word ... PBS debate job nowplaying thenandnow
> my_list = [1, 2, 1, 3, 2, 4, 3, 5, 4, 3, 2, 3, 1] > unique_list = [ > e > for i, e in enumerate(my_list) > if my_list.index(e) == i > ] > unique_list [1, 2, 3, 4, 5]
from itertools import ifilterfalse def unique_everseen(iterable, key=None): "List unique elements, preserving order. Remember all elements ever seen." seen = set() seen_add = seen.add if key is None: for element in ifilterfalse(seen.__contains__, iterable): seen_add(element) yield element else: for element in iterable: k = key(element) if k not in seen: seen_add(k) yield element
def get_distinct(original_list): distinct_list = [] for each in original_list: if each not in distinct_list: distinct_list.append(each) return distinct_list
def unique_elements(iterable): seen = set() result = [] for element in iterable: hashed = element if isinstance(element, dict): hashed = tuple(sorted(element.iteritems())) elif isinstance(element, list): hashed = tuple(element) if hashed not in seen: result.append(element) seen.add(hashed) return result
from collections import Counter l = [u c = Counter(l)
>>> t = [v for i,v in enumerate(mylist) if mylist.index(v) == i] [u
trends = [u output = set(trends) output = list(output)
trends = [{ output = set(trends) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unhashable type:
from copy import deepcopy try: trends = [{ output = set(trends) output = list(output) except TypeError: trends_copy = deepcopy(trends) while trends_copy: trend = trends_copy.pop() if trends_copy.count(trend) == 0: output.append(trend) print output
def unique(sequence): seen = set() for value in sequence: if value in seen: continue seen.add(value) yield value
unicode_list=[u list_unique=list(set(unicode_list)) print list_unique [u
list=[u list_unique=list(set(list)) print list_unique list_unique=list(set(list)) TypeError:
from collections import OrderedDict seq = [u list(set(seq)) list(OrderedDict.fromkeys(seq))
from collections import OrderedDict def keep_unique(elements): return list(OrderedDict.fromkeys(elements).keys()) elements = [2, 1, 4, 2, 1, 1, 5, 3, 1, 1] required_output = [2, 1, 4, 5, 3] assert keep_unique(elements) == required_output
def keep_unique(elements): return list(dict.fromkeys(elements).keys())
def getUnique(self): notunique = self.readLines() unique = [] for line in notunique: append = True for existing in unique: if line == existing: append = False break if append: unique.append(line) return unique
def get_unique_list(lst): if isinstance(lst,list): return list(set(lst))
class UniqueList(list): def appendunique(self,item): if item not in self: self.append(item) return True return False
unique = UniqueList() for each in [1,2,2,3,3,4]: if unique.appendunique(each): print else: print
Uniquely appended 1 Uniquely appended 2 Already contains 2 Uniquely appended 3 Already contains 3 Uniquely appended 4
unique = UniqueList() for each in [1,2,2,3,3,4]: unique.appendunique(each) newlist = unique[:] print newlist
s = np.empty(len(var)) s[:] = np.nan for x in set(var): x_positions = np.where(var==x) s[x_positions[0][0]]=x sorted_var=s[~np.isnan(s)]
def unique(a): k=0 while k < len(a): if a[k] in a[k+1:]: a.pop(k) else: k=k+1 return a
import os path = os.path.dirname(a_module.__file__)
>>> import os >>> import inspect >>> inspect.getfile(os) >>> inspect.getfile(inspect) >>> os.path.dirname(inspect.getfile(inspect))
/path2 Traceback (most recent call last): File "/path2/bar.py", line 3, in <module> print(__file__) NameError: name
os.path.abspath(__file__) is: /home/user/bar/foo.py os.path.dirname(os.path.abspath(__file__)) is: /home/user/bar
abspath(__file__) /home/user/file_test_link realpath(__file__) /home/user/file_test.py
import os path = os.path.abspath(__file__) dir_path = os.path.dirname(path)
import os,sys if hasattr(sys, base = sys.prefix else: base = os.path.dirname(os.path.realpath(__file__))
import importlib import os import sys args = sys.argv[1:] if len(args) > 0: module = importlib.import_module(args[0]) print os.path.dirname(module.__file__)
import os.path mydir = os.path.dirname(__file__) or full = os.path.abspath(mydir) print __file__, mydir, full
filedir = os.path.dirname(os.path.realpath(__file__)) filepath = os.path.join(filedir, with open(filepath, pass
some_dir/ maincli.py top_package/ __init__.py level_one_a/ __init__.py my_lib_a.py level_two/ __init__.py hello_world.py level_one_b/ __init__.py my_lib_b.py
import sys import os import imp class ConfigurationException(Exception): pass def get_maincli_path(): maincli_path = os.path.abspath(imp.find_module( if not os.path.exists(maincli_path): err_msg = raise ConfigurationException(err_msg) return maincli_path
global modpath modname = f=open("modname.py","w") f.write("import "+modname+"\n") f.write("modpath = "+modname+"\n") f.close() execfile( print modpath <module
from pathlib import Path print(Path().absolute()) print(Path().resolve( print(Path().cwd())
>>> import os >>> statinfo = os.stat( >>> statinfo (33188, 422511L, 769L, 1, 1032, 100, 926L, 1105022698,1105022732, 1105022732) >>> statinfo.st_size 926L
>>> import os >>> b = os.path.getsize("/path/isa_005.mp3") >>> b 2071611L
old_file_position = f.tell() f.seek(0, os.SEEK_END) size = f.tell() f.seek(old_file_position, os.SEEK_SET)
import os def convert_bytes(num): for x in [ if num < 1024.0: return "%3.1f %s" % (num, x) num /= 1024.0 def file_size(file_path): if os.path.isfile(file_path): file_info = os.stat(file_path) return convert_bytes(file_info.st_size) file_path = r"C:\Windows\System32\mspaint.exe" print file_size(file_path)
from pathlib import Path file = Path() / size = file.stat().st_size
print (5368709120 >> 10) print (5368709120 >> 20 ) print (5368709120 >> 30 )
import os file_path = r"<path to your file>" if os.stat(file_path).st_size > 0: <send an email to somebody> else: <continue to other things>
import os fsize=os.stat( print( if fsize.st_size < 10000000: process it ....
from collections import deque >>> l = deque([ >>> l.popleft() >>> l deque([
l = [0, 1, 2, 3, 4] l.reverse() print l [4, 3, 2, 1, 0] l.pop() 0 l.pop() 1 l.pop() 2 l.pop() 3 l.pop() 4
>>>> a=[1,2,3,4,5] >>>> a.remove(a[0]) >>>> print a >>>> [2,3,4,5]
import numpy as np a = np.array([1, 2, 3, 4, 5]) a = np.delete(a, 0) print(a)
class FileItem: def __init__(self, fname): self.fname = fname
>>> from json import JSONEncoder >>> class MyEncoder(JSONEncoder): def default(self, o): return o.__dict__ >>> MyEncoder().encode(f)
>>> def from_json(json_object): if return FileItem(json_object[ >>> f = JSONDecoder(object_hook = from_json).decode( >>> f <__main__.FileItem object at 0x9337fac> >>>
import json class Object: def toJSON(self): return json.dumps(self, default=lambda o: o.__dict__, sort_keys=True, indent=4)
me = Object() me.name = "Onur" me.age = 35 me.dog = Object() me.dog.name = "Apollo" print(me.toJSON())
class FileItem(dict): def __init__(self, fname): dict.__init__(self, fname=fname) f = FileItem( json.dumps(f)
import json class FileItem: def __init__(self, fname): self.fname = fname def __repr__(self): return json.dumps(self.__dict__)
import json class JsonSerializable(object): def toJson(self): return json.dumps(self.__dict__) def __repr__(self): return self.toJson() class FileItem(JsonSerializable): def __init__(self, fname): self.fname = fname
def dumper(obj): try: return obj.toJSON() except: return obj.__dict__ print json.dumps(some_big_object, default=dumper, indent=2)
import json import inspect class ObjectEncoder(json.JSONEncoder): def default(self, obj): if hasattr(obj, "to_json"): return self.default(obj.to_json()) elif hasattr(obj, "__dict__"): d = dict( (key, value) for key, value in inspect.getmembers(obj) if not key.startswith("__") and not inspect.isabstract(value) and not inspect.isbuiltin(value) and not inspect.isfunction(value) and not inspect.isgenerator(value) and not inspect.isgeneratorfunction(value) and not inspect.ismethod(value) and not inspect.ismethoddescriptor(value) and not inspect.isroutine(value) ) return self.default(d) return obj
class C(object): c = "NO" def to_json(self): return {"c": "YES"} class B(object): b = "B" i = "I" def __init__(self, y): self.y = y def f(self): print "f" class A(B): a = "A" def __init__(self): self.b = [{"ab": B("y")}] self.c = C() print json.dumps(A(), cls=ObjectEncoder, indent=2, sort_keys=True)
{ "a": "A", "b": [ { "ab": { "b": "B", "i": "I", "y": "y" } } ], "c": { "c": "YES" }, "i": "I" }
from json import JSONEncoder def _default(self, obj): return getattr(obj.__class__, "to_json", _default.default)(obj) _default.default = JSONEncoder().default JSONEncoder.default = _default
import simplejson class User(object): def __init__(self, name, mail): self.name = name self.mail = mail def _asdict(self): return self.__dict__ print(simplejson.dumps(User(
import json def default(o): return o._asdict() print(json.dumps(User(
import json import jsonpickle ... print json.dumps(json.loads(jsonpickle.encode(object)), indent=2)
import json class Serializer(object): @staticmethod def serialize(object): return json.dumps(object, default=lambda o: o.__dict__.values()[0])
import json class Foo(object): def __init__(self): self.bar = self._qux = def somemethod(self): pass def default(instance): return {k: v for k, v in vars(instance).items() if not str(k).startswith( json_foo = json.dumps(Foo(), default=default) assert print(json_foo)
class MyCustom(object): def __json__(self): return { } to_json = __json__ @classmethod def from_json(cls, json): obj = cls() obj.a = json[ obj.b = json[ return obj import simplejson obj = MyCustom() obj.a = 3 obj.b = 4 json = simplejson.dumps(obj, for_json=True) obj2_dict = simplejson.loads(json) obj2 = MyCustom.from_json(obj2_dict) assert isinstance(obj2, MyCustom) assert obj2.__dict__ == obj.__dict__
from jsonweb.encode import to_object, dumper @to_object() class DataModel(object): def __init__(self, id, value): self.id = id self.value = value >>> data = DataModel(5, "foo") >>> dumper(data)
import json, sys, os class File: def __init__(self, path): self.path = path def isdir(self): return os.path.isdir(self.path) def isfile(self): return os.path.isfile(self.path) def children(self): return [File(os.path.join(self.path, f)) for f in os.listdir(self.path)] def getsize(self): return os.path.getsize(self.path) def getModificationTime(self): return os.path.getmtime(self.path) def _default(o): d = {} d[ d[ d[ d[ d[ if o.isdir(): d[ return d folder = os.path.abspath( json.dump(File(folder), sys.stdout, default=_default)
from json_tricks import dumps json_str = dumps(cls_instance, indent=4)
{ "__instance_type__": [ "module_name.test_class", "MyTestCls" ], "attributes": { "attr": "val", "dct_attr": { "hello": 42 } } }
from json_tricks import loads json_str = loads(json_str)
class CustomEncodeCls: def __init__(self): self.relevant = 42 self.irrelevant = 37 def __json_encode__(self): return { def __json_decode__(self, **attrs): self.relevant = attrs[ self.irrelevant = 12
class CustomJsonEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, SomeTypeUnsupportedByJsonDumps): return < whatever value you want > return json.JSONEncoder.default(self, obj) @staticmethod def json_dumper(obj): return json.dumps(obj, cls=CustomJsonEncoder)
class SomeClass(Model): json_field = JSONField(dumps=CustomJsonEncoder.json_dumper)
class TransactionType(Enum): CURRENT = 1 STACKED = 2 def default(self, obj): if isinstance(obj, TransactionType): return obj.value return json.JSONEncoder.default(self, obj)
peewee_model = WhateverPeeweeModel() new_model = SomeClass() new_model.json_field = model_to_dict(peewee_model)
def getSerializable(doc): if isinstance(doc, list): for i, val in enumerate(doc): doc[i] = getSerializable(doc[i]) return doc if isinstance(doc, dict): for key in doc.keys(): doc[key] = getSerializable(doc[key]) return doc if isinstance(doc, ObjectId): doc = str(doc) return doc return doc
import json from datetime import datetime, date, time, timedelta def json_serial(obj): if isinstance(obj, (datetime, date)): serial = str(obj) return serial raise TypeError ("Type %s not serializable" % type(obj)) def FixDumps(fn): def hook(obj): return fn(obj, default=json_serial) return hook def FixDump(fn): def hook(obj, fp): return fn(obj,fp, default=json_serial) return hook json.dumps=FixDumps(json.dumps) json.dump=FixDump(json.dump) if __name__=="__main__": today=datetime.now() data={ str=json.dumps(data) print str
class Serializer(object): @staticmethod def serialize(obj): def check(o): for k, v in o.__dict__.items(): try: _ = json.dumps(v) o.__dict__[k] = v except TypeError: o.__dict__[k] = str(v) return o return json.dumps(check(obj).__dict__, indent=2)
class Base: __slots__ = class Right(Base): __slots__ = class Wrong(Base): __slots__ =
>>> from sys import getsizeof >>> getsizeof(Right()), getsizeof(Wrong()) (64, 80)
import timeit class Foo(object): __slots__ = class Bar(object): pass slotted = Foo() not_slotted = Bar() def get_set_delete_fn(obj): def get_set_delete(): obj.foo = obj.foo del obj.foo return get_set_delete
>>> min(timeit.repeat(get_set_delete_fn(slotted))) 0.2846834529991611 >>> min(timeit.repeat(get_set_delete_fn(not_slotted))) 0.3664822799983085
>>> 0.3664822799983085 / 0.2846834529991611 1.2873325658284342
Python 2.7 Python 3.6 attrs __slots__ __dict__* __slots__ __dict__* | *(no slots defined) none 16 56 + 272† 16 56 + 112† | †if __dict__ referenced one 48 56 + 272 48 56 + 112 two 56 56 + 272 56 56 + 112 six 88 56 + 1040 88 56 + 152 11 128 56 + 1040 128 56 + 240 22 216 56 + 3344 216 56 + 408 43 384 56 + 3344 384 56 + 752
>>> Foo.foo <member >>> type(Foo.foo) <class >>> getsizeof(Foo.foo) 72
>>> b = Base() >>> b.a = Traceback (most recent call last): File "<pyshell b.a = AttributeError:
>>> c.b = Traceback (most recent call last): File "<pyshell c.b = AttributeError:
class SlottedWithDict(Child): __slots__ = ( swd = SlottedWithDict() swd.a = swd.b = swd.c =
class NoSlots(Child): pass ns = NoSlots() ns.a = ns.b =
class BaseA(object): __slots__ = ( class BaseB(object): __slots__ = (
>>> class Child(BaseA, BaseB): __slots__ = () Traceback (most recent call last): File "<pyshell class Child(BaseA, BaseB): __slots__ = () TypeError: Error when calling the metaclass bases multiple bases have instance lay-out conflict
from abc import ABC class AbstractA(ABC): __slots__ = () class BaseA(AbstractA): __slots__ = ( class AbstractB(ABC): __slots__ = () class BaseB(AbstractB): __slots__ = ( class Child(AbstractA, AbstractB): __slots__ = ( c = Child()
from collections import namedtuple class MyNT(namedtuple( __slots__ = ()
>>> nt.quux = Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError:
class Foo(object): __slots__ = class Bar(object): __slots__ = >>> class Baz(Foo, Bar): pass Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: Error when calling the metaclass bases multiple bases have instance lay-out conflict
class Foo(object): __slots__ = () class Bar(object): __slots__ = () class Baz(Foo, Bar): __slots__ = ( b = Baz() b.foo, b.bar =
class AbstractBase: __slots__ = () def __init__(self, a, b): self.a = a self.b = b def __repr__(self): return f
class AbstractBaseC: __slots__ = () @property def c(self): print( return self._c @c.setter def c(self, arg): print( self._c = arg
class Concretion(AbstractBase, AbstractBaseC): __slots__ =
>>> c = Concretion( >>> c.c = c setting c! >>> c.c getting c! Concretion( >>> c.d = Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError:
>>> pickle.loads(pickle.dumps(f)) TypeError: a class that defines __slots__ without defining __getstate__ cannot be pickled
>>> pickle.loads(pickle.dumps(f, -1)) <__main__.Foo object at 0x1129C770>
>>> pickle.loads(pickle.dumps(f, 2)) <__main__.Foo object at 0x1129C770>
>>> pickle.loads(pickle.dumps(f, 4)) <__main__.Foo object at 0x1129C770>
>>> class Foo(object): pass >>> class Bar(object): __slots__ = ()
>>> foos = [Foo() for f in xrange(1000000)] >>> bars = [Bar() for b in xrange(1000000)]
>>> guppy.hpy().heap() Partition of a set of 2028259 objects. Total size = 99763360 bytes. Index Count % Size % Cumulative % Kind (class / dict of class) 0 1000000 49 64000000 64 64000000 64 __main__.Foo 1 169 0 16281480 16 80281480 80 list 2 1000000 49 16000000 16 96281480 97 __main__.Bar 3 12284 1 987472 1 97268952 97 str ...
>>> for f in foos: ... f.__dict__ >>> guppy.hpy().heap() Partition of a set of 3028258 objects. Total size = 379763480 bytes. Index Count % Size % Cumulative % Kind (class / dict of class) 0 1000000 33 280000000 74 280000000 74 dict of __main__.Foo 1 1000000 33 64000000 17 344000000 91 __main__.Foo 2 169 0 16281480 4 360281480 95 list 3 1000000 33 16000000 4 376281480 99 __main__.Bar 4 12284 0 987472 0 377268952 99 str ...
>>> class Test(object): ... __slots__ = [ ... >>> pt = Test() >>> dir(pt) [ >>> pt.x Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: x >>> pt.x = 1 >>> pt.x 1 >>> pt.z = 2 Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: >>> pt.__dict__ Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: >>> pt.__slots__ [
class Flyweight(object): def get(self, theData, index): return theData[index] def set(self, theData, index, value): theData[index]= value
class Test: pass obj1=Test() obj2=Test() print(obj1.__dict__) obj1.x=12 print(obj1.__dict__) obj1.y=20 print(obj1.__dict__) obj2.x=99 print(obj2.__dict__)
class Test: __slots__=("x") obj1=Test() obj2=Test() obj1.x=12 print(obj1.x) obj2.x=99 print(obj2.x) obj1.y=28 print(obj1.y)
from peak.util.proxies import ObjectWrapper class Original(object): def __init__(self): self.name = class ProxyOriginal(ObjectWrapper): __slots__ = [ def __init__(self, subject, proxy_name): self.proxy_info = self.proxy_name = proxy_name super(ProxyOriginal, self).__init__(subject) if __name__ == "__main__": original = Original() proxy = ProxyOriginal(original, print "original.name: ", original.name print "proxy.name: ", proxy.name print "original.proxy_info: ", original.proxy_info print "proxy.proxy_info: ", proxy.proxy_info print "proxy.proxy_name: ", proxy.proxy_name print "original.proxy_name: ", proxy.proxy_name
********** RUN 1 ********** 1.96036410332 <class 3.02922606468 <class 2.90828204155 dict ********** RUN 2 ********** 1.77050495148 <class 3.10655999184 <class 2.84120798111 dict ********** RUN 3 ********** 1.84069895744 <class 3.21540498734 <class 2.59615707397 dict ********** RUN 4 ********** 1.75041103363 <class 3.17366290092 <class 2.70941114426 dict
class Element(object): __slots__ = [ def __init__(self, typ, id, parent=None): self._typ = typ self.id = id self.childs = [] if parent: self.parent = parent parent.childs.append(self) class ElementNoSlots(object): (same, w/o slots)
na, nb, nc = 100, 100, 100 for i in (1, 2, 3, 4): print for cls in Element, ElementNoSlots: t1 = time.time() root = cls( for i in xrange(na): ela = cls(typ= for j in xrange(nb): elb = cls(typ= for k in xrange(nc): elc = cls(typ= to = time.time() - t1 print to, cls del root t1 = time.time() droot = { for i in xrange(na): ela = { droot[ for j in xrange(nb): elb = { ela[ for k in xrange(nc): elc = { elb[ td = time.time() - t1 print td, del droot
L = [] L.append(1) if L == [1]: print if L is [1]: print
>>> a = [1, 2, 3] >>> b = a >>> b is a True >>> b == a True >>> b = a[:] >>> b is a False >>> b == a True
>>> "a" is "a" True >>> "aa" is "a" * 2 True >>> x = "a" >>> "aa" is x * 2 False >>> "aa" is intern(x*2) True
>>> a = 500 >>> b = 500 >>> a == b True >>> a is b False
>>> c = 200 >>> d = 200 >>> c == d True >>> c is d True
>>> for i in range(250, 260): a = i; print "%i: %s" % (i, a is int(str(i))); ... 250: True 251: True 252: True 253: True 254: True 255: True 256: True 257: False 258: False 259: False
>>> class Object(object): pass >>> obj = Object() >>> obj2 = Object() >>> obj == obj, obj is obj (True, True) >>> obj == obj2, obj is obj2 (False, False)
>>> nan = float( >>> nan nan >>> nan is nan True >>> nan == nan False
>>> "foo" + "bar" == "foobar" True >>> "foo" + "bar" is "foobar" True >>> "foo"[:] + "bar" == "foobar" True >>> "foo"[:] + "bar" is "foobar" False
>>> value1 == value2 True >>> value1 is value2 True
>>> value1 == value2 True >>> value1 is value2 False
class MyClass(object): def __init__(self, val): self._value = val def __eq__(self, other): print( try: return self._value == other._value except AttributeError: raise TypeError( .format(type(self), type(other)))
>>> MyClass(10) == MyClass(10) __eq__ method called True
class AClass(object): def __init__(self, value): self._value = value >>> a = AClass(10) >>> b = AClass(10) >>> a == b False >>> a == a
>>> import numpy as np >>> np.arange(10) == 2 array([False, False, True, False, False, False, False, False, False, False], dtype=bool)
Yes: if greeting: No: if greeting == True: Worse: if greeting is True:
list1 = [1,2,3,4] tuple1 = (1,2,3,4) print(list1) print(tuple1) print(id(list1)) print(id(tuple1)) print(list1 == tuple1) print(list1 is tuple1)
a = [1,2] b = [1,2,3] b.pop() id(a) id(b) a is b a == b
a=[1,2,3] b=a c=list(a) if a==b: print( if a is b: print( if a==c: print( if a is c: print(
b = a[:] print(a == b) print(a is b) print(a is not b)
>>> a = b = [1,2,3] >>> c = [1,2,3] >>> a == b True >>> a == c True >>> a is b True >>> a is c False >>> a = [1,2,3] >>> b = [1,2] >>> a == b False >>> a is b False >>> del a[2] >>> a == b True >>> a is b False
Tip: Avoid using is operator for immutable types such as strings and numbers, the result is unpredictable.
a=10 b=10 print(a==b) print(a is b) a=[1] b=[1] print(a==b) print(a is b)
class A(): ...: def __init__(self,a): ...: self.a = a ...: def __repr__(self): ...: return str(self.a) ...: def __cmp__(self, value): ...: print self.a ...: print value.a ...: return cmp(self.a, value.a)
>>> np.linspace(0,1,11) array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]) >>> np.linspace(0,1,10,endpoint=False) array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
>>> import numpy as np >>> np.arange(0.0, 1.0, 0.1) array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
>>> numpy.arange(1, 1.3, 0.1) array([1. , 1.1, 1.2, 1.3])
>>> def drange(start, stop, step): ... r = start ... while r < stop: ... yield r ... r += step ... >>> i0=drange(0.0, 1.0, 0.1) >>> ["%g" % x for x in i0] [ >>>
[p/10 for p in range(0, 10)] [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
x=100 y=2 [p/x for p in range(0, int(x*y))] [0.0, 0.01, 0.02, 0.03, ..., 1.97, 1.98, 1.99]
def seq(start, stop, step=1): n = int(round((stop - start)/float(step))) if n > 1: return([start + step*i for i in range(n+1)]) elif n == 1: return([start]) else: return([])
import itertools def seq(start, end, step): if step == 0: raise ValueError("step must not be 0") sample_count = int(abs(end - start) / step) return itertools.islice(itertools.count(start, step), sample_count)
import numpy as np for i in np.arange(0, 1, 0.1): print i
r=map(lambda x: x/10.0,range(0,10)) for i in r: print i
from math import ceil try: _xrange = xrange except NameError: _xrange = range def frange(start, stop = None, step = 1): """frange generates a set of floating point values over the range [start, stop) with step size step frange([start,] stop [, step ])""" if stop is None: for x in _xrange(int(ceil(start))): yield x else: indices = (i for i in _xrange(0, int((stop-start)/step))) for i in indices: yield start + step*i import decimal from math import ceil try: _xrange = xrange except NameError: _xrange = range def drange(start, stop = None, step = 1, precision = None): """drange generates a set of Decimal values over the range [start, stop) with step size step drange([start,] stop, [step [,precision]])""" if stop is None: for x in _xrange(int(ceil(start))): yield x else: if precision is not None: decimal.getcontext().prec = precision start = decimal.Decimal(start) stop = decimal.Decimal(stop) step = decimal.Decimal(step) indices = ( i for i in _xrange( 0, ((stop-start)/step).to_integral_value() ) ) for i in indices: yield float(start + step*i) import frange import drange list(frange.frange(0, 2, 0.5)) list(drange.drange(0, 2, 0.5, precision = 6)) list(frange.frange(3)) list(frange.frange(3.5)) list(frange.frange(0,10, -1))
from __future__ import division from math import log def xfrange(start, stop, step): old_start = start digits = int(round(log(10000, 10)))+1 magnitude = 10**digits stop = int(magnitude * stop) step = int(magnitude * step) if start == 0: start = 10**(digits-1) else: start = 10**(digits)*start data = [] end_loop = int((stop-start) if old_start == 0: end_loop += 1 acc = start for i in xrange(0, end_loop): data.append(acc/magnitude) acc += step return data print xfrange(1, 2.1, 0.1) print xfrange(0, 1.1, 0.1) print xfrange(-1, 0.1, 0.1)
[1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0] [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1] [-1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0.0]
import more_itertools as mit for x in mit.numeric_range(0, 1, 0.1): print("{:.1f}".format(x))
def frange(start,end,step): return map(lambda x: x*step, range(int(start*1./step),int(end*1./step)))
def frange(a, b, stp=1.0): i = a+stp/2.0 while i<b: yield a a += stp i += stp
def frange(a,b,s): return [] if s > 0 and a > b or s < 0 and a < b or s==0 else [a]+frange(a+s,b,s)
def xdt(n): return dt*float(n) tlist = map(xdt, range(int(t_max/dt)+1))
def frange(start,step,stop): step *= 2*((stop>start)^(step<0))-1 return [start+i*step for i in range(int((stop-start)/step))]
def seq(start, stop, step=1, digit=0): x = float(start) v = [] while x <= stop: v.append(round(x,digit)) x += step return v
>>> step = .1 >>> N = 10 >>> [ x / pow(step, -1) for x in range(0, N + 1) ] [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
>>> step = .1 >>> rnge = 1 >>> N = int(rnge / step >>> [ x / pow(step,-1) for x in range(0, N + 1) ] [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
>>> import math >>> def f(x): return math.sin(x) >>> step = .1 >>> rnge = 1 >>> N = int(rnge / step) >>> [ f( x / pow(step,-1) ) for x in range(0, N + 1) ] [0.0, 0.09983341664682815, 0.19866933079506122, 0.29552020666133955, 0.3894183423086505, 0.479425538604203, 0.5646424733950354, 0.644217687237691, 0.7173560908995228, 0.7833269096274834, 0.8414709848078965]
def rangef(start, stop, step, fround=5): """ Yields sequence of numbers from start (inclusive) to stop (inclusive) by step (increment) with rounding set to n digits. :param start: start of sequence :param stop: end of sequence :param step: int or float increment (e.g. 1 or 0.001) :param fround: float rounding, n decimal places :return: """ try: i = 0 while stop >= start and step > 0: if i==0: yield start elif start >= stop: yield stop elif start < stop: if start == 0: yield 0 if start != 0: yield start i += 1 start += step start = round(start, fround) else: pass except TypeError as e: yield "type-error({})".format(e) else: pass print(list(rangef(-100.0,10.0,1))) print(list(rangef(-100,0,0.5))) print(list(rangef(-1,1,0.2))) print(list(rangef(-1,1,0.1))) print(list(rangef(-1,1,0.05))) print(list(rangef(-1,1,0.02))) print(list(rangef(-1,1,0.01))) print(list(rangef(-1,1,0.005))) print(list(rangef("1","10","1"))) print(list(rangef(1,10,"1")))
print(linspace(0, 10, 5)) print(list(linspace(0, 10, 5)))
import collections.abc import numbers class linspace(collections.abc.Sequence): """linspace(start, stop, num) -> linspace object Return a virtual sequence of num numbers from start to stop (inclusive). If you need a half-open range, use linspace(start, stop, num+1)[:-1]. """ def __init__(self, start, stop, num): if not isinstance(num, numbers.Integral) or num <= 1: raise ValueError( self.start, self.stop, self.num = start, stop, num self.step = (stop-start)/(num-1) def __len__(self): return self.num def __getitem__(self, i): if isinstance(i, slice): return [self[x] for x in range(*i.indices(len(self)))] if i < 0: i = self.num + i if i >= self.num: raise IndexError( if i == self.num-1: return self.stop return self.start + i*self.step def __repr__(self): return self.start, self.stop, self.num) def __eq__(self, other): if not isinstance(other, linspace): return False return ((self.start, self.stop, self.num) == (other.start, other.stop, other.num)) def __ne__(self, other): return not self==other def __hash__(self): return hash((type(self), self.start, self.stop, self.num))
from decimal import Decimal from decimal import Decimal as D def decimal_range(*args): zero, one = Decimal( if len(args) == 1: start, stop, step = zero, args[0], one elif len(args) == 2: start, stop, step = args + (one,) elif len(args) == 3: start, stop, step = args else: raise ValueError( if not all([type(arg) == Decimal for arg in (start, stop, step)]): raise ValueError( if (start == stop) or (start > stop and step >= zero) or \ (start < stop and step <= zero): return [] current = start while abs(current) < abs(stop): yield current current += step
list(decimal_range(D( list(decimal_range(D( list(decimal_range(D( list(decimal_range(D( list(decimal_range(D(
from decimal import Decimal def get_multiplier(_from, _to, step): digits = [] for number in [_from, _to, step]: pre = Decimal(str(number)) % 1 digit = len(str(pre)) - 2 digits.append(digit) max_digits = max(digits) return float(10 ** (max_digits)) def float_range(_from, _to, step, include=False): mult = get_multiplier(_from, _to, step) int_from = int(round(_from * mult)) int_to = int(round(_to * mult)) int_step = int(round(step * mult)) if include: result = range(int_from, int_to + int_step, int_step) result = [r for r in result if r <= int_to] else: result = range(int_from, int_to, int_step) float_result = [r / mult for r in result] return float_result print float_range(-1, 0, 0.01,include=False) assert float_range(1.01, 2.06, 5.05 % 1, True) ==\ [1.01, 1.06, 1.11, 1.16, 1.21, 1.26, 1.31, 1.36, 1.41, 1.46, 1.51, 1.56, 1.61, 1.66, 1.71, 1.76, 1.81, 1.86, 1.91, 1.96, 2.01, 2.06] assert float_range(1.01, 2.06, 5.05 % 1, False)==\ [1.01, 1.06, 1.11, 1.16, 1.21, 1.26, 1.31, 1.36, 1.41, 1.46, 1.51, 1.56, 1.61, 1.66, 1.71, 1.76, 1.81, 1.86, 1.91, 1.96, 2.01]
for d100 in xrange(0, 100, 1): d = d100 / 100.0 fl = float("0.00"[:4 - len(str(d100))] + str(d100)) print d, "=", fl , d == fl
def frange(start, stop, step): return [x*step+start for x in range(0,round(abs((stop-start)/step)+0.5001), int((stop-start)/step<0)*-2+1)]
def frange(a,b,i): p = 10**i sr = a*p er = (b*p) + 1 p = float(p) return map(lambda x: x/p, xrange(sr,er)) In >frange(-1,1,1) Out>[-1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
>>> import itertools >>> a = [1, 2, 3] >>> b = [4, 5, 6] >>> c = itertools.chain(a, b)
>>> list1, list2, list3 = [1,2,3], [ >>> all_lists = sum([list1, list2, list3], []) >>> all_lists [1, 2, 3,
>>> sum([(1,2), (1,), ()], ()) (1, 2, 1) >>> sum([Counter( Counter({ >>> sum([True, True, False], False) 2
>>> sum([ Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: sum() can
import operator list1, list2, list3 = [1,2,3], [ reduce(operator.add, [list1, list2, list3]) all_lists = [list1, list2, list3] reduce(operator.add, all_lists)
import six if isinstance(value, six.string_types): pass
import sys PY3 = sys.version_info[0] == 3 if PY3: string_types = str, else: string_types = basestring,
if isinstance(target, str) or isinstance(target, unicode):
def isstring(s): if (sys.version_info[0] >= 3): return isinstance(s, str) return isinstance(s, basestring)
from __future__ import unicode_literals from builtins import str isinstance( isinstance(u
a = "my string" type(a) == str a.__class__ == str isinstance(a, str) str(a) == a type(a) == type(
import sys PY2 = sys.version_info.major == 2 isinstance( isinstance( isinstance( isinstance(
s = ["test"]; isString = False; if(isinstance(s, str)): isString = True; try: if(isinstance(s, basestring)): isString = True; except NameError: pass; if(isString): print("String"); else: print("Not String");
>>> isinstance( True >>> isinstance(12, str) False >>> isinstance( False >>> isinstance(u True
varA = "hey" if type(varA) == str: print "it is a string"
import mymod class MyTestCase(unittest.TestCase): def test1(self): self.assertRaises(SomeCoolException, mymod.myfunc)
import unittest def broken_function(): raise Exception( class MyTestCase(unittest.TestCase): def test(self): with self.assertRaises(Exception) as context: broken_function() self.assertTrue( if __name__ == unittest.main()
def test_afunction_throws_exception(self): self.assertRaises(ExpectedException, afunction)
def test_afunction_throws_exception(self): self.assertRaises(ExpectedException, afunction, arg1, arg2)
def test_1_cannot_add_int_and_str(self): with self.assertRaises(TypeError): 1 +
class MyTestCase(unittest.TestCase): def test_1_cannot_add_int_and_str(self): with self.assertRaises(TypeError): 1 + def test_2_cannot_add_int_and_str(self): import operator self.assertRaises(TypeError, operator.add, 1,
unittest.TextTestRunner().run(unittest.TestLoader().loadTestsFromTestCase(MyTestCase))
.. ---------------------------------------------------------------------- Ran 2 tests in 0.007s OK <unittest2.runner.TextTestResult run=2 errors=0 failures=0>
unittest.TextTestRunner(verbosity=2).run(unittest.TestLoader().loadTestsFromTestCase(MyTestCase))
def test_afunction_throws_exception(self): try: afunction() except ExpectedException: pass except Exception as e: self.fail( else: self.fail(
def square_value(a): try: out = a*a except TypeError: raise TypeError("Input should be a string:") return out
import dum_function as df import unittest class Test(unittest.TestCase): def setUp(self): self.false_int = "A" def tearDown(self): pass def test_square_value(self): self.assertRaises(TypeError, df.square_value(self.false_int)) if __name__ == "__main__": unittest.main()
====================================================================== ERROR: test_square_value (__main__.Test) ---------------------------------------------------------------------- Traceback (most recent call last): File "test_dum_function.py", line 22, in test_square_value self.assertRaises(TypeError, df.square_value(self.false_int)) File "/home/jlengrand/Desktop/function.py", line 8, in square_value raise TypeError("Input should be a string:") TypeError: Input should be a string: ---------------------------------------------------------------------- Ran 1 test in 0.000s FAILED (errors=1)
self.assertRaises(TypeError, lambda: df.square_value(self.false_int))
---------------------------------------------------------------------- Ran 1 test in 0.000s OK
def throw_up(something, gowrong=False): """ >>> throw_up( Traceback (most recent call last): ... Exception: Fish n Chips >>> throw_up( """ if gowrong: return "I feel fine!" raise Exception(something) if __name__ == import doctest doctest.testmod()
import contextlib @contextlib.contextmanager def raises(exception): try: yield except exception as e: assert True else: assert False
with raises(Exception): print "Hola" with raises(Exception): raise Exception
def test_div_zero(): with pytest.raises(ZeroDivisionError): 1/0
pigueiras@pigueiras$ py.test ================= test session starts ================= platform linux2 -- Python 2.6.6 -- py-1.4.20 -- pytest-2.5.2 -- /usr/bin/python collected 1 items tests/test_div_zero.py:6: test_div_zero PASSED
from testcase import TestCase import mymod class MyTestCase(TestCase): def test1(self): self.assertRaisesWithMessage(SomeCoolException, mymod.myfunc)
import unittest class TestClass(): def raises_exception(self): raise Exception("test") class MyTestCase(unittest.TestCase): def test_if_method_raises_correct_exception(self): test_class = TestClass() self.assertRaises(Exception, test_class.raises_exception)
$ pyminifier --nonlatin --replacement-length=50 /tmp/tumult.py ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲמּ=ImportError ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ燱=print ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ巡=False ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ澨=object try: import demiurgic except ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲמּ: ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ燱("Warning: You try: import mystificate except ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲמּ: ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ燱("Warning: Dark voodoo may be unreliable.") ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲﺬ=ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ巡 class ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ𐦚(ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ澨): def __init__(self,*args,**kwargs): pass def ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ클(self,dactyl): ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ퐐=demiurgic.palpitation(dactyl) ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ𠛲=mystificate.dark_voodoo(ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ퐐) return ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ𠛲 def ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ𐠯(self,whatever): ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ燱(whatever) if __name__=="__main__": ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ燱("Forming...") ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲﺃ=ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ𐦚("epicaricacy","perseverate") ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲﺃ.ﺭ异𞸐𐤔ﭞﰣﺁں𝕌𨿩𞸇뻛𐬑𥰫嬭ﱌ𢽁𐡆𧪮Ꝫﴹ뙫𢤴퉊ﳦﲣפּܟﺶ𐐤ﶨࠔ𐰷𢡶𧐎𐭈𞸏𢢘𦘼ﶻ𩏃𦽨𞺎𠛘𐠲䉊ﰸﭳᣲ𐠯("Codswallop")
import datetime today = datetime.date.today() print today
import datetime mylist = [] today = datetime.date.today() mylist.append(today) print mylist
import datetime mylist = [] today = datetime.date.today() mylist.append(today) print mylist[0] 2008-11-22 print "This is a new day : ", mylist[0] >>> This is a new day : 2008-11-22 print "This is a new day : " + mylist[0] >>> cannot concatenate print "This is a new day : " + str(mylist[0]) >>> This is a new day : 2008-11-22
import datetime f"{datetime.datetime.now():%Y-%m-%d}" >>>
import datetime print datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
%a Locale’s abbreviated weekday name. %A Locale’s full weekday name. %b Locale’s abbreviated month name. %B Locale’s full month name. %c Locale’s appropriate date and time representation. %d Day of the month as a decimal number [01,31]. %f Microsecond as a decimal number [0,999999], zero-padded on the left %H Hour (24-hour clock) as a decimal number [00,23]. %I Hour (12-hour clock) as a decimal number [01,12]. %j Day of the year as a decimal number [001,366]. %m Month as a decimal number [01,12]. %M Minute as a decimal number [00,59]. %p Locale’s equivalent of either AM or PM. %S Second as a decimal number [00,61]. %U Week number of the year (Sunday as the first day of the week) %w Weekday as a decimal number [0(Sunday),6]. %W Week number of the year (Monday as the first day of the week) %x Locale’s appropriate date representation. %X Locale’s appropriate time representation. %y Year without century as a decimal number [00,99]. %Y Year with century as a decimal number. %z UTC offset in the form +HHMM or -HHMM. %Z Time zone name (empty string if the object is naive). %% A literal
import time import datetime print "Time in seconds since the epoch: %s" %time.time() print "Current date and time: " , datetime.datetime.now() print "Or like this: " ,datetime.datetime.now().strftime("%y-%m-%d-%H-%M") print "Current year: ", datetime.date.today().strftime("%Y") print "Month of year: ", datetime.date.today().strftime("%B") print "Week number of the year: ", datetime.date.today().strftime("%W") print "Weekday of the week: ", datetime.date.today().strftime("%w") print "Day of year: ", datetime.date.today().strftime("%j") print "Day of the month : ", datetime.date.today().strftime("%d") print "Day of week: ", datetime.date.today().strftime("%A")
Time in seconds since the epoch: 1349271346.46 Current date and time: 2012-10-03 15:35:46.461491 Or like this: 12-10-03-15-35 Current year: 2012 Month of year: October Week number of the year: 40 Weekday of the week: 3 Day of year: 277 Day of the month : 03 Day of week: Wednesday
>>> import time >>> time.strftime("%Y-%m-%d %H:%M")
d_date = datetime.datetime.now() reg_format_date = d_date.strftime("%Y-%m-%d %I:%M:%S %p") print(reg_format_date) reg_format_date = d_date.strftime("%d %B %Y %I:%M:%S %p") print(reg_format_date) reg_format_date = d_date.strftime("%Y-%m-%d %H:%M:%S") print(reg_format_date)
2016-10-06 01:21:34 PM 06 October 2016 01:21:34 PM 2016-10-06 13:21:34
from datetime import datetime, date "{:%d.%m.%Y}".format(datetime.now())
>>> import datetime >>> f"{datetime.datetime.now():%Y-%m-%d}"
import datetime collection = [] dateTimeString = str(datetime.date.today()) collection.append(dateTimeString) print collection
from datetime import date def time-format(): return str(date.today()) print (time-format())
import datetime mylist = [] today = str(datetime.date.today()) mylist.append(today) print mylist
>>> a = datetime.datetime(2015, 04, 01, 11, 23, 22) >>> a.strftime(
>>> import pandas as pd >>> pd.to_datetime( Timestamp( >>> print(pd.to_datetime( 2018-10-07 06:03:47 >>> pd.to_datetime( datetime.date(2018, 10, 7) >>> print(pd.to_datetime( 2018-10-07 >>>
>>> l=[] >>> l.append(pd.to_datetime( >>> l [datetime.date(2018, 10, 7)] >>> map(str,l) <map object at 0x0000005F67CCDF98> >>> list(map(str,l)) [
>>> l=list(map(str,l)) >>> list(map(pd.to_datetime,l)) [Timestamp(
import date_converter my_date = date_converter.date_to_string(today,
import datetime mylist = [] present = datetime.date.today() mylist.append(present) print present
from datetime import datetime now = datetime.now() print
import datetime import time months = ["Unknown","January","Febuary","Marchh","April","May","June","July","August","September","October","November","December"] datetimeWrite = (time.strftime("%d-%m-%Y ")) date = time.strftime("%d") month= time.strftime("%m") choices = { result = choices.get(month, year = time.strftime("%Y") Date = date+"-"+result+"-"+year print Date
glob(os.path.join( glob(os.path.join( glob(os.path.join( glob(os.path.join(
import glob for filename in glob.iglob( print(filename)
import fnmatch import os matches = [] for root, dirnames, filenames in os.walk( for filename in fnmatch.filter(filenames, matches.append(os.path.join(root, filename))
import os, fnmatch def find_files(directory, pattern): for root, dirs, files in os.walk(directory): for basename in files: if fnmatch.fnmatch(basename, pattern): filename = os.path.join(root, basename) yield filename for filename in find_files( print
>>> import glob2 >>> all_header_files = glob2.glob(
from pathlib import Path for file_path in Path( print(file_path)
import os import fnmatch def recursive_glob(treeroot, pattern): results = [] for base, dirs, files in os.walk(treeroot): goodfiles = fnmatch.filter(files, pattern) results.extend(os.path.join(base, f) for f in goodfiles) return results
import os cfiles = [] for root, dirs, files in os.walk( for file in files: if file.endswith( cfiles.append(os.path.join(root, file))
import os cfiles = [os.path.join(root, filename) for root, dirnames, filenames in os.walk( for filename in filenames if filename.endswith(
import os;cfiles=[os.path.join(r,f) for r,d,fs in os.walk(
import os def recursive_glob(rootdir= return [os.path.join(looproot, filename) for looproot, _, filenames in os.walk(rootdir) for filename in filenames if filename.endswith(suffix)] cfiles = recursive_glob(
import fnmatch import os def recursive_glob(rootdir= return [os.path.join(looproot, filename) for looproot, _, filenames in os.walk(rootdir) for filename in filenames if fnmatch.fnmatch(filename, pattern)] cfiles = recursive_glob(
import formic fileset = formic.FileSet(include="/src/**/*.c") for file_name in fileset.qualified_files(): print file_name
files = [] for root, dirnames, filenames in os.walk(myDir): files.extend(glob.glob(root + "/*.xml"))
import glob import shutil import os src_dir = "/home/mustafa/Masaüstü/yedek" dst_dir = "/home/mustafa/Genel/media" for mediafile in glob.iglob(os.path.join(src_dir, "*", "*.jpg")): shutil.copy(mediafile, dst_dir)
import glob import os def _getDirs(base): return [x for x in glob.iglob(os.path.join( base, def rglob(base, pattern): list = [] list.extend(glob.glob(os.path.join(base,pattern))) dirs = _getDirs(base) if len(dirs): for d in dirs: list.extend(rglob(os.path.join(base,d), pattern)) return list
import os,glob,sys def dirlist(path, c = 1): for i in glob.glob(os.path.join(path, "*")): if os.path.isfile(i): filepath, filename = os.path.split(i) print elif os.path.isdir(i): dirname = os.path.basename(i) print c+=1 dirlist(i,c) c-=1 path = os.path.normpath(sys.argv[1]) print(os.path.basename(path)) dirlist(path)
import os, glob, itertools results = itertools.chain.from_iterable(glob.iglob(os.path.join(root, for root, dirs, files in os.walk( for f in results: print(f)
import os matches = [] for root, dirnames, filenames in os.walk( matches += [os.path.join(root, f) for f in filenames if f[-2:] ==
>>> base = r"c:\User\xtofl" >>> binfiles = [ os.path.join(base,f) for base, _, files in os.walk(root) for f in files if f.endswith(".jpg") ]
import fnmatch, os def filepaths(directory, pattern): for root, dirs, files in os.walk(directory): for basename in files: try: matched = pattern.match(basename) except AttributeError: matched = fnmatch.fnmatch(basename, pattern) if matched: yield os.path.join(root, basename) if __name__ == from pprint import pprint as pp import re path = r pp([x for x in filepaths(path, re.compile(r pp([x for x in filepaths(path,
import os, glob def _globrec(path, *exts): dirs = [a[0] for a in os.walk(path)] f_filter = [d+e for d in dirs for e in exts] return [f for files in [glob.iglob(files) for files in f_filter] for f in files] my_pictures = _globrec(r for f in my_pictures: print f
import sys, os, glob dir_list = ["c:\\books\\heap"] while len(dir_list) > 0: cur_dir = dir_list[0] del dir_list[0] list_of_files = glob.glob(cur_dir+ for book in list_of_files: if os.path.isfile(book): print(book) else: dir_list.append(book)
import time import fnmatch import os def fileinfo(file): filename = os.path.basename(file) rootdir = os.path.dirname(file) lastmod = time.ctime(os.path.getmtime(file)) creation = time.ctime(os.path.getctime(file)) filesize = os.path.getsize(file) print "%s**\t%s\t%s\t%s\t%s" % (rootdir, filename, lastmod, creation, filesize) searchdir = r matches = [] for root, dirnames, filenames in os.walk(searchdir): for filename in filenames: fileinfo(os.path.join(root, filename))
import fnmatch import os import re def findfiles(dir, pattern): patternregex = fnmatch.translate(pattern) for root, dirs, files in os.walk(dir): for basename in files: filename = os.path.join(root, basename) if re.search(patternregex, filename, re.IGNORECASE): yield filename
import subprocess foundfiles= subprocess.check_output("ls src/*.c src/**/*.c", shell=True) for foundfile in foundfiles.splitlines(): print foundfile
try: do_stuff() except Exception, err: print Exception, err
import traceback try: raise TypeError("Oups!") except Exception, err: try: raise TypeError("Again !?!") except: pass traceback.print_exc()
import traceback import sys try: raise TypeError("Oups!") except Exception, err: try: exc_info = sys.exc_info() try: raise TypeError("Again !?!") except: pass finally: traceback.print_exception(*exc_info) del exc_info
import traceback try: raise TypeError("Oups!") except Exception as err: try: raise TypeError("Again !?!") except: pass traceback.print_tb(err.__traceback__)
import traceback import sys try: do_stuff() except Exception: print(traceback.format_exc()) print(sys.exc_info()[0])
try: do_something_that_might_error() except Exception as error: handle_the_error(error)
def raise_error(): raise RuntimeError( def do_something_that_might_error(): raise_error()
try: do_something_that_might_error() except Exception as error: traceback.print_exc()
Traceback (most recent call last): File "<stdin>", line 2, in <module> File "<stdin>", line 2, in do_something_that_might_error File "<stdin>", line 2, in raise_error RuntimeError: something bad happened!
import logging logging.basicConfig(level=logging.DEBUG) logger = logging.getLogger(__name__)
try: do_something_that_might_error() except Exception as error: logger.exception(error)
ERROR:__main__:something bad happened! Traceback (most recent call last): File "<stdin>", line 2, in <module> File "<stdin>", line 2, in do_something_that_might_error File "<stdin>", line 2, in raise_error RuntimeError: something bad happened!
try: do_something_that_might_error() except Exception as error: logger.debug(traceback.format_exc())
DEBUG:__main__:Traceback (most recent call last): File "<stdin>", line 2, in <module> File "<stdin>", line 2, in do_something_that_might_error File "<stdin>", line 2, in raise_error RuntimeError: something bad happened!
>>> do_something_that_might_error() Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 2, in do_something_that_might_error File "<stdin>", line 2, in raise_error RuntimeError: something bad happened!
desired_trace = traceback.format_exc(sys.exc_info())
import traceback import sys try: flaky_func() except KeyboardInterrupt: raise except Exception: desired_trace = traceback.format_exc(sys.exc_info()) log(desired_trace)
try: do_something_that_might_error() except Exception: logger.info(
for i in something: for j in somethingelse: for k in whatever: try: something_complex(i, j, k) except Exception, e: print e try: something_less_complex(i, j) except Exception, e: print e
import traceback, sys def do_stuff(): 1/0 try: do_stuff() except Exception: print(traceback.format_exc()) print(
log = logging.getLogger(__name__) try: call_code_that_fails() except MyError: log.exception(
>>> dict1 = {"key1": "value1", "key2": "value2"} >>> dict2 = dict1 >>> dict2 { >>> dict2["key2"] = "WHY?!" >>> dict1 {
>>> x={ >>> u=x.copy() >>> v=dict(x) >>> import copy >>> w=copy.deepcopy(x) >>> x[ >>> x { >>> u { >>> v { >>> w { >>> x[ >>> x { >>> u { >>> v { >>> w {
>>>dict1 = {"key1": "value1", "key2": "value2"} >>>dict2 = {**dict1} >>>print(dict2) { >>>dict2["key2"] = "WHY?!" >>>print(dict1) { >>>print(dict2) {
my_dict1 = dict() my_dict1["message"] = "Hello Python" print(my_dict1) my_dict2 = dict(my_dict1) print(my_dict2) my_dict1["name"] = "Emrit" print(my_dict1) print(my_dict2)
my_dict2 = dict() my_dict2.update(my_dict1) print(my_dict2) my_dict1["name"] = "Emrit" print(my_dict1) print(my_dict2)
copy.copy(x) Return a shallow copy of x. copy.deepcopy(x) Return a deep copy of x.
>>> import copy >>> a = [1,2,3,4,[ >>> b = a >>> c = copy.copy(a) >>> d = copy.deepcopy(a) >>> a.append(5) >>> a[4].append(
>>> a [1, 2, 3, 4, [ >>> b [1, 2, 3, 4, [ >>> c [1, 2, 3, 4, [ >>> d [1, 2, 3, 4, [
>>> dict1 = {"key1": "value1", "key2": "value2"} >>> dict2 = dict(dict1, key2="WHY?!") >>> dict1 { >>> dict2 {
>>> dict1 = {"key1": "value1", "key2": "value2"} >>> dict2 = {**dict1} >>> dict2 { >>> dict2["key2"] = "WHY?!" >>> dict1 { >>>
class ValueDict(dict): def __ilshift__(self, args): result = ValueDict(self) if isinstance(args, dict): dict.update(result, args) else: dict.__setitem__(result, *args) return result def __irshift__(self, args): result = ValueDict(self) dict.__delitem__(result, args) return result def __setitem__(self, k, v): raise AttributeError, \ "Use \"value_dict<<= def __delitem__(self, k): raise AttributeError, \ "Use \"value_dict>>= def update(self, d2): raise AttributeError, \ "Use \"value_dict<<=dict2\" instead of \"value_dict.update(dict2)\"" d = ValueDict() d <<= d <<= print "d =", d e = d e <<= print "e =", e print "d =", d d >>= print "d =", d d <<={ print "d =", d print "e =", e print "e[ d = { e = { d = { d = { d = { e = { e[
my_users = { } ids = my_users.get( ids.extend(my_users.get( print ids print my_users
import os class cd: def __init__(self, newPath): self.newPath = os.path.expanduser(newPath) def __enter__(self): self.savedPath = os.getcwd() os.chdir(self.newPath) def __exit__(self, etype, value, traceback): os.chdir(self.savedPath)
import subprocess with cd("~/Library"): subprocess.call("ls")
from contextlib import contextmanager import os @contextmanager def cd(newdir): prevdir = os.getcwd() os.chdir(os.path.expanduser(newdir)) try: yield finally: os.chdir(prevdir)
from __future__ import with_statement from grizzled.os import working_directory with working_directory(path_to_directory):
import os from contextlib import contextmanager @contextmanager def working_directory(directory): owd = os.getcwd() try: os.chdir(directory) yield directory finally: os.chdir(owd)
def quote_against_shell_expansion(s): import pipes return pipes.quote(s) def put_text_back_into_terminal_input_buffer(text): import fcntl, termios for c in text: fcntl.ioctl(1, termios.TIOCSTI, c) def change_parent_process_directory(dest): put_text_back_into_terminal_input_buffer("cd "+quote_against_shell_expansion(dest)+"\n")
import os abs_path = rel_path = os.chdir(abs_path) os.chdir(rel_path)
if _%1 == _. goto cdDone if _%1 == _? goto help if /i _%1 NEQ _-H goto doCd :help echo d.bat and dSup.py 2016.03.05. Extended chdir. echo -C = clear traversal list. echo -B or nothing = backward (to previous dir). echo -F or - = forward (to next dir). echo -R = remove current from list and return to previous. echo -S = select from list. echo -H, -h, ? = help. echo . = make window title current directory. echo Anything else = target directory. goto done :doCd %~dp0dSup.py %1 for /F %%d in ( %~dp0dSupList ) do ( cd %%d if errorlevel 1 ( %~dp0dSup.py -R ) goto cdDone ) :cdDone title %CD% :done
import sys, os, msvcrt def indexNoCase ( slist, s ) : for idx in range( len( slist )) : if slist[idx].upper() == s.upper() : return idx raise ValueError if len( sys.argv ) < 2 : cmd = 1 elif sys.argv[1][0] == if len(sys.argv[1]) == 1 : cmd = 2 else : cmd = else : cmd = -1 dir = os.path.abspath( sys.argv[1] ) + fo = open( os.path.dirname( sys.argv[0] ) + fo.seek( 0 ) dlist = fo.readlines( -1 ) if len( dlist ) == 0 : dlist.append( os.getcwd() + if cmd == 1 : target = dlist.pop(0) dlist.append( target ) elif cmd == 2 : target = dlist.pop( len( dlist ) - 1 ) dlist.insert( 0, target ) elif cmd == 3 : dlist.pop( 0 ) elif cmd == 4 : for idx in range( len( dlist )) : print( while True : inp = msvcrt.getche() if inp.isdigit() : inp = int( inp ) if inp < len( dlist ) : print( break print( if inp > 0 : dlist.insert( 0, dlist.pop( inp )) elif cmd == -1 : try: dlist.pop( indexNoCase( dlist, dir )) except ValueError : pass dlist = dlist[:9] dlist.insert( 0, dir ) fo.truncate( 0 ) if cmd != 0 : fo.writelines( dlist ) fo.close() exit(0)
>>> class MyClass: ... def myPublicMethod(self): ... print ... def __myPrivateMethod(self): ... print ... >>> obj = MyClass() >>> obj.myPublicMethod() public method >>> obj.__myPrivateMethod() Traceback (most recent call last): File "", line 1, in AttributeError: MyClass instance has no attribute >>> dir(obj) [ >>> obj._MyClass__myPrivateMethod() this is private!!
>>> class MyClass: ... def myPublicMethod(self): ... print ... def __myPrivateMethod(self): ... print ... >>> obj = MyClass()
>>> obj.__myPrivateMethod() Traceback (most recent call last): File "", line 1, in AttributeError: MyClass instance has no attribute
>>> obj._MyClass__myPrivateMethod() this is private!!
>>> class Foo(object): ... def __init__(self): ... self.__baz = 42 ... def foo(self): ... print self.__baz ... >>> class Bar(Foo): ... def __init__(self): ... super(Bar, self).__init__() ... self.__baz = 21 ... def bar(self): ... print self.__baz ... >>> x = Bar() >>> x.foo() 42 >>> x.bar() 21 >>> print x.__dict__ {
import re import inspect class MyClass : def __init__(self) : pass def private_function ( self ) : try : function_call = inspect.stack()[1][4][0].strip() matched = re.match( if not matched : print return except : print return print def public_function ( self ) : self.private_function()
>>> class Foo: def __init__(self): pass def __privateMethod(self): return 3 def invoke(self): return self.__privateMethod() >>> help(Foo) Help on class Foo in module __main__: class Foo(builtins.object) | Methods defined here: | | __init__(self) | | invoke(self) | | ---------------------------------------------------------------------- | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) >>> f = Foo() >>> f.invoke() 3 >>> f.__privateMethod() Traceback (most recent call last): File "<pyshell f.__privateMethod() AttributeError:
import re DATA = "Hey, you - what are you doing here!?" print re.findall(r"[\w
>>> import re >>> filter(None, re.split("[, \-!?:]+", "Hey, you - what are you doing here!?")) [
import string punc = string.punctuation thestring = "Hey, you - what are you doing here!?" s = list(thestring)
>>> import timeit >>> S = >>> def my_split(s, seps): ... res = [s] ... for sep in seps: ... s, res = res, [] ... for seq in s: ... res += seq.split(sep) ... return res ... >>> timeit.Timer( 54.65477919578552
>>> from string import translate,maketrans,punctuation >>> T = maketrans(punctuation, >>> timeit.Timer( 1.2835021018981934
def my_split(s, seps): res = [s] for sep in seps: s, res = res, [] for seq in s: res += seq.split(sep) return res print my_split( [
join = lambda x: sum(x,[]) join = lambda lists: [x for l in lists for x in l]
fragments = [text] for token in tokens: fragments = join(f.split(token) for f in fragments)
import re my_str = "Hey, you - what are you doing here!?" words = re.split(r
my_str = "Hey, you - what are you doing here!?" replacements = ( for r in replacements: my_str = my_str.replace(r, words = my_str.split()
import functools my_str = "Hey, you - what are you doing here!?" replacements = ( my_str = functools.reduce(lambda s, sep: s.replace(sep, words = my_str.split()
import re phrase = "Hey, you - what are you doing here!?" matches = re.findall( print matches
from itertools import groupby sep = s = "Hey, you - what are you doing here!?" print [
In [10]: import string In [11]: string.punctuation Out[11]:
In [12]: your_str = "Hey, you - what are you doing here!?" In [13]: line = your_str.translate(your_str.maketrans( In [14]: line = line.lower() In [15]: words = line.split() In [16]: print(words) [
import nltk data= "Hey, you - what are you doing here!?" word_tokens = nltk.tokenize.regexp_tokenize(data, r print word_tokens
split_without_punc = lambda text : [word.strip(string.punctuation) for word in text.split() if word.strip(string.punctuation) != split_without_punc("Hey, you -- what are you doing?!")
def split_without_punctuation2(text): words = text.split() return [word.strip(ignore) for word in words if word.strip(ignore) != split_without_punctuation2("Hey, you -- what are you doing?!")
def split_without(text: str, ignore: str) -> list: split_string = text.split() words = [] for word in split_string: word = word.strip(ignore) if word != words.append(word) return words import string final_text = split_without("Hey, you - what are you doing?!", string.punctuation)
import re DATA = "Hey, you - what are you doing here!?" reg_tok = re.compile("[\w print reg_tok.findall(DATA)
st = "Hey, you - what are you doing here!?" new_string = new_list = new_string.split() [
def split_string(source, splitlist): output = [] atsplit = True for char in source: if char in splitlist: atsplit = True else: if atsplit: output.append(char) atsplit = False else: output[-1] = output[-1] + char return output
import string specials = trans = string.maketrans(specials, body = body.translate(trans) words = body.strip().split()
def msplit( str, delims ): w = for z in str: if z not in delims: w += z else: if len(w) > 0 : yield w w = if len(w) > 0 : yield w
def split_string(source,splitlist): splits = frozenset(splitlist) l = [] s1 = "" for c in source: if c in splits: if s1: l.append(s1) s1 = "" else: print s1 s1 = s1 + c if s1: l.append(s1) return l >>>out = split_string("First Name,Last Name,Street Address,City,State,Zip Code",",") >>>print out >>>[
def split_string(text, splitlist): for sep in splitlist: text = text.replace(sep, splitlist[0]) return filter(None, text.split(splitlist[0])) if splitlist else [text]
def get_words(s): l = [] w = for c in s.lower(): if c in if w != l.append(w) w = else: w = w + c if w != l.append(w) return l
>>> s = "Hey, you - what are you doing here!?" >>> print get_words(s) [
def tokenizeSentence_Reversible(sentence): setOfDelimiters = [ listOfTokens = [sentence] for delimiter in setOfDelimiters: newListOfTokens = [] for ind, token in enumerate(listOfTokens): ll = [([delimiter, w] if ind > 0 else [w]) for ind, w in enumerate(token.split(delimiter))] listOfTokens = [item for sublist in ll for item in sublist] listOfTokens = filter(None, listOfTokens) newListOfTokens.extend(listOfTokens) listOfTokens = newListOfTokens return listOfTokens
import importlib moduleName = input( importlib.import_module(moduleName)
pmName = input( pm = __import__(pmName) print(dir(pm))
el@apollo:/home/el/foo$ python Python 2.7.3 (default, Sep 26 2013, 20:03:06) >>> import fox >>> fox.what_does_the_fox_say() vixens cry >>>
def question(): print "where are the nuclear wessels?"
el@apollo:/home/el/foo3$ python main.py where are the nuclear wessels?
def watchout(): print "computers are transforming into a noose and a yoke for humans"
import sys import os sys.path.append(os.path.abspath("/home/el/foo4/stuff")) from riaa import * watchout()
el@apollo:/home/el/foo4$ python main.py computers are transforming into a noose and a yoke for humans
class secretclass: def secretmessage(cls, myarg): return myarg + " is if.. up in the sky, the sky" secretmessage = classmethod( secretmessage ) def skycake(cls): return "cookie and sky pie people can skycake = classmethod( skycake )
import user msg = "The only way skycake tates good" msg = user.secretclass.secretmessage(msg) msg += user.secretclass.skycake() print(msg + " have the sky pie! SKYCAKE!")
$ python main.py The only way skycake tates good is if.. up in the sky, the skycookie and sky pie people can SKYCAKE!
el@apollo:/home/el/foo5/herp$ touch __init__.py el@apollo:/home/el/foo5/herp$ ls __init__.py
el@apollo:/home/el/foo5/herp/derp$ touch __init__.py el@apollo:/home/el/foo5/herp/derp$ ls __init__.py
def skycake(): print "SkyCake evolves to stay just beyond the cognitive reach of " + "the bulk of men. SKYCAKE!!"
el@apollo:/home/el/foo5$ python main.py SkyCake evolves to stay just beyond the cognitive reach of the bulk of men. SKYCAKE!!
scriptpath = "../Test/MyModule.py" sys.path.append(os.path.abspath(scriptpath)) import MyModule
import file file.function1_name() file.function2_name()
/main.py /mymodule /__init__.py /somefile.py /otherstuff.py
from mymodule.somefile import somefunc from mymodule.otherstuff import otherfunc
testString= "A string literal to import and test with"
/path/to/common_dir/module/file.py /path/to/common_dir/application/app.py /path/to/common_dir/application/subpath/config.json
import os, sys, inspect sys.path.append(os.getcwd()) from module.file import MyClass instance = MyClass()
filename = inspect.getframeinfo(inspect.currentframe()).filename dirname = os.path.dirname(os.path.abspath(filename)) MY_CONFIG = os.path.join(dirname, "subpath/config.json")
user@host:/path/to/common_dir$ python3 application/app.py
def my_function(): pass print get_function_name_as_string(my_function)
>>> import time >>> time.time.func_name Traceback (most recent call last): File "<stdin>", line 1, in ? AttributeError: >>> time.time.__name__
import sys this_function_name = sys._getframe().f_code.co_name
def func_name(): import traceback return traceback.extract_stack(None, 2)[0][2]
import traceback def who_am_i(): stack = traceback.extract_stack() filename, codeline, funcName, text = stack[-2] return funcName
def my_function(): pass class MyClass(object): def method(self): pass print(my_function.__name__) print(MyClass.method.__name__) print(my_function.__qualname__) print(MyClass.method.__qualname__)
class EnterExitLog(): def __init__(self, funcName): self.funcName = funcName def __enter__(self): gLog.debug( self.init_time = datetime.datetime.now() return self def __exit__(self, type, value, tb): gLog.debug( def func_timer_decorator(func): def func_wrapper(*args, **kwargs): with EnterExitLog(func.__name__): return func(*args, **kwargs) return func_wrapper
import inspect import logging import traceback def get_function_name(): return traceback.extract_stack(None, 2)[0][2] def get_function_parameters_and_values(): frame = inspect.currentframe().f_back args, _, _, values = inspect.getargvalues(frame) return ([(i, values[i]) for i in args]) def my_func(a, b, c=None): logging.info( pass logger = logging.getLogger() handler = logging.StreamHandler() formatter = logging.Formatter( handler.setFormatter(formatter) logger.addHandler(handler) logger.setLevel(logging.INFO) my_func(1, 3)
def function1(): print "function1" def function2(): print "function2" def function3(): print "function3" print function1.__name__
>>> a = ["foo", "bar", "baz"] >>> for i in reversed(a): ... print (i) ... baz bar foo
>>> for i, e in reversed(list(enumerate(a))): ... print (i, e) ... 2 baz 1 bar 0 foo
def reverse_enum(L): for index in reversed(xrange(len(L))): yield index, L[index] L = [ for index, item in reverse_enum(L): print index, item
import itertools def reversed_enumerate(sequence): return itertools.izip( reversed(xrange(len(sequence))), reversed(sequence), )
>>> foo = [ >>> for i in range(len(foo)): ... print foo[-(i+1)] ... 4d 3c 2b 1a >>>
>>> length = len(foo) >>> for i in range(length): ... print foo[length-i-1] ... 4d 3c 2b 1a >>>
def reverse(spam): k = [] for i in spam: k.insert(0,i) return "".join(k)
collection = [ [item for item in reversed( collection ) ]
i = len(collection)-1 while i>=0: value = collection[i] index = i i-=1
a = [1, 2, 3, 4, 5, 6, 7] for x in xrange(len(a)): x += 1 print a[-x]
>>> collection = ["ham", "spam", "eggs", "baked beans"] >>> for i in range(1, len(collection) + 1): ... print(collection[-i]) ... baked beans eggs spam ham
>>> for i in range(1, len(collection) + 1): ... print(i-1, collection[-i]) ... 0 baked beans 1 eggs 2 spam 3 ham
>>> for i in range(1, len(collection) + 1): ... print(len(collection)-i, collection[-i]) ... 3 baked beans 2 eggs 1 spam 0 ham
a = ["foo", "bar", "baz"] for i in range(len(a)-1, -1, -1): print(i, a[i]) 3 baz 2 bar 1 foo
a = ["foo", "bar", "baz"] from itertools import count, takewhile def larger_than_0(x): return x > 0 for x in takewhile(larger_than_0, count(3, -1)): print(x, a[x-1]) 3 baz 2 bar 1 foo
myArray = [1,2,3,4] myArray.reverse() for x in myArray: print x
>>> a = ["foo", "bar", "baz"] >>> for i in range(-1, -1*(len(a)+1), -1): ... print i, a[i] ... -1 baz -2 bar -3 foo
n = int(input()) arr = list(map(int, input().split())) for i in reversed(range(0, n)): print("%d %d" %(i, arr[i]))
zip(reversed(range(len(collection))), reversed(collection))
izip(reversed(xrange(len(collection))), reversed(collection))
def reversed_enumerate(collection): return zip(reversed(range(len(collection))), reversed(collection))
input_list = [ for i in range(-1,-len(input_list)-1,-1) print(input_list[i])
a = [ def enumerate_reversed(lyst): for index, value in enumerate(reversed(lyst)): index = len(lyst)-1 - index yield index, value for index, value in enumerate_reversed(a): do_something(index, value)
for index, value in enumerate(reversed(a)): index = len(a)-1 - index do_something(index, value)
>>> min(timeit.repeat( 4.6937971115112305 >>> min(timeit.repeat( 4.809093952178955 >>> min(timeit.repeat( 4.931743860244751 >>> min(timeit.repeat( 5.548468112945557 >>> min(timeit.repeat( 6.286104917526245 >>> min(timeit.repeat( 8.384078979492188
import platform platform.node() import socket socket.gethostname()
import socket socket.gethostbyaddr(socket.gethostname())[0]
import socket if socket.gethostname().find( name=socket.gethostname() else: name=socket.gethostbyaddr(socket.gethostname())[0]
>>> import os >>> os.path.abspath("mydir/myfile.txt")
>>> import os >>> os.path.abspath("C:/example/cwd/mydir/myfile.txt")
>>> from pathlib import Path >>> p = Path("pythonw.exe").resolve() >>> p WindowsPath( >>> str(p)
>>> from pathlib import Path >>> p = Path("python3.4").resolve() >>> p PosixPath( >>> str(p)
>>> from unipath import Path >>> absolute_path = Path( Path( >>> str(absolute_path) C:\\example\\cwd\\mydir\\myfile.txt >>>
from pathlib import Path relative = Path("mydir/myfile.txt") absolute = relative.absolute()
from os.path import abspath absolute = abspath(relative)
import os upload_folder = os.path.abspath("static/img/users")
>>>/Users/myUsername/PycharmProjects/OBS/static/img/user
>>> path=os.popen("readlink -f file").read() >>> print path abs/path/to/file
>>> import os >>> os.path.abspath( >>> from srblib import abs_path >>> abs_path(
filePath = os.path.abspath(directoryName) filePathWithSlash = filePath + "\\" filenameWithPath = os.path.join(filePathWithSlash, filename)
>>> b Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can
>>> f=open("new", "wb") >>> f.write("Hello Python!") Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError:
results = Model.objects.exclude(a=true, x__lt=5).exclude(a=true, x__gt=5)
>>> from myapp.models import Entry >>> from django.db.models import Q >>> Entry.objects.filter(~Q(id = 3)) [<Entry: Entry object>, <Entry: Entry object>, <Entry: Entry object>, ...]
results = Model.objects.filter(x=5).exclude(a=true)
exact iexact contains icontains in gt gte lt lte startswith istartswith endswith iendswith range year month day week_day isnull search regex iregex
from django.db.models import Lookup class NotEqual(Lookup): lookup_name = def as_sql(self, qn, connection): lhs, lhs_params = self.process_lhs(qn, connection) rhs, rhs_params = self.process_rhs(qn, connection) params = lhs_params + rhs_params return
from django.db.models.fields import Field Field.register_lookup(NotEqual)
results = Model.objects.exclude(a=true).filter(x=5)
from django.db.models import Q object_list = QuerySet.filter(~Q(a=True), x=5)
from django.db.models import Lookup from django.db.models.fields import Field @Field.register_lookup class NotEqual(Lookup): lookup_name = def as_sql(self, compiler, connection): lhs, lhs_params = self.process_lhs(compiler, connection) rhs, rhs_params = self.process_rhs(compiler, connection) params = lhs_params + rhs_params return
from django.db.models import Q object_list = QuerySet.filter(~Q(field=
results = Model.objects.exclude(a=true).filter(x=5)
results = Model.objects.filter(x=5).exclude(a=true)
results = Model.objects.filter(a=false)|Model.objects.filter(x=5)
from model_values import F Model.objects.exclude(F.x != 5, a=True)
new_project/ antigravity/ antigravity.py test/ test_antigravity.py setup.py etc.
new_project ├── antigravity.py └── test_antigravity.py
$ cd new_project $ python -m unittest test_antigravity
new_project ├── antigravity │ ├── __init__.py │ └── antigravity.py └── test ├── __init__.py └── test_antigravity.py
import antigravity from antigravity import antigravity from antigravity.antigravity import my_object
$ cd new_project $ python -m unittest test.test_antigravity
$ python -m unittest test.test_antigravity.GravityTestCase $ python -m unittest test.test_antigravity.GravityTestCase.test_method
import sys, os sys.path.insert(0, os.path.dirname(__file__))
import unittest import test.all_tests testSuite = test.all_tests.create_test_suite() text_runner = unittest.TextTestRunner().run(testSuite)
import glob import unittest def create_test_suite(): test_file_strings = glob.glob( module_strings = [ suites = [unittest.defaultTestLoader.loadTestsFromName(name) \ for name in module_strings] testSuite = unittest.TestSuite(suites) return testSuite
$ cd /path/to/googlemaps $ export PYTHONPATH=$PYTHONPATH:/path/to/googlemaps/googlemaps $ python test/test_googlemaps.py
import sys, os testdir = os.path.dirname(__file__) srcdir = sys.path.insert(0, os.path.abspath(os.path.join(testdir, srcdir))) import antigravity import unittest
{ "version": "0.2.0", "configurations": [ { "name": "Python", "type": "python", "request": "launch", "stopOnEntry": false, "pythonPath": "${config:python.pythonPath}", "program": "${file}", "cwd": "${workspaceRoot}", "env": {}, "envFile": "${workspaceRoot}/.env", "debugOptions": [ "WaitOnAbnormalExit", "WaitOnNormalExit", "RedirectOutput" ] } ] }
ProjectName ├── project_name | ├── models | | └── thing_1.py | └── __main__.py └── test ├── models | └── test_thing_1.py └── __main__.py
import sys import unittest sys.path.append( loader = unittest.TestLoader() testSuite = loader.discover( testRunner = unittest.TextTestRunner(verbosity=2) testRunner.run(testSuite)
import unittest from project_name.models import Thing1 class Thing1TestCase(unittest.TestCase): def test_thing_1_init(self): thing_id = thing1 = Thing1(thing_id) self.assertEqual(thing_id, thing.id)
parser = argparse.ArgumentParser() parser.add_argument(
for filename in args.files: exec(open(filename).read())
alltests = unittest.TestSuite() for name, obj in inspect.getmembers(sys.modules[__name__]): if inspect.isclass(obj) and name.startswith("FooTest"): alltests.addTest(unittest.makeSuite(obj))
result = unittest.TextTestRunner(verbosity=2).run(alltests)
ProjectFolder: - project: - __init__.py - item.py - tests: - test_item.py
import unittest import sys class ItemTest(unittest.TestCase): def setUp(self): sys.path.insert(0, "../project") from project import item def test_item_props(self): if __name__ == "__main__": unittest.main()
import antigravity class TestAntigravity(unittest.TestCase): def test_something(self):
setlocal & cd src & python -m unittest discover -s ../test
import sys import os sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__),
import unittest try: import context except ModuleNotFoundError: import test.context import antigravity
this_program="$0" dirname="`dirname $this_program`" readlink="`readlink -e $dirname`" python -m unittest discover -s "$readlink"/test -v
new_project ├── antigravity │ ├── __init__.py │ └── antigravity.py └── test ├── __init__.py └── test_antigravity.py
$ cd new_project $ python -m unittest test.test_antigravity
$ python -m unittest test.test_antigravity.GravityTestCase
/home/johndoe/snakeoil └── test ├── __init__.py └── frontend └── __init__.py └── test_foo.py └── backend └── __init__.py └── test_bar.py
python -m unittest discover -s /home/johndoe/snakeoil/test -t /home/johndoe/snakeoil
-s START, --start-directory START Directory to start discovery ( -t TOP, --top-level-directory TOP Top level directory of project (defaults to start directory)
>>> import locale >>> locale.setlocale(locale.LC_ALL, >>> locale.format("%d", 1255000, grouping=True)
def intWithCommas(x): if type(x) not in [type(0), type(0L)]: raise TypeError("Parameter must be an integer.") if x < 0: return result = while x >= 1000: x, r = divmod(x, 1000) result = ",%03d%s" % (r, result) return "%d%s" % (x, result)
def group(number): s = groups = [] while s and s[-1].isdigit(): groups.append(s[-3:]) s = s[:-3] return s + >>> group(-23432432434.34)
>>> num = 10000000 >>> print(f"{num:,d}") 10,000,000
re.sub("(\d)(?=(\d{3})+(?!\d))", r"\1,", "%d" % val)
import re val = 1234567890 re.sub("(\d)(?=(\d{3})+(?!\d))", r"\1,", "%d" % val) val = 1234567890.1234567890
re.sub("(\d)(?=(\d{3})+(?!\d))", r"\1,", "%.3f" % val)
re.sub("(\d)(?=(\d{3})+(?!\d))", r"\1,", "%.5f" % val)
re.sub(pattern, repl, string) pattern = \ "(\d) (?= (\d{3})+ (?!\d) )", repl = \ r"\1,", string = \ "%d" % val
import locale locale.setlocale( locale.LC_ALL, locale.currency( 1234567.89, grouping = True )
def intToStringWithCommas(x): if type(x) is not int and type(x) is not long: raise TypeError("Not an integer!") if x < 0: return elif x < 1000: return str(x) else: return intToStringWithCommas(x / 1000) +
import re def thous(x, sep= num, _, frac = str(x).partition(dot) num = re.sub(r if frac: num += dot + frac return num
def format_number_using_lists(number): string = result_list = list(string) indexes = range(len(string)) for index in indexes[::-3][1:]: if result_list[index] != result_list.insert(index+1, return
def format_number_using_generators_and_list_comprehensions(number): string = generator = reversed( [ value+ for index,value in enumerate(reversed(string)) ] ) return
def float2comma(f): s = str(abs(f)) decimalposition = s.find(".") if decimalposition == -1: decimalposition = len(s) out = "" for i in range(decimalposition+1, len(s)): if not (i-decimalposition-1) % 3 and i-decimalposition-1: out = out+"," out = out+s[i] if len(out): out = "."+out for i in range(decimalposition-1,-1,-1): if not (decimalposition-i-1) % 3 and decimalposition-i-1: out = ","+out out = s[i]+out if f < 0: out = "-"+out return out
>>> float2comma(10000.1111) >>> float2comma(656565.122) >>> float2comma(-656565.122)
def add_commas(instr): out = [instr[0]] for i in range(1, len(instr)): if (len(instr) - i) % 3 == 0: out.append( out.append(instr[i]) return
add_commas(instr): rng = reversed(range(1, len(instr) + (len(instr) - 1) out = [ return
for i in range(1, 11): instr = print(instr, add_commas(instr))
1 1 12 12 123 123 1234 1,234 12345 12,345 123456 123,456 1234567 1,234,567 12345678 12,345,678 123456789 123,456,789 1234567890 1,234,567,890
def format_money(money, presym= fmt = dot = string.find(fmt, ret = [] if money < 0 : ret.append( p0 = 1 else : p0 = 0 ret.append(presym) p1 = (dot-p0) % 3 + p0 while True : ret.append(fmt[p0:p1]) if p1 == dot : break ret.append( p0 = p1 p1 += 3 ret.append(fmt[dot:]) ret.append(postsym) if money < 0 : ret.append( return
import random number = str(random.randint(1, 10000000)) comma_placement = 4 print( while True: if len(number) % 3 == 0: for i in range(0, len(number) number = number[0:len(number) - comma_placement + 1] + comma_placement = comma_placement + 4 else: for i in range(0, len(number) number = number[0:len(number) - comma_placement + 1] + break print(
import random number = str(random.randint(1, 10000000)) comma_placement = 4 print while True: if len(number) % 3 == 0: for i in range(0, len(number) number = number[0:len(number) - comma_placement + 1] + comma_placement = comma_placement + 4 else: for i in range(0, len(number) number = number[0:len(number) - comma_placement + 1] + break print
from __future__ import with_statement from contextlib import contextmanager import re,time re_first_num = re.compile(r"\d") def intcomma_noregex(value): end_offset, start_digit, period = len(value),re_first_num.search(value).start(),value.rfind( if period == -1: period=end_offset segments,_from_index,leftover = [],0,(period-start_digit) % 3 for _index in xrange(start_digit+3 if not leftover else start_digit+leftover,period,3): segments.append(value[_from_index:_index]) _from_index=_index if not segments: return value segments.append(value[_from_index:]) return def intcomma_noregex_reversed(value): end_offset, start_digit, period = len(value),re_first_num.search(value).start(),value.rfind( if period == -1: period=end_offset _from_index,segments = end_offset,[] for _index in xrange(period-3,start_digit,-3): segments.append(value[_index:_from_index]) _from_index=_index if not segments: return value segments.append(value[:_from_index]) return re_3digits = re.compile(r def intcomma(value): segments,last_endoffset=[],len(value) while last_endoffset > 3: digit_group = re_3digits.search(value,0,last_endoffset) if not digit_group: break segments.append(value[digit_group.start():last_endoffset]) last_endoffset=digit_group.start() if not segments: return value if last_endoffset: segments.append(value[:last_endoffset]) return def intcomma_recurs(value): """ Converts an integer to a string containing commas every three digits. For example, 3000 becomes """ new = re.sub("^(-?\d+)(\d{3})", if value == new: return new else: return intcomma(new) @contextmanager def timed(save_time_func): begin=time.time() try: yield finally: save_time_func(time.time()-begin) def testset_xsimple(func): func( def testset_simple(func): func( def testset_onecomma(func): func( def testset_complex(func): func( def testset_average(func): func( func( func( if __name__ == print for test_data in ( for func in (intcomma,intcomma_noregex,intcomma_noregex_reversed,intcomma_recurs): print func.__name__,test_data,func(test_data) times=[] def overhead(x): pass for test_run in xrange(1,4): for func in (intcomma,intcomma_noregex,intcomma_noregex_reversed,intcomma_recurs,overhead): for testset in (testset_xsimple,testset_simple,testset_onecomma,testset_complex,testset_average): for x in xrange(1000): testset(func) with timed(lambda x:times.append(((test_run,func,testset),x))): for x in xrange(50000): testset(func) for (test_run,func,testset),_delta in times: print test_run,func.__name__,testset.__name__,_delta
intcomma 5 5 intcomma_noregex 5 5 intcomma_noregex_reversed 5 5 intcomma_recurs 5 5 intcomma 567 567 intcomma_noregex 567 567 intcomma_noregex_reversed 567 567 intcomma_recurs 567 567 intcomma 1234 1,234 intcomma_noregex 1234 1,234 intcomma_noregex_reversed 1234 1,234 intcomma_recurs 1234 1,234 intcomma 1234.56 1,234.56 intcomma_noregex 1234.56 1,234.56 intcomma_noregex_reversed 1234.56 1,234.56 intcomma_recurs 1234.56 1,234.56 intcomma -253892.045 -253,892.045 intcomma_noregex -253892.045 -253,892.045 intcomma_noregex_reversed -253892.045 -253,892.045 intcomma_recurs -253892.045 -253,892.045 1 intcomma testset_xsimple 0.0410001277924 1 intcomma testset_simple 0.0369999408722 1 intcomma testset_onecomma 0.213000059128 1 intcomma testset_complex 0.296000003815 1 intcomma testset_average 0.503000020981 1 intcomma_noregex testset_xsimple 0.134000062943 1 intcomma_noregex testset_simple 0.134999990463 1 intcomma_noregex testset_onecomma 0.190999984741 1 intcomma_noregex testset_complex 0.209000110626 1 intcomma_noregex testset_average 0.513000011444 1 intcomma_noregex_reversed testset_xsimple 0.124000072479 1 intcomma_noregex_reversed testset_simple 0.12700009346 1 intcomma_noregex_reversed testset_onecomma 0.230000019073 1 intcomma_noregex_reversed testset_complex 0.236999988556 1 intcomma_noregex_reversed testset_average 0.56299996376 1 intcomma_recurs testset_xsimple 0.348000049591 1 intcomma_recurs testset_simple 0.34600019455 1 intcomma_recurs testset_onecomma 0.625 1 intcomma_recurs testset_complex 0.773999929428 1 intcomma_recurs testset_average 1.6890001297 1 overhead testset_xsimple 0.0179998874664 1 overhead testset_simple 0.0190000534058 1 overhead testset_onecomma 0.0190000534058 1 overhead testset_complex 0.0190000534058 1 overhead testset_average 0.0309998989105 2 intcomma testset_xsimple 0.0360000133514 2 intcomma testset_simple 0.0369999408722 2 intcomma testset_onecomma 0.207999944687 2 intcomma testset_complex 0.302000045776 2 intcomma testset_average 0.523000001907 2 intcomma_noregex testset_xsimple 0.139999866486 2 intcomma_noregex testset_simple 0.141000032425 2 intcomma_noregex testset_onecomma 0.203999996185 2 intcomma_noregex testset_complex 0.200999975204 2 intcomma_noregex testset_average 0.523000001907 2 intcomma_noregex_reversed testset_xsimple 0.130000114441 2 intcomma_noregex_reversed testset_simple 0.129999876022 2 intcomma_noregex_reversed testset_onecomma 0.236000061035 2 intcomma_noregex_reversed testset_complex 0.241999864578 2 intcomma_noregex_reversed testset_average 0.582999944687 2 intcomma_recurs testset_xsimple 0.351000070572 2 intcomma_recurs testset_simple 0.352999925613 2 intcomma_recurs testset_onecomma 0.648999929428 2 intcomma_recurs testset_complex 0.808000087738 2 intcomma_recurs testset_average 1.81900000572 2 overhead testset_xsimple 0.0189998149872 2 overhead testset_simple 0.0189998149872 2 overhead testset_onecomma 0.0190000534058 2 overhead testset_complex 0.0179998874664 2 overhead testset_average 0.0299999713898 3 intcomma testset_xsimple 0.0360000133514 3 intcomma testset_simple 0.0360000133514 3 intcomma testset_onecomma 0.210000038147 3 intcomma testset_complex 0.305999994278 3 intcomma testset_average 0.493000030518 3 intcomma_noregex testset_xsimple 0.131999969482 3 intcomma_noregex testset_simple 0.136000156403 3 intcomma_noregex testset_onecomma 0.192999839783 3 intcomma_noregex testset_complex 0.202000141144 3 intcomma_noregex testset_average 0.509999990463 3 intcomma_noregex_reversed testset_xsimple 0.125999927521 3 intcomma_noregex_reversed testset_simple 0.126999855042 3 intcomma_noregex_reversed testset_onecomma 0.235999822617 3 intcomma_noregex_reversed testset_complex 0.243000030518 3 intcomma_noregex_reversed testset_average 0.56200003624 3 intcomma_recurs testset_xsimple 0.337000131607 3 intcomma_recurs testset_simple 0.342000007629 3 intcomma_recurs testset_onecomma 0.609999895096 3 intcomma_recurs testset_complex 0.75 3 intcomma_recurs testset_average 1.68300008774 3 overhead testset_xsimple 0.0189998149872 3 overhead testset_simple 0.018000125885 3 overhead testset_onecomma 0.018000125885 3 overhead testset_complex 0.0179998874664 3 overhead testset_average 0.0299999713898
>>> class number(long): def __init__(self, value): self = value def __repr__(self): s = str(self) l = [x for x in s if x in for x in reversed(range(len(s)-1)[::3]): l.insert(-x, l = return ( >>> number(-100000) -100,000 >>> number(-100) -100 >>> number(-12345) -12,345 >>> number(928374) 928,374 >>> 345
from random import randint voci = { "immobilizzazioni": randint(200000, 500000), "tfr": randint(10000, 25000), "ac": randint(150000, 200000), "fondo": randint(10500, 22350), "debiti": randint(150000, 250000), "ratei_attivi": randint(2000, 2500), "ratei_passivi": randint(1500, 2600), "crediti_v_soci": randint(10000, 30000) } testo_rnd2 = """Nell’azienda Hypermax S.p.a. di Bologna le immobilizzazioni valgono {immobilizzazioni:,} €, i debiti per TFR sono pari a {tfr:,} €, l’attivo circolante è di {ac:,} euro, il fondo rischi ed oneri ha un importo pari a {fondo:,} euro, i debiti sono {debiti:,} €, i ratei e risconti attivi sono pari a {ratei_attivi:,} euro, i ratei e risconti passivi sono pari a {ratei_passivi:,} euro. I crediti verso i soci sono pari a {crediti_v_soci:,} euro.""" print(testo_rnd2)
def ncomma(num): def _helper(num): numstr = for ii, digit in enumerate(reversed(numstr)): if ii and ii % 3 == 0 and digit.isdigit(): yield yield digit return
>>> for i in (0, 99, 999, 9999, 999999, 1000000, -1, -111, -1111, -111111, -1000000): ... print i, ncomma(i) ... 0 0 99 99 999 999 9999 9,999 999999 999,999 1000000 1,000,000 -1 -1 -111 -111 -1111 -1,111 -111111 -111,111 -1000000 -1,000,000
def format_money(f, delimiter= negative_fix = int(f < 0) s = if len(s) < 5 + frac_digits + negative_fix: return s l = list(s) l_fix = l[negative_fix:] p = len(l_fix) - frac_digits - 5 l_fix[p::-3] = [i + delimiter for i in l_fix[p::-3]] return
>>> a=[1,2,3] >>> a.remove(2) >>> a [1, 3] >>> a=[1,2,3] >>> del a[1] >>> a [1, 3] >>> a= [1,2,3] >>> a.pop(1) 2 >>> a [1, 3] >>>
>>> a = [0, 2, 3, 2] >>> a.remove(2) >>> a [0, 3, 2]
>>> a = [4, 5, 6] >>> a.remove(7) Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: list.remove(x): x not in list >>> del a[7] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: list assignment index out of range >>> a.pop(7) Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: pop index out of range
>>> lst = [3, 2, 2, 1] >>> del lst[10:] >>> lst [3, 2, 2, 1]
class Deque(object): def __init__(self): self.items=[] def addFront(self,item): return self.items.insert(0,item) def addRear(self,item): return self.items.append(item) def deleteFront(self): return self.items.pop(0) def deleteRear(self): return self.items.pop() def returnAll(self): return self.items[:]
def deleteFront(self): return self.items.pop(0) def deleteRear(self): return self.items.pop()
list_ez=[1,2,3,4,5,6,7,8] for i in list_ez: if i%2==0: list_ez.remove(i) print list_ez
set_ez=set_ez=set(range(10)) set_ez.remove(11) set_ez.discard(11)
>>> a = [0, 2, 3, 2, 1, 4, 6, 5, 7] >>> a.remove(2) >>> a [0, 3, 2, 1, 4, 6, 5, 7]
>>> x = [1, 0, 0, 0, 3, 4, 5] >>> x.remove(4) >>> x [1, 0, 0, 0, 3, 5] >>> del x[7] Traceback (most recent call last): File "<pyshell del x[7] IndexError: list assignment index out of range
>>> x = [1, 2, 3, 4] >>> del x[3] >>> x [1, 2, 3] >>> del x[4] Traceback (most recent call last): File "<pyshell del x[4] IndexError: list assignment index out of range
>>> x = [1, 2, 3] >>> x.pop(2) 3 >>> x [1, 2] >>> x.pop(4) Traceback (most recent call last): File "<pyshell x.pop(4) IndexError: pop index out of range
>>> isinstance(open, types.FunctionType) False >>> callable(open) True
In [1]: import types In [2]: types.FunctionType Out[2]: <type In [3]: def f(): pass ...: In [4]: isinstance(f, types.FunctionType) Out[4]: True In [5]: isinstance(lambda x : None, types.FunctionType) Out[5]: True
>>> from inspect import isfunction >>> def f(): pass >>> isfunction(f) True >>> isfunction(lambda x: x) True
>>> class Spam(object): ... def __call__(self): ... return >>> can_o_spam = Spam() >>> can_o_spam() >>> callable(can_o_spam) True >>> hasattr(can_o_spam, True >>> import collections >>> isinstance(can_o_spam, collections.Callable) True
>>> del Spam.__call__ >>> can_o_spam.__call__ = lambda *args:
>>> can_o_spam() Traceback (most recent call last): ... TypeError:
>>> isinstance(can_o_spam, collections.Callable) True
import collections isinstance(obj, collections.Callable)
class A(object): def __call__(self): return def B(): return a = A() b = B print type(a), callable(a) print type(b), callable(b)
test_as_func = True try: b() except TypeError: test_as_func = False except: pass
import types isinstance(x, (types.FunctionType, types.BuiltinFunctionType, types.MethodType, types.BuiltinMethodType, types.UnboundMethodType))
try: x() except TypeError: print "was not callable"
>>> def x(): ... raise TypeError ... >>> hasattr(x, True >>> try: ... x() ... except TypeError: ... print "x was not callable" ... x was not callable
def isFunction1(f) : return type(f) == type(lambda x: x); def isFunction2(f) : return
>>> type(lambda x: x); <type >>> str(type(lambda x: x)); "<type
class A(object): def __init__(self): pass def __call__(self): print MyClass = A() def foo(): pass print hasattr(foo.__class__, print hasattr(A.__class__, print hasattr(foo, print hasattr(A,
import types def is_func(obj): return isinstance(obj, (types.FunctionType, types.LambdaType)) def f(x): return x assert is_func(f) assert is_func(lambda x: x)
def detect_function(obj): return hasattr(obj,"__call__") In [26]: detect_function(detect_function) Out[26]: True In [27]: callable(detect_function) Out[27]: True
In [46]: inspect.isfunction(detect_function) Out[46]: True In [47]: inspect.isfunction(hasattr) Out[47]: False In [48]: isinstance(detect_function, types.FunctionType) Out[48]: True In [49]: isinstance(getattr, types.FunctionType) Out[49]: False
In [50]: isinstance(getattr, types.BuiltinFunctionType) Out[50]: True In [51]: isinstance(detect_function, types.BuiltinFunctionType) Out[51]: False
class A(): def __call__(self, a,b): print(a,b) def func1(self, a, b): print("[classfunction]:", a, b) @classmethod def func2(cls, a,b): print("[classmethod]:", a, b) @staticmethod def func3(a,b): print("[staticmethod]:", a, b) def func(a,b): print("[function]", a,b)
builtins_func = open ordinary_func = func lambda_func = lambda a : func(a,4) partial_func = functools.partial(func, b=4) class_callable_instance = A() class_ordinary_func = A.func1 class_bound_method = A.func2 class_static_func = A.func3
xfuncs = [builtins_func, ordinary_func, lambda_func, partial_func, class_callable_instance, class_ordinary_func, class_bound_method, class_static_func] xtypes = [types.BuiltinFunctionType, types.FunctionType, types.MethodType, types.LambdaType, functools.partial]
res = [callable(xfunc) for xfunc in xfuncs] print("functors callable:") print(res)
res = [[isinstance(xfunc, xtype) for xtype in xtypes] for xfunc in xfuncs] print("functors for (row, xfunc) in zip(res, xfuncs): print(row, xfunc) """ functors [True, False, False, False, False] <built-in function open> [False, True, False, True, False] <function func at 0x7f1b5203e048> [False, True, False, True, False] <function <lambda> at 0x7f1b5081fd08> [False, False, False, False, True] functools.partial(<function func at 0x7f1b5203e048>, b=4) [False, False, False, False, False] <__main__.A object at 0x7f1b50870cc0> [False, True, False, True, False] <function A.func1 at 0x7f1b5081fb70> [False, False, True, False, False] <bound method A.func2 of <class [False, True, False, True, False] <function A.func3 at 0x7f1b5081fc80> """
def func(a,b): print("[function]", a,b) >>> callable(func) True >>> isinstance(func, types.FunctionType) True >>> isinstance(func, (types.BuiltinFunctionType, types.FunctionType, functools.partial)) True >>> >>> isinstance(func, (types.MethodType, functools.partial)) False
>>> import collections >>> Test = collections.namedtuple( >>> callable(Test) True >>> hasattr(Test, True
>>> import inspect >>> inspect.isfunction(Test) False >>> def t(): pass >>> inspect.isfunction(t) True
from pprint import pprint def print_callables_of(obj): li = [] for name in dir(obj): attr = getattr(obj, name) if hasattr(attr, li.append(name) pprint(li)
def myfunc(x): try: x() except TypeError: raise Exception("Not callable")
def a():pass type(a) str(type(a))=="<class b = lambda x:x*2 str(type(b))=="<class
>>> def foo(): ... print "foo" ... >>> class A: ... def bar( self ): ... print "bar" ... >>> a = A() >>> foo <function foo at 0x00A98D70> >>> a.bar <bound method A.bar of <__main__.A instance at 0x00A9BC88>> >>>
>>> def fooFighters( self ): ... print "fooFighters" ... >>> A.fooFighters = fooFighters >>> a2 = A() >>> a2.fooFighters <bound method A.fooFighters of <__main__.A instance at 0x00A9BEB8>> >>> a2.fooFighters() fooFighters
>>> def barFighters( self ): ... print "barFighters" ... >>> a.barFighters = barFighters >>> a.barFighters() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: barFighters() takes exactly 1 argument (0 given)
>>> a.barFighters <function barFighters at 0x00A98EF0>
>>> import types >>> a.barFighters = types.MethodType( barFighters, a ) >>> a.barFighters <bound method ?.barFighters of <__main__.A instance at 0x00A9BC88>> >>> a.barFighters() barFighters
>>> a2.barFighters() Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: A instance has no attribute
import types class A(object): pass def patch_me(target): def method(target,x): print "x=",x print "called from", target target.method = types.MethodType(method,target) a = A() print a patch_me(a) a.method(5) patch_me(A) A.method(6)
def sample_method(self, bar, baz): print(bar + baz)
foo.sample_method = types.MethodType(sample_method, foo, Foo)
def bind(instance, method): def binding_scope_fn(*args, **kwargs): return method(instance, *args, **kwargs) return binding_scope_fn
>>> foo.sample_method = bind(foo, sample_method) >>> foo.sample_method(1,2) 3
>>> from functools import partial >>> foo.sample_method = partial(sample_method, foo) >>> foo.sample_method(1,2) 3
>>> foo.sample_method = sample_method >>> foo.sample_method(1,2) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: sample_method() takes exactly 3 arguments (2 given)
In [5]: A.__dict__[ Out[5]: <function m at 0xa66b8b4>
In [11]: class MetaA(type): ....: def __getattribute__(self, attr_name): ....: print str(self), In [12]: class A(object): ....: __metaclass__ = MetaA In [23]: A.m <class <class
In [2]: A.m Out[2]: <unbound method A.m> In [59]: type(A.m) Out[59]: <type In [60]: type(b.m) Out[60]: <type In [61]: types.MethodType Out[61]: <type
from SomeOtherProduct.SomeModule import SomeClass def speak(self): return "ook ook eee eee eee!" SomeClass.speak = speak
>>> class A: ... def m(self): ... print >>> a = A() >>> a.m() im m, invoked with: <__main__.A instance at 0x973ec6c> >>> a.m <bound method A.m of <__main__.A instance at 0x973ec6c>> >>> >>> def foo(firstargument): ... print >>> foo <function foo at 0x978548c>
>>> a.foo = foo.__get__(a, A) >>> a.foo() im foo, invoked with: <__main__.A instance at 0x973ec6c> >>> a.foo <bound method A.foo of <__main__.A instance at 0x973ec6c>>
>>> instancemethod = type(A.m) >>> instancemethod <type >>> a.foo2 = instancemethod(foo, a, type(a)) >>> a.foo2() im foo, invoked with: <__main__.A instance at 0x973ec6c> >>> a.foo2 <bound method instance.foo of <__main__.A instance at 0x973ec6c>>
def run(self): print self._instanceString class A(object): def __init__(self): self._instanceString = "This is instance string" a = A() a.run = lambda: run(a) a.run()
>>> def printme(s): print repr(s) >>> class A: pass >>> setattr(A, >>> a = A() >>> a.printme() < __ main __ . A instance at 0xABCDEFG>
a.methodname = function () { console.log("Yay, a new method!") }
import types import inspect def listattr(c): for m in [(n, v) for n, v in inspect.getmembers(c, inspect.ismethod) if isinstance(v,types.MethodType)]: print m[0], m[1] def ADDMETHOD(c, method, name): c.__dict__[name] = types.MethodType(method, c) class C(): r = 10 def __init__(self): pass def addmethod(self, method, name): self.__dict__[name] = types.MethodType( method, self.__class__ ) def f0(self, x): print a = C() b = C() def f1(self, x): print def f2( self, x): print def f3( self, x): print def f4( self, x): print b.addmethod(f1, b.__dict__[ b.f3 = types.MethodType( f3, b) ADDMETHOD(b, f4, b.f0(0) b.f1(1) b.f2(2) b.f3(3) b.f4(4) k = 2 print b.r = k print b.f0(0) b.f1(1) b.f2(2) b.f3(3) b.f4(4) c = C() print listattr(a) print listattr(b) print listattr(c)
def y(self, x): pass d = C() for i in range(1,5): ADDMETHOD(d, y, print listattr(d)
class A: def bar( self ): print "bar1" def reloadCode(self, methodName): import types import ReloadCodeDemo as ReloadMod reload (ReloadMod) myM = getattr(ReloadMod.A,methodName) myTempFunc = types.FunctionType( myM.im_func.func_code, globals(), argdefs=myM.im_func.func_defaults ) myNewM = types.MethodType(myTempFunc,self,self.__class__) setattr(self,methodName,myNewM) if __name__ == a = A() a.bar() a.reloadCode( a.bar()
>>> class Test(object): ... def a(self): ... pass ... >>> def b(self): ... pass ... >>> Test.b = b >>> type(b) <type >>> type(Test.a) <type >>> type(Test.b) <type
import gorilla import guineapig @gorilla.patch(guineapig) def needle(): print("awesome")
def binder (function, instance): copy_of_function = type (function) (function.func_code, {}) copy_of_function.__bind_to__ = instance def bound_function (*args, **kwargs): return copy_of_function (copy_of_function.__bind_to__, *args, **kwargs) return bound_function class SupaClass (object): def __init__ (self): self.supaAttribute = 42 def new_method (self): print self.supaAttribute supaInstance = SupaClass () supaInstance.supMethod = binder (new_method, supaInstance) otherInstance = SupaClass () otherInstance.supaAttribute = 72 otherInstance.supMethod = binder (new_method, otherInstance) otherInstance.supMethod () supaInstance.supMethod ()
def addmethod(obj, name, func): klass = obj.__class__ subclass = type(klass.__name__, (klass,), {}) setattr(subclass, name, func) obj.__class__ = subclass
from types import MethodType def method(self): print setattr( targetObj, method.__name__, MethodType(method, targetObj, type(method)) )
if val != None: if not (val is None): if val is not None:
>>> def f(val): ... if val != None: ... return True ... return False ... >>> def g(val): ... if not (val is None): ... return True ... return False ... >>> def h(val): ... if val is not None: ... return True ... return False ... >>> import dis >>> dis.dis(f) 2 0 LOAD_FAST 0 (val) 3 LOAD_CONST 0 (None) 6 COMPARE_OP 3 (!=) 9 POP_JUMP_IF_FALSE 16 3 12 LOAD_GLOBAL 1 (True) 15 RETURN_VALUE 4 >> 16 LOAD_GLOBAL 2 (False) 19 RETURN_VALUE >>> dis.dis(g) 2 0 LOAD_FAST 0 (val) 3 LOAD_CONST 0 (None) 6 COMPARE_OP 9 (is not) 9 POP_JUMP_IF_FALSE 16 3 12 LOAD_GLOBAL 1 (True) 15 RETURN_VALUE 4 >> 16 LOAD_GLOBAL 2 (False) 19 RETURN_VALUE >>> dis.dis(h) 2 0 LOAD_FAST 0 (val) 3 LOAD_CONST 0 (None) 6 COMPARE_OP 9 (is not) 9 POP_JUMP_IF_FALSE 16 3 12 LOAD_GLOBAL 1 (True) 15 RETURN_VALUE 4 >> 16 LOAD_GLOBAL 2 (False) 19 RETURN_VALUE
def str2bool(v): return v.lower() in ("yes", "true", "t", "1")
>>> import json >>> json.loads("false".lower()) False >>> json.loads("True".lower()) True
def to_bool(value): valid = { } if isinstance(value, bool): return value if not isinstance(value, basestring): raise ValueError( lower_value = value.lower() if lower_value in valid: return valid[lower_value] else: raise ValueError( assert to_bool( assert to_bool( assert to_bool( assert to_bool( assert to_bool( assert to_bool( assert to_bool( assert to_bool(True), assert to_bool(u assert to_bool( assert to_bool( assert to_bool( assert to_bool( assert to_bool( assert to_bool( assert to_bool( assert to_bool(False) is False, assert to_bool(u try: to_bool( to_bool(12) to_bool([]) to_bool( to_bool( except ValueError, e: pass
def to_bool(value): """ Converts Possible True values: 1, True, "1", "TRue", "yes", "y", "t" Possible False values: 0, False, None, [], {}, "", "0", "faLse", "no", "n", "f", 0.0, ... """ if str(value).lower() in ("yes", "y", "true", "t", "1"): return True if str(value).lower() in ("no", "n", "false", "f", "0", "0.0", "", "none", "[]", "{}"): return False raise Exception(
>>> to_bool(True) True >>> to_bool("tRUe") True >>> to_bool("1") True >>> to_bool(1) True >>> to_bool(2) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 9, in to_bool Exception: Invalid value for boolean conversion: 2 >>> to_bool([]) False >>> to_bool({}) False >>> to_bool(None) False >>> to_bool("Wasssaaaaa") Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 9, in to_bool Exception: Invalid value for boolean conversion: Wasssaaaaa >>>
a= if a is True: print else: print "a isn b = eval(a) if b is True: print else: print "b isn
def to_bool(bool_str): if isinstance(bool_str, basestring) and bool_str: if bool_str.lower() in [ elif bool_str.lower() in [ raise ValueError("%s is no recognized as a boolean value" % bool_str)
>>> [to_bool(v) for v in [ [True, True, True, False, False, False] >>> to_bool("") Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 8, in to_bool ValueError:
import yaml parsed = yaml.load("true") print bool(parsed)
def toBoolean( val ): """ Get the boolean value of the provided input. If the value is a boolean return the value. Otherwise check to see if the value is in ["false", "f", "no", "n", "none", "0", "[]", "{}", "" ] and returns True if value is not in the list """ if val is True or val is False: return val falseItems = ["false", "f", "no", "n", "none", "0", "[]", "{}", "" ] return not str( val ).strip().lower() in falseItems
from collections import defaultdict bool_mapping = defaultdict(bool) for val in [ bool_mapping[val] = True print(bool_mapping[ print(bool_mapping[
def to_bool(value): """ Converts Case is ignored for strings. These string values are handled: True: False: "", "0", "faLse", "no", "n", "f" Non-string values are passed to bool. """ if type(value) == type( if value.lower() in ("yes", "y", "true", "t", "1"): return True if value.lower() in ("no", "n", "false", "f", "0", ""): return False raise Exception( return bool(value)
test_cases = [ ( ( ( ( ( ( ( ( ( ( ( (1, True), (0, False), (1.0, True), (0.0, False), ([], False), ({}, False), ((), False), ([1], True), ({1:2}, True), ((1,), True), (None, False), (object(), True), ]
def boolify(val): if (isinstance(val, basestring) and bool(val)): return not val in ( else: return bool(val)
def str2bool(value): return {"True": True, "true": True}.get(value, False)
from ansible.module_utils.parsing.convert_bool import boolean boolean( boolean( boolean(
>>> import Tkinter >>> tk = Tkinter.Tk() >>> var = Tkinter.BooleanVar(tk) >>> var.set("false") >>> var.get() False >>> var.set("1") >>> var.get() True >>> var.set("[exec >>> var.get() Traceback (most recent call last): File "<stdin>", line 1, in <module> File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 324, in get return self._tk.getboolean(self._tk.globalgetvar(self._name)) _tkinter.TclError: 0expected boolean value but got "[exec >>>
def str2bool(str): if isinstance(str, basestring) and str.lower() in [ return False else: return bool(str)
def as_bool(val): if val: try: if not int(val): val=False except: pass try: if val.lower()=="false": val=False except: pass return bool(val)
def str_to_bool(input, default): """ | Default | not_default_str | input | result | T | "false" | "true" | T | T | "false" | "false" | F | F | "true" | "true" | T | F | "true" | "false" | F """ if default: not_default_str = "false" else: not_default_str = "true" if input.lower() == not_default_str: return not default else: return default
true_false = "trUE" type(true_false) true_false = eval(true_false.capitalize()) type(true_false)
import os for dirname, dirnames, filenames in os.walk( for subdirname in dirnames: print(os.path.join(dirname, subdirname)) for filename in filenames: print(os.path.join(dirname, filename)) if dirnames.remove(
import os def listdir_fullpath(d): return [os.path.join(d, f) for f in os.listdir(d)]
import os for filename in os.listdir("C:\\temp"): print filename
import os for top, dirs, files in os.walk( for nm in files: print os.path.join(top, nm)
import os def scan_dir(dir): for name in os.listdir(dir): path = os.path.join(dir, name) if os.path.isfile(path): print path else: scan_dir(path)
import os import sys def ls(dir, hidden=False, relative=True): nodes = [] for nm in os.listdir(dir): if not hidden and nm.startswith( continue if not relative: nm = os.path.join(dir, nm) nodes.append(nm) nodes.sort() return nodes def find(root, files=True, dirs=False, hidden=False, relative=True, topdown=True): root = os.path.join(root, for parent, ldirs, lfiles in os.walk(root, topdown=topdown): if relative: parent = parent[len(root):] if dirs and parent: yield os.path.join(parent, if not hidden: lfiles = [nm for nm in lfiles if not nm.startswith( ldirs[:] = [nm for nm in ldirs if not nm.startswith( if files: lfiles.sort() for nm in lfiles: nm = os.path.join(parent, nm) yield nm def test(root): print "* directory listing, with hidden files:" print ls(root, hidden=True) print print "* recursive listing, with dirs, but no hidden files:" for f in find(root, dirs=True): print f print if __name__ == "__main__": test(*sys.argv[1:])
import os def scan_dir(path): print map(os.path.abspath, os.listdir(pwd))
import os def scan_dir(path): print(list(map(os.path.abspath, os.listdir(pwd))))
import os def scan_dir(path): print([os.path.abspath(f) for f in os.listdir(path)])
import os dir = filenames = [os.path.join(os.path.dirname(os.path.abspath(__file__)),dir,i) for i in os.listdir(dir)]
import os _CURRENT_DIR = def rec_tree_traverse(curr_dir, indent): "recurcive function to traverse the directory" try : dfList = [os.path.join(curr_dir, f_or_d) for f_or_d in os.listdir(curr_dir)] except: print "wrong path name/directory name" return for file_or_dir in dfList: if os.path.isdir(file_or_dir): print indent, file_or_dir,"\\" rec_tree_traverse(file_or_dir, indent*2) if os.path.isfile(file_or_dir): print indent, file_or_dir def main(): base_dir = _CURRENT_DIR rec_tree_traverse(base_dir," ") raw_input("enter any key to exit....") if __name__ == main()
path = for dirname, dirnames, filenames in os.walk(path): for filename in filenames: fname_path = os.path.join(dirname, filename) fext = os.path.splitext(fname_path)[1] if fext == print fname_path else: continue
import os, sys path = "My Documents" dirs = os.listdir( path ) for file in dirs: print (file)
import re import os [a for a in os.listdir(".") if re.search("^.*\.py$",a)]
def print_directory_contents(sPath): import os for sChild in os.listdir(sPath): sChildPath = os.path.join(sPath,sChild) if os.path.isdir(sChildPath): print_directory_contents(sChildPath) else: print(sChildPath)
import subprocess print(subprocess.check_output(["ls", "/"]).decode("utf8"))
with os.scandir(path) as it: for entry in it: if not entry.name.startswith( print(entry.name)
In [16]: Path( Out[16]: <generator object Path.iterdir at 0x110853fc0>
In [10]: p = Path( In [11]: core = p / In [13]: [x for x in core.iterdir() if x.is_file()] Out[13]: [PosixPath( PosixPath( PosixPath(
str_list = filter(None, str_list) str_list = filter(bool, str_list) str_list = filter(len, str_list) str_list = filter(lambda item: item, str_list)
>>> timeit( 2.4797441959381104 >>> timeit( 2.4788150787353516 >>> timeit( 5.2126238346099854 >>> timeit( 13.354584932327271 >>> timeit( 17.427681922912598
strings = ["first", "", "second"] [x for x in strings if x]
>>> lstr = [ >>> lstr [ >>> [ >>> filter(None, lstr) [
>>> from timeit import timeit >>> timeit( 4.226747989654541 >>> timeit( 3.0278358459472656
str_list = [None, [x for x in str_list if x != [None, 0, "Hi", "Hello"]
strings = ["first", "", "second ", " "] [x.strip() for x in strings if x.strip()]
l = ["1", "", "3", ""] while True: try: l.remove("") except ValueError: break
for item in listtext: if item: newlist.append(str(item))
>>> lstr = [ >>> lstr [ >>> [ >>> filter(str.strip, lstr) [
>>> from timeit import timeit >>> timeit( 3.356455087661743 >>> timeit( 5.276503801345825
>>> lstr = [ >>> lstr [ >>> [ >>> filter(str.strip, lstr) [
space_clean_list = [x for x in space_to_empty if x]
slist = map(lambda s: s and s.strip(), slist) slist = filter(None, slist)
def f1(slist): slist = [s and s.strip() for s in slist] return list(filter(None, slist)) def f2(slist): slist = [s and s.strip() for s in slist] return [s for s in slist if s] def f3(slist): slist = map(lambda s: s and s.strip(), slist) return list(filter(None, slist)) def f4(slist): slist = map(lambda s: s and s.strip(), slist) return [s for s in slist if s] %timeit f1(words) 10000 loops, best of 3: 106 µs per loop %timeit f2(words) 10000 loops, best of 3: 126 µs per loop %timeit f3(words) 10000 loops, best of 3: 165 µs per loop %timeit f4(words) 10000 loops, best of 3: 169 µs per loop
str_list = [ for item in str_list: if len(item) < 1: str_list.remove(item)
import os os.path.dirname(os.path.abspath(__file__))
from pathlib import Path mypath = Path().absolute() print(mypath)
from IPython.terminal.embed import InteractiveShellEmbed ip_shell = InteractiveShellEmbed() present_working_directory = ip_shell.magic("%pwd")
import os def getLocalFolder(): path=str(os.path.dirname(os.path.abspath(__file__))).split( return path[len(path)-1]
In [1]: import numpy as np In [2]: import pandas as pd In [3]: df = pd.DataFrame(np.arange(12).reshape(4,3)) In [4]: df Out[4]: 0 1 2 0 0 1 2 1 3 4 5 2 6 7 8 3 9 10 11 In [5]: df.shape Out[5]: (4, 3) In [6]: timeit df.shape 2.77 µs ± 644 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) In [7]: timeit df[0].count() 348 µs ± 1.31 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) In [8]: len(df.index) Out[8]: 4 In [9]: timeit len(df.index) 990 ns ± 4.97 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
In [7]: timeit len(df.index) 1000000 loops, best of 3: 248 ns per loop In [8]: timeit len(df) 1000000 loops, best of 3: 573 ns per loop
total_rows=len(df.axes[0]) total_cols=len(df.axes[1])
df.shape?? Type: property String form: <property object at 0x1127b33c0> Source: @property def shape(self): return len(self.index), len(self.columns)
df.__len__?? Signature: df.__len__() Source: def __len__(self): return len(self.index) File: ~/miniconda2/lib/python2.7/site-packages/pandas/core/frame.py Type: instancemethod
row_count = ( pd.DataFrame(np.random.rand(3,4)) .reset_index() .pipe(len) )
>>> 9223372036854775807 9223372036854775807 >>> 9223372036854775808 9223372036854775808L
>>> 10**100 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000L
>>> import pandas as pd >>> import numpy as np >>> df = pd.DataFrame(columns=[ >>> for i in range(5): >>> df.loc[i] = [np.random.randint(-1,1) for n in range(3)] >>> >>> print(df) lib qty1 qty2 0 0 0 -1 1 -1 -1 1 2 1 -1 1 3 0 0 0 4 1 -1 -1 [5 rows x 3 columns]
rows_list = [] for row in input_rows: dict1 = {} dict1.update(blah..) rows_list.append(dict1) df = pd.DataFrame(rows_list)
import pandas as pd import numpy as np numberOfRows = 5 df = pd.DataFrame(index=np.arange(0, numberOfRows), columns=( for x in np.arange(0, numberOfRows): df.loc[x] = [np.random.randint(-1,1) for n in range(3)] In[23]: df Out[23]: lib qty1 qty2 0 -1 -1 -1 1 0 0 0 2 -1 0 -1 3 0 -1 0 4 -1 0 0
In[30]: %timeit tryThis() In[31]: %timeit tryOther() 1000 loops, best of 3: 1.23 ms per loop 100 loops, best of 3: 2.31 ms per loop
In [1]: se = pd.Series([1,2,3]) In [2]: se Out[2]: 0 1 1 2 2 3 dtype: int64 In [3]: se[5] = 5. In [4]: se Out[4]: 0 1.0 1 2.0 2 3.0 5 5.0 dtype: float64
In [1]: dfi = pd.DataFrame(np.arange(6).reshape(3,2), .....: columns=[ .....: In [2]: dfi Out[2]: A B 0 0 1 1 2 3 2 4 5 In [3]: dfi.loc[:, In [4]: dfi Out[4]: A B C 0 0 1 0 1 2 3 2 2 4 5 4 In [5]: dfi.loc[3] = 5 In [6]: dfi Out[6]: A B C 0 0 1 0 1 2 3 2 2 4 5 4 3 5 5 5
mycolumns = [ df = pd.DataFrame(columns=mycolumns) rows = [[1,2],[3,4],[5,6]] for row in rows: df.loc[len(df)] = row
>>> f = pandas.DataFrame(data = { >>> f Animal Color 0 cow blue 1 horse red >>> f.append({ Animal Color 0 cow blue 1 horse red 2 mouse black
res = pd.DataFrame(columns=( res = res.append([{ print(res.head()) lib qty1 qty2 0 NaN 10.0 NaN
Adding 1000 rows 5000 rows 10000 rows .append 1.04 4.84 9.56 .loc 1.16 5.59 11.50 dict 0.23 0.26 0.34
import pandas import numpy import time numOfRows = 10000 startTime = time.perf_counter() df1 = pandas.DataFrame(numpy.random.randint(100, size=(5,5)), columns=[ for i in range( 1,numOfRows): df1 = df1.append( dict( (a,numpy.random.randint(100)) for a in [ print( startTime = time.perf_counter() df2 = pandas.DataFrame(numpy.random.randint(100, size=(5,5)), columns=[ for i in range( 1,numOfRows): df2.loc[df2.index.max()+1] = numpy.random.randint(100, size=(1,5))[0] print( startTime = time.perf_counter() row_list = [] for i in range (0,5): row_list.append(dict( (a,numpy.random.randint(100)) for a in [ for i in range( 1,numOfRows): dict1 = dict( (a,numpy.random.randint(100)) for a in [ row_list.append(dict1) df3 = pandas.DataFrame(row_list, columns=[ print(
import pandas as pd BaseData = pd.DataFrame({ BaseData columns = [ rows_list=[] for name, group in BaseData.groupby( RecordtoAdd={} RecordtoAdd.update({ RecordtoAdd.update({ RecordtoAdd.update({ rows_list.append(RecordtoAdd) AnalysedData = pd.DataFrame(rows_list) print(
import pandas as pd rows = [] columns = [ for i in range(6): row = [i, i*2, i*i] rows.append(row) df = pd.DataFrame(rows, columns=columns)
new_record = pd.DataFrame([[0, old_data_frame = pd.concat([old_data_frame,new_record])
>>> df A B C one 1 2 3 >>> df.loc["two"] = [4,5,6] >>> df A B C one 1 2 3 two 4 5 6
def add_row(df, row): df.loc[-1] = row df.index = df.index + 1 return df.sort_index() add_row(df, [1,2,3])
def add_row(df, row): colnames = list(df.columns) ncol = len(colnames) assert ncol == len(row), "Length of row must be the same as width of DataFrame: %s" % row return df.append(pd.DataFrame([row], columns=colnames))
import pandas as pd def add_row(self, row): self.loc[len(self.index)] = row pd.DataFrame.add_row = add_row
import pandas as pd res = pd.DataFrame(columns=( for i in range(5): res_list = list(map(int, input().split())) res = res.append(pd.Series(res_list,index=[
import pandas as pd t1=pd.DataFrame() for i in range(len(the number of rows)): t1[i]=list(rows) t1=t1.transpose() t1.columns=list(columns)
df = pd.DataFrame(columns=[ df.loc[0 if math.isnan(df.index.max()) else df.index.max() + 1] = [x for x in range(7)]
import numpy as np import pandas as pd df = pd.DataFrame(np.random.rand(10, 5))
In [6]: df Out[6]: 0 1 2 3 4 mean 0 0.445598 0.173835 0.343415 0.682252 0.582616 0.445543 1 0.881592 0.696942 0.702232 0.696724 0.373551 0.670208 2 0.662527 0.955193 0.131016 0.609548 0.804694 0.632596 3 0.260919 0.783467 0.593433 0.033426 0.512019 0.436653 4 0.131842 0.799367 0.182828 0.683330 0.019485 0.363371 5 0.498784 0.873495 0.383811 0.699289 0.480447 0.587165 6 0.388771 0.395757 0.745237 0.628406 0.784473 0.588529 7 0.147986 0.459451 0.310961 0.706435 0.100914 0.345149 8 0.394947 0.863494 0.585030 0.565944 0.356561 0.553195 9 0.689260 0.865243 0.136481 0.386582 0.730399 0.561593 In [7]: cols = df.columns.tolist() In [8]: cols Out[8]: [0L, 1L, 2L, 3L, 4L,
In [12]: cols = cols[-1:] + cols[:-1] In [13]: cols Out[13]: [
In [16]: df = df[cols] In [17]: df Out[17]: mean 0 1 2 3 4 0 0.445543 0.445598 0.173835 0.343415 0.682252 0.582616 1 0.670208 0.881592 0.696942 0.702232 0.696724 0.373551 2 0.632596 0.662527 0.955193 0.131016 0.609548 0.804694 3 0.436653 0.260919 0.783467 0.593433 0.033426 0.512019 4 0.363371 0.131842 0.799367 0.182828 0.683330 0.019485 5 0.587165 0.498784 0.873495 0.383811 0.699289 0.480447 6 0.588529 0.388771 0.395757 0.745237 0.628406 0.784473 7 0.345149 0.147986 0.459451 0.310961 0.706435 0.100914 8 0.553195 0.394947 0.863494 0.585030 0.565944 0.356561 9 0.561593 0.689260 0.865243 0.136481 0.386582 0.730399
In [39]: df Out[39]: 0 1 2 3 4 mean 0 0.172742 0.915661 0.043387 0.712833 0.190717 1 1 0.128186 0.424771 0.590779 0.771080 0.617472 1 2 0.125709 0.085894 0.989798 0.829491 0.155563 1 3 0.742578 0.104061 0.299708 0.616751 0.951802 1 4 0.721118 0.528156 0.421360 0.105886 0.322311 1 5 0.900878 0.082047 0.224656 0.195162 0.736652 1 6 0.897832 0.558108 0.318016 0.586563 0.507564 1 7 0.027178 0.375183 0.930248 0.921786 0.337060 1 8 0.763028 0.182905 0.931756 0.110675 0.423398 1 9 0.848996 0.310562 0.140873 0.304561 0.417808 1 In [40]: df = df[[
In [41]: df Out[41]: mean 4 3 2 1 0 1 0.190717 0.712833 0.043387 0.915661 1 1 0.617472 0.771080 0.590779 0.424771 2 1 0.155563 0.829491 0.989798 0.085894 3 1 0.951802 0.616751 0.299708 0.104061 4 1 0.322311 0.105886 0.421360 0.528156 5 1 0.736652 0.195162 0.224656 0.082047 6 1 0.507564 0.586563 0.318016 0.558108 7 1 0.337060 0.921786 0.930248 0.375183 8 1 0.423398 0.110675 0.931756 0.182905 9 1 0.417808 0.304561 0.140873 0.310562
df = df.reindex_axis(sorted(df.columns), axis=1) df = df.reindex_axis([
df = df.reindex(columns=sorted(df.columns)) df = df.reindex(columns=([
cols = [df.columns[-1]] + [col for col in df if col != df.columns[-1]] df = df[cols]
inserted_cols = [ cols = ([col for col in inserted_cols if col in df] + [col for col in df if col not in inserted cols]) df = df[cols]
def order(frame,var): if type(var) is str: var = [var] varlist =[w for w in frame.columns if w not in var] frame = frame[var+varlist] return frame
frame = order(frame,[v for v in frame.columns if "VAR" in v])
new_order = [3,2,1,4,5,0] df = df[df.columns[new_order]] print(df) a c b mean d e 0 0.637589 0.634264 0.733961 0.617316 0.534911 0.545856 1 0.854449 0.830046 0.883416 0.678389 0.183003 0.641032 2 0.332996 0.195891 0.879472 0.545261 0.447813 0.870135 3 0.902704 0.843252 0.348227 0.677614 0.635780 0.658107 4 0.422357 0.529151 0.619282 0.412559 0.405749 0.086255 5 0.251454 0.940245 0.068633 0.554269 0.691631 0.819380 6 0.423781 0.179961 0.643971 0.361245 0.105050 0.453460 7 0.680696 0.487651 0.255453 0.419046 0.330417 0.341014 8 0.276729 0.473765 0.981271 0.690007 0.817877 0.900394 9 0.964470 0.248088 0.609391 0.463661 0.128077 0.368279
new_order = [-1,0,1,2,3,4] df = df[df.columns[new_order]] print(df) mean a b c d e 0 0.595177 0.329206 0.713246 0.712898 0.572263 0.648273 1 0.638860 0.452519 0.598171 0.797982 0.858137 0.487490 2 0.287636 0.100442 0.244445 0.288450 0.285795 0.519049 3 0.653974 0.863342 0.460811 0.782644 0.827890 0.335183 4 0.285233 0.004613 0.485135 0.014066 0.489957 0.432394 5 0.430761 0.630070 0.328865 0.528100 0.031827 0.634943 6 0.444338 0.102679 0.808613 0.389616 0.440022 0.480759 7 0.536163 0.063105 0.420832 0.959125 0.643879 0.593874 8 0.556107 0.716114 0.180603 0.668684 0.262900 0.952237 9 0.416280 0.816816 0.064956 0.178113 0.377693 0.643820
cols = df.columns.tolist() cols.insert(0, cols.pop(-1)) cols >>>[ df = df[cols]
def change_column_order(df, col_name, index): cols = df.columns.tolist() cols.remove(col_name) cols.insert(index, col_name) return df[cols]
import pandas as pd df = pd.DataFrame({"A": [1,2,3], "B": [2,4,8], "C": [5,5,5]}) cols = df.columns.tolist() column_to_move = "C" new_position = 1 cols.insert(new_position, cols.pop(cols.index(column_to_move))) df = df[cols]
cols = list(set(df.columns.tolist()) - set([ cols.insert(0, df = df[cols]
my_column = df.pop( df.insert(3, my_column.name, my_column)
def mean_first(df): ncols = df.shape[1] index = list(range(ncols)) index.insert(0,ncols) return(df.assign(mean=df.mean(1)).iloc[:,index])
meanDf = pd.DataFrame(df.pop( meanDf.join(df) df.join(meanDf)
from boltons.setutils import IndexedSet cols = list(IndexedSet(df.columns.tolist()) - set([ cols[0:0] =[ df = df[cols]
f.seek(pos [, (0|1|2)]) pos .. position of the r/w pointer [] .. optionally () .. one of -> 0 .. absolute position 1 .. relative position to current 2 .. relative position from end
>>> import os >>> if os.path.exists("myfile.dat"): ... f = file("myfile.dat", "r+") ... else: ... f = file("myfile.dat", "w")
import os writepath = mode = with open(writepath, mode) as f: f.write(
file_path = try: fp = open(file_path) except IOError: fp = open(file_path,
>>> open( Traceback (most recent call last): File "<pyshell open( ValueError: must have exactly one of read/write/append mode
from pathlib import Path filename = Path( filename.touch(exist_ok=True) file = open(filename)
import os f_loc = r"C:\Users\Russell\Desktop\ip_addr.txt" if not os.path.exists(f_loc): open(f_loc, with open(f_loc) as f:
w write mode r read mode a append mode w+ create file if it doesn r+ create file if it doesn a+ create file if it doesn
import os, platform os.chdir( try : file = open("Learn Python.txt","a") print( except: print( file.write( fhead = open( for line in fhead: words = line.split() print(words)
>>> with open( ... f.write( ... >>> with open( ... f.write( ... Traceback (most recent call last): File "<stdin>", line 1, in <module> FileExistsError: [Errno 17] File exists: >>>
if ( cond1 == cond3 == ): do_something if (cond1 == cond3 == do_something
if cond1 == cond2 == cond3 == cond4 == do_something
if ( cond1 == val1 and cond2 == val2 and cond3 == val3 ): do_stuff()
if ( cond1 == val1 or ( cond2_1 == val2_1 and cond2_2 >= val2_2 and cond2_3 != bad2_3 ) ): do_more_stuff()
allCondsAreOK = (cond1 == cond3 == if allCondsAreOK: do_something
def is_action__required(...): return (cond1 == and cond3 ==
if ( expr1 and (expr2 or expr3) and hasattr(thingy1, or status=="HappyTimes" ): do_stuff() else: do_other_stuff()
if (this_is_one_thing and that_is_another_thing): do_something() if (this_is_one_thing and that_is_another_thing): do_something() if (this_is_one_thing and that_is_another_thing): do_something()
condition = [cond1 == if all(condition): do_something
def c1(): print " Executed c1" return False def c2(): print " Executed c2" return False print "simple and (aborts early!)" if c1() and c2(): pass print print "all (executes all :( )" if all((c1(),c2())): pass print
if (cond1 == "val1" and cond22 == "val2" and cond333 == "val3" and cond4444 == "val4"): do_something
if (cond1 == "val1" and cond22 == "val2" and cond333 == "val3" and cond4444 == "val4") { do_something }
conditions_met = ( cond1 == and cond2 == and cond3 == and cond4 == ) if conditions_met: do_something
if not user.isAdmin() and user.isTeacher() and not user.isStudent(): doSomething()
displayTeacherPanel = not user.isAdmin() and user.isTeacher() and not user.isStudent() if displayTeacherPanel: showTeacherPanel()
if displayTeacherPanel or user.canSeeSpecialPanel(): showSpecialPanel()
my_list = [ ] if all( print("Hello World!") if all( for item in my_list ): print("Hello World!")
class Klass(object): def __init__(self, some_vars): def __nonzero__(self): return (self.cond1 == self.cond3 == foo = Klass() if foo: print "foo is true!" else: print "foo is false!"
class Klass(object): def __init__(self): def __eq__(self): return (self.cond1 == self.cond3 == x = Klass(some_values) y = Klass(some_other_values) if x == y: print else: print
if bool(condition1 and condition2 and ... conditionN): foo() bar()
if (((foo and bar and frob and ninja_bear))): do_stuff()
if foo is not None: if (cond1 == cond3 == do_something
conditions = [1, 2, 3, 4] values = [1, 2, 3, 4] if all([c==v for c, v in zip(conditions, values)]):
if (condition1==value1) and (condition2==value2) and \ (condition3==value3) and (condition4==value4):
proceed = True for c, v in zip(conditions, values): proceed &= c==v if proceed:
if cond1 == cond2 == cond3 == cond4 == do_something
if cond1 == and cond2 == and cond3 == and cond4 == do_something
cond_list = [ if all([eval(i) for i in cond_list]): do something
import sys numberOfArgument =len(sys.argv) weblogic_username = weblogic_password = weblogic_admin_server_host = weblogic_admin_server_port = if numberOfArgument == 5: weblogic_username = sys.argv[1] weblogic_password = sys.argv[2] weblogic_admin_server_host =sys.argv[3] weblogic_admin_server_port=sys.argv[4] elif numberOfArgument <5: print " weblogic UserName, weblogic Password and weblogic host details are Mandatory like, defalutUser, passwordForDefaultUser, t3s: weblogic_username = raw_input("Enter Weblogic user Name") weblogic_password = raw_input( weblogic_admin_server_host = raw_input( weblogic_admin_server_port = raw_input(
condition = random.randint(0, 100) anti_conditions = [42, 67, 12] if condition not in anti_conditions: pass
for pet in zoo: cute = every_pet() furry = hair is small = size < min_size if cute and furry and small: return
$ pip show Jinja2 --- Name: Jinja2 Version: 2.7.3 Location: /path/to/virtualenv/lib/python2.7/site-packages Requires: markupsafe
$ pip show specloud Package: specloud Version: 0.4.4 Requires: nose figleaf pinocchio
$ pip list argparse (1.2.1) pip (1.5.1) setuptools (2.1) wsgiref (0.1.2)
$ pip list --outdated distribute (Current: 0.6.34 Latest: 0.7.3) django-bootstrap3 (Current: 1.1.0 Latest: 4.3.0) Django (Current: 1.5.4 Latest: 1.6.4) Jinja2 (Current: 2.6 Latest: 2.8)
$ pip list --outdated | grep Jinja2 Jinja2 (Current: 2.6 Latest: 2.8)
(venv)CWD> /space/vhosts/pyramid.xcode.com/venv/build/unittest project@pyramid 43> yolk -l Chameleon - 2.8.2 - active Jinja2 - 2.6 - active Mako - 0.7.0 - active MarkupSafe - 0.15 - active PasteDeploy - 1.5.0 - active Pygments - 1.5 - active Python - 2.7.3 - active development (/usr/lib/python2.7/lib-dynload) SQLAlchemy - 0.7.6 - active WebOb - 1.2b3 - active account - 0.0 - active development (/space/vhosts/pyramid.xcode.com/project/account) distribute - 0.6.19 - active egenix-mx-base - 3.2.3 - active ipython - 0.12 - active logilab-astng - 0.23.1 - active logilab-common - 0.57.1 - active nose - 1.1.2 - active pbkdf2 - 1.3 - active pip - 1.0.2 - active pyScss - 1.1.3 - active pycrypto - 2.5 - active pylint - 0.25.1 - active pyramid-debugtoolbar - 1.0.1 - active pyramid-tm - 0.4 - active pyramid - 1.3 - active repoze.lru - 0.5 - active simplejson - 2.5.0 - active transaction - 1.2.0 - active translationstring - 1.1 - active venusian - 1.0a3 - active waitress - 0.8.1 - active wsgiref - 0.1.2 - active development (/usr/lib/python2.7) yolk - 0.4.3 - active zope.deprecation - 3.5.1 - active zope.interface - 3.8.0 - active zope.sqlalchemy - 0.7 - active
* return HttpResponse({variable to inspect}) * print {variable to inspect} * raise Exception({variable to inspect})
@register.filter def pdb(element): import pdb; pdb.set_trace() return element
bash: manage.py runserver --pdb Validating models... 0 errors found Django version 1.3, using settings Development server is running at http: Quit the server with CONTROL-C. GET / function "myview" in testapp/views.py:6 args: () kwargs: {} > /Users/tom/github/django-pdb/testproject/testapp/views.py(7)myview() -> a = 1 (Pdb)
bash: manage.py test testapp --pdb Creating test database for alias E ====================================================================== >>> test_error (testapp.tests.SimpleTest) ---------------------------------------------------------------------- Traceback (most recent call last): File ".../django-pdb/testproject/testapp/tests.py", line 16, in test_error one_plus_one = four NameError: global name ====================================================================== > /Users/tom/github/django-pdb/testproject/testapp/tests.py(16)test_error() -> one_plus_one = four (Pdb)
In [2]: import epdb; epdb.connect() (Epdb) request <WSGIRequest path:/foo, GET:<QueryDict: {}>, POST:<QuestDict: {}>, ... > (Epdb) request.session.session_key (Epdb) list 85 raise some_error.CustomError() 86 87 88 def login(request, username, password): 89 import epdb; epdb.serve() 90 -> return my_login_method(username, password) 91 92 93 def get_session_key(request): 94 return request.session.session_key 95
import epdb; epdb.serve(4242) >> import epdb; epdb.connect(host=
{% print var %} prints variable {% print %} prints all
@register.filter def pdb(element): from django.conf import settings if settings.DEBUG: import pdb pdb.set_trace() return element
TypeError at /db/hcm91dmo/catalog/records/ render_option() argument after * must be a sequence, not int .... Error during template rendering In template /opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/crispy_forms/templates/bootstrap3/field.html, error at line 28 render_option() argument after * must be a sequence, not int 18 19 {% if field|is_checkboxselectmultiple %} 20 {% include 21 {% endif %} 22 23 {% if field|is_radioselect %} 24 {% include 25 {% endif %} 26 27 {% if not field|is_checkboxselectmultiple and not field|is_radioselect %} 28 {% if field|is_checkbox and form_show_labels %}
File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/django/forms/forms.py", line 537, in __str__ return self.as_widget() File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/django/forms/forms.py", line 593, in as_widget return force_text(widget.render(name, self.value(), attrs=attrs)) File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/django/forms/widgets.py", line 513, in render options = self.render_options(choices, [value]) File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/django/forms/widgets.py", line 543, in render_options output.append(self.render_option(selected_choices, *option)) TypeError: render_option() argument after * must be a sequence, not int INFO lib.capture_middleware log write_to_index(http: INFO lib.capture_middleware log write_to_index:end > /opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/django/forms/widgets.py(543)render_options() -> output.append(self.render_option(selected_choices, *option)) (Pdb) import pprint (Pdb) pprint.PrettyPrinter(indent=4).pprint(self) <django.forms.widgets.Select object at 0x115fe7d10> (Pdb) pprint.PrettyPrinter(indent=4).pprint(vars(self)) { (Pdb)
from argparse import ArgumentParser parser = ArgumentParser() parser.add_argument("-f", "--file", dest="filename", help="write report to FILE", metavar="FILE") parser.add_argument("-q", "--quiet", action="store_false", dest="verbose", default=True, help="don args = parser.parse_args()
import argparse if __name__ == parser = argparse.ArgumentParser() parser.add_argument( nargs= parser.add_argument( default=max, help= args = parser.parse_args() print(args.accumulate(args.integers))
"""Naval Fate. Usage: naval_fate.py ship new <name>... naval_fate.py ship <name> move <x> <y> [--speed=<kn>] naval_fate.py ship shoot <x> <y> naval_fate.py mine (set|remove) <x> <y> [--moored | --drifting] naval_fate.py (-h | --help) naval_fate.py --version Options: -h --help Show this screen. --version Show version. --speed=<kn> Speed in knots [default: 10]. --moored Moored (anchored) mine. --drifting Drifting mine. """ from docopt import docopt if __name__ == arguments = docopt(__doc__, version= print(arguments)
import sys first_name = sys.argv[1] last_name = sys.argv[2] print("Hello " + first_name + " " + last_name)
Options: -h, --help show this help message and exit -l, --list-geocoders -a API_KEY, --api-key=API_KEY -g GEOCODER, --geocoder=GEOCODER
try: opts, args = getopt.getopt(sys.argv[1:], except getopt.GetoptError, err: usage(err) for opt, arg in opts: if opt in ( usage() if len(args) != 1: usage("specify thing...")
import argh def echo(text): "Returns given word as is." return text def greet(name, greeting= "Greets the user with given name. The greeting is customizable." return greeting + parser = argh.ArghParser() parser.add_commands([echo, greet]) if __name__ == parser.dispatch()
import argparse parser = argparse.ArgumentParser(description= parser.add_argument( help= parser.add_argument( const=sum, default=max, help= args = parser.parse_args() print(args.accumulate(args.integers)) Assuming the Python code above is saved into a file called prog.py $ python prog.py -h Ref-link: https:
from entrypoint2 import entrypoint @entrypoint def add(file, quiet=True): :param file: write report to FILE :param quiet: don print file,quiet
usage: report.py [-h] [-q] [--debug] file This function writes report. positional arguments: file write report to FILE optional arguments: -h, --help show this help message and exit -q, --quiet don --debug set logging level to DEBUG
my_str = "hello world" my_str_as_bytes = str.encode(my_str) type(my_str_as_bytes) my_decoded_str = my_str_as_bytes.decode() type(my_decoded_str)
In [1]: %timeit -r 10 The slowest run took 38.07 times longer than the fastest. This could mean that an intermediate result is being cached. 10000000 loops, best of 10: 183 ns per loop In [2]: %timeit -r 10 The slowest run took 27.34 times longer than the fastest. This could mean that an intermediate result is being cached. 10000000 loops, best of 10: 137 ns per loop
>>> Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeDecodeError:
def to_bytes(bytes_or_str): if isinstance(bytes_or_str, str): value = bytes_or_str.encode() else: value = bytes_or_str return value def to_str(bytes_or_str): if isinstance(bytes_or_str, bytes): value = bytes_or_str.decode() else: value = bytes_or_str return value
try: with open( do_something() except IOError as e: print
try: with open( do_something() except IOError as e: print
with open("inFile.txt", with open("outFile1.txt", with open("outFile2.txt", for line in fr.readlines(): fw1.writelines(line) fw2.writelines(line)
with ExitStack() as stack: files = [stack.enter_context(open(fname)) for fname in filenames]
from contextlib import ExitStack class X: num = 1 def __init__(self): self.num = X.num X.num += 1 def __repr__(self): cls = type(self) return def __enter__(self): print( return self.num def __exit__(self, exc_type, exc_value, traceback): print( return True xs = [X() for _ in range(3)] with ExitStack() as stack: print(len(stack._exit_callbacks)) nums = [stack.enter_context(x) for x in xs] print(len(stack._exit_callbacks)) print(len(stack._exit_callbacks)) print(nums)
0 enter X1 enter X2 enter X3 3 exit X3 exit X2 exit X1 0 [1, 2, 3]
>>> import os, argparse >>> parser = argparse.ArgumentParser() >>> parser.add_argument( _StoreTrueAction(option_strings=[ >>> parser.add_argument( _StoreAction(option_strings=[], dest= >>> parser.parse_args( Namespace(dir= >>> parser.parse_args( Namespace(dir= >>> parser.parse_args( Namespace(dir= >>> parser.parse_args([ Namespace(dir= >>> parser.parse_args( usage: [-h] [-v] [dir] positional arguments: dir optional arguments: -h, --help show this help message and exit -v
parser = argparse.ArgumentParser(description= parser.add_argument( args = parser.parse_args()
>>> df STK_ID EPS cash STK_ID RPT_Date 601166 20111231 601166 NaN NaN 600036 20111231 600036 NaN 12 600016 20111231 600016 4.3 NaN 601009 20111231 601009 NaN NaN 601939 20111231 601939 2.5 NaN 000001 20111231 000001 NaN NaN
STK_ID EPS cash STK_ID RPT_Date 600016 20111231 600016 4.3 NaN 601939 20111231 601939 2.5 NaN
In [24]: df = pd.DataFrame(np.random.randn(10,3)) In [25]: df.iloc[::2,0] = np.nan; df.iloc[::4,1] = np.nan; df.iloc[::3,2] = np.nan; In [26]: df Out[26]: 0 1 2 0 NaN NaN NaN 1 2.677677 -1.466923 -0.750366 2 NaN 0.798002 -0.906038 3 0.672201 0.964789 NaN 4 NaN NaN 0.050742 5 -1.250970 0.030561 -2.678622 6 NaN 1.036043 NaN 7 0.049896 -0.308003 0.823295 8 NaN NaN 0.637482 9 -0.310130 0.078891 NaN
In [27]: df.dropna() Out[27]: 0 1 2 1 2.677677 -1.466923 -0.750366 5 -1.250970 0.030561 -2.678622 7 0.049896 -0.308003 0.823295
In [28]: df.dropna(how= Out[28]: 0 1 2 1 2.677677 -1.466923 -0.750366 2 NaN 0.798002 -0.906038 3 0.672201 0.964789 NaN 4 NaN NaN 0.050742 5 -1.250970 0.030561 -2.678622 6 NaN 1.036043 NaN 7 0.049896 -0.308003 0.823295 8 NaN NaN 0.637482 9 -0.310130 0.078891 NaN
In [29]: df.dropna(thresh=2) Out[29]: 0 1 2 1 2.677677 -1.466923 -0.750366 2 NaN 0.798002 -0.906038 3 0.672201 0.964789 NaN 5 -1.250970 0.030561 -2.678622 7 0.049896 -0.308003 0.823295 9 -0.310130 0.078891 NaN
In [30]: df.dropna(subset=[1]) Out[30]: 0 1 2 1 2.677677 -1.466923 -0.750366 2 NaN 0.798002 -0.906038 3 0.672201 0.964789 NaN 5 -1.250970 0.030561 -2.678622 6 NaN 1.036043 NaN 7 0.049896 -0.308003 0.823295 9 -0.310130 0.078891 NaN
In [332]: df[df.EPS.notnull()] Out[332]: STK_ID RPT_Date STK_ID.1 EPS cash 2 600016 20111231 600016 4.3 NaN 4 601939 20111231 601939 2.5 NaN In [334]: df[~df.EPS.isnull()] Out[334]: STK_ID RPT_Date STK_ID.1 EPS cash 2 600016 20111231 600016 4.3 NaN 4 601939 20111231 601939 2.5 NaN In [347]: df[~np.isnan(df.EPS)] Out[347]: STK_ID RPT_Date STK_ID.1 EPS cash 2 600016 20111231 600016 4.3 NaN 4 601939 20111231 601939 2.5 NaN
In [149]: df.query("EPS == EPS") Out[149]: STK_ID EPS cash STK_ID RPT_Date 600016 20111231 600016 4.3 NaN 601939 20111231 601939 2.5 NaN
STK_ID EPS cash STK_ID RPT_Date 600016 20111231 600016 4.3 NaN 601939 20111231 601939 2.5 NaN
import os import pwd def get_username(): return pwd.getpwuid( os.getuid() )[ 0 ]
import os userhome = os.path.expanduser( print "User print "username: " + os.path.split(userhome)[-1]
try: import pwd except ImportError: import getpass pwd = None def current_user(): if pwd: return pwd.getpwuid(os.geteuid()).pw_name else: return getpass.getuser()
import commands username = commands.getoutput("echo $(whoami)") print username
import commands username = commands.getoutput("whoami")
import os os.system("sudo usermod -aG \"group_name\" $(whoami)") print "You have been added to \"group_name\"! Please log out for this to take effect"
if tbh.bag: n = 0 for _ in tbh.bag.atom_set(): n += 1
>>> import dateutil.parser >>> dateutil.parser.parse( datetime.datetime(2008, 9, 3, 20, 56, 35, 450686, tzinfo=tzutc()) >>> dateutil.parser.parse( datetime.datetime(2008, 9, 3, 20, 56, 35, 450686) >>> dateutil.parser.parse( datetime.datetime(2008, 9, 3, 20, 56, 35, 450686) >>> dateutil.parser.parse( datetime.datetime(2008, 9, 3, 0, 0)
>>> datetime.datetime.strptime("2008-09-03T20:56:35.450686Z", "%Y-%m-%dT%H:%M:%S.%fZ")
from datetime import datetime date = datetime.fromisoformat(
>>> datetime.datetime.strptime("2008-08-12T12:20:30.656234Z", "%Y-%m-%dT%H:%M:%S.Z") ValueError: time data did not match format: data=2008-08-12T12:20:30.656234Z fmt=%Y-%m-%dT%H:%M:%S.Z
>>> def gt(dt_str): dt, _, us= dt_str.partition(".") dt= datetime.datetime.strptime(dt, "%Y-%m-%dT%H:%M:%S") us= int(us.rstrip("Z"), 10) return dt + datetime.timedelta(microseconds=us) >>> gt("2008-08-12T12:20:30.656234Z") datetime.datetime(2008, 8, 12, 12, 20, 30, 656234)
>>> import arrow >>> date = arrow.get("2008-09-03T20:56:35.450686Z") >>> date.datetime datetime.datetime(2008, 9, 3, 20, 56, 35, 450686, tzinfo=tzutc())
def from_utc(utcTime,fmt="%Y-%m-%dT%H:%M:%S.%fZ"): return datetime.datetime.strptime(utcTime, fmt)
>>> import dateutil.parser as dp >>> t = >>> parsed_t = dp.parse(t) >>> t_in_seconds = parsed_t.strftime( >>> t_in_seconds
>>> from iso8601utils import parsers >>> parsers.datetime( datetime.datetime(2008, 9, 3, 20, 56, 35, 450686)
parse_datetime( datetime.datetime(2016, 8, 9, 15, 12, 3, 654780, tzinfo=<UTC>)
from django.utils import formats from django.forms.fields import DateTimeField from django.utils.dateparse import parse_datetime class DateTimeFieldFixed(DateTimeField): def strptime(self, value, format): if format == return parse_datetime(value) return super().strptime(value, format) DateTimeField.strptime = DateTimeFieldFixed.strptime formats.ISO_INPUT_FORMATS[
from __future__ import with_statement, division, print_function import sqlite3 import datetime testtimes = [ "2016-08-25T16:01:26.123456Z", "2016-08-25T16:01:29", ] db = sqlite3.connect(":memory:") c = db.cursor() for timestring in testtimes: c.execute("SELECT strftime( converted = c.fetchone()[0] print("%s is %s after epoch" % (timestring, converted)) dt = datetime.datetime.fromtimestamp(int(converted)) print("datetime is %s" % dt)
2016-08-25T16:01:26.123456Z is 1472140886 after epoch datetime is 2016-08-25 12:01:26 2016-08-25T16:01:29 is 1472140889 after epoch datetime is 2016-08-25 12:01:29
datetime.datetime.strptime(timestamp.translate(None,
import re conformed_timestamp = re.sub(r"[:]|([-](?!((\d{2}[:]\d{2})|(\d{4}))$))", datetime.datetime.strptime(conformed_timestamp, "%Y%m%dT%H%M%S.%f%z" )
import re import datetime conformed_timestamp = re.sub(r"[:]|([-](?!((\d{2}[:]\d{2})|(\d{4}))$))", split_timestamp = re.split(r"[+|-]",conformed_timestamp) main_timestamp = split_timestamp[0] if len(split_timestamp) == 3: sign = split_timestamp[1] offset = split_timestamp[2] else: sign = None offset = None output_datetime = datetime.datetime.strptime(main_timestamp +"Z", "%Y%m%dT%H%M%S.%fZ" ) if offset: offset_delta = datetime.timedelta(hours=int(sign+offset[:-2]), minutes=int(sign+offset[-2:])) output_datetime = output_datetime + offset_delta
calendar.timegm(time.strptime(date.split(".")[0]+"UTC", "%Y-%m-%dT%H:%M:%S%Z"))
from dateutil import parser ds = try: dt = parser.parse(ds) except ValueError, e: print
>>> import maya >>> str = >>> maya.MayaDT.from_rfc3339(str).datetime() datetime.datetime(2008, 9, 3, 20, 56, 35, 450686, tzinfo=<UTC>)
from datetime import datetime, timezone, timedelta datetime.strptime(timestamp, "%Y-%m-%dT%H:%M:%S.%fZ").replace( tzinfo=timezone(timedelta(0)))
>>> datetime.utcnow().replace(tzinfo=timezone(timedelta(0))) ... datetime.datetime(2015, 3, 11, 6, 2, 47, 879129, tzinfo=datetime.timezone.utc)
class FixedOffset(tzinfo): def __init__(self, offset): self.__offset = timedelta(minutes=offset) hours, minutes = divmod(offset, 60) self.__name = def utcoffset(self, dt=None): return self.__offset def tzname(self, dt=None): return self.__name def dst(self, dt=None): return timedelta(0) def __repr__(self): return def __getinitargs__(self): return (self.__offset.total_seconds()/60,) def parse_isoformat_datetime(isodatetime): try: return datetime.strptime(isodatetime, except ValueError: pass try: return datetime.strptime(isodatetime, except ValueError: pass pat = r temp = re.sub(pat, r naive_date_str = temp[:-5] offset_str = temp[-5:] naive_dt = datetime.strptime(naive_date_str, offset = int(offset_str[-4:-2])*60 + int(offset_str[-2:]) if offset_str[0] == "-": offset = -offset return naive_dt.replace(tzinfo=FixedOffset(offset))
def parseISO8601DateTime(datetimeStr): import time from datetime import datetime, timedelta def log_date_string(when): gmt = time.gmtime(when) if time.daylight and gmt[8]: tz = time.altzone else: tz = time.timezone if tz > 0: neg = 1 else: neg = 0 tz = -tz h, rem = divmod(tz, 3600) m, rem = divmod(rem, 60) if neg: offset = else: offset = return time.strftime( dt = datetime.strptime(datetimeStr, timestamp = dt.timestamp() return dt + timedelta(hours=dt.hour-time.gmtime(timestamp).tm_hour)
conda install -n testenv pip source activate testenv pip <pip command>
str1 = raw_input("Enter string one:") str2 = raw_input("Enter string two:") if logical_xor(str1, str2): print "ok" else: print "bad"
>>> 1 ^ 1 0 >>> 2 ^ 1 3 >>> "abc" ^ "" Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unsupported operand type(s) for ^:
def logical_xor(str1, str2): return bool(str1) ^ bool(str2)
def logical_xor(a, b): if bool(a) == bool(b): return False else: return a or b
>>> logical_xor( False >>> logical_xor( False >>> logical_xor( >>> logical_xor(
%timeit not a != (not b) 10000000 loops, best of 3: 78.5 ns per loop In [130]: %timeit bool(a) != bool(b) 1000000 loops, best of 3: 343 ns per loop In [131]: %timeit not a ^ (not b) 10000000 loops, best of 3: 131 ns per loop
def xor(*vars): sum = bool(False) for v in vars: sum = sum ^ bool(v) return sum
if xor(False, False, True, False): print "Hello World!"
def isOne(*vars): sum = bool(False) for v in vars: if sum and v: return False else: sum = sum or v return sum
def xor(*operands, falsechoice = -2, truechoice = -2): if not operands: raise TypeError( choices = [falsechoice, truechoice] matches = {} result = False first = True value = choice = None for operand in operands: value = bool(operand) result ^= value choice = choices[value] if choice < -1 or (choice == -1 and value == result) or (choice == 1 and first) or (choice > 1 and value not in matches): matches[value] = operand first = False if (choices[result] == -1) and (result != value): return result else: return matches.get(result, result) testcases = [ (-1, None, True, {None: None}, [], (None, -1, {None: None}, (None, -1, True, {None: None}, (-1, None, {None: None}, [], choices = {-2: for c in testcases: print(c) for f in sorted(choices.keys()): for t in sorted(choices.keys()): x = xor(*c, falsechoice = f, truechoice = t) print( print()
>>> True is not True False >>> True is not False True >>> False is not True True >>> False is not False False >>>
>>> "abc" is not "" True >>> False >>> True >>> True >>> False >>>
def logical_xor(a, b): return (a and not b) or (not a and b) test_data = [ [False, False], [False, True], [True, False], [True, True], ] for a, b in test_data: print
str1 = raw_input("Enter string one:") str2 = raw_input("Enter string two:") any([str1, str2]) and not all([str1, str2])
str1 = "Hello" str2 = "World" newstr = " ".join((str1, str2))
%%timeit x = [] for i in range(100000000): x.append( x =
str = "Hello" str2 = " World" st = str.__add__(str2) print(st)
var1 = "foo" var2 = "bar" var3 = f"{var1}{var2}" print(var3)
try: f = open( s = f.readline() i = int(s.strip()) except IOError as (errno, strerror): print "I/O error({0}): {1}".format(errno, strerror) except ValueError: print "Could not convert data to an integer." except: print "Unexpected error:", sys.exc_info()[0] raise
import traceback import logging try: whatever() except Exception as e: logging.error(traceback.format_exc())
try: a = 2/0 except Exception as e: print e.__doc__ print e.message
try: print "Performing an action which may throw an exception." except Exception, error: print "An exception was thrown!" print str(error) else: print "Everything looks great!" finally: print "Finally is called directly after executing the try statement whether an exception is thrown or not."
try: something() except BaseException as error: print(
try: raise IndexError except Exception as e: excepName = type(e).__name__
inv_map = {} for k, v in my_map.iteritems(): inv_map[v] = inv_map.get(v, []) inv_map[v].append(k)
def inverse_mapping(f): return f.__class__(map(reversed, f.items()))
inv_map = dict(zip(my_map.values(), my_map.keys()))
class ReversibleDict(dict): def reversed(self): """ Return a reversed dict, with common values in the original dict grouped into a list in the returned dict. Example: >>> d = ReversibleDict({ >>> d.reversed() {1: [ """ revdict = {} for k, v in self.iteritems(): revdict.setdefault(v, []).append(k) return revdict
In [7]: my_map Out[7]: {1: In [8]: inv_map = dict(map(reversed, my_map.items())) In [9]: inv_map Out[9]: {
{v:[i for i in d.keys() if d[i] == v ] for k,v in d.items()}
inv_map = dict( (v, [k for (k, xx) in filter(lambda (key, value): value == v, my_map.items())]) for v in set(my_map.values()) )
from collections import Counter, defaultdict def invert_dict(d): d_inv = defaultdict(list) for k, v in c.items(): d_inv[v].append(k) return d_inv text = c = Counter(text.split()) dict(invert_dict(c))
invert = lambda mydict: {v:k for k, v in mydict.items()}
invert = lambda mydict: dict( zip(mydict.values(), mydict.keys()) )
inv_map = {v:[k for k in my_map if my_map[k] == v] for v in my_map.itervalues()}
class SymDict: def __init__(self): self.aToB = {} self.bToA = {} def assocAB(self, a, b): currB = None if a in self.aToB: currB = self.bToA[a] currA = None if b in self.bToA: currA = self.aToB[b] self.aToB[a] = b self.bToA[b] = a return (currA, currB) def lookupA(self, a): if a in self.aToB: return self.aToB[a] return None def lookupB(self, b): if b in self.bToA: return self.bToA[b] return None
inv_map = dict(zip(my_map.values(), my_map.keys()))
inv_map={}; for i in my_map: inv_map[my_map[i]]=i print inv_map
def invertDictionary(d): myDict = {} for i in d: value = d.get(i) myDict.setdefault(value,[]).append(i) return myDict print invertDictionary({
def reverse_dictionary(input_dict): out = {} for v in input_dict.values(): for value in v: if value not in out: out[value.lower()] = [] for i in input_dict: for j in out: if j in map (lambda x : x.lower(),input_dict[i]): out[j].append(i.lower()) out[j].sort() return out
inverted_dict = dictio() for key, value in dict.items(): inverted_dict.setdefault(value, list()).append(key)
inverted_dict = {value: key for key, value in dict.items()}
dict = {value: key for key in inverted_dict for value in my_map[key]}
def reverse_dict(dictionary): reverse_dict = {} for key, value in dictionary.iteritems(): if not isinstance(value, (list, tuple)): value = [value] for val in value: reverse_dict[val] = reverse_dict.get(val, []) reverse_dict[val].append(key) for key, value in reverse_dict.iteritems(): if len(value) == 1: reverse_dict[key] = value[0] return reverse_dict
def r_maping(dictionary): List_z=[] Map= {} for z, x in dictionary.iteritems(): Map.setdefault(x,List_z).append(z) return Map
def inverse(mapping): A function to inverse mapping, collecting keys with simillar values in list. Careful to retain original type and to be fast. >> d = dict(a=1, b=2, c=1, d=3, e=2, f=1, g=5, h=2) >> inverse(d) {1: [ res = {} setdef = res.setdefault for key, value in mapping.items(): setdef(value, []).append(key) return res if mapping.__class__==dict else mapping.__class__(res)
for k, v in myDict.items(): if len(v) > 1: for item in v: invDict[item] = invDict.get(item, []) invDict[item].append(k) else: invDict[v] = invDict.get(v, []) invDict[v].append(k)
def digList(lst): temp = [] for item in lst: if type(item) is list: temp.append(digList(item)) else: temp.append(item) return set(temp) for k, v in myDict.items(): if type(v) is list: items = digList(v) for item in items: invDict[item] = invDict.get(item, []) invDict[item].append(k) else: invDict[v] = invDict.get(v, []) invDict[v].append(k)
dict_ = {"k0":"v0", "k1":"v1", "k2":"v1"} inversed_dict_ = {val: key for key, val in dict_.items()} print(inversed_dict_["v1"])
from itertools import imap, groupby def fst(s): return s[0] def snd(s): return s[1] def inverseDict(d): """ input d: a -> b output : b -> set(a) """ return { v : set(imap(fst, kv_iter)) for (v, kv_iter) in groupby( sorted(d.iteritems(), key=snd), key=snd ) }
def dict_invert(map1): inv_map = {} for key in map1.keys(): inv_map[map1.get(key)] = key return inv_map
inv_map = {v: inv_map.get(v, []) + [k] for k,v in my_map.items()}
dictionary = { reverse_dictionary = {} for index, val in enumerate(list(dictionary.values())): reverse_dictionary[val] = list(dictionary.keys())[index]
def foo(): foo.counter += 1 print "Counter is %d" % foo.counter foo.counter = 0
def static_var(varname, value): def decorate(func): setattr(func, varname, value) return func return decorate
@static_var("counter", 0) def foo(): foo.counter += 1 print "Counter is %d" % foo.counter
def static_vars(**kwargs): def decorate(func): for k in kwargs: setattr(func, k, kwargs[k]) return func return decorate @static_vars(counter=0) def foo(): foo.counter += 1 print "Counter is %d" % foo.counter
def myfunc(): myfunc.counter += 1 print myfunc.counter myfunc.counter = 0
def myfunc(): if not hasattr(myfunc, "counter"): myfunc.counter = 0 myfunc.counter += 1
def foo(): try: foo.counter += 1 except AttributeError: foo.counter = 1
>>> def foo(counter=[0]): ... counter[0] += 1 ... print("Counter is %i." % counter[0]); ... >>> foo() Counter is 1. >>> foo() Counter is 2. >>>
class Foo(object): counter = 0 def __call__(self): Foo.counter += 1 print Foo.counter foo = Foo() foo() foo() foo()
def fn(): fn.counter=vars(fn).setdefault( fn.counter+=1 print (fn.counter)
def Fibonacci(n): if n<2: return n Fibonacci.memo=vars(Fibonacci).setdefault( return Fibonacci.memo.setdefault(n,Fibonacci(n-1)+Fibonacci(n-2))
def TheOnlyPlaceStaticFunctionIsCalled(): memo={} def Fibonacci(n): nonlocal memo if n<2: return n return memo.setdefault(n,Fibonacci(n-1)+Fibonacci(n-2)) ... print (Fibonacci(200)) ...
foo = foo_gen().next for i in range(0,10): print foo()
def foo_gen(limit=100000): n = 0 while n < limit: n+=1 yield n
def make_counter(): i = 0 def counter(): nonlocal i i = i + 1 return i return counter counter = make_counter()
def staticvariables(**variables): def decorate(function): for variable in variables: setattr(function, variable, variables[variable]) return function return decorate @staticvariables(counter=0, bar=1) def foo(): print(foo.counter) print(foo.bar)
counter = 0 def foo(): nonlocal counter counter += 1 print(f
>>> def func(_static={ ... _static[ ... print _static[ ... >>> func() 1 >>> func() 2 >>>
@static_var2( def funccounter(statics, add=1): statics.seed += add return statics.seed print funccounter() print funccounter(add=2) print funccounter() class ACircle(object): @static_var2( def counter(statics, self, add=1): statics.seed += add return statics.seed c = ACircle() print c.counter() print c.counter(add=2) print c.counter() d = ACircle() print d.counter() print d.counter(add=2) print d.counter()
class StaticMan(object): def __init__(self): self.__dict__[ def __getattr__(self, name): return self.__dict__[ def __getitem__(self, name): return self.__dict__[ def __setattr__(self, name, val): self.__dict__[ def __setitem__(self, name, val): self.__dict__[ def static_var2(name, val): def decorator(original): if not hasattr(original, def wrapped(*args, **kwargs): return original(getattr(wrapped, setattr(wrapped, f = wrapped else: f = original getattr(f, return f return decorator
import types def func(_static=types.SimpleNamespace(counter=0)): _static.counter += 1 print(_static.counter)
def staticize(name, factory): """Makes a pseudo-static variable in calling function. If name `name` exists in calling function, return it. Otherwise, saves return value of `factory()` in name `name` of calling function and return it. :param name: name to use to store static object in calling function :type name: String :param factory: used to initialize name `name` in calling function :type factory: function :rtype: `type(factory())` >>> def steveholt(z): ... a = staticize( ... a.append(z) >>> steveholt.a Traceback (most recent call last): ... AttributeError: >>> steveholt(1) >>> steveholt.a [1] >>> steveholt( >>> steveholt.a [1, >>> steveholt.a = [] >>> steveholt.a [] >>> steveholt( >>> steveholt.a [ """ from inspect import stack calling_fn_scope = stack()[2][0] calling_fn_name = stack()[1][3] calling_fn = calling_fn_scope.f_locals[calling_fn_name] if not hasattr(calling_fn, name): setattr(calling_fn, name, factory()) return getattr(calling_fn, name)
class Count: def foo(self): try: self.foo.__func__.counter += 1 except AttributeError: self.foo.__func__.counter = 1 print self.foo.__func__.counter m = Count() m.foo() m.foo() m.foo()
class foo(object): counter = 0; @staticmethod def __call__(): foo.counter += 1 print "counter is %i" % foo.counter
isInt_try: 0.3690 isInt_str: 0.3981 isInt_re: 0.5870 isInt_re2: 0.3632
class Foo_class { private: int counter; public: Foo_class() { counter = 0; } void operator() () { counter++; printf("counter is %d\n", counter); } }; Foo_class foo;
class Foo_class: def __init__(self): self.counter = 0 def __call__(self): self.counter += 1 print("counter is %d" % self.counter); foo = Foo_class()
counter is 1 counter is 2 counter is 3 counter is 4 counter is 5
class Foo_class: def __init__(self): self.counter = 0 def __call__(self, x, y, z): self.counter += 1 print("counter is %d" % self.counter); print("x, y, z, are %d, %d, %d" % (x, y, z)); foo = Foo_class() from foo import foo for i in range(0, 5): foo(7, 8, 9) counter is 1 x, y, z, are 7, 8, 9 counter is 2 x, y, z, are 7, 8, 9 counter is 3 x, y, z, are 7, 8, 9 counter is 4 x, y, z, are 7, 8, 9 counter is 5 x, y, z, are 7, 8, 9
def fn(): counter = vars(fn).setdefault( counter += 1 print (counter)
def foo(): foo.__dict__.setdefault( foo.count += 1 return foo.count
counter = 0 def foo(): global counter counter += 1 print("counter is {}".format(counter)) foo() foo() foo()
from bunch import * def static_vars(**kwargs): def decorate(func): statics = Bunch(**kwargs) setattr(func, "statics", statics) return func return decorate @static_vars(name = "Martin") def my_function(): statics = my_function.statics print("Hello, {0}".format(statics.name))
class Bunch(dict): def __init__(self, **kw): dict.__init__(self,kw) self.__dict__ = self
class Foo(object): counter = 0 def __call__(self, inc_value=0): Foo.counter += inc_value return Foo.counter foo = Foo() def use_foo(x,y): if(x==5): foo(2) elif(y==7): foo(3) if(foo() == 10): print("yello") use_foo(5,1) use_foo(5,1) use_foo(1,7) use_foo(1,7) use_foo(1,1)
stat_c +=9; foo(9) if(stat_c==10){ if(foo() == 10): Output : yello yello
$ git clone git@github.com/myuser/foo.git@my_version $ pip install --editable ./
from distutils.core import setup import py2exe from distutils.filelist import findall import matplotlib setup( console=[ options={ } }, data_files = matplotlib.get_py2exe_datafiles() )
import sys def main(argv): pass if __name__ == "__main__": main(sys.argv)
class MyApplication(something): if __name__ == "__main__": app = MyApplication() app.run()
def sum(a, b): return a + b values = (1, 2) s = sum(*values)
def sum(a, b, c, d): return a + b + c + d values1 = (1, 2) values2 = { s = sum(*values1, **values2)
def sum(*values): s = 0 for v in values: s = s + v return s s = sum(1, 2, 3, 4, 5)
def get_a(**values): return values[ s = get_a(a=1, b=2)
def sum(*values, **options): s = 0 for i in values: s = s + i if "neg" in options: if options["neg"]: s = -s return s s = sum(1, 2, 3, 4, 5) s = sum(1, 2, 3, 4, 5, neg=True) s = sum(1, 2, 3, 4, 5, neg=False)
def add(a, b): return a + b tests = { (1,4):5, (0, 0):0, (-1, 3):3 } for test, result in tests.items(): print
a/b/c/ a/b/c \a\b\c \a\b\c\ a\b\c a/b/../../a/b/c/ a/b/../../a/b/c
def path_leaf(path): head, tail = ntpath.split(path) return tail or ntpath.basename(head)
>>> paths = [ ... >>> [path_leaf(path) for path in paths] [
head, tail = os.path.split("/tmp/d/a.dat") >>> print(tail) a.dat >>> print(head) /tmp/d
>>> from pathlib import Path >>> Path("/tmp/d/a.dat").name
>>> import os >>> path = >>> path = path.rstrip(os.sep) >>> os.path.basename(path)
paths = [ def path_leaf(path): return path.strip( [path_leaf(path) for path in paths]
paths = [ ... for path in paths: os.path.basename(os.path.normpath(path))
b = [ for a in b: print (a, a.rstrip("\\" if a.count("/") == 0 else
import re def extract_basename(path): basename = re.search(r if basename: return basename.group(0) paths = [ print([extract_basename(path) for path in paths]) extra_paths = [ print([extract_basename(path) for path in extra_paths])
import tempfile abc = tempfile.NamedTemporaryFile(dir= abc.name abc.name.replace("/", " ").split()[-1]
>>> from pathlib import PureWindowsPath >>> paths = [ ... >>> [PureWindowsPath(path).name for path in paths] [
import posixpath from pathlib2 import PurePath, PureWindowsPath, PurePosixPath def path2unix(path, nojoin=True, fromwinpath=False): """From a path given in any format, converts to posix path format fromwinpath=True forces the input path to be recognized as a Windows path (useful on Unix machines to unit test Windows paths)""" if not path: return path if fromwinpath: pathparts = list(PureWindowsPath(path).parts) else: pathparts = list(PurePath(path).parts) if nojoin: return pathparts else: return posixpath.join(*pathparts)
In [9]: path2unix( Out[9]: [ In [10]: path2unix(r Out[10]: [ In [11]: path2unix(r Out[11]: [
In [12]: testcase = paths = [ ...: ... In [14]: for t in testcase: ...: print(path2unix(t)[-1]) ...: ...: c c c c c c c
from datetime import date from datetime import datetime d = date.today() datetime.combine(d, datetime.min.time())
>>> t=datetime.date.today() >>> datetime.datetime.fromordinal(t.toordinal()) datetime.datetime(2009, 12, 20, 0, 0) >>> datetime.datetime(t.year, t.month, t.day) datetime.datetime(2009, 12, 20, 0, 0) >>> datetime.datetime(*t.timetuple()[:-4]) datetime.datetime(2009, 12, 20, 0, 0)
from datetime import date, datetime today = date.today() today_with_time = datetime( year=today.year, month=today.month, day=today.day, )
from datetime import date import pandas as pd d = date.today() pd.Timestamp(d)
from datetime import datetime isinstance(pd.Timestamp(d), datetime)
from datetime import date, datetime d = date.today() datetime.strptime(d.strftime(
import date_converter my_datetime = date_converter.date_to_datetime(my_date)
dates = pd.DataFrame( { >>> dates date 0 2017-01-01 1 2017-01-02 2 2017-01-03 3 2017-01-04 4 2017-01-05 >>> pd.DatetimeIndex(dates[ [datetime.datetime(2017, 1, 1, 0, 0), datetime.datetime(2017, 1, 2, 0, 0), datetime.datetime(2017, 1, 3, 0, 0), datetime.datetime(2017, 1, 4, 0, 0), datetime.datetime(2017, 1, 5, 0, 0)]
dates = pd.DataFrame( { dates[ pd.DatetimeIndex(dates[
import sys from datetime import datetime from time import mktime, strptime user_date = if user_date is not None: user_date = datetime.strptime(user_date,"%m/%d/%Y") else: user_date = datetime.now() print user_date
class Counter: def __init__(self, low, high): self.current = low self.high = high def __iter__(self): return self def next(self): if self.current > self.high: raise StopIteration else: self.current += 1 return self.current - 1 for c in Counter(3, 8): print c
def counter(low, high): current = low while current <= high: yield current current += 1 for c in counter(3, 8): print c
def uc_gen(text): for char in text: yield char.upper() def uc_genexp(text): return (char.upper() for char in text) class uc_iter(): def __init__(self, text): self.text = text self.index = 0 def __iter__(self): return self def __next__(self): try: result = self.text[self.index].upper() except IndexError: raise StopIteration self.index += 1 return result class uc_getitem(): def __init__(self, text): self.text = text def __getitem__(self, index): result = self.text[index].upper() return result
for iterator in uc_gen, uc_genexp, uc_iter, uc_getitem: for ch in iterator( print ch, print
def __reversed__(self): return reversed(self.text) def __len__(self) return len(self.text)
def even_gen(): result = 0 while True: yield result result += 2 def even_genexp(): return (num for num in even_gen()) class even_iter(): def __init__(self): self.value = 0 def __iter__(self): return self def __next__(self): next_value = self.value self.value += 2 return next_value class even_getitem(): def __getitem__(self, index): return index * 2 import random for iterator in even_gen, even_genexp, even_iter, even_getitem: limit = random.randint(15, 30) count = 0 for even in iterator(): print even, count += 1 if count >= limit: break print
0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32
class range: def __init__(self,a,b): self.a = a self.b = b def __iter__(self): i = self.a while i < self.b: yield i i+=1
class CustomRange: def __init__(self, low, high): self.low = low self.high = high def __getitem__(self, item): if item >= len(self): raise IndexError("CustomRange index out of range") return self.low + item def __len__(self): return self.high - self.low cr = CustomRange(0, 10) for i in cr: print(i)
def count(low, high): counter = [0] def tmp(): val = low + counter[0] if val < high: counter[0] += 1 return val return None return iter(tmp, None)
def count(low, high): counter = 0 def tmp(): nonlocal counter val = low + counter if val < high: counter += 1 return val return None return iter(tmp, None)
class A(object): def __init__(self, l): self.data = l def __iter__(self): return iter(self.data)
In [3]: a = A([2,3,4]) In [4]: [i for i in a] Out[4]: [2, 3, 4]
class Test(object): def __init__(self, string): self.string = string def __iter__(self): return (ch for ch in string)
class AlphaCounter: def __init__(self, low, high): self.current = low self.high = high def __iter__(self): return self def __next__(self): alpha = n_current = sum([(alpha.find(self.current[x])* 26**(len(self.current)-x-1)) for x in range(len(self.current))]) n_high = sum([(alpha.find(self.high[x])* 26**(len(self.high)-x-1)) for x in range(len(self.high))]) if n_current > n_high: raise StopIteration else: increment = True ret = for x in self.current[::-1]: if if increment: ret += else: ret += else: if increment: ret += alpha[alpha.find(x)+1] increment = False else: ret += x if increment: ret += tmp = self.current self.current = ret[::-1] return tmp for c in AlphaCounter( print(c)
x=chr(92) print type(x), len(x) y= print type(y), len(y) x==y x is y
from bson import json_util import json json.dumps(anObject, default=json_util.default)
json.loads(aJsonString, object_hook=json_util.object_hook)
from django.core.serializers.json import DjangoJSONEncoder return json.dumps( item, sort_keys=True, indent=1, cls=DjangoJSONEncoder )
import datetime import json def default(o): if isinstance(o, (datetime.date, datetime.datetime)): return o.isoformat() return json.dumps( item, sort_keys=True, indent=1, default=default )
"last_login": "2018-08-03T10:51:42.990", "last_login": "2018-08-03T10:51:42.990239",
from datetime import date, datetime def json_serial(obj): if isinstance(obj, (datetime, date)): return obj.isoformat() raise TypeError ("Type %s not serializable" % type(obj))
from datetime import datetime from json import dumps print dumps(datetime.now(), default=json_serial)
json.dumps(my_dictionary, indent=4, sort_keys=True, default=str)
from datetime import datetime import json class DateTimeEncoder(json.JSONEncoder): def default(self, o): if isinstance(o, datetime): return o.isoformat() return json.JSONEncoder.default(self, o)
def default(obj): import calendar, datetime if isinstance(obj, datetime.datetime): if obj.utcoffset() is not None: obj = obj - obj.utcoffset() millis = int( calendar.timegm(obj.timetuple()) * 1000 + obj.microsecond / 1000 ) return millis raise TypeError(
import datetime, json print json.dumps(datetime.datetime.now(), default=default)
import json class DatetimeEncoder(json.JSONEncoder): def default(self, obj): try: return super(DatetimeEncoder, obj).default(obj) except TypeError: return str(obj)
class DateTimeEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, datetime.datetime): encoded_object = list(obj.timetuple())[0:6] else: encoded_object =json.JSONEncoder.default(self, obj) return encoded_object sample = {} sample[ sample[ print sample print json.dumps(sample, cls=DateTimeEncoder)
{ {"somedate": [2013, 8, 1, 16, 22, 45], "title": "String"}
import json import datetime json.JSONEncoder.default = lambda self,obj: (obj.isoformat() if isinstance(obj, datetime.datetime) else None)
def default(o): if type(o) is datetime.date or type(o) is datetime.datetime: return o.isoformat() def jsondumps(o): return json.dumps(o, default=default)
def default(o): if type(o) is datetime.date or type(o) is datetime.datetime: return o.isoformat() if type(o) is decimal.Decimal: return float(o)
enco = lambda obj: ( obj.isoformat() if isinstance(obj, datetime.datetime) or isinstance(obj, datetime.date) else None ) json.dumps({
>>> import json >>> class ComplexEncoder(json.JSONEncoder): ... def default(self, obj): ... if isinstance(obj, complex): ... return [obj.real, obj.imag] ... return json.JSONEncoder.default(self, obj) ... >>> dumps(2 + 1j, cls=ComplexEncoder) >>> ComplexEncoder().encode(2 + 1j) >>> list(ComplexEncoder().iterencode(2 + 1j)) [
from datetime import datetime time_dict = { sample_dict = { sample_dict.update(time_dict) sample_dict
response = make_response(dumps(sample, cls=CustomEncoder)) response.headers[ response.headers[ return response
from flask import make_response from json import JSONEncoder, dumps class CustomEncoder(JSONEncoder): def default(self, obj): if set([ return str(obj) elif hasattr(obj, return list(obj) return JSONEncoder.default(self, obj) @app.route( def get_reps(): sample = [ response = make_response(dumps({ response.headers[ response.headers[ return response
import calendar, datetime, json def outputJSON(obj): if isinstance(obj, datetime.datetime): if obj.utcoffset() is not None: obj = obj - obj.utcoffset() return obj.strftime( return str(obj) def inputJSON(obj): newDic = {} for key in obj: try: if float(key) == int(float(key)): newKey = int(key) else: newKey = float(key) newDic[newKey] = obj[key] continue except ValueError: pass try: newDic[str(key)] = datetime.datetime.strptime(obj[key], continue except TypeError: pass newDic[str(key)] = obj[key] return newDic x = { print x with open( json.dump(x, fp, default=outputJSON) with open( my_dict = json.load(f, object_hook=inputJSON) print my_dict
{"Date": "2013-11-08 02:30:56.479727", "34": 89.9, "45": 67, "12.3": 90, "Extra": 6}
def myconverter(o): if isinstance(o, datetime.datetime): return o.__str__() print(json.dumps(d, default = myconverter))
from datetime import datetime from datetime import timezone from datetime import timedelta import json def default(obj): if isinstance(obj, datetime): return { return super().default(obj) def object_hook(obj): _isoformat = obj.get( if _isoformat is not None: return datetime.fromisoformat(_isoformat) return obj if __name__ == d = { s = json.dumps(d, default=default) print(s) print(d == json.loads(s, object_hook=object_hook))
{"now": {"_isoformat": "2000-01-01T00:00:00-08:00"}} True
from datetime import datetime from json_tricks import dumps foo = { dumps(foo)
{"title": "String", "datetime": {"__datetime__": null, "year": 2012, "month": 8, "day": 8, "hour": 21, "minute": 46, "second": 24, "microsecond": 862000}}
import datetime import json import dateutil.parser class JSONEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, datetime.datetime): return obj.isoformat() return super(JSONEncoder, self).default(obj) def test(): dts = [ datetime.datetime.now(), datetime.datetime.now(datetime.timezone(-datetime.timedelta(hours=4))), datetime.datetime.utcnow(), datetime.datetime.now(datetime.timezone.utc), ] for dt in dts: dt_isoformat = json.loads(json.dumps(dt, cls=JSONEncoder)) dt_parsed = dateutil.parser.parse(dt_isoformat) assert dt == dt_parsed print(f if __name__ == test()
from datetime import datetime import json from pytz import timezone import pytz def json_dt_serializer(obj): rsp = dict() if isinstance(obj, datetime): rsp[ rsp[ rsp[ rsp[ rsp[ rsp[ rsp[ rsp[ return rsp raise TypeError("Type not serializable") def json_dt_deserialize(obj): if isinstance(obj, str): obj = json.loads(obj) tzone = timezone(obj[ tmp_dt = datetime(obj[ obj[ obj[ hour=obj[ minute=obj[ second=obj[ microsecond=obj[ loc_dt = tzone.localize(tmp_dt) deserialize = loc_dt.astimezone(tzone) return deserialize
now = datetime.now(pytz.utc) rsp = json_dt_serializer(now) tmp = json_dt_deserialize(rsp) assert tmp == now assert isinstance(tmp, datetime) == True assert isinstance(now, datetime) == True tmp = json.dumps(datetime.now(pytz.utc), default=json_dt_serializer) rsp = json_dt_deserialize(tmp) assert isinstance(rsp, datetime) == True eastern = timezone( now = datetime.now(eastern) rsp = json_dt_serializer(now) tmp = json_dt_deserialize(rsp) print(tmp) print(now) assert tmp == now
Class Puppy(Base): ... @property def serialize(self): return { ... }
for key,val in sample.items(): if isinstance(val, datetime): sample[key] = json.dumps(sample)
import datetime, json dt = datetime.datetime.now() print("This is now: {}".format(dt)) dt1 = json.dumps(repr(dt)) print("This is serialised: {}".format(dt1)) dt2 = json.loads(dt1) print("This is loaded back from json: {}".format(dt2)) dt3 = eval(dt2) print("This is the same object as we started: {}".format(dt3)) print("Check if they are equal: {}".format(dt == dt3))
def externalize(model_obj): keys = model_obj._meta.get_all_field_names() data = {} for key in keys: if key == date_time_obj = getattr(model_obj, key) data[key] = date_time_obj.strftime("%A %d. %B %Y") else: data[key] = getattr(model_obj, key) return data
def j_serial(o): from datetime import datetime, date return str(o).split(
import datetime serial_d = j_serial(datetime.datetime.now()) if serial_d: print(serial_d)
import json, datetime date = str(datetime.datetime.now()) print(json.dumps(date)) "2018-12-01 15:44:34.409085" print(type(date)) <class datetime_obj = datetime.datetime.strptime(date, print(datetime_obj) 2018-12-01 15:44:34.409085 print(type(datetime_obj)) <class
import datetime,json sampledict = {} sampledict[ sampledict[ print sampledict output : Traceback (most recent call last): File "./jsonencodedecode.py", line 10, in <module> print json.dumps(sampledict) File "/usr/lib/python2.7/json/__init__.py", line 244, in dumps return _default_encoder.encode(obj) File "/usr/lib/python2.7/json/encoder.py", line 207, in encode chunks = self.iterencode(o, _one_shot=True) File "/usr/lib/python2.7/json/encoder.py", line 270, in iterencode return _iterencode(o, 0) File "/usr/lib/python2.7/json/encoder.py", line 184, in default raise TypeError(repr(o) + " is not JSON serializable") TypeError: datetime.datetime(2017, 4, 15, 5, 16, 17, 435706) is not JSON serializable sampledict[ afterdump = json.dumps(sampledict) print afterdump print type(afterdump) afterloads = json.loads(afterdump) print afterloads print type(afterloads)
import urllib.request contents = urllib.request.urlopen("http:
>>> print(r.status_code) >>> print(r.headers) >>> print(r.content)
import httplib2 resp, content = httplib2.Http().request("http:
import httplib2 resp, content = httplib2.Http().request("http:
import sys, urllib def reporthook(a, b, c): print "% 3.1f%% of %d bytes\r" % (min(100, float(a * b) / c * 100), c), sys.stdout.flush() for url in sys.argv[1:]: i = url.rfind("/") file = url[i+1:] print url, "->", file urllib.urlretrieve(url, file, reporthook) print
import sys, urllib def reporthook(a, b, c): print "% 3.1f%% of %d bytes\r" % (min(100, float(a * b) / c * 100), c), for url in sys.argv[1:]: i = url.rfind("/") file = url[i+1:] print url, "->", file urllib.urlretrieve(url, file, reporthook) print
import sys, urllib.request def reporthook(a, b, c): print ("% 3.1f%% of %d bytes\r" % (min(100, float(a * b) / c * 100), c)) sys.stdout.flush() for url in sys.argv[1:]: i = url.rfind("/") file = url[i+1:] print (url, "->", file) urllib.request.urlretrieve(url, file, reporthook) print
try: import urllib2 as urlreq except: import urllib.request as urlreq req = urlreq.Request("http: req.add_header( urlreq.urlopen(req).read()
import urllib.request contents = urllib.request.urlopen(urllib.request.Request( "https: headers={"Accept" : )).read() print(contents)
import urllib2 contents = urllib2.urlopen(urllib2.Request( "https: headers={"Accept" : )).read() print(contents)
from nap.url import Url api = Url( gists = api.join( response = gists.get(params={ print(response.json())
Error: pg_config executable not found. Please add the directory containing pg_config to the PATH or specify the full executable path with the option: python setup.py build_ext --pg-config /path/to/pg_config build ... or with the pg_config option in ---------------------------------------- Command python setup.py egg_info failed with error code 1 in /tmp/pip-build/psycopg2
curl -O http: rpm -ivh pgdg-centos91-9.1-4.noarch.rpm yum install postgresql yum install postgresql-devel PATH=$PATH:/usr/pgsql-9.1/bin/ pip install psycopg2
sudo yum install postgresql postgresql-devel python-devel
sudo apt-get install postgresql postgresql-dev python-dev
sudo PATH=$PATH:/usr/pgsql-9.3/bin/ pip install psycopg2
My-MacBook-Pro:~ Me$ /Applications/Postgres93.app/Contents/MacOS/bin/psql ; exit;
PATH=$PATH:/Applications/Postgres93.app/Contents/MacOS/bin/
PATH=$PATH:/Applications/Postgres.app/Contents/Versions/9.3/bin
PATH=$PATH:/usr/pgsql-9.1/bin/ ./pip install psycopg2
export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/latest/bin
$ wget http: $ tar -xzf psycopg2-2.5.3.tar.gz $ cd psycopg2-2.5.3 $ python setup.py install
python setup.py build_ext --pg-config /usr/pgsql-9.1/bin/pg_config build
python setup.py build_ext --pg-config /usr/pgsql-9.1/bin/pg_config build
>>> import sys >>> x = 2 >>> sys.getsizeof(x) 24 >>> sys.getsizeof(sys.getsizeof) 32 >>> sys.getsizeof( 38 >>> sys.getsizeof( 48
import sys from numbers import Number from collections import Set, Mapping, deque try: zero_depth_bases = (basestring, Number, xrange, bytearray) iteritems = except NameError: zero_depth_bases = (str, bytes, Number, range, bytearray) iteritems = def getsize(obj_0): _seen_ids = set() def inner(obj): obj_id = id(obj) if obj_id in _seen_ids: return 0 _seen_ids.add(obj_id) size = sys.getsizeof(obj) if isinstance(obj, zero_depth_bases): pass elif isinstance(obj, (tuple, list, Set, deque)): size += sum(inner(i) for i in obj) elif isinstance(obj, Mapping) or hasattr(obj, iteritems): size += sum(inner(k) + inner(v) for k, v in getattr(obj, iteritems)()) if hasattr(obj, size += inner(vars(obj)) if hasattr(obj, size += sum(inner(getattr(obj, s)) for s in obj.__slots__ if hasattr(obj, s)) return size return inner(obj_0)
>>> getsize([ 344 >>> getsize(Foo()) 16 >>> getsize(tuple( 194 >>> getsize([ 752 >>> getsize({ 400 >>> getsize({}) 280 >>> getsize({ 360 >>> getsize( 40 >>> class Bar(): ... def baz(): ... pass >>> getsize(Bar()) 352 >>> getsize(Bar().__dict__) 280 >>> sys.getsizeof(Bar()) 72 >>> getsize(Bar.__dict__) 872 >>> sys.getsizeof(Bar.__dict__) 280
from pylab import * from sys import getsizeof A = rand(10) B = rand(10000)
In [64]: getsizeof(A) Out[64]: 40 In [65]: getsizeof(B) Out[65]: 40
In [66]: A.nbytes Out[66]: 80 In [67]: B.nbytes Out[67]: 80000
from pympler import asizeof asizeof.asizeof(my_object)
>>> asizeof.asizeof(tuple( 200 >>> asizeof.asizeof({ 400 >>> asizeof.asizeof({}) 280 >>> asizeof.asizeof({ 360 >>> asizeof.asizeof( 40 >>> asizeof.asizeof(Bar()) 352 >>> asizeof.asizeof(Bar().__dict__) 280 >>> A = rand(10) >>> B = rand(10000) >>> asizeof.asizeof(A) 176 >>> asizeof.asizeof(B) 80096
import sys def get_size(obj, seen=None): size = sys.getsizeof(obj) if seen is None: seen = set() obj_id = id(obj) if obj_id in seen: return 0 seen.add(obj_id) if isinstance(obj, dict): size += sum([get_size(v, seen) for v in obj.values()]) size += sum([get_size(k, seen) for k in obj.keys()]) elif hasattr(obj, size += get_size(obj.__dict__, seen) elif hasattr(obj, size += sum([get_size(i, seen) for i in obj]) return size
import sys try: print sys.getsizeof(object) except AttributeError: print "sys.getsizeof exists in Python ≥2.6"
>>> print >>> from __future__ import print_function >>> print <built-in function print> >>>
>>> import __future__ >>> __future__.division _Feature((2, 2, 0,
def f(): ... def g(value): ... return g(value-1) + 1 ...
def fib(): a, b = 0, 1 while 1: yield b a, b = b, a+b
from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text, LEFT, DISABLED, NORMAL, RIDGE, END)
from Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \ LEFT, DISABLED, NORMAL, RIDGE, END
from Tkinter import Tk, Frame, Button, Entry, Canvas, Text from Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END
from __future__ import print_function ... print (v_num,end="") ...
from __future__ import print_function class Star(object): def __init__(self,count): self.count = count def start(self): for i in range(1,self.count): for j in range (i): print( print() a = Star(5) a.start() Output: * ** *** ****
def split_line(text): words = text.split() for word in words: print(word)
>>> line="a sentence with a few words" >>> line.split() [ >>>
import nltk words = nltk.word_tokenize(raw_sentence)
>>> import nltk >>> s = "The fox >>> words = nltk.word_tokenize(s) >>> words [
>>> text " >>> text.split() [" >>> import string >>> [word.strip(string.punctuation) for word in text.split()] [
>>> the_string = "this is a sentence" >>> words = the_string.split(" ") >>> print(words) [ >>> type(words) <type
def split_line(text): words = text.split() for current_word in words: print(words)
def split_line(text): words = text.split() for current_word in words: print(current_word)
my_list = [] for current_word in words: my_list.append(current_word.lower())
my_list = [current_word.lower() for current_word in words]
import string s = "string. With. Punctuation?" out = s.translate(string.maketrans("",""), string.punctuation)
import re, string, timeit s = "string. With. Punctuation" exclude = set(string.punctuation) table = string.maketrans("","") regex = re.compile( def test_set(s): return def test_re(s): return regex.sub( def test_trans(s): return s.translate(table, string.punctuation) def test_repl(s): for c in string.punctuation: s=s.replace(c,"") return s print "sets :",timeit.Timer( print "regex :",timeit.Timer( print "translate :",timeit.Timer( print "replace :",timeit.Timer(
sets : 19.8566138744 regex : 6.86155414581 translate : 2.12455511093 replace : 28.4436721802
import re s = "string. With. Punctuation?" s = re.sub(r
import string s = "string. With. Punctuation?" table = string.maketrans("","") new_s = s.translate(table, string.punctuation)
import string s = "string. With. Punctuation?" table = str.maketrans({key: None for key in string.punctuation}) new_s = s.translate(table)
>>> s = "string. With. Punctuation?" >>> import string >>> for c in string.punctuation: ... s= s.replace(c,"") ... >>> s
import re, string s = "string. With. Punctuation?" out = re.sub(
import string remove_punct_map = dict.fromkeys(map(ord, string.punctuation)) s.translate(remove_punct_map)
import unicodedata import sys remove_punct_map = dict.fromkeys(i for i in range(sys.maxunicode) if unicodedata.category(chr(i)).startswith(
import regex s = u"string. With. Some・Really Weird、Non？ASCII。 「（Punctuation）」?" remove = regex.compile(ur remove.sub(u" ", s).strip()
def stripPunc(wordList): puncList = [".",";",":","!","?","/","\\",","," for punc in puncList: for word in wordList: wordList=[word.replace(punc, return wordList
import re s = "string. With. Punctuation?" out = re.sub(ur
import string input_text = "!where??and!!or$$then:)" punctuation_replacer = string.maketrans(string.punctuation, print Output>> where and or then
table = str.maketrans({key: None for key in string.punctuation})
import re, string, timeit s = "string. With. Punctuation" def test_set(s): exclude = set(string.punctuation) return def test_set2(s): _punctuation = set(string.punctuation) for punct in set(s).intersection(_punctuation): s = s.replace(punct, return def test_re(s): regex = re.compile( return regex.sub( def test_trans(s): table = str.maketrans({key: None for key in string.punctuation}) return s.translate(table) def test_trans2(s): table = str.maketrans( return(s.translate(table)) def test_repl(s): for c in string.punctuation: s=s.replace(c,"") return s print("sets :",timeit.Timer( print("sets2 :",timeit.Timer( print("regex :",timeit.Timer( print("translate :",timeit.Timer( print("translate2 :",timeit.Timer( print("replace :",timeit.Timer(
sets : 3.1830138750374317 sets2 : 2.189873124472797 regex : 7.142953420989215 translate : 4.243278483860195 translate2 : 2.427158243022859 replace : 4.579746678471565
>>> s = "string. With. Punctuation?" >>> s = re.sub(r >>> re.split(r [
import re s = "string. With. Punctuation?" out = re.sub(r
punctuation= newstring= word=raw_input("Enter string: ") for i in word: if(i not in punctuation): newstring+=i print "The string without punctuation is",newstring word=raw_input("Enter string: ") punctuation= newstring=word.translate(None,punctuation) print "The string without punctuation is",newstring Enter string: hello! welcome -to_python(programming.language)??, The string without punctuation is: hello welcome topythonprogramminglanguage
with open( str1=myFile.read() print(str1) punctuation = [ for i in punctuation: str1 = str1.replace(i," ") myList=[] myList.extend(str1.split(" ")) print (str1) for i in myList: print(i,end= print ("____________")
print( with open( str1=myFile.read() stop_words ="not", "is", "it", "By","between","This","By","A","when","And","up","Then","was","by","It","If","can","an","he","This","or","And","a","i","it","am","at","on","in","of","to","is","so","too","my","the","and","but","are","very","here","even","from","them","then","than","this","that","though","be","But","these" myList=[] myList.extend(str1.split(" ")) for i in myList: if i not in stop_words: print ("____________") print(i,end=
print( with open( str1=myFile.read() str1.lower() print(str1.lower()) print( with open( str1=myFile.read() str1.upper() print(str1.upper())
def scrub(abc): while abc[-1] is in list(string.punctuation): abc=abc[:-1] while abc[0] is in list(string.punctuation): abc=abc[1:] return abc
x = 0 y = 1 z = 3 mylist = [] if x or y or z == 0 : mylist.append("c") if x or y or z == 1 : mylist.append("d") if x or y or z == 2 : mylist.append("e") if x or y or z == 3 : mylist.append("f")
x = 0 y = 1 z = 3 d = {0: mylist = [d[k] for k in [x, y, z]]
if 0 in {x, y, z}: Mylist.append("c") elif 1 in {x, y, z}: Mylist.append("d") ...
if 0 in {x, y, z}: Mylist.append("c") if 1 in {x, y, z}: Mylist.append("d") if 2 in {x, y, z}: Mylist.append("e") ...
numToLetters = {0:"c", 1:"d", 2:"e", 3:"f"} for number in numToLetters: if number in {x, y, z}: Mylist.append(numToLetters[number])
if any(map((lambda value: value == 0), (x,y,z))): pass
my_cases = { 0: Mylist.append("c"), 1: Mylist.append("d") } for key in my_cases: if key in (x,y,z): my_cases[key]() break
list = [] list.append(x) list.append(y) list.append(z) nums = [add numbers here] letters = [add corresponding letters here] for index in range(len(nums)): for obj in list: if obj == num[index]: MyList.append(letters[index]) break
from itertools import repeat from operator import contains
my_dict = {0: "c", 1: "d", 2: "e", 3: "f"} def validate(x, y, z): for ele in [x, y, z]: if ele in my_dict.keys(): return my_dict[ele]
print validate(0, 8, 9) c print validate(9, 8, 9) None print validate(9, 8, 2) e
myList = [] aList = [0, 1, 3] for l in aList: if l==0: myList.append( elif l==1: myList.append( elif l==2: myList.append( elif l==3: myList.append( print(myList)
>>> x = "Wild things" >>> y = "throttle it back" >>> z = "in the beginning" >>> if "Wild" in {x, y, z}: print (True) ...
>>> x = "Wild things" >>> y = "throttle it back" >>> z = "in the beginning" >>> if "Wild" in [x, y, z]: print (True) ...
>>> [x, y, z] [ >>> {x, y, z} { >>> >>> if "Wild" in str([x, y, z]): print (True) ... True >>> if "Wild" in str({x, y, z}): print (True) ... True
>>> x=[ >>> if "rot" in str(x): print(True) ... True
d = {0: x, y, z = (0, 1, 3) print [v for (k,v) in d.items() if x==k or y==k or z==k]
L ={x, y, z} T= ((0,"c"),(1,"d"),(2,"e"),(3,"f"),) List2=[] for t in T : if t[0] in L : List2.append(t[1]) break;
mydict = {0:"c", 1:"d", 2:"e", 3:"f"} mylist= [] num_var = int(raw_input("How many variables? ")) for i in range(num_var): globals()[ mylist += mydict[globals()[ print mylist >>> [
x = 0 y = 1 z = 3 mylist = [] if any(v == 0 for v in (x, y, z)): mylist.append("c") if any(v == 1 for v in (x, y, z)): mylist.append("d") if any(v == 2 for v in (x, y, z)): mylist.append("e") if any(v == 3 for v in (x, y, z)): mylist.append("f")
input_values = (0, 1, 3) origo = ord( [chr(val + origo) for val in inputs]
for value in [var1,var2,var3]: li.append("targetValue")
x = 0 y = 1 z = 3 list=[] dict = {0: if x in dict: list.append(dict[x]) else: pass if y in dict: list.append(dict[y]) else: pass if z in dict: list.append(dict[z]) else: pass print list
>>> import uuid >>> uuid.uuid4() UUID( >>> str(uuid.uuid4()) >>> uuid.uuid4().hex
>>> import uuid >>> >>> uuid.uuid1() UUID( >>> >>> uuid.uuid3(uuid.NAMESPACE_DNS, UUID( >>> >>> uuid.uuid4() UUID( >>> >>> uuid.uuid5(uuid.NAMESPACE_DNS, UUID( >>> >>> x = uuid.UUID( >>> >>> str(x) >>> >>> x.bytes >>> >>> uuid.UUID(bytes=x.bytes) UUID(
import base64 import uuid def get_a_uuid(): r_uuid = base64.urlsafe_b64encode(uuid.uuid4().bytes) return r_uuid.replace(
import random as r def generate_uuid(): random_string = random_str_seq = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" uuid_format = [8, 4, 4, 4, 12] for n in uuid_format: for i in range(0,n): random_string += str(random_str_seq[r.randint(0, len(random_str_seq) - 1)]) if n != 12: random_string += return random_string
$ otool -L bin/python python: @executable_path/../Python (compatibility version 3.4.0, current version 3.4.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
>>> import calendar >>> calendar.monthrange(2002,1) (1, 31) >>> calendar.monthrange(2008,2) (4, 29) >>> calendar.monthrange(2100,2) (0, 28)
>>> from calendar import monthrange >>> monthrange(2012, 2) (2, 29)
import datetime def last_day_of_month(any_day): next_month = any_day.replace(day=28) + datetime.timedelta(days=4) return next_month - datetime.timedelta(days=next_month.day)
>>> for month in range(1, 13): ... print last_day_of_month(datetime.date(2012, month, 1)) ... 2012-01-31 2012-02-29 2012-03-31 2012-04-30 2012-05-31 2012-06-30 2012-07-31 2012-08-31 2012-09-30 2012-10-31 2012-11-30 2012-12-31
>>> import datetime >>> datetime.date (2000, 2, 1) - datetime.timedelta (days = 1) datetime.date(2000, 1, 31) >>>
def last_day_of_month(date): if date.month == 12: return date.replace(day=31) return date.replace(month=date.month+1, day=1) - datetime.timedelta(days=1) >>> last_day_of_month(datetime.date(2002, 1, 17)) datetime.date(2002, 1, 31) >>> last_day_of_month(datetime.date(2002, 12, 9)) datetime.date(2002, 12, 31) >>> last_day_of_month(datetime.date(2008, 2, 14)) datetime.date(2008, 2, 29)
from datetime import datetime from dateutil.relativedelta import relativedelta date_in_feb = datetime.datetime(2013, 2, 21) print datetime.datetime(2013, 2, 21) + relativedelta(day=31) >>> datetime.datetime(2013, 2, 28, 0, 0)
from dateutil.relativedelta import relativedelta last_date_of_month = datetime(mydate.year,mydate.month,1)+relativedelta(months=1,days=-1)
from datetime import datetime def last_day_of_month(year, month): last_days = [31, 30, 29, 28, 27] for i in last_days: try: end = datetime(year, month, i) except ValueError: continue else: return end.date() return None
>>> >>> last_day_of_month(2008, 2) datetime.date(2008, 2, 29) >>> last_day_of_month(2009, 2) datetime.date(2009, 2, 28) >>> last_day_of_month(2008, 11) datetime.date(2008, 11, 30) >>> last_day_of_month(2008, 12) datetime.date(2008, 12, 31)
from datetime import timedelta (any_day.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
>>> import datetime >>> import calendar >>> date = datetime.datetime.now() >>> print date 2015-03-06 01:25:14.939574 >>> print date.replace(day = 1) 2015-03-01 01:25:14.939574 >>> print date.replace(day = calendar.monthrange(date.year, date.month)[1]) 2015-03-31 01:25:14.939574
from datetime import date, timedelta import calendar last_day = date.today().replace(day=calendar.monthrange(date.today().year, date.today().month)[1])
calendar.monthrange(date.today().year, date.today().month)[1]
>>> date.today() datetime.date(2017, 1, 3) >>> date.today().replace(day=31) datetime.date(2017, 1, 31)
import datetime now = datetime.datetime.now() start_month = datetime.datetime(now.year, now.month, 1) date_on_next_month = start_month + datetime.timedelta(35) start_next_month = datetime.datetime(date_on_next_month.year, date_on_next_month.month, 1) last_day_month = start_next_month - datetime.timedelta(1)
selected_date = date(some_year, some_month, some_day) if selected_date.month == 12: last_day_selected_month = date(selected_date.year, selected_date.month, 31) else: last_day_selected_month = date(selected_date.year, selected_date.month + 1, 1) - timedelta(days=1)
import datetime as dt from dateutil.relativedelta import relativedelta thisDate = dt.datetime(2017, 11, 17) last_day_of_the_month = dt.datetime(thisDate.year, (thisDate + relativedelta(months=1)).month, 1) - dt.timedelta(days=1) print last_day_of_the_month
import datetime as dt import calendar from dateutil.relativedelta import relativedelta someDates = [dt.datetime.today() - dt.timedelta(days=x) for x in range(0, 10000)] start1 = dt.datetime.now() for thisDate in someDates: lastDay = dt.datetime(thisDate.year, (thisDate + relativedelta(months=1)).month, 1) - dt.timedelta(days=1) print ( start2 = dt.datetime.now() for thisDate in someDates: lastDay = dt.datetime(thisDate.year, thisDate.month, calendar.monthrange(thisDate.year, thisDate.month)[1]) print (
Time Spent= 0:00:00.097814 Time Spent= 0:00:00.109791
import datetime def end_date_of_a_month(date): start_date_of_this_month = date.replace(day=1) month = start_date_of_this_month.month year = start_date_of_this_month.year if month == 12: month = 1 year += 1 else: month += 1 next_month_start_date = start_date_of_this_month.replace(month=month, year=year) this_month_end_date = next_month_start_date - datetime.timedelta(days=1) return this_month_end_date
end_date_of_a_month(datetime.datetime.now().date())
some_date = datetime.date(2012, 5, 23) last_weekday = np.asarray(calendar.monthcalendar(some_date.year, some_date.month))[:,0:-2].ravel().max() print last_weekday 31
def isMonthEnd(date): return date + pd.offsets.MonthEnd(0) == date isMonthEnd(datetime(1999, 12, 31)) True isMonthEnd(pd.Timestamp( True isMonthEnd(pd.Timestamp(1965, 1, 10)) False
import datetime import calendar date=datetime.datetime.now() month_end_date=datetime.datetime(date.year,date.month,1) + datetime.timedelta(days=calendar.monthrange(date.year,date.month)[1] - 1)
import calendar from time import gmtime, strftime calendar.monthrange(int(strftime("%Y", gmtime())), int(strftime("%m", gmtime())))[1]
import calendar from time import gmtime, strftime lastDay = calendar.monthrange(int(strftime("%Y", gmtime())), int(strftime("%m", gmtime())))[1] today = strftime("%d", gmtime()) lastDay == today
def eomday(year, month): days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] d = days_per_month[month - 1] if month == 2 and (year % 4 == 0 and year % 100 != 0 or year % 400 == 0): d = 29 return d
def last_day_of_month(any_days): res = [] for any_day in any_days: nday = any_day.days_in_month -any_day.day res.append(any_day + timedelta(days=nday)) return res
import datetime def DateTime( d ): return datetime.datetime.strptime( d, def RelativeDate( start, num_days ): d = DateTime( start ) return str( d + datetime.timedelta( days = num_days ) ) def get_first_day_of_month( dt ): return dt[:-2] + def get_last_day_of_month( dt ): fd = get_first_day_of_month( dt ) fd_next_month = get_first_day_of_month( RelativeDate( fd, 31 ) ) return RelativeDate( fd_next_month, -1 )
datetime.date(year + int(month/12), (month+1)%12, 1)-datetime.timdelta(days=1)
next_month = lambda y, m, d: (y, m + 1, 1) if m + 1 < 13 else ( y+1 , 1, 1) month_end = lambda dte: date( *next_month( *dte.timetuple()[:3] ) ) - timedelta(days=1)
import time from datetime import datetime, date from datetime import timedelta from dateutil import relativedelta start_date = fields.Date( string= required=True, ) end_date = fields.Date( string= required=True, ) _defaults = { }
import datetime datetime.date(2012,2, 1).replace(day=1,month=datetime.date(2012,2,1).month+1)-timedelta(days=1) datetime.date(2012, 2, 29)
>>> s = pd.Series(["8", 6, "7.5", 3, "0.9"]) >>> s 0 8 1 6 2 7.5 3 3 4 0.9 dtype: object >>> pd.to_numeric(s) 0 8.0 1 6.0 2 7.5 3 3.0 4 0.9 dtype: float64
my_series = pd.to_numeric(my_series) df["a"] = pd.to_numeric(df["a"])
df = df.apply(pd.to_numeric) df[["a", "b"]] = df[["a", "b"]].apply(pd.to_numeric)
>>> s = pd.Series([ >>> s 0 1 1 2 2 4.7 3 pandas 4 10 dtype: object
>>> pd.to_numeric(s) ValueError: Unable to parse string
>>> pd.to_numeric(s, errors= 0 1.0 1 2.0 2 4.7 3 NaN 4 10.0 dtype: float64
>>> s = pd.Series([1, 2, -7]) >>> s 0 1 1 2 2 -7 dtype: int64
>>> pd.to_numeric(s, downcast= 0 1 1 2 2 -7 dtype: int8
>>> pd.to_numeric(s, downcast= 0 1.0 1 2.0 2 -7.0 dtype: float32
df = df.astype(int) df = df.astype({"a": int, "b": complex}) s = s.astype(np.float16) s = s.astype(str) s = s.astype(
>>> s = pd.Series([1, 2, -7]) >>> s 0 1 1 2 2 -7 dtype: int64
>>> df = pd.DataFrame({ >>> df.dtypes a object b object dtype: object
>>> df = df.infer_objects() >>> df.dtypes a int64 b object dtype: object
a = [[ df = pd.DataFrame(a, columns=[ df Out[16]: one two three 0 a 1.2 4.2 1 b 70 0.03 2 x 5 0 df.dtypes Out[17]: one object two object three object df[[ df.dtypes Out[19]: one object two float64 three float64
def coerce_df_columns_to_numeric(df, column_list): df[column_list] = df[column_list].apply(pd.to_numeric, errors=
import pandas as pd def coerce_df_columns_to_numeric(df, column_list): df[column_list] = df[column_list].apply(pd.to_numeric, errors= a = [[ df = pd.DataFrame(a, columns=[ coerce_df_columns_to_numeric(df, [
d1 = pd.DataFrame(columns=[ d1 = d1.append(pd.DataFrame(columns=[
In[8}: d1.dtypes Out[8]: float_column float64 string_column object dtype: object
a = [[ df = pd.DataFrame(a, columns=[ df = df.astype({
a = 19998989890 b = 19998989889 +1 >>> a is b False >>> a == b True
data = [[1,2,3], [4,5,6], [7,8,9]] data = [(1,2,3), (4,5,6), (7,8,9)]
sorted_by_second = sorted(data, key=lambda tup: tup[1])
from operator import itemgetter data.sort(key=itemgetter(1))
decorated = [(tup[1], tup) for tup in data] decorated.sort() undecorated = [tup for second, tup in decorated]
[b for a,b in sorted((tup[1], tup) for tup in data)]
sorted(data, key=lambda tup: (tup[1],tup[2]) ) [(1, 1, 4), (1, 2, 1), (1, 2, 3)]
>>> gunters = [( >>> gunters.sort(key=lambda tup: tup[0]) >>> print gunters [(
>>> from operator import itemgetter >>> from numpy.random import randint >>> values = randint(0, 9, 30000).reshape((10000,3)) >>> tpls = [tuple(values[i,:]) for i in range(len(values))] >>> tpls[:5] [(1, 0, 0), (8, 5, 5), (5, 4, 0), (5, 7, 7), (4, 2, 1)] >>> sorted(tpls[:5], key=itemgetter(1)) [(1, 0, 0), (4, 2, 1), (5, 4, 0), (8, 5, 5), (5, 7, 7)] >>> %timeit sorted(tpls, key=itemgetter(1)) 100 loops, best of 3: 4.89 ms per loop >>> %timeit sorted(tpls, key=lambda tup: tup[1]) 100 loops, best of 3: 6.39 ms per loop >>> %timeit sorted(tpls, key=(itemgetter(1,0))) 100 loops, best of 3: 16.1 ms per loop >>> %timeit sorted(tpls, key=lambda tup: (tup[1], tup[0])) 100 loops, best of 3: 17.1 ms per loop
text_file = open("Output.txt", "w") text_file.write("Purchase Amount: " text_file.close()
text_file = open("Output.txt", "w") text_file.write("Purchase Amount: %s" % TotalAmount) text_file.close()
with open("Output.txt", "w") as text_file: text_file.write("Purchase Amount: %s" % TotalAmount)
with open("Output.txt", "w") as text_file: text_file.write("Purchase Amount: {0}".format(TotalAmount))
with open("Output.txt", "w") as text_file: print("Purchase Amount: {}".format(TotalAmount), file=text_file)
with open("Output.txt", "w") as text_file: print(f"Purchase Amount: {TotalAmount}", file=text_file)
price = 33.3 with open("Output.txt", "w") as text_file: text_file.write("Purchase Amount: %s price %f" % (TotalAmount, price))
your_data = {"Purchase Amount": print(your_data, file=open(
def my_func(): return 25.256 def write_file(data): file_name = r with open(file_name, x_file.write( def run(): data = my_func() write_file(data) run()
import pathlib pathlib.Path("output.txt").write_text("Purchase Amount: {}" .format(TotalAmount))
pathlib.Path("output.txt").write_text(f"Purchase Amount: {TotalAmount}")
file=open( file.write("Purchase Amount: " file.close()
import os string_input = "Hello World" os.system("echo %s > output_file.txt" %string_input)
import os string_input = "Hello World" os.system("echo %s | tee output_file.txt" %string_input)
permutations([]) [] permutations([1]) [1] permutations([1, 2]) [1, 2] [2, 1] permutations([1, 2, 3]) [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1]
import itertools list(itertools.permutations([1, 2, 3]))
def all_perms(elements): if len(elements) <=1: yield elements else: for perm in all_perms(elements[1:]): for i in range(len(elements)): yield perm[:i] + elements[0:1] + perm[i:]
def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r if r > n: return indices = range(n) cycles = range(n, n-r, -1) yield tuple(pool[i] for i in indices[:r]) while n: for i in reversed(range(r)): cycles[i] -= 1 if cycles[i] == 0: indices[i:] = indices[i+1:] + indices[i:i+1] cycles[i] = n - i else: j = cycles[i] indices[i], indices[-j] = indices[-j], indices[i] yield tuple(pool[i] for i in indices[:r]) break else: return
def permutations(iterable, r=None): pool = tuple(iterable) n = len(pool) r = n if r is None else r for indices in product(range(n), repeat=r): if len(set(indices)) == r: yield tuple(pool[i] for i in indices)
print list(itertools.permutations([1,2,3,4], 2)) [(1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), (3, 1), (3, 2), (3, 4), (4, 1), (4, 2), (4, 3)]
print list(itertools.product([1,2,3], [4,5,6])) [(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]
print list(itertools.product([1,2], repeat=3)) [(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2), (2, 1, 1), (2, 1, 2), (2, 2, 1), (2, 2, 2)]
def permutations(head, tail= if len(head) == 0: print tail else: for i in range(len(head)): permutations(head[0:i] + head[i+1:], tail+head[i])
def permutations (orig_list): if not isinstance(orig_list, list): orig_list = list(orig_list) yield orig_list if len(orig_list) == 1: return for n in sorted(orig_list): new_list = orig_list[:] pos = new_list.index(n) del(new_list[pos]) new_list.insert(0, n) for resto in permutations(new_list[1:]): if new_list[:1] + resto <> orig_list: yield new_list[:1] + resto
def perm(a, k=0): if k == len(a): print a else: for i in xrange(k, len(a)): a[k], a[i] = a[i] ,a[k] perm(a, k+1) a[k], a[i] = a[i], a[k] perm([1,2,3])
[1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 2, 1] [3, 1, 2]
def permute_in_place(a): a.sort() yield list(a) if len(a) <= 1: return first = 0 last = len(a) while 1: i = last - 1 while 1: i = i - 1 if a[i] < a[i+1]: j = last - 1 while not (a[i] < a[j]): j = j - 1 a[i], a[j] = a[j], a[i] r = a[i+1:last] r.reverse() a[i+1:last] = r yield list(a) break if i == first: a.reverse() return if __name__ == for n in range(5): for a in permute_in_place(range(1, n+1)): print a print for a in permute_in_place([0, 0, 1, 1, 1]): print a print
def permutList(l): if not l: return [[]] res = [] for e in l: temp = l[:] temp.remove(e) res.extend([[e] + r for r in permutList(temp)]) return res
def addperm(x,l): return [ l[0:i] + [x] + l[i:] for i in range(len(l)+1) ] def perm(l): if len(l) == 0: return [[]] return [x for y in perm(l[1:]) for x in addperm(l[0],y) ] print perm([ i for i in range(3)])
[[0, 1, 2], [1, 0, 2], [1, 2, 0], [0, 2, 1], [2, 0, 1], [2, 1, 0]]
list2Perm = [1, 2.0, listPerm = [[a, b, c] for a in list2Perm for b in list2Perm for c in list2Perm if ( a != b and b != c and a != c ) ] print listPerm
global result result = [] def permutation(li): if li == [] or li == None: return if len(li) == 1: result.append(li[0]) print result result.pop() return for i in range(0,len(li)): result.append(li[i]) permutation(li[:i] + li[i+1:]) result.pop()
[1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1]
from math import factorial def permutations(l): permutations=[] length=len(l) for x in xrange(factorial(length)): available=list(l) newPermutation=[] for radix in xrange(length, 0, -1): placeValue=factorial(radix-1) index=x/placeValue newPermutation.append(available.pop(index)) x-=index*placeValue permutations.append(newPermutation) return permutations permutations(range(3))
[[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]
def all_perms(elements): if len(elements) <= 1: yield elements else: for (index, first_elmt) in enumerate(elements): other_elmts = elements[:index]+elements[index+1:] for permutation in all_perms(other_elmts): yield [first_elmt] + permutation
def permutation(list): if len(list) == 0: return [[]] else: return [[x] + ys for x in list for ys in permutation(delete(list, x))] def delete(list, item): lc = list[:] lc.remove(item) return lc
from numpy import empty, uint8 from math import factorial def perms(n): f = 1 p = empty((2*n-1, factorial(n)), uint8) for i in range(n): p[i, :f] = i p[i+1:2*i+1, :f] = p[:i, :f] for j in range(i): p[:i+1, f*(j+1):f*(j+2)] = p[j+1:j+i+2, :f] f = f*(i+1) return p[:n, :]
In [1]: %timeit -n10 list(permutations(range(10))) 10 loops, best of 3: 815 ms per loop In [2]: %timeit -n100 perms(10) 100 loops, best of 3: 40 ms per loop
from __future__ import print_function def perm(n): p = [] for i in range(0,n+1): p.append(i) while True: for i in range(1,n+1): print(p[i], end= print("") i = n - 1 found = 0 while (not found and i>0): if p[i]<p[i+1]: found = 1 else: i = i - 1 k = n while p[i]>p[k]: k = k - 1 aux = p[i] p[i] = p[k] p[k] = aux for j in range(1,(n-i)/2+1): aux = p[i+j] p[i+j] = p[n-j+1] p[n-j+1] = aux if not found: break perm(5)
def permute(xs, low=0): if low + 1 >= len(xs): yield xs else: for p in permute(xs, low + 1): yield p for i in range(low + 1, len(xs)): xs[low], xs[i] = xs[i], xs[low] for p in permute(xs, low + 1): yield p xs[low], xs[i] = xs[i], xs[low] for p in permute([1, 2, 3, 4]): print p
>>> import copy >>> def perm(prefix,rest): ... for e in rest: ... new_rest=copy.copy(rest) ... new_prefix=copy.copy(prefix) ... new_prefix.append(e) ... new_rest.remove(e) ... if len(new_rest) == 0: ... print new_prefix + new_rest ... continue ... perm(new_prefix,new_rest) ... >>> perm([],[ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [
def pzip(c, seq): result = [] for item in seq: for i in range(len(item)+1): result.append(item[i:]+c+item[:i]) return result def perm(line): seq = [c for c in line] if len(seq) <=1 : return seq else: return pzip(seq[0], perm(seq[1:]))
def permute(items): length = len(items) def inner(ix=[]): do_yield = len(ix) == length - 1 for i in range(0, length): if i in ix: continue if do_yield: yield tuple([items[y] for y in ix + [i]]) else: for p in inner(ix + [i]): yield p return inner()
for p in permute((1,2,3)): print(p) (1, 2, 3) (1, 3, 2) (2, 1, 3) (2, 3, 1) (3, 1, 2) (3, 2, 1)
def calcperm(arr, size): result = set([()]) for dummy_idx in range(size): temp = set() for dummy_lst in result: for dummy_outcome in arr: if dummy_outcome not in dummy_lst: new_seq = list(dummy_lst) new_seq.append(dummy_outcome) temp.add(tuple(new_seq)) result = temp return result
lst = [1, 2, 3, 4] seq = 2 final = calcperm(lst, seq) print(len(final)) print(final)
def all_insert(x, e, i=0): return [x[0:i]+[e]+x[i:]] + all_insert(x,e,i+1) if i<len(x)+1 else [] def for_each(X, e): return all_insert(X[0], e) + for_each(X[1:],e) if X else [] def permute(x): return [x] if len(x) < 2 else for_each( permute(x[1:]) , x[0]) perms = permute([1,2,3])
def permutation(flag, k =1 ): N = len(flag) for i in xrange(0, N): if flag[i] != 0: continue flag[i] = k if k == N: print flag permutation(flag, k+1) flag[i] = 0 permutation([0, 0, 0])
def permutes(input,offset): if( len(input) == offset ): return [ result=[] for i in range( offset, len(input) ): input[offset], input[i] = input[i], input[offset] result = result + permutes(input,offset+1) input[offset], input[i] = input[i], input[offset] return result def permutations(input): return permutes( list(input), 0 ) print( permutations("wxyz") )
def permutation(word, first_char=None): if word == None or len(word) == 0: return [] if len(word) == 1: return [word] result = [] first_char = word[0] for sub_word in permutation(word[1:], first_char): result += insert(first_char, sub_word) return sorted(result) def insert(ch, sub_word): arr = [ch + sub_word] for i in range(len(sub_word)): arr.append(sub_word[i:] + ch + sub_word[:i]) return arr assert permutation(None) == [] assert permutation( assert permutation( assert permutation( print permutation(
@numba.njit() def permutations(A, k): r = [[i for i in range(0)]] for i in range(k): r = [[a] + b for a in A for b in r if (a in b)==False] return r permutations([1,2,3],3) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
%timeit permutations(np.arange(5),5) 243 µs ± 11.1 µs per loop (mean ± std. dev. of 7 runs, 1 loop each) time: 406 ms %timeit list(itertools.permutations(np.arange(5),5)) 15.9 µs ± 8.61 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) time: 12.9 s
def permutations(arr): if not arr: return print arr for idx, val in enumerate(arr): permutations(arr[:idx]+arr[idx+1:])
from itertools import product, permutations A = ([1,2,3]) print (list(permutations(sorted(A),2)))
class Abstract1( object ): def aMethod( self ): raise NotImplementedError( "Should have implemented this" )
class SomeAbstraction( object ): pass class Mixin1( object ): def something( self ): pass class Mixin2( object ): def something( self ): pass class Concrete1( SomeAbstraction, Mixin1 ): pass class Concrete2( SomeAbstraction, Mixin2 ): pass
import collections class MySet(collections.Set): pass
>>> MySet() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: Can __contains__, __iter__, __len__
class ListBasedSet(collections.Set): def __init__(self, iterable): self.elements = lst = [] for value in iterable: if value not in lst: lst.append(value) def __iter__(self): return iter(self.elements) def __contains__(self, value): return value in self.elements def __len__(self): return len(self.elements) s1 = ListBasedSet( s2 = ListBasedSet( overlap = s1 & s2
class Effable(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def __str__(self): raise NotImplementedError(
class Effable(object, metaclass=abc.ABCMeta): @abc.abstractmethod def __str__(self): raise NotImplementedError(
>>> MyEffable() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: Can
class MyEffable(Effable): def __str__(self): return
>>> x = dict2obj(d) >>> x.a 1 >>> x.b.c 2 >>> x.d[1].foo bar
>>> from collections import namedtuple >>> MyStruct = namedtuple( >>> s = MyStruct(a=1, b={ >>> s MyStruct(a=1, b={ >>> s.a 1 >>> s.b { >>> s.c Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: >>> s.d [
class Struct: def __init__(self, **entries): self.__dict__.update(entries)
>>> args = { >>> s = Struct(**args) >>> s <__main__.Struct instance at 0x01D6A738> >>> s.a 1 >>> s.b 2
class obj(object): def __init__(self, d): for a, b in d.items(): if isinstance(b, (list, tuple)): setattr(self, a, [obj(x) if isinstance(x, dict) else x for x in b]) else: setattr(self, a, obj(b) if isinstance(b, dict) else b) >>> d = { >>> x = obj(d) >>> x.b.c 2 >>> x.d[1].foo
>>> from bunch import bunchify >>> d = { >>> x = bunchify(d) >>> x.a 1 >>> x.b.c 2 >>> x.d[1].foo
>>> d { >>> def obj_dic(d): top = type( seqs = tuple, list, set, frozenset for i, j in d.items(): if isinstance(j, dict): setattr(top, i, obj_dic(j)) elif isinstance(j, seqs): setattr(top, i, type(j)(obj_dic(sj) if isinstance(sj, dict) else sj for sj in j)) else: setattr(top, i, j) return top >>> x = obj_dic(d) >>> x.a 1 >>> x.b.c 2 >>> x.d[1].foo
from collections import namedtuple d_named = namedtuple( In [7]: d_named Out[7]: Struct(a=1, b={ In [8]: d_named.a Out[8]: 1
class Struct: def __init__(self, obj): for k, v in obj.iteritems(): if isinstance(v, dict): setattr(self, k, Struct(v)) else: setattr(self, k, v) def __getitem__(self, val): return self.__dict__[val] def __repr__(self): return (k, v) in self.__dict__.iteritems()))
class Struct(object): def __init__(self, data): for name, value in data.iteritems(): setattr(self, name, self._wrap(value)) def _wrap(self, value): if isinstance(value, (tuple, list, set, frozenset)): return type(value)([self._wrap(v) for v in value]) else: return Struct(value) if isinstance(value, dict) else value
import json from collections import namedtuple json.loads(data, object_hook=lambda d: namedtuple(
class Dictate(object): """Object view of a dict, updating the passed in dict when values are set or deleted. "Dictate" the contents of a dict...: """ def __init__(self, d): object.__setattr__(self, def __getitem__(self, name): value = self.__dict[name] if isinstance(value, dict): value = Dictate(value) return value def __setitem__(self, name, value): self.__dict[name] = value def __delitem__(self, name): del self.__dict[name] def __getattr__(self, name): return self[name] def __setattr__(self, name, value): self[name] = value def __delattr__(self, name): del self[name] def __repr__(self): return "%s(%r)" % (type(self).__name__, self.__dict) def __str__(self): return str(self.__dict)
d = { dd = Dictate(d) assert dd.a == assert dd[1] == 2 dd.c = assert d[ del dd.a del dd[1] dd.e = {} dd.e.f = assert dd[ assert d == {
>>> def dict2obj(d): if isinstance(d, list): d = [dict2obj(x) for x in d] if not isinstance(d, dict): return d class C(object): pass o = C() for k in d: o.__dict__[k] = dict2obj(d[k]) return o >>> d = { >>> x = dict2obj(d) >>> x.a 1 >>> x.b.c 2 >>> x.d[1].foo
class DictProxy(object): def __init__(self, obj): self.obj = obj def __getitem__(self, key): return wrap(self.obj[key]) def __getattr__(self, key): try: return wrap(getattr(self.obj, key)) except AttributeError: try: return self[key] except KeyError: raise AttributeError(key) class ListProxy(object): def __init__(self, obj): self.obj = obj def __getitem__(self, key): return wrap(self.obj[key]) def wrap(value): if isinstance(value, dict): return DictProxy(value) if isinstance(value, (tuple, list)): return ListProxy(value) return value
class dict2obj(object): def __init__(self, d): self.__dict__[ def __getattr__(self, key): value = self.__dict__[ if type(value) == type({}): return dict2obj(value) return value d = { x = dict2obj(d) print x.a print x.b.c print x.d[1].foo
class Object( dict ): def __init__( self, data = None ): super( Object, self ).__init__() if data: self.__update( data, {} ) def __update( self, data, did ): dataid = id(data) did[ dataid ] = self for k in data: dkid = id(data[k]) if did.has_key(dkid): self[k] = did[dkid] elif isinstance( data[k], Object ): self[k] = data[k] elif isinstance( data[k], dict ): obj = Object() obj.__update( data[k], did ) self[k] = obj obj = None else: self[k] = data[k] def __getattr__( self, key ): return self.get( key, None ) def __setattr__( self, key, value ): if isinstance(value,dict): self[key] = Object( value ) else: self[key] = value def update( self, *args ): for obj in args: for k in obj: if isinstance(obj[k],dict): self[k] = Object( obj[k] ) else: self[k] = obj[k] return self def merge( self, *args ): for obj in args: for k in obj: if self.has_key(k): if isinstance(self[k],list) and isinstance(obj[k],list): self[k] += obj[k] elif isinstance(self[k],list): self[k].append( obj[k] ) elif isinstance(obj[k],list): self[k] = [self[k]] + obj[k] elif isinstance(self[k],Object) and isinstance(obj[k],Object): self[k].merge( obj[k] ) elif isinstance(self[k],Object) and isinstance(obj[k],dict): self[k].merge( obj[k] ) else: self[k] = [ self[k], obj[k] ] else: if isinstance(obj[k],dict): self[k] = Object( obj[k] ) else: self[k] = obj[k] return self def test01(): class UObject( Object ): pass obj = Object({1:2}) d = {} d.update({ "a": 1, "b": { "c": 2, "d": [ 3, 4, 5 ], "e": [ [6,7], (8,9) ], "self": d, }, 1: 10, "1": 11, "obj": obj, }) x = UObject(d) assert x.a == x["a"] == 1 assert x.b.c == x["b"]["c"] == 2 assert x.b.d[0] == 3 assert x.b.d[1] == 4 assert x.b.e[0][0] == 6 assert x.b.e[1][0] == 8 assert x[1] == 10 assert x["1"] == 11 assert x[1] != x["1"] assert id(x) == id(x.b.self.b.self) == id(x.b.self) assert x.b.self.a == x.b.self.b.self.a == 1 x.x = 12 assert x.x == x["x"] == 12 x.y = {"a":13,"b":[14,15]} assert x.y.a == 13 assert x.y.b[0] == 14 def test02(): x = Object({ "a": { "b": 1, "c": [ 2, 3 ] }, 1: 6, 2: [ 8, 9 ], 3: 11, }) y = Object({ "a": { "b": 4, "c": [ 5 ] }, 1: 7, 2: 10, 3: [ 12 , 13 ], }) z = { 3: 14, 2: 15, "a": { "b": 16, "c": 17, } } x.merge( y, z ) assert 2 in x.a.c assert 3 in x.a.c assert 5 in x.a.c assert 1 in x.a.b assert 4 in x.a.b assert 8 in x[2] assert 9 in x[2] assert 10 in x[2] assert 11 in x[3] assert 12 in x[3] assert 13 in x[3] assert 14 in x[3] assert 15 in x[2] assert 16 in x.a.b assert 17 in x.a.c if __name__ == test01() test02()
import json class obj(object): def __init__(self, dict_): self.__dict__.update(dict_) def dict2obj(d): return json.loads(json.dumps(d), object_hook=obj)
>>> d = { >>> o = dict2obj(d) >>> o.a 1 >>> o.b.c 2 >>> o.d[0] u >>> o.d[1].foo u
def dict2obj(d): if isinstance(d, dict): n = {} for item in d: if isinstance(d[item], dict): n[item] = dict2obj(d[item]) elif isinstance(d[item], (list, tuple)): n[item] = [dict2obj(elem) for elem in d[item]] else: n[item] = d[item] return type( elif isinstance(d, (list, tuple,)): l = [] for item in d: l.append(dict2obj(item)) return l else: return d
class Struct(dict): def __init__(self,data): for key, value in data.items(): if isinstance(value, dict): setattr(self, key, Struct(value)) else: setattr(self, key, type(value).__init__(value)) dict.__init__(self,data)
class Object: """If your dict is "flat", this is a simple way to create an object from a dict >>> obj = Object() >>> obj.__dict__ = d >>> d.a 1 """ pass
def dict2obj(d): """Convert a dict to an object >>> d = { >>> obj = dict2obj(d) >>> obj.b.c 2 >>> obj.d ["hi", { """ try: d = dict(d) except (TypeError, ValueError): return d obj = Object() for k, v in d.iteritems(): obj.__dict__[k] = dict2obj(v) return obj
>>> d = { >>> obj = dict2obj(d) >>> obj.d.hi.foo "bar"
def dictToObject(d): for k,v in d.items(): if isinstance(v, dict): d[k] = dictToObject(v) return namedtuple( d = { { }, { }, }, }, }, } }, } d1 = dictToObject(d) d1.columns.col1 d1.metadata.rows
def dict2obj(d): if isinstance(d, dict): n = {} for item in d: if isinstance(d[item], dict): n[item] = dict2obj(d[item]) elif isinstance(d[item], (list, tuple)): n[item] = [dict2obj(elem) for elem in d[item]] else: n[item] = d[item] return type( else: return d
File "test.py", line 20 print x.from == 1 ^ SyntaxError: invalid syntax
class dict2obj(dict): def __init__(self, dict_): super(dict2obj, self).__init__(dict_) for key in self: item = self[key] if isinstance(item, list): for idx, it in enumerate(item): if isinstance(it, dict): item[idx] = dict2obj(it) elif isinstance(item, dict): self[key] = dict2obj(item) def __getattr__(self, key): return self[key] d = { x = dict2obj(d) assert x.a == x[ assert x.b.c == x[ assert x.d[1].foo == x[
class DictObj(object): def __init__(self, d): self.__dict__ = d def dict_to_obj(d): if isinstance(d, (list, tuple)): return map(dict_to_obj, d) elif not isinstance(d, dict): return d return DictObj(dict((k, dict_to_obj(v)) for (k,v) in d.iteritems()))
from functools import partial d2o=partial(type, "d2o", ())
>>> o=d2o({"a" : 5, "b" : 3}) >>> print o.a 5 >>> print o.b 3
group=["class1","class2","class3","class4",] rank=["rank1","rank2","rank3","rank4","rank5",] data=["name","sex","height","weight","score"] student_dic=dict([(g,dict([(r,dict([(d, class dic2class(dict): def __init__(self, dic): for key,val in dic.items(): self.__dict__[key]=self[key]=dic2class(val) if isinstance(val,dict) else val student_class=dic2class(student_dic) student_class.class1.rank1[ student_class.class1.rank1[ print student_class.class1.rank1 print student_class.class1[ print for rank in student_class.class1: print getattr(student_class.class1,rank)
{ { -------------------------------------------------- { { { { {
class DObj(object): pass dobj = Dobj() dobj.__dict__ = { print dobj.a >>> aaa print dobj.b >>> bbb
class Struct(dict): def __getattr__(self, name): try: return self[name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): self[name] = value def copy(self): return Struct(dict.copy(self))
points = Struct(x=1, y=2) points[ points.y = 1 points[ points[ points[ points.z points_copy = points.copy() points.x = 2 points_copy.x
class data(object): def __init__(self,*args,**argd): self.__dict__.update(dict(*args,**argd)) def makedata(d): d2 = {} for n in d: d2[n] = trydata(d[n]) return data(d2) def trydata(o): if isinstance(o,dict): return makedata(o) elif isinstance(o,list): return [trydata(i) for i in o] else: return o
class Struct(object): class NoneStruct(object): def __getattribute__(*args): return Struct.NoneStruct() def __eq__(self, obj): return obj == None def __init__(self, obj): for k, v in obj.iteritems(): if isinstance(v, dict): setattr(self, k, Struct(v)) else: setattr(self, k, v) def __getattribute__(*args): try: return object.__getattribute__(*args) except: return Struct.NoneStruct() def __repr__(self): return (k, v) in self.__dict__.iteritems()))
bla = Struct({ print(bla.a.b) >> 1 print(bla.a.c == None) >> True
class dict2obj_new(dict): def __init__(self, dict_): super(dict2obj_new, self).__init__(dict_) for key in self: item = self[key] if isinstance(item, list): for idx, it in enumerate(item): if isinstance(it, dict): item[idx] = dict2obj_new(it) elif isinstance(item, dict): self[key] = dict2obj_new(item) def __getattr__(self, key): if self.has_key(key): return self[key] else: return None
ab = dict2obj_new(addr_bk) for person in ab.person: print "Person ID:", person.id print " Name:", person.name if person.email: print " E-mail address:", person.email if person.phone: for phone_number in person.phone: if phone_number.type == codec.enums.PhoneType.MOBILE: print " Mobile phone elif phone_number.type == codec.enums.PhoneType.HOME: print " Home phone else: print " Work phone print phone_number.number
class A(object): _dict = dict() def __new__(cls): if print "EXISTS" return A._dict[ else: print "NEW" return super(A, cls).__new__(cls) def __init__(self): print "INIT" A._dict[ print "" a1 = A() a2 = A() a3 = A()
def singleton(cls): instances = {} def getinstance(): if cls not in instances: instances[cls] = cls() return instances[cls] return getinstance @singleton class MyClass: ...
class Singleton(type): def __init__(self, *args, **kwargs): super(Singleton, self).__init__(*args, **kwargs) self.__instance = None def __call__(self, *args, **kwargs): if self.__instance is None: self.__instance = super(Singleton, self).__call__(*args, **kwargs) return self.__instance
class Agent(object): _agents = dict() def __new__(cls, *p): number = p[0] if not number in cls._agents: cls._agents[number] = object.__new__(cls) return cls._agents[number] def __init__(self, number): self.number = number def __eq__(self, rhs): return self.number == rhs.number Agent("a") is Agent("a") == True
def SingletonClass(cls): class Single(cls): __doc__ = cls.__doc__ _initialized = False _instance = None def __new__(cls, *args, **kwargs): if not cls._instance: cls._instance = super(Single, cls).__new__(cls, *args, **kwargs) return cls._instance def __init__(self, *args, **kwargs): if self._initialized: return super(Single, self).__init__(*args, **kwargs) self.__class__._initialized = True return Single
class Singleton(object): __initialized = False def __new__(cls, *args, **kwargs): if not cls.__initialized: cls.__init__(*args, **kwargs) cls.__initialized = True return cls class MyClass(Singleton): @classmethod def __init__(cls, x, y): print "init is here" @classmethod def do(cls): print "doing stuff"
class M(type): _dict = {} def __call__(cls, key): if key in cls._dict: print return cls._dict[key] else: print instance = super(M, cls).__call__(key) cls._dict[key] = instance return instance class A(object): __metaclass__ = M def __init__(self, key): print self.key = key print a1 = A( a2 = A( a3 = A(
class MetaQuasiSingleton(type): def __init__(cls, name, bases, attibutes): cls._dict = {} def __call__(cls, key): if key in cls._dict: print( instance = cls._dict[key] else: print( instance = super().__call__(key) cls._dict[key] = instance return instance class A(metaclass=MetaQuasiSingleton): def __init__(self, key): print self.key = key print()
class Singleton(object): def __new__(cls, *args, **kwds): it = cls.__dict__.get("__it__") if it is not None: return it cls.__it__ = it = object.__new__(cls) it.init(*args, **kwds) return it def init(self, *args, **kwds): pass
def singleton(cls): instances = {} def getinstance(): if cls not in instances: instances[cls] = cls() return instances[cls] return getinstance @singleton class MyClass: ...
def _alt(func): import functools @functools.wraps(func) def init(self, *p, **k): if hasattr(self, "parent_initialized"): return else: self.parent_initialized = True func(self, *p, **k) return init class Parent: parent_cache = {} def __new__(cls, n, *args, **kwargs): if n in cls.parent_cache: return cls.parent_cache[n] else: if not hasattr(cls, "parent_modified"): cls.parent_modified = True cls.parent_cache = {} cls.__init__ = _alt(cls.__init__) obj = super().__new__(cls) cls.parent_cache[n] = obj return obj
class A(Parent): def __init__(self, n): print("A.__init__", n) class B(Parent): def __init__(self, n): print("B.__init__", n)
>>> A(1) A.__init__ 1 <__main__.A object at 0x000001A73A4A2E48> >>> A(1) <__main__.A object at 0x000001A73A4A2E48> >>> A(2) A.__init__ 2 <__main__.A object at 0x000001A7395D9C88> >>> B(2) B.__init__ 2 <__main__.B object at 0x000001A73951B080>
def logged(func): def with_logging(*args, **kwargs): print(func.__name__ + " was called") return func(*args, **kwargs) return with_logging
from functools import wraps def logged(func): @wraps(func) def with_logging(*args, **kwargs): print(func.__name__ + " was called") return func(*args, **kwargs) return with_logging @logged def f(x): return x + x * x print(f.__name__) print(f.__doc__)
class DecBase(object): func = None def __init__(self, func): self.__func = func def __getattribute__(self, name): if name == "func": return super(DecBase, self).__getattribute__(name) return self.func.__getattribute__(name) def __setattr__(self, name, value): if name == "func": return super(DecBase, self).__setattr__(name, value) return self.func.__setattr__(name, value)
class process_login(DecBase): def __call__(self, *args): if len(args) != 2: raise Exception("You can only specify two arguments") return self.func(*args)
>>> from functools import partial >>> basetwo = partial(int, base=2) >>> basetwo.__doc__ = >>> basetwo( 18
WRAPPER_ASSIGNMENTS = ( WRAPPER_UPDATES = ( def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): """Update a wrapper function to look like the wrapped function wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools.WRAPPER_ASSIGNMENTS) updated is a tuple naming the attributes of the wrapper that are updated with the corresponding attribute from the wrapped function (defaults to functools.WRAPPER_UPDATES) """ for attr in assigned: setattr(wrapper, attr, getattr(wrapped, attr)) for attr in updated: getattr(wrapper, attr).update(getattr(wrapped, attr, {})) return wrapper def wraps(wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): """Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments. Default arguments are as for update_wrapper(). This is a convenience function to simplify applying partial() to update_wrapper(). """ return partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)
size = 3 matrix_surprise = [[0] * size] * size matrix = [[0]*size for i in range(size)]
>>> inner = [1,1,1,1] >>> outer = [inner]*3 >>> outer [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] >>> inner[0] = 5 >>> outer [[5, 1, 1, 1], [5, 1, 1, 1], [5, 1, 1, 1]]
>>> a=list(repeat(1,4)) [1, 1, 1, 1] >>> a[0]=5 >>> a [5, 1, 1, 1]
In [1]: import numpy as np In [2]: In [2]: np.ones(4) Out[2]: array([ 1., 1., 1., 1.]) In [3]: np.ones((4, 2)) Out[3]: array([[ 1., 1.], [ 1., 1.], [ 1., 1.], [ 1., 1.]]) In [4]: np.zeros((4, 2)) Out[4]: array([[ 0., 0.], [ 0., 0.], [ 0., 0.], [ 0., 0.]]) In [5]: np.repeat([7], 10) Out[5]: array([7, 7, 7, 7, 7, 7, 7, 7, 7, 7])
>>> a = [] >>> b = [a] >>> b [[]] >>> a.append(1) >>> b [[1]]
>>> c = b + b >>> c [[1], [1]] >>> >>> a[0] = 2 >>> c [[2], [2]]
myList = [[1 for __ in range(4)] for _ in range(3)]
print("myList:") for i, subList in enumerate(myList): print("\t[{}]: {}".format(i, id(subList))) for j, elem in enumerate(subList): print("\t\t[{}]: {}".format(j, id(elem)))
x: 1 y: [1] z: [1, 1, 1, 1] myList: [0]: 4300763792 [0]: 4298171528 [1]: 4298171528 [2]: 4298171528 [3]: 4298171528 [1]: 4300763792 [0]: 4298171528 [1]: 4298171528 [2]: 4298171528 [3]: 4298171528 [2]: 4300763792 [0]: 4298171528 [1]: 4298171528 [2]: 4298171528 [3]: 4298171528
a out:[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] a.remove(a[0]) out:[[1, 1, 1, 1], [1, 1, 1, 1]] a.append([5,1,1,1]) out:[[1, 1, 1, 1], [1, 1, 1, 1], [5, 1, 1, 1]] a.reverse() out:[[5, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]
x = [[0, 0], [0, 0]] print(type(x)) print(x) x[0][0] = 1 print(x)
y = [[0] * 2] * 2 print(type(y)) print(y) y[0][0] = 1 print(y)
import copy y = [0] * 2 print(y) y = [y, copy.deepcopy(y)] print(y) y[0][0] = 1 print(y)
import copy y = [0] * 2 print(y) y = [copy.deepcopy(y) for num in range(1,5)] print(y) y[0][0] = 5 print(y)
main.py mypackage/ __init__.py mymodule.py myothermodule.py
def as_int(a): return int(a) def _test(): assert as_int( if __name__ == _test()
from .mymodule import as_int def add(a, b): return as_int(a) + as_int(b) def _test(): assert add( if __name__ == _test()
from mypackage.myothermodule import add def main(): print(add( if __name__ == main()
import sys import os PACKAGE_PARENT = SCRIPT_DIR = os.path.dirname(os.path.realpath(os.path.join(os.getcwd(), os.path.expanduser(__file__)))) sys.path.append(os.path.normpath(os.path.join(SCRIPT_DIR, PACKAGE_PARENT))) from mypackage.mymodule import as_int
import sys from pathlib import Path if __name__ == file = Path(__file__).resolve() parent, top = file.parent, file.parents[3] sys.path.append(str(top)) try: sys.path.remove(str(parent)) except ValueError: pass import package.subpackage.subsubpackage __package__ = from ... import module
if __name__ == import_parents(level=3) from ... import module from ...module.submodule import thing
from setuptools import setup, find_packages setup( name = packages = find_packages(), )
import sys from pathlib import Path file = Path(__file__).resolve() parent, root = file.parent, file.parents[1] sys.path.append(str(root)) try: sys.path.remove(str(parent)) except ValueError: pass
if __name__ == from mymodule import as_int else: from .mymodule import as_int def add(a, b): return as_int(a) + as_int(b) def _test(): assert add( if __name__ == _test()
import os, sys; sys.path.append(os.path.dirname(os.path.realpath(__file__)))
├── project │ ├── package │ │ ├── __init__.py │ │ ├── module1.py │ │ └── module2.py │ └── setup.py
import repackage repackage.up() from mypackage.mymodule import myfunction
$ python3 test/my_module/module_test.py 2.4.0 Traceback (most recent call last): File "test/my_module/module_test.py", line 6, in <module> from my_module.module import * ModuleNotFoundError: No module named
$ PYTHONPATH=. python3 test/my_module/module_test.py 2.4.0 ........... ---------------------------------------------------------------------- Ran 11 tests in 0.001s OK
from setuptools import setup, find_packages setup( name= packages=find_packages() )
import datetime dt=str(datetime.datetime.now().date())
import time import datetime def gen_dates_list(end, numdays): start = end - datetime.timedelta(days=numdays+1) end = int(time.mktime(end.timetuple())) start = int(time.mktime(start.timetuple())) return xrange(start, end, 86400) for dt in reversed(gen_dates_list(datetime.datetime.today(), 100)): print datetime.datetime.fromtimestamp(dt).date()
>>> x = lambda: False in [False, True] >>> dis.dis(x) 1 0 LOAD_GLOBAL 0 (False) 3 LOAD_GLOBAL 0 (False) 6 LOAD_GLOBAL 1 (True) 9 BUILD_LIST 2 12 COMPARE_OP 6 (in) 15 RETURN_VALUE
>>> x = lambda: not(True) in [False, True] >>> dis.dis(x) 1 0 LOAD_GLOBAL 0 (True) 3 LOAD_GLOBAL 1 (False) 6 LOAD_GLOBAL 0 (True) 9 BUILD_LIST 2 12 COMPARE_OP 7 (not in) 15 RETURN_VALUE >>>
>>> x = lambda: (not(True)) in [False, True] >>> dis.dis(x) 1 0 LOAD_GLOBAL 0 (True) 3 UNARY_NOT 4 LOAD_GLOBAL 1 (False) 7 LOAD_GLOBAL 0 (True) 10 BUILD_LIST 2 13 COMPARE_OP 6 (in) 16 RETURN_VALUE
@app.route( def parse_request(): data = request.data
search = request.args.get("search") page = request.args.get("page")
email = request.form.get( password = request.form.get(
from flask import Flask, abort, request import json app = Flask(__name__) @app.route( def foo(): if not request.json: abort(400) print request.json return json.dumps(request.json) if __name__ == app.run(host=
curl -i -H "Content-Type: application/json" -X POST -d
{Content-Type: application/json} @app.route("/something", methods=["POST"]) def do_something(): data = request.get_json()
@app.before_request def before_request(): g.data = request.get_json() or request.values
@app.route("/something", methods=["POST"]) def do_something(): result = handle(g.data) return jsonify(data=result)
@app.route( def process_data(): req_data = request.get_json(force=True) language = req_data[ return
@app.route( def f_data(): if request.method == "POST": fields = [k for k in request.form] values = [request.form[k] for k in request.form] data = dict(zip(fields, values)) return jsonify(data)
$ curl http: { "name": "ivanleoncz", "role": "Software Developer" }
len = request.headers["Content-Length"] data=request.stream.read()
var value_data = [1,2,3,4]; $.ajax({ type: url: data:JSON.stringify(value_data), success: function (response) { alert("Data added successfully"); }, });
def get_request_info(): args = str(request.args) form = str(request.form) files = str(request.files) maybe_json = request.get_json(silent=True, cache=False) if maybe_json: thejson = json.dumps(maybe_json) else: thejson = "no json" return
from flask import Flask, request app = Flask(__name__) @app.route( def index(): print("Posted data : {}".format(request.form)) return """ <form method="post"> <input type="text"> <input type="text" id="idtxt2"> <input type="text" name="txt3" id="idtxt3"> <input type="submit" Value="Hopla!"> </form> """ if __name__ == "__main__": app.run()
freezed@machine % python3 run.py * Serving Flask app "flaskstuff.views" (lazy loading) * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: on * Running on http: * Restarting with stat * Debugger is active! * Debugger PIN: 268-634-781 127.0.0.1 - - [20/Aug/2018 16:52:59] "POST / HTTP/1.1" 200 - Posted data : ImmutableMultiDict([(
from flask import Flask, request, jsonify @app.route( def add(): data = request.get_json(force=True) l = { lingual.append(l) return jsonify({
b1 = [1,2,3,4,5,9,11,15] b2 = [4,5,6,7,8] b3 = [val for val in b1 if val in b2]
def intersect(a, b): return list(set(a) & set(b)) print intersect(b1, b2)
c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]
c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]] c3 = [[13, 32], [7, 13, 28], [1,6]]
c3 = [filter(lambda x: x in c1, sublist) for sublist in c2]
c3 = [list(filter(lambda x: x in c1, sublist)) for sublist in c2]
>>> b1 = [1,2,3,4,5,9,11,15] >>> b2 = [4,5,6,7,8] >>> set(b1).intersection(b2) set([4, 5])
b1 = [1,2,3,4,5,9,11,15] b2 = [4,5,6,7,8] b3 = [val for val in b1 if val in b2]
def intersect(a, b): return list(set(a) & set(b)) print intersect(b1, b2)
b1 = [1,2,3,4,5] b2 = [3,4,5,6] s2 = set(b2) b3 = [val for val in b1 if val in s2]
>>> c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] >>> c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]] >>> c1set = frozenset(c1)
>>> [n for lst in c2 for n in lst if n in c1set] [13, 32, 7, 13, 28, 1, 6]
>>> [[n for n in lst if n in c1set] for lst in c2] [[13, 32], [7, 13, 28], [1, 6]]
input_list = [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]] result = reduce(set.intersection, map(set, input_list))
def flatten(x): """flatten(sequence) -> list Returns a single, flat list which contains all elements retrieved from the sequence and all recursively contained sub-sequences (iterables). Examples: >>> [1, 2, [3,4], (5,6)] [1, 2, [3, 4], (5, 6)] >>> flatten([[[1,2,3], (42,None)], [4,5], [6], 7, MyVector(8,9,10)]) [1, 2, 3, 42, None, 4, 5, 6, 7, 8, 9, 10]""" result = [] for el in x: if hasattr(el, "__iter__") and not isinstance(el, basestring): result.extend(flatten(el)) else: result.append(el) return result
c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]] def intersect(a, b): return list(set(a) & set(b)) print intersect(flatten(c1), flatten(c2))
>>> c3 = [intersect(c1, i) for i in c2] >>> c3 [[32, 13], [28, 13, 7], [1, 6]]
>>> c3 = [list(set(c1).intersection(i)) for i in c2] >>> c3 [[32, 13], [28, 13, 7], [1, 6]]
> c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] > c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]
> c3 = [ [i for i in set(f) if i in c1] for f in c2]
def intersect(a, b): result=[] for i in b: if isinstance(i,list): result.append(intersect(a,i)) else: if i in a: result.append(i) return result
>>> c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] >>> c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]] >>> print intersect(c1,c2) [[13, 32], [7, 13, 28], [1, 6]] >>> b1 = [1,2,3,4,5,9,11,15] >>> b2 = [4,5,6,7,8] >>> print intersect(b1,b2) [4, 5]
def compareLists(a,b): removed = [x for x in a if x not in b] added = [x for x in b if x not in a] overlap = [x for x in a if x in b] return [removed,added,overlap]
from collections import Counter >>> c1 = [1, 2, 2, 3, 4, 4, 4] >>> c2 = [1, 2, 4, 4, 4, 4, 5] >>> list((Counter(c1) & Counter(c2)).elements()) [1, 2, 4, 4, 4]
c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]] c3 = [list(set(c2[i]).intersection(set(c1))) for i in xrange(len(c2))] c3 ->[[32, 13], [28, 13, 7], [1, 6]]
c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]] result = [] for li in c2: res = set(li) & set(c1) result.append(list(res)) print result
c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]
c3 = [] for sublist in c2: c3.append([val for val in c1 if val in sublist])
c3 = [[val for val in c1 if val in sublist] for sublist in c2]
c1 = [1, 6, 7, 10, 13, 28, 32, 41, 58, 63] c2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]] c3 = [list(set(i) & set(c1)) for i in c2] c3 [[32, 13], [28, 13, 7], [1, 6]]
app/ __init__.py sub1/ __init__.py mod1.py sub2/ __init__.py mod2.py
main.py setup.py app/ -> __init__.py package_a/ -> __init__.py module_a.py package_b/ -> __init__.py module_b.py
import sys sys.path.insert(0, "../settings") try: from local_settings import * except ImportError: print(
def import_path(fullpath): path, filename = os.path.split(fullpath) filename, ext = os.path.splitext(filename) sys.path.append(path) module = __import__(filename) reload(module) del sys.path[-1] return module
main.py app/ -> __init__.py package_a/ -> __init__.py fun_a.py package_b/ -> __init__.py fun_b.py
from app.package_a.fun_a import print_a def print_b(): print print print print_a()
This is a function in dir package_b going to call a function in dir package_a ------------------------------ This is a function in dir package_a
mymodule\ __init__.py mymodule1\ __init__.py mymodule1_1 mymodule2\ __init__.py mymodule2_1 import mymodule.mymodule1.mymodule1_1
import os.path import sys sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
app/ __init__.py sub1/ __init__.py mod1.py sub12/ __init__.py mod2.py
for each_line in fileinput.input(input_file): do_something(each_line) for each_line_again in fileinput.input(input_file): do_something(each_line_again)
with open("x.txt") as f: for line in f: do something with data
def readInChunks(fileObj, chunkSize=2048): while True: data = fileObj.read(chunkSize) if not data: break yield data f = open( for chuck in readInChunks(f): do_something(chunk) f.close()
import fileinput for line in fileinput.input([ do_something(line)
with open(file_path, for line_terminated in f: line = line_terminated.rstrip( ...
with open(file_path, with line_native_terminated in f: ...
f = open(input_file) for line in f: do_stuff(line) f.close()
HP-Z820:/mnt/fastssd/fast_file_reader$ ls -l /mnt/fastssd/nzv/HIGGS.csv -rw-rw-r-- 1 8035497980 Jan 24 16:00 /mnt/fastssd/nzv/HIGGS.csv HP-Z820:/mnt/fastssd$ ls -l all_bin.csv -rw-rw-r-- 1 40412077758 Feb 2 09:00 all_bin.csv ga@ga-HP-Z820:/mnt/fastssd$ time python fastread.py --fileName="all_bin.csv" --numProcesses=32 --balanceFactor=2 2367496 real 0m8.920s user 1m30.056s sys 2m38.744s In [1]: 40412077758. / 8.92 Out[1]: 4530501990.807175
HP-Z820:/mnt/fastssd$ time wc -l all_bin.csv 2367496 all_bin.csv real 0m8.807s user 0m1.168s sys 0m7.636s HP-Z820:/mnt/fastssd/fast_file_reader$ time python fastread.py --fileName="HIGGS.csv" --numProcesses=16 --balanceFactor=2 11000000 real 0m2.257s user 0m12.088s sys 0m20.512s HP-Z820:/mnt/fastssd/fast_file_reader$ time wc -l HIGGS.csv 11000000 HIGGS.csv real 0m1.820s user 0m0.364s sys 0m1.456s
HP-Z820:/mnt/fastssd/fast_file_reader$ time python fastread.py --fileName="HIGGS.csv" --numProcesses=16 --balanceFactor=2 11000000 real 0m2.256s user 0m10.696s sys 0m19.952s HP-Z820:/mnt/fastssd/fast_file_reader$ time python fastread.py --fileName="HIGGS.csv" --numProcesses=1 --balanceFactor=1 11000000 real 0m17.380s user 0m11.124s sys 0m6.272s
HP-Z820:/mnt/fastssd/fast_file_reader$ time python fastread.py --fileName="HIGGS.csv" --numProcesses=1 --balanceFactor=2 11000000 real 1m37.077s user 0m12.432s sys 1m24.700s
fileBytes = stat(fileName).st_size startByte, endByte = PartitionDataToWorkers(workers=numProcesses, items=fileBytes, balanceFactor=balanceFactor) p = Pool(numProcesses) partialSum = p.starmap(ReadFileSegment, zip(startByte, endByte, repeat(fileName))) globalSum = sum(partialSum) print(globalSum) def ReadFileSegment(startByte, endByte, fileName, searchChar= with open(fileName, f.seek(startByte-1) bytes = f.read(endByte - startByte + 1) cnt = len(re.findall(searchChar, bytes)) return cnt
with f_outer as open(input_file, for line_outer in f_outer: with f_inner as open(input_file, for line_inner in f_inner: compute_distance(line_outer, line_inner)
with open("yourFile.txt","r") as f: text = f.readlines() for line in text: print line
fileinput.FileInput([files[, inplace[, backup[, mode[, openhook]]]]])
for each_line in fileinput.input([input_file, input_file]): do_something(each_line)
import numpy as np import math lines_total = n similarity = np.zeros(n,n) lines_per_chunk = m n_chunks = math.ceil(float(n)/m) for i in xrange(n_chunks): for j in xrange(n_chunks): chunk_i = (function of your choice to read lines i*lines_per_chunk to (i+1)*lines_per_chunk) chunk_j = (function of your choice to read lines j*lines_per_chunk to (j+1)*lines_per_chunk) similarity[i*lines_per_chunk:(i+1)*lines_per_chunk, j*lines_per_chunk:(j+1)*lines_per_chunk] = fast_operation(chunk_i, chunk_j)
with open(file_name, "rU") as read_file: for i, row in enumerate(read_file, 1):
package Foo; sub frotz { return "Bamf"; } package Bar; @ISA = qw(Foo); sub frotz { my $str = SUPER::frotz(); return uc($str); }
class Foo(Bar): def baz(self, arg): return super(Foo, self).baz(arg)
class A(object): def foo(self): print "foo" class B(A): def foo(self): super(B, self).foo() myB = B() myB.foo()
class Foo(Bar): def __init__(self): super().__init__()
class A(): def bar(self, string): print("Hi, I class B(A): def baz(self): self.bar(" - called by baz in B") B().baz()
class Dog(object): name = moves = [] def __init__(self, name): self.name = name def moves_setup(self): self.moves.append( self.moves.append( def get_moves(self): return self.moves class Superdog(Dog): def moves_setup(self): super(Superdog, self).moves_setup() self.moves.append( dog = Superdog( print dog.name dog.moves_setup() print dog.get_moves()
class Foo(Bar): def __init__(self): super(Foo, self).__init__() self.baz = 5
class A: def __init__(self): print "I am Class %s"%self.__class__.__name__ for parentClass in self.__class__.__bases__: print " I am inherited from:",parentClass.__name__ class B(A):pass class C(B):pass a,b,c = A(),B(),C()
class Foo(bar) def baz(self, arg, *args, **kwargs): return super(Foo, self).baz(arg, *args, **kwargs)
class Dog(object): name = moves = [] def __init__(self, name): self.name = name def moves_setup(self,x): self.moves.append( self.moves.append( self.moves.append(x) def get_moves(self): return self.moves class Superdog(Dog): def moves_setup(self): super().moves_setup("hello world") self.moves.append( dog = Superdog( print (dog.name) dog.moves_setup() print (dog.get_moves())
from myA import A as parent class B( parent ): def foo( self ): parent.foo( self )
class a(object): def my_hello(self): print "hello ravi" class b(a): def my_hello(self): super(b,self).my_hello() print "hi" obj = b() obj.my_hello()
>>> "hello world".title() >>> u"hello world".title() u
s = lst = [word[0].upper() + word[1:] for word in s.split()] s = " ".join(lst)
import re s = def repl_func(m): return m.group(1) + m.group(2).upper() s = re.sub("(^|\s)(\S)", repl_func, s) >>> re.sub("(^|\s)(\S)", repl_func, s) "They
from itertools import chain def cap_sentence(s): return
import re def cap_sentence(s): return re.sub("(^|\s)(\S)", lambda m: m.group(1) + m.group(2).upper(), s)
"" => "" "a b c" => "A B C" "foO baR" => "FoO BaR" "foo bar" => "Foo Bar" "foo "foo "foo 1bar" => "Foo 1bar"
return s.title() "foO baR" => "Foo Bar" "foo "foo "foo 1bar" => "Foo 1Bar"
return import string return string.capwords(s) "foO baR" => "Foo Bar" "foo bar" => "Foo Bar"
return import string return string.capwords(s, "foO baR" => "Foo Bar"
string = "the brown fox" string[0].upper()+string[1:]
input = "they words = input.split( capitalized_words = [] for word in words: title_case_word = word[0].upper() + word[1:] capitalized_words.append(title_case_word) output =
def my_uppercase(title): if not title: return return title[0].upper() + title[1:]
str = "this is string example.... wow!!!"; print "str.title() : ", str.title();
import re def titlecase(s): return re.sub(r"[A-Za-z]+( text = "He print(titlecase(text))
def capitalize_words(string): words = string.split(" ") return capitalize_words(string) >
with open(input_file) as file: lines = [x for x in reader(file) if x] for line in lines: name = [x.strip().lower() for x in line if x] print(name)
with open( for item in my_list: f.write("%s\n" % item)
with open( for item in my_list: print >> thefile, item
>>> import simplejson >>> f = open( >>> simplejson.dump([1,2,3,4], f) >>> f.close()
with open(filepath, for item in the_list: file_handler.write("{}\n".format(item))
file.writelines( list( "%s\n" % item for item in list ) )
In [1]: import os In [2]: f = file(os.devnull, "w") In [3]: %timeit f.writelines( "%s\n" % item for item in xrange(2**20) ) 1 loops, best of 3: 385 ms per loop In [4]: %timeit f.writelines( ["%s\n" % item for item in xrange(2**20)] ) ERROR: Internal Python error in the inspect module. Below is the traceback from this internal error. Traceback (most recent call last): ... MemoryError
In [4]: %timeit f.writelines( "%s\n" % item for item in xrange(2**20) ) 1 loops, best of 3: 370 ms per loop In [5]: %timeit f.writelines( ["%s\n" % item for item in xrange(2**20)] ) 1 loops, best of 3: 360 ms per loop
fo = open("foo.txt", "rw+") seq = ["This is 6th line\n", "This is 7th line"] line = fo.writelines( seq ) fo.close()
import json a = [1,2,3] with open( f.write(json.dumps(a)) with open( a = json.loads(f.read())
with open ("test.txt","w")as fp: for line in list12: fp.write(line+"\n")
outfile = open( for item in list_to_persistence: outfile.write(str(item) + outfile.close()
for item in items: filewriter.write(f"{item}" + "\n")
poem = Programming is fun When the work is done if you wanna make your work also fun: use Python! f = open( f.write(poem) f.close()
| r r+ w w+ a a+ ------------------|-------------------------- read | + + + + write | + + + + + write after seek | + + + create | + + + + truncate | + + position at start | + + + + position at end | + +
>>> import os >>> print os.name posix >>> import platform >>> platform.system() >>> platform.release()
>>> import os >>> os.name >>> import platform >>> platform.system() >>> platform.release()
>>> import os >>> os.name >>> import platform >>> platform.system() >>> platform.release()
>>> import os >>> os.name >>> import platform >>> platform.system() >>> platform.release()
from sys import platform as _platform if _platform == "linux" or _platform == "linux2": elif _platform == "darwin": elif _platform == "win32": elif _platform == "win64":
import platform import sys def linux_distribution(): try: return platform.linux_distribution() except: return "N/A" print( % ( sys.version.split( str(platform.dist()), linux_distribution(), platform.system(), platform.machine(), platform.platform(), platform.uname(), platform.version(), platform.mac_ver(), ))
wls:/offline> import os wls:/offline> print os.name java wls:/offline> import sys wls:/offline> print sys.platform
def iswindows(): os = java.lang.System.getProperty( "os.name" ) return "win" in os.lower()
def get_os_platform(): ver = sys.platform.lower() if ver.startswith( import java.lang ver = java.lang.System.getProperty("os.name").lower() print( return ver
import psutil psutil.MACOS psutil.WINDOWS psutil.LINUX
def cls(): from subprocess import call from platform import system os = system() if os == call( elif os == call(
>>> import os, platform >>> print os.name posix >>> print platform.system() CYGWIN_NT-6.3-WOW
>>> import os >>> os.name >>> import platform >>> platform.system() >>> platform.release()
import platform is_windows=(platform.system().lower().find("win") > -1) if(is_windows): lv_dll=LV_dll("my_so_dll.dll") else: lv_dll=LV_dll("./my_so_dll.so")
>>> import platform >>> print platform.linux_distribution() ( >>> print platform.linux_distribution()[0] CentOS Linux >>> print platform.linux_distribution()[1] 6.0
>>> import platform >>> print platform.dist() ( >>> print platform.dist()[0] centos >>> print platform.dist()[1] 6.0
import platform print dir(platform) for x in dir(platform): if x[0].isalnum(): try: result = getattr(platform, x)() print "platform."+x+": "+result except TypeError: continue
>>> import platform >>> platform.os.name >>> platform.uname() (
system : Darwin node : mainframe.local release : 15.3.0 version : Darwin Kernel Version 15.3.0: Thu Dec 10 18:40:58 PST 2015; root:xnu-3248.30.4~1/RELEASE_X86_64 machine : x86_64 processor : i386
In []: for i in [platform.linux_distribution(),platform.mac_ver(),platform.win32_ver()]: ....: if i[0]: ....: print
import platform from enum import Enum class OS(Enum): def checkPlatform(osName): return osName.lower()== platform.system().lower() MAC = checkPlatform("darwin") LINUX = checkPlatform("linux") WINDOWS = checkPlatform("windows")
import os os_name = os.getenv("OS") if os_name == "Windows_NT": elif "linux" in os_name: elif ...
>>> import urllib >>> f = { >>> urllib.urlencode(f)
>>> urllib.parse.urlencode(f) eventName=myEvent&eventDescription=cool+event
import urllib dict_name_value_pairs = { "bravo" : "True != False", "alpha" : "http: "charlie" : "hello world", "delta" : "1234567 !@ "echo" : "user@example.com", } ary_ordered_names = [] ary_ordered_names.append( ary_ordered_names.append( ary_ordered_names.append( ary_ordered_names.append( ary_ordered_names.append( if( queryString = urllib.urlencode(dict_name_value_pairs) print queryString """ echo=user%40example.com&bravo=True+%21%3D+False&delta=1234567+%21%40%23%24%25%5E%26%2A&charlie=hello+world&alpha=http%3A%2F%2Fwww.example.com """ if( queryString = "&".join( [ item+ print queryString """ alpha=http%3A%2F%2Fwww.example.com&bravo=True+%21%3D+False&charlie=hello+world&delta=1234567+%21%40%23%24%25%5E%26%2A&echo=user%40example.com """
>>> import urllib.request as req >>> query = >>> req.pathname2url(query) >>>
import urllib3 urllib3.request.urlencode({"user" : "john" })
import socket socket.gethostbyname(socket.gethostname())
import socket s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect(("8.8.8.8", 80)) print(s.getsockname()[0]) s.close()
import socket print([l for l in ([ip for ip in socket.gethostbyname_ex(socket.gethostname())[2] if not ip.startswith("127.")][:1], [[(s.connect((
import socket print((([ip for ip in socket.gethostbyname_ex(socket.gethostname())[2] if not ip.startswith("127.")] or [[(s.connect(("8.8.8.8", 53)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1]]) + ["no IP found"])[0])
import socket print([ip for ip in socket.gethostbyname_ex(socket.gethostname())[2] if not ip.startswith("127.")][:1])
import socket def get_ip(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) try: s.connect(( IP = s.getsockname()[0] except: IP = finally: s.close() return IP
from netifaces import interfaces, ifaddresses, AF_INET for ifaceName in interfaces(): addresses = [i[ print
from urllib.request import urlopen import re def getPublicIp(): data = str(urlopen( return re.compile(r
from urllib import urlopen import re def getPublicIp(): data = str(urlopen( return re.compile(r
import socket s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect(( local_ip_address = s.getsockname()[0]
>>> import socket, struct, fcntl >>> sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) >>> sockfd = sock.fileno() >>> SIOCGIFADDR = 0x8915 >>> >>> def get_ip(iface = ... ifreq = struct.pack( ... try: ... res = fcntl.ioctl(sockfd, SIOCGIFADDR, ifreq) ... except: ... return None ... ip = struct.unpack( ... return socket.inet_ntoa(ip) ... >>> get_ip( >>>
import os import socket if os.name != "nt": import fcntl import struct def get_interface_ip(ifname): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) return socket.inet_ntoa(fcntl.ioctl( s.fileno(), 0x8915, struct.pack( )[20:24]) def get_lan_ip(): ip = socket.gethostbyname(socket.gethostname()) if ip.startswith("127.") and os.name != "nt": interfaces = ["eth0","eth1","eth2","wlan0","wlan1","wifi0","ath0","ath1","ppp0"] for ifname in interfaces: try: ip = get_interface_ip(ifname) break; except IOError: pass return ip
import commands commands.getoutput("/sbin/ifconfig").split("\n")[1].split()[1][5:]
def getIPAddresses(): from ctypes import Structure, windll, sizeof from ctypes import POINTER, byref from ctypes import c_ulong, c_uint, c_ubyte, c_char MAX_ADAPTER_DESCRIPTION_LENGTH = 128 MAX_ADAPTER_NAME_LENGTH = 256 MAX_ADAPTER_ADDRESS_LENGTH = 8 class IP_ADDR_STRING(Structure): pass LP_IP_ADDR_STRING = POINTER(IP_ADDR_STRING) IP_ADDR_STRING._fields_ = [ ("next", LP_IP_ADDR_STRING), ("ipAddress", c_char * 16), ("ipMask", c_char * 16), ("context", c_ulong)] class IP_ADAPTER_INFO (Structure): pass LP_IP_ADAPTER_INFO = POINTER(IP_ADAPTER_INFO) IP_ADAPTER_INFO._fields_ = [ ("next", LP_IP_ADAPTER_INFO), ("comboIndex", c_ulong), ("adapterName", c_char * (MAX_ADAPTER_NAME_LENGTH + 4)), ("description", c_char * (MAX_ADAPTER_DESCRIPTION_LENGTH + 4)), ("addressLength", c_uint), ("address", c_ubyte * MAX_ADAPTER_ADDRESS_LENGTH), ("index", c_ulong), ("type", c_uint), ("dhcpEnabled", c_uint), ("currentIpAddress", LP_IP_ADDR_STRING), ("ipAddressList", IP_ADDR_STRING), ("gatewayList", IP_ADDR_STRING), ("dhcpServer", IP_ADDR_STRING), ("haveWins", c_uint), ("primaryWinsServer", IP_ADDR_STRING), ("secondaryWinsServer", IP_ADDR_STRING), ("leaseObtained", c_ulong), ("leaseExpires", c_ulong)] GetAdaptersInfo = windll.iphlpapi.GetAdaptersInfo GetAdaptersInfo.restype = c_ulong GetAdaptersInfo.argtypes = [LP_IP_ADAPTER_INFO, POINTER(c_ulong)] adapterList = (IP_ADAPTER_INFO * 10)() buflen = c_ulong(sizeof(adapterList)) rc = GetAdaptersInfo(byref(adapterList[0]), byref(buflen)) if rc == 0: for a in adapterList: adNode = a.ipAddressList while True: ipAddr = adNode.ipAddress if ipAddr: yield ipAddr adNode = adNode.next if not adNode: break
>>> for addr in getIPAddresses(): >>> print addr 192.168.0.100 10.5.9.207
import commands RetMyIP = commands.getoutput("hostname -I")
import socket socket.gethostbyname(socket.gethostname())
import socket import fcntl import struct def get_ip_address(ifname): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) return socket.inet_ntoa(fcntl.ioctl( s.fileno(), 0x8915, struct.pack( )[20:24])
import commands ips = commands.getoutput("/sbin/ifconfig | grep -i \"inet\" | grep -iv \"inet6\" | " + "awk { print ips
import socket def getNetworkIp(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) s.connect(( return s.getsockname()[0] print (getNetworkIp())
import socket addr = socket.gethostbyname(socket.gethostname())
if addr == "127.0.0.1": import commands output = commands.getoutput("/sbin/ifconfig") addr = parseaddress(output)
import errno import socket _local_networks = ("127.", "0:0:0:0:0:0:0:1") _ignored_networks = _local_networks + ("0.", "0:0:0:0:0:0:0:0", "169.254.", "fe80:") def detect_family(addr): if "." in addr: assert ":" not in addr return socket.AF_INET elif ":" in addr: return socket.AF_INET6 else: raise ValueError("invalid ipv4/6 address: %r" % addr) def expand_addr(addr): family = detect_family(addr) addr = socket.inet_ntop(family, socket.inet_pton(family, addr)) if "::" in addr: count = 8-addr.count(":") addr = addr.replace("::", (":0" * count) + ":") if addr.startswith(":"): addr = "0" + addr return addr def _get_local_addr(family, remote): try: s = socket.socket(family, socket.SOCK_DGRAM) try: s.connect((remote, 9)) return s.getsockname()[0] finally: s.close() except socket.error: return None def get_local_addr(remote=None, ipv6=True): if remote: family = detect_family(remote) local = _get_local_addr(family, remote) if not local: return None if family == socket.AF_INET6: local = expand_addr(local) if local.startswith(_local_networks): return local else: if ipv6: local = _get_local_addr(socket.AF_INET6, "2001:db8::1234") if local: local = expand_addr(local) else: local = None if not local: local = _get_local_addr(socket.AF_INET, "192.0.2.123") if not local: return None if local.startswith(_ignored_networks): return None return local
import socket, subprocess, re def get_ipv4_address(): """ Returns IP address(es) of current machine. :return: """ p = subprocess.Popen(["ifconfig"], stdout=subprocess.PIPE) ifc_resp = p.communicate() patt = re.compile(r resp = patt.findall(ifc_resp[0]) print resp get_ipv4_address()
import socket [i[4][0] for i in socket.getaddrinfo(socket.gethostname(), None)]
import select import socket import threading from queue import Queue, Empty def get_local_ip(): def udp_listening_server(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind(( s.setblocking(0) while True: result = select.select([s],[],[]) msg, address = result[0][0].recvfrom(1024) msg = str(msg, if msg == break queue.put(address) queue = Queue() thread = threading.Thread(target=udp_listening_server) thread.queue = queue thread.start() s2 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s2.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) waiting = True while waiting: s2.sendto(bytes( try: address = queue.get(False) except Empty: pass else: waiting = False return address[0] if __name__ == print(get_local_ip())
import commands,re,socket iplines=(line.strip() for line in commands.getoutput("ip address show").split( addresses1=reduce(lambda a,v:a+v,(re.findall(r"inet ([\d.]+/\d+)",line)+re.findall(r"inet6 ([\:\da-f]+/\d+)",line) for line in iplines)) ipv4s=[(ip,int(subnet)) for ip,subnet in (addr.split( ipv6s=[(ip,int(subnet)) for ip,subnet in (addr.split(
import sys , pynotify if sys.version_info[1] != 7: raise RuntimeError( from subprocess import check_output IP = check_output([ Split_Result = IP.split() pynotify.init("image") notify = pynotify.Notification("Ip", "Server Running At:" + Split_Result[2] , "/home/User/wireless.png") notify.show()
import netifaces PROTO = netifaces.AF_INET ifaces = netifaces.interfaces() if_addrs = [netifaces.ifaddresses(iface) for iface in ifaces] if_inet_addrs = [addr[PROTO] for addr in if_addrs if PROTO in addr] iface_addrs = [s[
import netifaces PROTO = netifaces.AF_INET ifaces = netifaces.interfaces() if_addrs = [(netifaces.ifaddresses(iface), iface) for iface in ifaces] if_inet_addrs = [(tup[0][PROTO], tup[1]) for tup in if_addrs if PROTO in tup[0]] iface_addrs = [(s[
from __future__ import print_function from pprint import pprint as pp print( pp(ifaces) print( pp(if_addrs) print( pp(if_inet_addrs) print( pp(iface_addrs)
import socket, subprocess def getIpAndHostname(): hostname = socket.gethostname() shell_cmd = "ifconfig | awk proc = subprocess.Popen([shell_cmd], stdout=subprocess.PIPE, shell=True) (out, err) = proc.communicate() ip_list = out.split( ip = ip_list[0] for _ip in ip_list: try: if _ip != "127.0.0.1" and _ip.split(".")[3] != "1": ip = _ip except: pass return ip, hostname ip_addr, hostname = getIpAndHostname()
_local_ip_cache = [] _nonlocal_ip_cache = [] def ip_islocal(ip): if ip in _local_ip_cache: return True if ip in _nonlocal_ip_cache: return False s = socket.socket() try: try: s.bind((ip, 0)) except socket.error, e: if e.args[0] == errno.EADDRNOTAVAIL: _nonlocal_ip_cache.append(ip) return False else: raise finally: s.close() _local_ip_cache.append(ip) return True
import socket socket.gethostbyname(socket.getfqdn())
import netifaces as ni ni.ifaddresses( ip = ni.ifaddresses( print(ip)
try: operation_that_can_throw_ioerror() except IOError: handle_the_exception_somehow() else: another_operation_that_can_throw_ioerror() finally: something_we_always_need_to_do()
try: from EasyDialogs import AskPassword getpass = AskPassword except ImportError: getpass = default_getpass
try: from EasyDialogs import AskPassword except ImportError: getpass = default_getpass else: getpass = AskPassword
try: from EasyDialogs import AskPassword except ImportError: getpass = default_getpass return False getpass = AskPassword
try: this_should_raise_TypeError() except TypeError: pass except: assert False, "Raised the wrong exception type" else: assert False, "Didn
for arg in sys.argv[1:]: try: f = open(arg, except IOError: print else: print arg, f.close()
def handle_error(): try: raise RuntimeError( except RuntimeError as error: print( else: print( print(
>>> handle_error() handled a RuntimeError, no big deal. And now we have left the try block!
try: data = something_that_can_go_wrong() except Exception as e: handle_exception(e) else: do_stuff(data) finally: clean_up()
try: cs = x.cleanupSet except AttributeError: pass else: for v in cs: v.cleanup()
try: for v in x.cleanupSet: v.clenaup() except AttributeError: pass
a = [1,2,3] try: something = a[2] except: print "out of bounds" else: print something
try: something = a[2] except: print "out of bounds" if "something" in locals(): print something
for arg in sys.argv[1:]: try: f = open(arg, except IOError: print else: print arg, f.close()
try: do_init_stuff() except: handle_init_suff_execption() else: try: do_middle_stuff() except: handle_middle_stuff_exception()
try: fp= open("configuration_file", "rb") except EnvironmentError: confdata= else: confdata= fp.read() fp.close()
def debuglog(text, obj=None): " Simple little logger. " try: debug except NameError: pass except: print( else: try: if obj in debug: print(text) except TypeError: print( except: print( def myfunc(): debuglog( debug = [myfunc,] myfunc()
try: test_consistency(valuable_data) except Except1: inconsistency_type = 1 except Except2: inconsistency_type = 2 except: raise else: inconsistency_type = 0
try: query = queue.get() conn = connect_to_db(<main db>) curs = conn.cursor() try: curs.execute("<some query on user input that may fail even if sanitized">) except DBError: logconn = connect_to_db(<logging db>) logcurs = logconn.cursor() logcurs.execute("<update in DB log with record of failed query") logcurs.close() logconn.close() else: logconn = connect_to_db(<logging db>) logcurs = logconn.cursor() logcurs.execute("<update in DB log with record of successful query") logcurs.close() logconn.close() except DBError: finally: curs.close() conn.close()
while data in items: try data = json.loads(data) except ValueError as e: log error else:
try: val = dic[key] except KeyError: do_some_stuff() else: do_some_stuff_with_val()
while True: try: r = random.random() some_operation_that_fails_for_specific_r(r) except Exception: continue else: break
try: value, unit = cfg[ except ValueError: msg = self.log( else:
Downloading/unpacking http: -2.4.tar.gz Downloading psycopg2-2.4.tar.gz (607Kb): 607Kb downloaded Running setup.py egg_info for package from http: rce/p/psycopg2/psycopg2-2.4.tar.gz Error: pg_config executable not found. Please add the directory containing pg_config to the PATH or specify the full executable path with the option: python setup.py build_ext --pg-config /path/to/pg_config build ... or with the pg_config option in Complete output from command python setup.py egg_info: running egg_info creating pip-egg-info\psycopg2.egg-info writing pip-egg-info\psycopg2.egg-info\PKG-INFO writing top-level names to pip-egg-info\psycopg2.egg-info\top_level.txt writing dependency_links to pip-egg-info\psycopg2.egg-info\dependency_links.txt writing manifest file warning: manifest_maker: standard file Error: pg_config executable not found. Please add the directory containing pg_config to the PATH or specify the full executable path with the option: python setup.py build_ext --pg-config /path/to/pg_config build ... or with the pg_config option in ---------------------------------------- Command python setup.py egg_info failed with error code 1 Storing complete log in C:\Documents and Settings\anlopes\Application Data\pip\p ip.log
python setup.py build_ext --pg-config /path/to/pg_config build ...
C:\virtualenv\Scripts\> activate.bat (virtualenv) C:\virtualenv\Scripts\> easy_install psycopg2-2.5.win32-py2.7-pg9.2.4-release.exe
sudo yum install postgresql postgresql-devel python-devel
sudo PATH=$PATH:/usr/pgsql-9.3/bin/ pip install psycopg2
sudo dnf install postgresql-devel python3-devel sudo dnf install redhat-rpm-config
sudo pacman -S python-psycopg2 pip2 install psycopg2
brew install postgresql PATH=$PATH:/Library/PostgreSQL/9.4/bin pip install psycopg2
sudo port install postgresql96 export PATH=/opt/local/lib/postgresql96/bin:$PATH
std::string str = "Hello World!"; for (int i = 0; i < str.length(); ++i) { std::cout << str[i] << std::endl; }
>>> for i, c in enumerate( ... print i, c ... 0 t 1 e 2 s 3 t
name = "Mr.Suryaa" for index in range ( len ( name ) ): print ( name[index] )
for i in range ( 5 ) : can produce 0 , 1 , 2 , 3 , 4
class Simple: def __init__(self, s): print("inside the simple constructor") self.s = s def show(self): print(self.s) def showMsg(self, msg): print(msg +
if __name__ == "__main__": x = Simple("constructor argument") x.s = "test15" x.show() x.showMsg("A message")
class A: def __init__(self): self.__var = 123 def printVar(self): print self.__var
In [5]: class Test(object): ...: def __private_method(self): ...: return "Boo" ...: def public_method(self): ...: return self.__private_method() ...: In [6]: x = Test() In [7]: x.public_method() Out[7]: In [8]: x.__private_method() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-8-fa17ce05d8bc> in <module>() ----> 1 x.__private_method() AttributeError:
class Foo: def __init__(self, bar): self._bar = bar @property def bar(self): return self._bar
class Simple: def __init__(self, str): print("inside the simple constructor") self.__s = str def show(self): print(self.__s) def showMsg(self, msg): print(msg +
class A(object): def __init__(self): self.__foobar = None class B(A): def __init__(self): self.__foobar = 1
from classes.user import User from classes.dir import Dir
$ cat > class1.py <<\EOF class Class1: OKBLUE = ENDC = OK = OKBLUE + "[Class1 OK]: " + ENDC EOF
$ cat > class2.py <<\EOF class Class2: OKBLUE = ENDC = OK = OKBLUE + "[Class2 OK]: " + ENDC EOF
$ cat > main.py <<\EOF from class1 import Class1 from class2 import Class2 print Class1.OK print Class2.OK EOF
import log if __name__ == "__main__": app = log.SampleApp() app.mainloop()
from basic import log if __name__ == "__main__": app = log.SampleApp() app.mainloop()
import argparse parser = argparse.ArgumentParser() parser.add_argument("a") args = parser.parse_args() if args.a == print
... parser.add_argument("a", nargs= ... if args.a == print elif args.a == print else: print args.a
parser = argparse.ArgumentParser(description= parser.add_argument( parser.add_argument( args = vars(parser.parse_args())
parser = argparse.ArgumentParser() parser.add_argument( parser.add_argument( args = parser.parse_args()
args = parser.parse_args() print args.my_foo print args.bar_value
if (args.foo): print "foo is true" if (args.no_foo is False): print "nofoo is false"
args = parser.parse_args() argsdict = vars(args) print argsdict[ print argsdict[
import argparse parser = argparse.ArgumentParser(description="An argparse example") parser.add_argument( parser.add_argument( args = parser.parse_args() if args.action == "install": print("You asked for installation") else: print("You asked for something other than installation") print(getattr(args,
ValueError: dest supplied twice for positional argument
$ python test.py usage: test.py [-h] action foo-bar test.py: error: too few arguments $ python test.py -h usage: test.py [-h] action foo-bar An argparse example positional arguments: action The action to take (e.g. install, remove, etc.) foo-bar Hyphens are cumbersome in positional arguments optional arguments: -h, --help show this help message and exit $ python test.py install foo You asked for installation foo
import argparse parser = argparse.ArgumentParser() parser.add_argument("square", type=int, help="display a square of a given number") args = parser.parse_args() print(args.square**2)
import argparse parser = argparse.ArgumentParser() parser.add_argument("square", type=int, help="display a square of a given number") parser.add_argument("-v", "--verbosity", type=int, choices=[0, 1, 2], help="increase output verbosity") args = parser.parse_args() answer = args.square**2 if args.verbosity == 2: print("the square of {} equals {}".format(args.square, answer)) elif args.verbosity == 1: print("{}^2 == {}".format(args.square, answer)) else: print(answer)
import argparse def main(): parser = argparse.ArgumentParser() parser.add_argument( parser.add_argument( parser.add_argument( parser.add_argument( parsed = parser.parse_args() print( print( if __name__ == "__main__": main()
import argparse if __name__ == "__main__": parser = argparse.ArgumentParser() # # args = parser.parse_args() # #
parser.add_argument( parser.add_argument( parser.add_argument(
... parser.add_argument( globals().update(vars(parser.parse_args())) ... print(inputted_variable)
def main( arg: ( ): if arg == print("Argument has value A") elif arg == print("Argument has value B") if __name__ == import plac plac.call(main)
usage: example.py [-h] {A,B} example.py: error: the following arguments are required: arg
usage: example.py [-h] {A,B} example.py: error: argument arg: invalid choice:
usage: example.py [-h] {A,B} General help for application positional arguments: {A,B} Argument with two possible values optional arguments: -h, --help show this help message and exit
class Child(SomeBaseClass): def __init__(self): super(Child, self).__init__()
class Child(SomeBaseClass): def __init__(self): SomeBaseClass.__init__(self)
class SomeBaseClass(object): def __init__(self): print( class UnsuperChild(SomeBaseClass): def __init__(self): print( SomeBaseClass.__init__(self) class SuperChild(SomeBaseClass): def __init__(self): print( super(SuperChild, self).__init__()
class InjectMe(SomeBaseClass): def __init__(self): print( super(InjectMe, self).__init__() class UnsuperInjector(UnsuperChild, InjectMe): pass class SuperInjector(SuperChild, InjectMe): pass
>>> o = UnsuperInjector() UnsuperChild.__init__(self) called SomeBaseClass.__init__(self) called
>>> o2 = SuperInjector() SuperChild.__init__(self) called InjectMe.__init__(self) called SomeBaseClass.__init__(self) called
class A: def __init__(self): print("A.__init__()") class B(A): def __init__(self): print("B.__init__()") super(B, self).__init__()
In [26]: D.__mro__ Out[26]: (__main__.D, __main__.B, __main__.C, __main__.A, object)
In [23]: class A(object): ...: def __init__(self): ...: print("I ...: ...: class B(A): ...: def __init__(self): ...: print("I ...: super().__init__() ...: ...: class C(A): ...: def __init__(self): ...: print("I ...: super().__init__() ...: ...: class D(B, C): ...: def __init__(self): ...: print("I ...: super().__init__() ...: d = D() ...: I I I I A / ⇖ B ⇒ C ⇖ / D
In [21]: class A(object): ...: def __init__(self): ...: print("I ...: ...: class B(A): ...: def __init__(self): ...: super().__init__() ...: print("I ...: ...: class C(A): ...: def __init__(self): ...: super().__init__() ...: print("I ...: ...: class D(B, C): ...: def __init__(self): ...: super().__init__() ...: print("I ...: d = D() ...: I I I I
class A(object): def __new__(cls, *a, **kw): return super(A, cls).__new__(cls, *a, **kw)
class A(object): def __new__(cls): pass A.__new__() A.__new__(A)
class A(object): def __new__(cls, *a, **kw): return object.__new__(cls, *a, **kw)
class A(object): def __init__(self, *a, **kw): super(A, self).__init__(*a, **kw)
class A(object): def __init__(self, *a, **kw): object.__init__(self, *a, **kw)
class A(object): @classmethod def alternate_constructor(cls, *a, **kw): print "A.alternate_constructor called" return cls(*a, **kw) class B(A): @classmethod def alternate_constructor(cls, *a, **kw): print "B.alternate_constructor called" return super(B, cls).alternate_constructor(*a, **kw)
a = A.alternate_constructor() b = B.alternate_constructor()
class B(A): @classmethod def alternate_constructor(cls, *a, **kw): print "B.alternate_constructor called" return A.alternate_constructor(cls, *a, **kw)
class B(A): @classmethod def alternate_constructor(cls, *a, **kw): print "B.alternate_constructor called" unbound_func = A.alternate_constructor.im_func return unbound_func(cls, *a, **kw)
import signal import sys def signal_handler(sig, frame): print( sys.exit(0) signal.signal(signal.SIGINT, signal_handler) print( signal.pause()
import time, sys x = 1 while True: try: print x time.sleep(.3) x += 1 except KeyboardInterrupt: print "Bye" sys.exit()
import signal class GracefulInterruptHandler(object): def __init__(self, sig=signal.SIGINT): self.sig = sig def __enter__(self): self.interrupted = False self.released = False self.original_handler = signal.getsignal(self.sig) def handler(signum, frame): self.release() self.interrupted = True signal.signal(self.sig, handler) return self def __exit__(self, type, value, tb): self.release() def release(self): if self.released: return False signal.signal(self.sig, self.original_handler) self.released = True return True
with GracefulInterruptHandler() as h: for i in xrange(1000): print "..." time.sleep(1) if h.interrupted: print "interrupted!" time.sleep(2) break
with GracefulInterruptHandler() as h1: while True: print "(1)..." time.sleep(1) with GracefulInterruptHandler() as h2: while True: print "\t(2)..." time.sleep(1) if h2.interrupted: print "\t(2) interrupted!" time.sleep(2) break if h1.interrupted: print "(1) interrupted!" time.sleep(2) break
import signal import time def handler(signum, frame): print signal.signal(signal.SIGINT, handler) time.sleep(10)
if __name__ == try: main() except KeyboardInterrupt: pass finally: exit_gracefully()
class GracefulInterruptHandler(object): def __init__(self, signals=(signal.SIGINT, signal.SIGTERM)): self.signals = signals self.original_handlers = {} def __enter__(self): self.interrupted = False self.released = False for sig in self.signals: self.original_handlers[sig] = signal.getsignal(sig) signal.signal(sig, self.handler) return self def handler(self, signum, frame): self.release() self.interrupted = True def __exit__(self, type, value, tb): self.release() def release(self): if self.released: return False for sig in self.signals: signal.signal(sig, self.original_handlers[sig]) self.released = True return True
class SIGINT_handler(): def __init__(self): self.SIGINT = False def signal_handler(self, signal, frame): print( self.SIGINT = True handler = SIGINT_handler() signal.signal(signal.SIGINT, handler.signal_handler)
import signal default_handler = signal.getsignal(signal.SIGINT) catch_count = 0 def handler(signum, frame): global default_handler, catch_count catch_count += 1 print ( if catch_count > 3: signal.signal(signal.SIGINT, default_handler) print( signal.signal(signal.SIGINT, handler) print( while True: pass
RefactoringTool: Skipping implicit fixer: buffer RefactoringTool: Skipping implicit fixer: idioms RefactoringTool: Skipping implicit fixer: ws_comma --- range_test.py (original) +++ range_test.py (refactored) @@ -1,7 +1,7 @@ for x in range(20): - a=range(20) + a=list(range(20)) b=list(range(20)) c=[x for x in range(20)] d=(x for x in range(20)) - e=xrange(20) + e=range(20)
multiples_of_seven = range(7,100,7) print "Multiples of seven < 100: ", multiples_of_seven
Python 2.7.3 (default, Jul 13 2012, 22:29:01) [GCC 4.7.1] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> range(123456787676676767676676,123456787676676767676679) [123456787676676767676676L, 123456787676676767676677L, 123456787676676767676678L] >>> xrange(123456787676676767676676,123456787676676767676679) Traceback (most recent call last): File "<stdin>", line 1, in <module> OverflowError: Python int too large to convert to C long
Python 3.2.3 (default, Jul 14 2012, 01:01:48) [GCC 4.7.1] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> range(123456787676676767676676,123456787676676767676679) range(123456787676676767676676, 123456787676676767676679)
from __future__ import division def read_xrange(xrange_object): start = xrange_object[0] if len(xrange_object) > 1: step = xrange_object[1] - xrange_object[0] else: step = 1 stop = xrange_object[-1] + step return start, stop, step class Xrange(object): ex: a = Xrange(20) a.index(10) will work Also a[:5] will return another Xrange object with the specified attributes Also allows for the conversion from an existing xrange object def __init__(self, *inputs): if len(inputs) == 1: test, = inputs if type(test) == xrange: self.xrange = test self.start, self.stop, self.step = read_xrange(test) return self.start, self.step = 0, None if len(inputs) == 1: self.stop, = inputs elif len(inputs) == 2: self.start, self.stop = inputs elif len(inputs) == 3: self.start, self.stop, self.step = inputs else: raise ValueError(inputs) self.xrange = xrange(self.start, self.stop, self.step) def __iter__(self): return iter(self.xrange) def __getitem__(self, item): if type(item) is int: if item < 0: item += len(self) return self.xrange[item] if type(item) is slice: start, stop, step = item.start, item.stop, item.step start = start if start != None else 0 if start < 0: start += start start = self[start] if start < 0: raise IndexError(item) step = (self.step if self.step != None else 1) * (step if step != None else 1) stop = stop if stop is not None else self.xrange[-1] if stop < 0: stop += stop stop = self[stop] stop = stop if stop > self.stop: raise IndexError if start < self.start: raise IndexError return Xrange(start, stop, step) def index(self, value): error = ValueError( index = (value - self.start)/self.step if index % 1 != 0: raise error index = int(index) try: self.xrange[index] except (IndexError, TypeError): raise error return index def __len__(self): return len(self.xrange)
>>> zip(range(5), xrange(100000000)) [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
In [1]: range(1,10) Out[1]: [1, 2, 3, 4, 5, 6, 7, 8, 9] In [2]: xrange(10) Out[2]: xrange(10) In [3]: print xrange.__doc__ Out[3]: xrange([start,] stop[, step]) -> xrange object
import timeit for list_len in [1, 10, 100, 1000, 10000, 100000, 1000000]: rtime = timeit.timeit( xrtime = timeit.timeit( print "Loop list of len %d: range=%.4f, xrange=%.4f"%(list_len, rtime, xrtime)
Loop list of len 1: range=0.0003, xrange=0.0003 Loop list of len 10: range=0.0013, xrange=0.0011 Loop list of len 100: range=0.0068, xrange=0.0034 Loop list of len 1000: range=0.0609, xrange=0.0438 Loop list of len 10000: range=0.5527, xrange=0.5266 Loop list of len 100000: range=10.1666, xrange=7.8481 Loop list of len 1000000: range=168.3425, xrange=155.8719
In [5]: df = DataFrame({ In [6]: df Out[6]: A B 0 5 1 1 6 2 2 3 3 3 4 5 In [7]: df[df[ Out[7]: A B 1 6 2 2 3 3
for column in df.columns: for idx in df[column].index: x = df.get_value(idx,column) try: x = unicode(x.encode( df.set_value(idx,column,x) except Exception: print df.set_value(idx,column, continue
for column in df.columns: for idx in df[column].index: x = df.get_value(idx,column) try: x = x if type(x) == str else str(x).encode( df.set_value(idx,column,x) except Exception: print( df.set_value(idx,column, continue
df.to_dense().to_csv("submission.csv", index = False, sep=
In [1]: l = [4,5,6] In [2]: tuple Out[2]: <type In [3]: tuple(l) Out[3]: (4, 5, 6)
In [4]: tuple = tuple(l) In [5]: tuple Out[5]: (4, 5, 6)
>>> tuple = 45, 34 >>> tuple (45, 34) >>> l = [4, 5, 6] >>> tuple(l) Traceback (most recent call last): File "<pyshell tuple(l) TypeError: >>> >>> del tuple >>> tuple(l) (4, 5, 6)
>>> l= [1,2,"stackoverflow","pytho"] >>> l [1, 2, >>> tup = tuple(l) >>> type(tup) >>> tup = tuple(l) >>> type(tup) <type >>> type(tup) <type >>> tup (1, 2,
www.example.com/article/The%2046%20Year%20Old%20Virgin
class Article(models.Model): title = models.CharField(max_length=100) slug = models.SlugField(max_length=100)
from django.template.defaultfilters import slugify class Article(models.Model): title = models.CharField(max_length=100) def slug(self): return slugify(self.title)
class Article(models.Model): title = models.CharField(max_length=100) slug = models.SlugField(max_length=100, unique=True)
class ArticleAdmin(admin.ModelAdmin): list_display = ( search_fields = ( prepopulated_fields = {
import sys print(sys.platform) print(2**100) raw_input()
try: input = raw_input except NameError: pass print("Hi " + input("Say something: "))
Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation. All rights reserved. C:\Users\Weeble\My Python Program>_
try: import __builtin__ input = getattr(__builtin__, except (ImportError, AttributeError): pass
Python 2.7.3 (default, Apr 24 2012, 00:00:54) [GCC 4.7.0 20120414 (prerelease)] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> import time >>> ts = time.time() >>> print ts 1355563265.81 >>> import datetime >>> st = datetime.datetime.fromtimestamp(ts).strftime( >>> print st 2012-12-15 01:21:05 >>>
>>> import datetime >>> print datetime.datetime.utcnow() 2012-12-15 10:14:51.898000
>>> print datetime.datetime.now() 2012-12-15 11:15:09.205000
>>> datetime.datetime.now().strftime("%A, %d. %B %Y %I:%M%p")
>>> ts = datetime.datetime.now() >>> tf = datetime.datetime.now() >>> te = tf - ts >>> print ts 2015-04-21 12:02:19.209915 >>> print tf 2015-04-21 12:02:30.449895 >>> print te 0:00:11.239980
>>> import time >>> ts = int(time.time()) >>> print(ts) 1389177318
from datetime import datetime utc_dt = datetime.utcfromtimestamp(timestamp)
>>> import time >>> time.mktime(time.gmtime()) 1509467455.0
import os, sys sys.path.append( sys.path.append( os.environ[
@hourly python /path/to/project/manage.py runjobs hourly
from apscheduler.schedulers.background import BackgroundScheduler scheduler = BackgroundScheduler() job = None def tick(): print( def start_job(): global job job = scheduler.add_job(tick, try: scheduler.start() except: pass
import os,sys sys.path.append( os.environ[ from django.core.management impor setup_environ from store import settings setup_environ(settings)
from threading import Timer def sync(): do something... sync_timer = Timer(self.interval, sync, ()) sync_timer.start()
from celery import task from celery.decorators import periodic_task from celery.task.schedules import crontab from celery.utils.log import get_task_logger @periodic_task(run_every=crontab(minute="0", hour="23")) def do_every_midnight():
dictionary = { search_age = raw_input("Provide age") for age in dictionary.values(): if age == search_age: name = dictionary[age] print name
for name, age in dictionary.items(): if age == search_age: print(name)
mydict = { print mydict.keys()[mydict.values().index(16)]
mydict = { print(list(mydict.keys())[list(mydict.values()).index(16)])
for name, age in mydict.items(): if age == search_age: print name
[name for name, age in mydict.items() if age == search_age]
next((name for name, age in mydict.items() if age == search_age), None)
>>> def method1(list,search_age): ... for name,age in list.iteritems(): ... if age == search_age: ... return name ... >>> def method2(list,search_age): ... return [name for name,age in list.iteritems() if age == search_age] ... >>> def method3(list,search_age): ... return list.keys()[list.values().index(search_age)]
>>> profile.run("for i in range(0,100000): method1(list,16)") 200004 function calls in 1.173 seconds
>>> profile.run("for i in range(0,100000): method2(list,16)") 200004 function calls in 1.222 seconds
>>> profile.run("for i in range(0,100000): method3(list,16)") 400004 function calls in 2.125 seconds
>>> profile.run("for i in range(0,10000): method1(UIC_CRS, 20004 function calls in 2.928 seconds
>>> profile.run("for i in range(0,10000): method2(UIC_CRS, 20004 function calls in 3.872 seconds
>>> profile.run("for i in range(0,10000): method3(UIC_CRS, 40004 function calls in 1.176 seconds
lKey = [key for key, value in lDictionary.iteritems() if value == lValue][0]
list1 = { search_age = raw_input("Provide age: ") print search_age = int(search_age) listByAge = {} for name, age in list1.items(): if age == search_age: age = str(age) results = name + " " +age print results age2 = int(age) listByAge[name] = listByAge.get(name,0)+age2 print print listByAge
list1 = { search_age = raw_input("Provide age: ") print search_age = int(search_age) listByAge = {} for name, age in list1.items(): if age == search_age: age = str(age) results = name + " " +age print results age2 = int(age) listByAge[name] = listByAge.get(name,0)+age2 print print listByAge
Running: *\test.py (Thu Jun 06 05:10:02 2013) Provide age: 19 amber 19 Garry 19 { Execution Successful!
names_dict = { search_age = int(raw_input("Provide age")) key = names_dict.keys()[names_dict.values().index(search_age)]
lookup = {value: key for key, value in self.data} lookup[value]
import pandas as pd list = { lookup_list = pd.Series(list)
answer = lookup_list[lookup_list.values == 19].index answer = pd.Index.tolist(answer)
def recover_key(dicty,value): for a_key in dicty.keys(): if (dicty[a_key] == value): return a_key
mydict = { res = dict((v,k) for k,v in mydict.iteritems()) print(res[16])
mydict = { dict((v,k) for k,v in mydict.iteritems())[16]
for name in mydict.keys(): if mydict[name] == search_age: print name
def find_key(value, dictionary): return reduce(lambda x, y: x if x is not None else y, map(lambda x: x[0] if x[1] == value else None, dictionary.iteritems()))
def get_Value(dic,value): for name in dic: if dic[name] == value: del dic[name] return name
get_key = lambda v, d: next(k for k in d if d[k] is v)
reversed_dictionary = dict(map(reversed, dictionary.items()))
myList = { result=[] search_age = int(input( for keywords in myList.keys(): if myList[keywords] ==search_age: result.append(keywords) for res in result: print(res)
D = { age = int(input( for element in D.keys(): if D[element] == age: print(element)
ages = { search = 16 print([name for (name, age) in ages.items() if age == search])
for key in list: if list[key] == search_value: return key
titleDic = { def categoryTitleForNumber(self, num): search_title = for title, titleNum in self.titleDic.items(): if int(titleNum) == int(num): search_title = title return search_title
from enum import Enum class Color(Enum): red = 1 green = 2 blue = 3 >>> print(Color.red) Color.red >>> print(repr(Color.red)) <color.red: 1=""> >>> type(Color.red) <enum >>> isinstance(Color.green, Color) True >>> member = Color.red >>> member.name >>> member.value 1
reversedict = dict([(value, key) for key, value in mydict.iteritems()])
reversedict = {value:key for key, value in mydict.iteritems()}
reversedict = defaultdict(list) [reversedict[value].append(key) for key, value in mydict.iteritems()]
largedict = dict((x,x) for x in range(100000)) In [26]: %timeit largedict.keys()[largedict.values().index(90000)] 100 loops, best of 3: 4.81 ms per loop In [27]: %timeit largedict.keys()[largedict.values().index(9)] 100 loops, best of 3: 2.94 ms per loop In [31]: %timeit islice(largedict.iterkeys(), largedict.values().index(90000)) 100 loops, best of 3: 3.38 ms per loop In [32]: %timeit islice(largedict.iterkeys(), largedict.values().index(9)) 1000 loops, best of 3: 1.48 ms per loop In [24]: %timeit reversedict = dict([(value, key) for key, value in largedict.iteritems()]) 10 loops, best of 3: 22.9 ms per loop In [23]: %%timeit ....: reversedict = defaultdict(list) ....: [reversedict[value].append(key) for key, value in largedict.iteritems()] ....: 10 loops, best of 3: 53.6 ms per loop
In [72]: %%timeit ....: myf = ifilter(lambda x: x[1] == 90000, largedict.iteritems()) ....: myf.next()[0] ....: 100 loops, best of 3: 15.1 ms per loop In [73]: %%timeit ....: myf = ifilter(lambda x: x[1] == 9, largedict.iteritems()) ....: myf.next()[0] ....: 100000 loops, best of 3: 2.36 us per loop
list = { search_age = raw_input("Provide age") for age in list: if list[age] == search_age: print age
list = { search_age = raw_input("Provide age") for name in list: if list[name] == search_age: print name
people = { search_age = raw_input("Provide age") for name in people: if people[name][ print name
dictionary = { search_age = raw_input("Provide age") key = [filter( lambda x: dictionary[x] == k , dictionary ),[None]][0]
keys = [filter( lambda x: dictionary[x] == k , dictionary )]
def find_name(age, _rev_lookup=dict((v, k) for k, v in ages_by_name.items())): return _rev_lookup[age]
def create_name_finder(ages_by_name): names_by_age = dict((v, k) for k, v in ages_by_name.items()) def find_name(age): return names_by_age[age]
find_teen_by_age = create_name_finder({ ... find_teen_by_age(search_age)
>>> x = 10 >>> if x == 10 or x > 0 or \ x < 100: print
queryText= "SELECT * FROM TABLE1 AS T1"\ "JOIN TABLE2 AS T2 ON T1.SOMETHING = T2.SOMETHING"\ "JOIN TABLE3 AS T3 ON T3.SOMETHING = T2.SOMETHING"\ "WHERE SOMETHING BETWEEN <WHATEVER> AND <WHATEVER ELSE>"\ "ORDER BY WHATEVERS DESC"
SQL = """SELECT id, fld_1, fld_2, fld_3, ...... FROM some_tbl"""
SQL = "SELECT id, fld_1, fld_2, fld_3, .................................... FROM some_tbl"
age = int(input("Please enter your age: ")) if age >= 18: print("You are able to vote in the United States!") else: print("You are not able to vote in the United States.")
while True: try: age = int(input("Please enter your age: ")) except ValueError: print("Sorry, I didn continue else: break if age >= 18: print("You are able to vote in the United States!") else: print("You are not able to vote in the United States.")
while True: data = input("Please enter a loud message (must be all caps): ") if not data.isupper(): print("Sorry, your response was not loud enough.") continue else: break while True: data = input("Pick an answer from A to D:") if data.lower() not in ( print("Not an appropriate choice.") else: break
while True: try: age = int(input("Please enter your age: ")) except ValueError: print("Sorry, I didn continue if age < 0: print("Sorry, your response must not be negative.") continue else: break if age >= 18: print("You are able to vote in the United States!") else: print("You are not able to vote in the United States.")
def get_non_negative_int(prompt): while True: try: value = int(input(prompt)) except ValueError: print("Sorry, I didn continue if value < 0: print("Sorry, your response must not be negative.") continue else: break return value age = get_non_negative_int("Please enter your age: ") kids = get_non_negative_int("Please enter the number of children you have: ") salary = get_non_negative_int("Please enter your yearly earnings, in dollars: ")
def sanitised_input(prompt, type_=None, min_=None, max_=None, range_=None): if min_ is not None and max_ is not None and max_ < min_: raise ValueError("min_ must be less than or equal to max_.") while True: ui = input(prompt) if type_ is not None: try: ui = type_(ui) except ValueError: print("Input type must be {0}.".format(type_.__name__)) continue if max_ is not None and ui > max_: print("Input must be less than or equal to {0}.".format(max_)) elif min_ is not None and ui < min_: print("Input must be greater than or equal to {0}.".format(min_)) elif range_ is not None and ui not in range_: if isinstance(range_, range): template = "Input must be between {0.start} and {0.stop}." print(template.format(range_)) else: template = "Input must be {0}." if len(range_) == 1: print(template.format(*range_)) else: print(template.format(" or ".join((", ".join(map(str, range_[:-1])), str(range_[-1]))))) else: return ui
age = sanitised_input("Enter your age: ", int, 1, 101) answer = sanitised_input("Enter your answer: ", str.lower, range_=(
data = input("Please enter a loud message (must be all caps): ") while not data.isupper(): print("Sorry, your response was not loud enough.") data = input("Please enter a loud message (must be all caps): ")
def get_non_negative_int(prompt): try: value = int(input(prompt)) except ValueError: print("Sorry, I didn return get_non_negative_int(prompt) if value < 0: print("Sorry, your response must not be negative.") return get_non_negative_int(prompt) else: return value
age = None while age is None: input_value = input("Please enter your age: ") try: age = int(input_value) except ValueError: print("{input} is not a number, please enter a number only".format(input=input_value)) if age >= 18: print("You are able to vote in the United States!") else: print("You are not able to vote in the United States.")
Please enter your age: *potato* potato is not a number, please enter a number only Please enter your age: *5* You are not able to vote in the United States.
f=lambda age: (age.isdigit() and ((int(age)>=18 and "Can vote" ) or "Cannot vote")) or \ f(input("invalid input. Try again\nPlease enter your age: ")) print(f(input("Please enter your age: ")))
def read_single_keypress() -> str: """Waits for a single keypress on stdin. -- from :: https: """ import termios, fcntl, sys, os fd = sys.stdin.fileno() flags_save = fcntl.fcntl(fd, fcntl.F_GETFL) attrs_save = termios.tcgetattr(fd) attrs = list(attrs_save) attrs[0] &= ~(termios.IGNBRK | termios.BRKINT | termios.PARMRK | termios.ISTRIP | termios.INLCR | termios. IGNCR | termios.ICRNL | termios.IXON ) attrs[1] &= ~termios.OPOST attrs[2] &= ~(termios.CSIZE | termios. PARENB) attrs[2] |= termios.CS8 attrs[3] &= ~(termios.ECHONL | termios.ECHO | termios.ICANON | termios.ISIG | termios.IEXTEN) termios.tcsetattr(fd, termios.TCSANOW, attrs) fcntl.fcntl(fd, fcntl.F_SETFL, flags_save & ~os.O_NONBLOCK) try: ret = sys.stdin.read(1) except KeyboardInterrupt: ret = 0 finally: termios.tcsetattr(fd, termios.TCSAFLUSH, attrs_save) fcntl.fcntl(fd, fcntl.F_SETFL, flags_save) return ret def until_not_multi(chars) -> str: """read stdin until !(chars)""" import sys chars = list(chars) y = "" sys.stdout.flush() while True: i = read_single_keypress() _ = sys.stdout.write(i) sys.stdout.flush() if i not in chars: break y += i return y def _can_you_vote() -> str: print("can you vote? age : ", end="") x = int("0" + until_not_multi("0123456789")) if not x: print("\nsorry, age can only consist of digits.") return print("your age is", x, "\nYou can vote!" if x >= 18 else "Sorry! you can _can_you_vote()
$ ./input_constrain.py can you vote? age : a sorry, age can only consist of digits. $ ./input_constrain.py can you vote? age : 23<RETURN> your age is 23 You can vote! $ _
def validate_age(age): if age >=0 : return True return False while True: try: age = int(raw_input("Please enter your age:")) if validate_age(age): break except ValueError: print "Error: Invalid age."
def takeInput(required): print ans = raw_input( if not ans: print "You entered nothing...!" return takeInput(required) elif ans in [ print "Closing instance." exit() else: if ans.isdigit(): current = elif set( current = elif isinstance(ans,basestring): current = else: current = if required == current : return ans else: return takeInput(required) print "input: ", takeInput(
while True: try: age = int(input("Please enter your age: ")) if age >= 18: print("You are able to vote in the United States!") break else: print("You are not able to vote in the United States.") break except ValueError: print("Please enter a valid response")
def getValidInt(iMaxAttemps = None): iCount = 0 while True: if iCount != None and iCount > iMaxAttemps: return 0 i = raw_input("Enter no") try: i = int(i) except ValueError as e: print "Enter valid int value" else: break return i age = getValidInt()
def Input(Message): Value = None while Value == None or Value.isdigit() == False: try: Value = str(input(Message)).strip() except InputError: Value = None return Value age = 0 while age <=0 or age >150: age = int(Input("Please enter your age: ")) if age == 0: print("Terminating ...") exit(0) if age >= 18 and age <=150: print("You are able to vote in the United States!") else: print("You are not able to vote in the United States.")
while True: age = input("Please enter your age: ") if age.isdigit(): age = int(age) break else: print("Invalid number if age >= 18: print("You are able to vote in the United States!") else: print("You are not able to vote in the United States.")
while True: var = True try: age = int(input("Please enter your age: ")) except ValueError: print("Invalid input.") var = False if var == True: if age >= 18: print("You are able to vote in the United States.") break else: print("You are not able to vote in the United States.")
while True: name = input("Enter Your Name\n") if not name: print("I did not understood that") continue else: break while True: try: salary = float(input("whats ur salary\n")) except ValueError: print("I did not understood that") continue else: break while True: try: print("whats ur age?") age = int(float(input())) except ValueError: print("I did not understood that") continue else: break print("Hello "+ name + "\nYour salary is " + str(salary) +
while(1): try: age = int(input("Please enter your age: ")) if age >= 18: print("You are able to vote in the United States!") break() else: print("You are not able to vote in the United States.") break() except: print("Please only enter numbers ")
class ValidationError(ValueError): pass def RangeValidator(text,num,r): if num in r: return num raise ValidationError(text) def ValidCol(c): return RangeValidator("Columns must be in the range of 0 to 3 (inclusive)", c, range(4)) def ValidRow(r): return RangeValidator("Rows must be in the range of 5 to 15(exclusive)", r, range(5,15))
def GetInt(text, validator=None): print() while True: n = input(text) try: n = int(n) return n if validator is None else validator(n) except ValueError as ve: if isinstance(ve, ValidationError): print(ve) else: print("Invalid input: ", n) column = GetInt("Pleased enter column: ", ValidCol) row = GetInt("Pleased enter row: ", ValidRow) print( row, column)
Pleased enter column: 22 Columns must be in the range of 0 to 3 (inclusive) Pleased enter column: -2 Columns must be in the range of 0 to 3 (inclusive) Pleased enter column: 2 Pleased enter row: a Invalid input: a Pleased enter row: 72 Rows must be in the range of 5 to 15(exclusive) Pleased enter row: 9 9, 2
def validate_input(prompt, error_map): while True: try: data = int(input(prompt)) assert data > 0 return data except tuple(error_map.keys()) as e: print(error_map[type(e)])
d = {ValueError: KeyboardInterrupt: user_input = validate_input("Positive number: ", d)
import sys class ValidationError(ValueError): pass def validate_input(prompt, cast=str, cond=(lambda x: True), onerror=None): if onerror==None: onerror = {} while True: try: data = cast(input(prompt)) if not cond(data): raise ValidationError return data except tuple(onerror.keys()) as e: print(onerror[type(e)], file=sys.stderr)
anystr = validate_input("Enter any string: ") letters = validate_input("Enter letters: ", cond=str.isalpha, onerror={ValidationError: "Only letters, please!"}) percentage = validate_input("Percentage? ", cast=float, cond=lambda x: 0.0<=x<=100.0, onerror={ValidationError: "Must be between 0 and 100!", ValueError: "Not a number!"})
age = validate_input("Please enter your age: ", cast=int, cond=lambda a:0<=a<150, onerror={ValidationError: "Enter a plausible age, please!", ValueError: "Enter an integer, please!"}) if age >= 18: print("You are able to vote in the United States!") else: print("You are not able to vote in the United States.")
from ast import literal_eval def input_type(input_data): try: return type(literal_eval(input_data)) except (ValueError, SyntaxError): return str flag = True while(flag): age = raw_input("Please enter your age: ") if input_type(age)==float or input_type(age)==int: if eval(age)>=18: print("You are able to vote in the United States!") flag = False elif eval(age)>0 and eval(age)<18: print("You are not able to vote in the United States.") flag = False else: print("Please enter a valid number as your age.") else: print("Sorry, I didn
p = subprocess.Popen( output_str = p.stdout.readline()
import sys from subprocess import PIPE, Popen from threading import Thread try: from queue import Queue, Empty except ImportError: from Queue import Queue, Empty ON_POSIX = def enqueue_output(out, queue): for line in iter(out.readline, b queue.put(line) out.close() p = Popen([ q = Queue() t = Thread(target=enqueue_output, args=(p.stdout, q)) t.daemon = True t.start() try: line = q.get_nowait() except Empty: print( else:
import fcntl import os import sys fd = sys.stdin.fileno() fl = fcntl.fcntl(fd, fcntl.F_GETFL) fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK) while mainThreadIsRunning: try: input = sys.stdin.readline() except: continue handleInput(input)
import asyncio import os class SubprocessProtocol(asyncio.SubprocessProtocol): def pipe_data_received(self, fd, data): if fd == 1: print(data) def connection_lost(self, exc): loop.stop() if os.name == loop = asyncio.ProactorEventLoop() asyncio.set_event_loop(loop) else: loop = asyncio.get_event_loop() try: loop.run_until_complete(loop.subprocess_exec(SubprocessProtocol, "myprogram.exe", "arg1", "arg2")) loop.run_forever() finally: loop.close()
import asyncio import locale import sys from asyncio.subprocess import PIPE from contextlib import closing async def readline_and_kill(*args): process = await asyncio.create_subprocess_exec(*args, stdout=PIPE) async for line in process.stdout: print("got line:", line.decode(locale.getpreferredencoding(False))) break process.kill() return await process.wait() if sys.platform == "win32": loop = asyncio.ProactorEventLoop() asyncio.set_event_loop(loop) else: loop = asyncio.get_event_loop() with closing(loop): sys.exit(loop.run_until_complete(readline_and_kill( "myprogram.exe", "arg1", "arg2")))
import os from asyncproc import Process myProc = Process("myprogram.app") while True: poll = myProc.wait(os.WNOHANG) if poll != None: break out = myProc.read() if out != "": print out
from twisted.internet import protocol, reactor class MyProcessProtocol(protocol.ProcessProtocol): def outReceived(self, data): print data proc = MyProcessProtocol() reactor.spawnProcess(proc, reactor.run()
import subprocess def readAllSoFar(proc, retVal= while (select.select([proc.stdout],[],[],0)[0]!=[]): retVal+=proc.stdout.read(1) return retVal p = subprocess.Popen([ while not p.poll(): print (readAllSoFar(p))
lines = [ while not p.poll(): lines = readAllSoFar(p, lines[-1]).split( for a in range(len(lines)-1): print a lines = readAllSoFar(p, lines[-1]).split( for a in range(len(lines)-1): print a
f = open( p = subprocess.Popen( p.wait() f.close() str = open(
import tornado_subprocess import tornado.ioloop def print_res( status, stdout, stderr ) : print status, stdout, stderr if status == 0: print "OK:" print stdout else: print "ERROR:" print stderr t = tornado_subprocess.Subprocess( print_res, timeout=30, args=[ "cat", "/etc/passwd" ] ) t.start() tornado.ioloop.IOLoop.instance().start()
class MyHandler(tornado.web.RequestHandler): def on_done(self, status, stdout, stderr): self.write( stdout ) self.finish() @tornado.web.asynchronous def get(self): t = tornado_subprocess.Subprocess( self.on_done, timeout=30, args=[ "cat", "/etc/passwd" ] ) t.start()
from subprocess import Popen, PIPE from threading import Thread def process_output(myprocess): nextline = None buf = while True: out = myprocess.stdout.read(1) if out == if out != buf += out if out == nextline = buf buf = if not nextline: continue line = nextline nextline = None print myprocess.stdout.close() myprocess = Popen( p1 = Thread(target=process_output, args=(dcmpid,)) p1.daemon = True p1.start() if myprocess.poll() == None: myprocess.kill() myprocess.wait() if p1 and p1.is_alive(): p1.join()
import os import sys import time import fcntl import subprocess def async_read(fd): fl = fcntl.fcntl(fd, fcntl.F_GETFL) fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK) while True: try: ch = os.read(fd.fileno(), 1) if not ch: break sys.stdout.write(ch) except OSError: pass def shell(args, async=True): proc = subprocess.Popen(args, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) if async: async_read(proc.stdout) sout, serr = proc.communicate() return (sout, serr) if __name__ == cmd = sout, serr = shell(cmd.split())
import fcntl def non_block_read(output): fd = output.fileno() fl = fcntl.fcntl(fd, fcntl.F_GETFL) fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK) try: return output.read() except: return "" from subprocess import * sb = Popen("echo test && sleep 1000", shell=True, stdout=PIPE) sb.kill() non_block_read(sb.stdout)
# # from sys import argv from subprocess import Popen, PIPE import os, io from threading import Thread import Queue def __main__(): if (len(argv) > 1) and (argv[-1] == "-sub-"): import time, sys print "Application runned!" time.sleep(2) print "Slept 2 second" time.sleep(1) print "Slept 1 additional second", time.sleep(2) sys.stderr.write("Stderr output after 5 seconds") print "Eol on stdin" sys.stderr.write("Eol on stderr\n") time.sleep(1) print "Wow, we have end of work!", else: os.environ["PYTHONUNBUFFERED"]="1" try: p = Popen( argv + ["-sub-"], bufsize=0, stdin=PIPE, stdout=PIPE, stderr=PIPE ) except WindowsError, W: if W.winerror==193: p = Popen( argv + ["-sub-"], shell=True, bufsize=0, stdin=PIPE, stdout=PIPE, stderr=PIPE ) else: raise inp = Queue.Queue() sout = io.open(p.stdout.fileno(), serr = io.open(p.stderr.fileno(), def Pump(stream, category): queue = Queue.Queue() def rdr(): while True: buf = stream.read1(8192) if len(buf)>0: queue.put( buf ) else: queue.put( None ) return def clct(): active = True while active: r = queue.get() try: while True: r1 = queue.get(timeout=0.005) if r1 is None: active = False break else: r += r1 except Queue.Empty: pass inp.put( (category, r) ) for tgt in [rdr, clct]: th = Thread(target=tgt) th.setDaemon(True) th.start() Pump(sout, Pump(serr, while p.poll() is None: try: chan,line = inp.get(timeout = 1.0) if chan== print "STDOUT>>", line, "<?<" elif chan== print " ERROR==", line, "=?=" except Queue.Empty: pass print "Finish" if __name__ == __main__()
""" Example use: p = subprocess.Popen( command, stdout=subprocess.PIPE, ) pipe_non_blocking_set(p.stdout.fileno()) try: data = os.read(p.stdout.fileno(), 1) except PortableBlockingIOError as ex: if not pipe_non_blocking_is_error_blocking(ex): raise ex """ __all__ = ( "pipe_non_blocking_set", "pipe_non_blocking_is_error_blocking", "PortableBlockingIOError", ) import os if os.name == "nt": def pipe_non_blocking_set(fd): import msvcrt from ctypes import windll, byref, wintypes, WinError, POINTER from ctypes.wintypes import HANDLE, DWORD, BOOL LPDWORD = POINTER(DWORD) PIPE_NOWAIT = wintypes.DWORD(0x00000001) def pipe_no_wait(pipefd): SetNamedPipeHandleState = windll.kernel32.SetNamedPipeHandleState SetNamedPipeHandleState.argtypes = [HANDLE, LPDWORD, LPDWORD, LPDWORD] SetNamedPipeHandleState.restype = BOOL h = msvcrt.get_osfhandle(pipefd) res = windll.kernel32.SetNamedPipeHandleState(h, byref(PIPE_NOWAIT), None, None) if res == 0: print(WinError()) return False return True return pipe_no_wait(fd) def pipe_non_blocking_is_error_blocking(ex): if not isinstance(ex, PortableBlockingIOError): return False from ctypes import GetLastError ERROR_NO_DATA = 232 return (GetLastError() == ERROR_NO_DATA) PortableBlockingIOError = OSError else: def pipe_non_blocking_set(fd): import fcntl fl = fcntl.fcntl(fd, fcntl.F_GETFL) fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK) return True def pipe_non_blocking_is_error_blocking(ex): if not isinstance(ex, PortableBlockingIOError): return False return True PortableBlockingIOError = BlockingIOError
def non_blocking_readlines(f, chunk=1024): """ Iterate over lines, yielding b or when new data is not yet available. stdout_iter = iter(non_blocking_readlines(process.stdout)) line = next(stdout_iter) """ import os from .pipe_non_blocking import ( pipe_non_blocking_set, pipe_non_blocking_is_error_blocking, PortableBlockingIOError, ) fd = f.fileno() pipe_non_blocking_set(fd) blocks = [] while True: try: data = os.read(fd, chunk) if not data: yield b blocks.clear() except PortableBlockingIOError as ex: if not pipe_non_blocking_is_error_blocking(ex): raise ex yield b continue while True: n = data.find(b if n == -1: break yield b data = data[n + 1:] blocks.clear() blocks.append(data)
import io from subprocess import PIPE, Popen p = Popen([ SLEEP_DELAY = 0.001 with io.open(p.stdout.fileno(), while p.poll() == None: time.sleep(SLEEP_DELAY) while line = buffer.readline() while buffer.peek(): line = buffer.readline()
from subprocess import Popen, PIPE, STDOUT import io def __main__(): try: p = Popen( ["ping", "-n", "3", "127.0.0.1"], stdin=PIPE, stdout=PIPE, stderr=STDOUT ) except: print("Popen failed"); quit() sout = io.open(p.stdout.fileno(), while True: buf = sout.read1(1024) if len(buf) == 0: break print buf, if __name__ == __main__()
import fcntl import threading import sys, os, errno import subprocess class Logger(threading.Thread): def __init__(self, *modules): threading.Thread.__init__(self) try: from select import epoll, EPOLLIN self.__poll = epoll() self.__evt = EPOLLIN self.__to = -1 except: from select import poll, POLLIN print self.__poll = poll() self.__evt = POLLIN self.__to = 100 self.__fds = {} self.daemon = True self.start() def run(self): while True: events = self.__poll.poll(self.__to) for fd, ev in events: if (ev&self.__evt) != self.__evt: continue try: self.__fds[fd].run() except Exception, e: print e def add(self, fd, log): assert not self.__fds.has_key(fd) self.__fds[fd] = log self.__poll.register(fd, self.__evt) class log: logger = Logger() def __init__(self, name): self.__name = name self.__piped = False def fileno(self): if self.__piped: return self.write self.read, self.write = os.pipe() fl = fcntl.fcntl(self.read, fcntl.F_GETFL) fcntl.fcntl(self.read, fcntl.F_SETFL, fl | os.O_NONBLOCK) self.fdRead = os.fdopen(self.read) self.logger.add(self.read, self) self.__piped = True return self.write def __run(self, line): self.chat(line, nl=False) def run(self): while True: try: line = self.fdRead.readline() except IOError, exc: if exc.errno == errno.EAGAIN: return raise self.__run(line) def chat(self, line, nl=True): if nl: nl = else: nl = sys.stdout.write( def system(command, param=[], cwd=None, env=None, input=None, output=None): args = [command] + param p = subprocess.Popen(args, cwd=cwd, stdout=output, stderr=output, stdin=input, env=env, bufsize=0) p.wait() ls = log( ls.chat( system("ls", [ date = log( date.chat( system("date", output=date)
import os import sys import select import termios import tty import pty from subprocess import Popen command = old_tty = termios.tcgetattr(sys.stdin) tty.setraw(sys.stdin.fileno()) master_fd, slave_fd = pty.openpty() p = Popen(command, preexec_fn=os.setsid, stdin=slave_fd, stdout=slave_fd, stderr=slave_fd, universal_newlines=True) while p.poll() is None: r, w, e = select.select([sys.stdin, master_fd], [], []) if sys.stdin in r: d = os.read(sys.stdin.fileno(), 10240) os.write(master_fd, d) elif master_fd in r: o = os.read(master_fd, 10240) if o: os.write(sys.stdout.fileno(), o) termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_tty)
class workerThread(QThread): def __init__(self, cmd): QThread.__init__(self) self.cmd = cmd self.result = None self.error = None self.errorstr = "" def __del__(self): self.wait() DEBUG("Thread removed") def run(self): cmd_list = self.cmd.split(" ") try: cmd = subprocess.Popen(cmd_list, bufsize=1, stdin=None , universal_newlines=True , stderr=subprocess.PIPE , stdout=subprocess.PIPE) except OSError: self.error = 1 self.errorstr = "Failed to execute " + self.cmd ERROR(self.errorstr) finally: VERBOSE("task started...") import select while True: try: r,w,x = select.select([cmd.stdout, cmd.stderr],[],[]) if cmd.stderr in r: line = cmd.stderr.readline() if line != "": line = line.strip() self.emit(SIGNAL("update_error(QString)"), line) if cmd.stdout in r: line = cmd.stdout.readline() if line == "": break line = line.strip() self.emit(SIGNAL("update_output(QString)"), line) except IOError: pass cmd.wait() self.result = cmd.returncode if self.result < 0: self.error = 1 self.errorstr = "Task terminated by signal " + str(self.result) ERROR(self.errorstr) return if self.result: self.error = 1 self.errorstr = "exit code " + str(self.result) ERROR(self.errorstr) return return
import select def read_available(input_stream, max_bytes=None): """ Blocks until any data is available, then all available data is then read and returned. This function returns an empty string when end of stream is reached. Args: input_stream: The stream to read from. max_bytes (int|None): The maximum number of bytes to read. This function may return fewer bytes than this. Returns: str """ input_streams = [input_stream] empty_list = [] read_buffer = "" if len(select.select(input_streams, empty_list, empty_list)[0]) > 0: def select_func(): return len(select.select(input_streams, empty_list, empty_list, 0)[0]) > 0 if max_bytes is not None: def while_func(): return (len(read_buffer) < max_bytes) and select_func() else: while_func = select_func while True: read_data = input_stream.read(1) if len(read_data) == 0: break read_buffer += read_data if not while_func(): break return read_buffer
import sys import os from select import select readEnd, writeEnd = os.pipe() readFile = os.fdopen(readEnd) writeFile = os.fdopen(writeEnd, "w") def getKey(): dr,dw,de = select([sys.__stdin__, readFile], [], []) if sys.__stdin__ in dr: return sys.__stdin__.read(1) else: return None def breakStdinRead(): writeFile.write( writeFile.flush() key = getKey() if key: else: breakStdinRead()
def set_up_ping(ip, w): p = subprocess.Popen([ fl = fcntl.fcntl(p.stdout, fcntl.F_GETFL) fcntl.fcntl(p.stdout, fcntl.F_SETFL, fl | os.O_NONBLOCK) stdout_gid = gobject.io_add_watch(p.stdout, gobject.IO_IN, w) return stdout_gid
>>> class Dict(dict): ... def __add__(self, other): ... copy = self.copy() ... copy.update(other) ... return copy ... def __radd__(self, other): ... copy = other.copy() ... copy.update(self) ... return copy ... >>> default_data = Dict({ >>> default_data + { { >>> { {
>>> s = pd.Series(np.nan, index=[49,48,47,46,45, 1, 2, 3, 4, 5]) >>> s 49 NaN 48 NaN 47 NaN 46 NaN 45 NaN 1 NaN 2 NaN 3 NaN 4 NaN 5 NaN
>>> s.iloc[:3] 49 NaN 48 NaN 47 NaN >>> s.loc[:3] 49 NaN 48 NaN 47 NaN 46 NaN 45 NaN 1 NaN 2 NaN 3 NaN >>> s.ix[:3] 49 NaN 48 NaN 47 NaN 46 NaN 45 NaN 1 NaN 2 NaN 3 NaN
>>> s.iloc[:6] 49 NaN 48 NaN 47 NaN 46 NaN 45 NaN 1 NaN >>> s.loc[:6] KeyError: 6 >>> s.ix[:6] KeyError: 6
>>> s2 = pd.Series(np.nan, index=[ >>> s2.index.is_mixed() True >>> s2.ix[:6] a NaN b NaN c NaN d NaN e NaN 1 NaN
>>> df = pd.DataFrame(np.nan, index=list( columns=[ >>> df x y z 8 9 a NaN NaN NaN NaN NaN b NaN NaN NaN NaN NaN c NaN NaN NaN NaN NaN d NaN NaN NaN NaN NaN e NaN NaN NaN NaN NaN
>>> df.ix[: x y z 8 a NaN NaN NaN NaN b NaN NaN NaN NaN c NaN NaN NaN NaN
>>> df.iloc[:df.index.get_loc( x y z 8 a NaN NaN NaN NaN b NaN NaN NaN NaN c NaN NaN NaN NaN
age 4 color white food Apple height 80 score 3.3 state AL Name: Penelope, dtype: object
age 32 color gray food Cheese height 180 score 1.8 state AK Name: Dean, dtype: object
df.iloc[[1,4], 2] Nick Lamb Dean Cheese Name: food, dtype: object
labels = [ index_ints = [df.index.get_loc(label) for label in labels] df.iloc[index_ints, [2, 4]]
df[ Jane Steak Nick Lamb Aaron Mango Penelope Apple Dean Cheese Christina Melon Cornelia Beans Name: food, dtype: object
from setuptools import setup, find_packages setup( name = "mymath", version = "0.1", packages = find_packages() )
>>> from collections import Counter >>> A = Counter({ >>> B = Counter({ >>> A + B Counter({
a = { b = { r = dict(a.items() + b.items() + [(k, a[k] + b[k]) for k in set(b) & set(a)])
def combine_dicts(a, b, op=operator.add): return dict(a.items() + b.items() + [(k, op(a[k], b[k])) for k in set(b) & set(a)])
>>> a = { >>> b = { >>> import operator >>> print combine_dicts(a, b, operator.mul) {
>>> A = { >>> B = { >>> c = {x: A.get(x, 0) + B.get(x, 0) for x in set(A).union(B)} >>> print(c) {
class MyDict(dict): def __add__(self, oth): r = self.copy() try: for key, val in oth.items(): if key in r: r[key] += val else: r[key] = val except AttributeError: return NotImplemented return r a = MyDict({ b = MyDict({ print(a+b)
myDict = {} for k in itertools.chain(A.keys(), B.keys()): myDict[k] = A.get(k, 0)+B.get(k, 0)
A = { B = { newdict = {} newdict.update(A) newdict.update(B) for i in A.keys(): try: addition = A[i] + B[i] newdict[i] = addition except KeyError: continue
In [1]: from collections import Counter In [2]: A = Counter({ In [3]: B = Counter({ In [4]: A + B Out[4]: Counter({
import itertools import collections dictA = { dictB = { new_dict = collections.defaultdict(int) for k, v in itertools.chain(dictA.iteritems(), dictB.iteritems()): new_dict[k] += v print dict(new_dict) {
from mergedict import MergeDict class SumDict(MergeDict): @MergeDict.dispatch(int) def merge_int(this, other): return this + other d2 = SumDict({ d2.merge({ assert d2 == {
from collections import Counter a = Counter({ b = Counter({ %timeit a + b; %timeit a.update(b)
a = { "a": 1, "b": 2, "c": 3 } b = { "a": 2, "b": 3, "d": 5 } for key in b: if key in a: b[key] = b[key] + a[key] c = {**a, **b} print(c) >>> c {
a = { b = { def mergsum(a, b): for k in b: if k in a: b[k] = b[k] + a[k] c = {**a, **b} return c print(mergsum(a, b))
def merge_with(f, xs, ys): xs = a_copy_of(xs) for (y, v) in ys.iteritems(): xs[y] = v if y not in xs else f(xs[x], v) merge_with((lambda x, y: x + y), A, B)
def merge_dicts(f, *dicts): result = {} for d in dicts: for (k, v) in d.iteritems(): result[k] = v if k not in result else f(result[k], v)
a = { dicts = [{ { def merge_dicts(merged,mergedfrom): for k,v in mergedfrom.items(): if k in merged: merged[k] += v else: merged[k] = v return merged for dct in dicts: a = merge_dicts(a,dct) print (a)
class SumDict(dict): def __add__(self, y): return {x: self.get(x, 0) + y.get(x, 0) for x in set(self).union(y)} A = SumDict({ B = SumDict({ print(A + B)
from collections import Counter A = Counter({ B = Counter({ C = Counter({ list_of_counts = [A, B, C] total = sum(list_of_counts, Counter()) print(total)
total = Counter() for count in list_of_counts: total += count print(total)
def dict_merge_and_sum( d1, d2 ): ret = d1 ret.update({ k:v + d2[k] for k,v in d1.items() if k in d2 }) ret.update({ k:v for k,v in d2.items() if k not in d1 }) return ret A = { B = { print( dict_merge_and_sum( A, B ) )
import os path="/Users/HOME/Desktop/Addl Work/TimeSeries-Done" os.chdir(path)
import os import pandas as pd tar = os.chdir( print os.getcwd()
var = raw_input("Please enter something: ") print "you entered", var
var = input("Please enter something: ") print("You entered " + str(var))
input_var = input("Enter something: ") print ("you entered " + input_var)
import argparse import sys try: parser = argparse.ArgumentParser() parser.add_argument("square", help="display a square of a given number", type=int) args = parser.parse_args() print args.square**2 print sys.argv print sys.argv[1] except: e = sys.exc_info()[0] print e
C:\Users\bgh37516\Desktop>python -i emp.py five usage: emp.py [-h] square emp.py: error: argument square: invalid int value: <type
import argparse parser = argparse.ArgumentParser(description= parser.add_argument( help= parser.add_argument( const=sum, default=max, help= args = parser.parse_args() print args.accumulate(args.integers)
sudo apt-get install python-setuptools sudo easy_install statlib sudo easy_install construct
$ python -c "import requests; print(requests.__version__)" 2.14.2 $ python -c "import lxml; print(lxml.__version__)" Traceback (most recent call last): File "<string>", line 1, in <module> AttributeError:
>>> import statlib >>> print statlib.__version__ >>> import construct >>> print contruct.__version__
>>> import pkg_resources >>> pkg_resources.get_distribution("construct").version
python -c "import pkg_resources; print pkg_resources.get_distribution(
sudo pip install show sudo pip show YOUR_PACKAGE_NAME | grep Version
$ pip show numpy Name: numpy Version: 1.13.3 Summary: NumPy: array processing for numbers, strings, records, and objects. Home-page: http: Author: NumPy Developers Author-email: numpy-discussion@python.org License: BSD Location: c:\users\prowinjvm\appdata\local\programs\python\python36\lib\site-packages Requires:
>>> import celery >>> print(celery.__version__) 3.1.14
import sys for name, module in sorted(sys.modules.items()): if hasattr(module, print name, module.__version__
import modulename modulename.version modulename.version_info
asn1crypto==0.22.0 astroid==1.5.2 attrs==16.3.0 Automat==0.5.0 backports.functools-lru-cache==1.3 cffi==1.10.0 ...
!pip show xgboost !pip freeze | grep xgboost !pip list | grep xgboost
[{pkg.key : pkg.version} for pkg in pip.get_installed_distributions() if pkg.key in set(sys.modules) & set(globals())]
>>> import sys, pip, nltk, bs4 >>> [{pkg.key : pkg.version} for pkg in pip.get_installed_distributions() if pkg.key in set(sys.modules) & set(globals())] [{
>>>!pip show lxml | grep Version Version: 4.1.0 >>>!pip freeze | grep lxml lxml==4.1.0 >>>!pip list | grep lxml lxml 4.1.0 >>>!pip show lxml Name: lxml Version: 4.1.0 Summary: Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. Home-page: http: Author: lxml dev team Author-email: lxml-dev@lxml.de License: BSD Location: c:\users\karls\anaconda2\lib\site-packages Requires: Required-by: jupyter-contrib-nbextensions
dictionary = {"Name": "Harry", "Age": 17} dictionary["Name"] dictionary.get("Name")
>>> d = {1:2,2:3} >>> d[1] 2 >>> d.get(1) 2 >>> d.get(3) >>> repr(d.get(3)) >>> d.get(3,1) 1
def getway(d): for i in range(100): s = d.get(i) def lookup(d): for i in range(100): s = d[i]
>>> import timeit >>> print(timeit.timeit("getway({i:i for i in range(100)})","from __main__ import getway")) 20.2124660015 >>> print(timeit.timeit("lookup({i:i for i in range(100)})","from __main__ import lookup")) 16.16223979
>>> def lookup(d,val): ... return d[val] ... >>> def getway(d,val): ... return d.get(val) ... >>> dis.dis(getway) 2 0 LOAD_FAST 0 (d) 3 LOAD_ATTR 0 (get) 6 LOAD_FAST 1 (val) 9 CALL_FUNCTION 1 12 RETURN_VALUE >>> dis.dis(lookup) 2 0 LOAD_FAST 0 (d) 3 LOAD_FAST 1 (val) 6 BINARY_SUBSCR 7 RETURN_VALUE
class MyDict(dict): def __missing__(self, key): return None
>>> my_d = MyDict({1:2,2:3}) >>> my_d[1] 2 >>> my_d[3] >>> repr(my_d[3])
dictionary = {"Name": "Harry", "Age": 17} dictionary.get( >>
{"bids":{"id":16210506,"submitdate":"2011-10-16 15:53:25","submitdate_f":"10\/16\/2011 at 21:53 CEST","submitdate_f2":"p\u0159ed 2 lety","submitdate_ts":1318794805,"users_id":"2674360","project_id":"1250499"}}
{"bids":{"id":16210506,"submitdate":"2011-10-16 15:53:25","submitdate_f":"10\/16\/2011 at 21:53 CEST","submitdate_f2":"p\u0159ed 2 lety","users_id":"2674360","project_id":"1250499"}}
for item in API_call: submitdate_ts = item["bids"]["submitdate_ts"]
for item in API_call: submitdate_ts = item.get("bids", {
fruits = [ d = {} for fruit in fruits: if fruit not in d: d[fruit] = 0 d[fruit] += 1
for fruit in fruits: d[fruit] = d.get(fruit, 0) + 1
In [14]: user_dict = { In [15]: user_dict.get( Out[15]: False In [16]: user_dict.get( Out[16]:
In [17]: user_dict = { In [18]: user_dict.get( Out[18]: In [19]: user_dict.get( Out[19]:
d = {"Name": "Harry", "Age": 17} In [4]: d[ KeyError: In [5]: d.get( Out[5]:
def get_harry_info(key): try: return "{}".format(d[key]) except KeyError: return In [9]: get_harry_info( Out[9]: In [10]: get_harry_info( Out[10]:
>>> d={ >>> d[ Traceback (most recent call last): File "<pyshell d[ KeyError: >>> d.get( >>> print(d.get( None >>> d.get( 100 >>> d[ [1, 2, 3] >>> d.get( [1, 2, 3]
title = u"Klüft skräms inför på fédéral électoral große" import unicodedata unicodedata.normalize(
>>> a=u"aaaàçççñññ" >>> type(a) <type >>> a.encode( >>> a.encode( >>>
import codecs f = codecs.open( f.write(my_unicode_string)
import unicodedata raw_text = u"here $%6757 dfgdfg" convert_text = unicodedata.normalize(
import json, ast jdata = ast.literal_eval(json.dumps(jdata))
import os,sys,inspect currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) parentdir = os.path.dirname(currentdir) sys.path.insert(0,parentdir) import mymodule
import sys sys.path.append( from ptdraft import nib import ptdraft
. └── ptdraft ├── __init__.py ├── nib.py └── simulations ├── __init__.py └── life ├── __init__.py └── life.py
from setuptools import setup, find_packages setup(name=
PS C:\tmp\test_imports> python -m venv venv PS C:\tmp\test_imports> .\venv\Scripts\activate (venv) PS C:\tmp\test_imports>
(venv) PS C:\tmp\test_imports> pip install -e . Obtaining file: Installing collected packages: myproject Running setup.py develop for myproject Successfully installed myproject (venv) PS C:\tmp\test_imports> pip freeze myproject==1.0
from ptdraft.nib import function_from_nib if __name__ == function_from_nib()
(venv) PS C:\tmp\test_imports> python .\ptdraft\simulations\life\life.py I am the return value from function_from_nib!
import os.path, sys sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), os.pardir))
from inspect import getsourcefile import os.path as path, sys current_dir = path.dirname(path.abspath(getsourcefile(lambda:0))) sys.path.insert(0, current_dir[:current_dir.rfind(path.sep)]) import my_module sys.path.pop(0)
from inspect import getsourcefile import os.path import sys current_path = os.path.abspath(getsourcefile(lambda:0)) current_dir = os.path.dirname(current_path) parent_dir = current_dir[:current_dir.rfind(os.path.sep)] sys.path.insert(0, parent_dir) import my_module
from inspect import getsourcefile from os.path import abspath
import sys from pathlib import Path sys.path.append(str(Path(
import os,sys parentdir = os.path.dirname(__file__) sys.path.insert(0,parentdir)
string1 = string2 = if string1.lower() == string2.lower(): print "The strings are the same (case insensitive)" else: print "The strings are not the same (case insensitive)"
import unicodedata [unicodedata.name(char) for char in "ê"] [unicodedata.name(char) for char in "ê"]
unicodedata.normalize("NFKD", "ê") == unicodedata.normalize("NFKD", "ê")
import unicodedata def normalize_caseless(text): return unicodedata.normalize("NFKD", text.casefold()) def caseless_equal(left, right): return normalize_caseless(left) == normalize_caseless(right)
>>> utf8_bytes = open("unicode.txt", >>> print repr(utf8_bytes) >>> u = utf8_bytes.decode( >>> print u Σίσυφος ΣΊΣΥΦΟΣ >>> first, second = u.splitlines() >>> print first.lower() σίσυφος >>> print second.lower() σίσυφοσ >>> first.lower() == second.lower() False >>> first.upper() == second.upper() True
>>> s = open( >>> print(s) Σίσυφος ΣΊΣΥΦΟΣ >>> first, second = s.splitlines() >>> print(first.lower()) σίσυφος >>> print(second.lower()) σίσυφος >>> first.lower() == second.lower() True >>> first.upper() == second.upper() True
import unicodedata def NFD(text): return unicodedata.normalize( def canonical_caseless(text): return NFD(NFD(text).casefold())
In [42]: if re.search("ê","ê", re.IGNORECASE): ....: print(1) ....: 1
In [36]: "ß".lower() Out[36]: In [37]: "ß".upper() Out[37]: In [38]: "ß".upper().lower() Out[38]: In [39]: if re.search("ß","ßß", re.IGNORECASE): ....: print(1) ....: 1 In [40]: if re.search("SS","ßß", re.IGNORECASE): ....: print(1) ....: In [41]: if re.search("ß","SS", re.IGNORECASE): ....: print(1) ....:
def insenStringCompare(s1, s2): try: return s1.lower() == s2.lower() except AttributeError: print "Please only pass strings into this method." print "You passed a %s and %s" % (s1.__class__, s2.__class__)
import re as yes def bar_or_spam(): message = raw_input("\nEnter FoO for BaR or SpaM for EgGs (NCS): ") message_in_coconut = yes.compile(r lost_n_found = message_in_coconut.search(message).group() if lost_n_found != None: return lost_n_found.lower() else: print ("Make tea not love") return whatz_for_breakfast = bar_or_spam() if whatz_for_breakfast == foo: print ("BaR") elif whatz_for_breakfast == spam: print ("EgGs")
list1 = map(lambda each:each.lower(), list1) list2 = map(lambda each:each.lower(), list2)
def strings_iequal(first, second): try: return first.upper() == second.upper() except AttributeError: if not first: if not second: return True
import sys def Factorial(n): result = 1 for i in range (1,n): result = result * i print "factorial is ",result return result
import sys def Factorial(n): result = 1 for i in range (1,n): result = result * i print "factorial is ",result return result print Factorial(10)
class a: def blah: print("Hello world") def blah1: print("Hello world")
def your_choice(answer): if answer>5: print("You elif answer<=5 and answer>1: print("Welcome to the toddler else: print("No worries mate!")
File "foobar.py", line 69 ^ IndentationError: expected an indented block
import sys def Factorial(n): result = 0 for i in range (1,n): result = result * i print "factorial is ",result return result
class Unbuffered(object): def __init__(self, stream): self.stream = stream def write(self, data): self.stream.write(data) self.stream.flush() def writelines(self, datas): self.stream.writelines(datas) self.stream.flush() def __getattr__(self, attr): return getattr(self.stream, attr) import sys sys.stdout = Unbuffered(sys.stdout) print
def disable_stdout_buffering(): gc.garbage.append(sys.stdout) sys.stdout = os.fdopen(sys.stdout.fileno(), disable_stdout_buffering() print "hello" subprocess.call(["echo", "bye"])
Traceback (most recent call last): File "test/buffering.py", line 17, in <module> print "hello" IOError: [Errno 9] Bad file descriptor close failed: [Errno 9] Bad file descriptor
def disable_stdout_buffering(): fileno = sys.stdout.fileno() temp_fd = os.dup(fileno) sys.stdout.close() os.dup2(temp_fd, fileno) os.close(temp_fd) sys.stdout = os.fdopen(fileno, "w", 0)
import os import sys buf_arg = 0 if sys.version_info[0] == 3: os.environ[ buf_arg = 1 sys.stdout = os.fdopen(sys.stdout.fileno(), sys.stderr = os.fdopen(sys.stderr.fileno(),
import functools print = functools.partial(print, flush=True)
fl = fcntl.fcntl(fd.fileno(), fcntl.F_GETFL) fl |= os.O_SYNC fcntl.fcntl(fd.fileno(), fcntl.F_SETFL, fl)
def DisOutBuffering(): if sys.stdout.name == sys.stdout = os.fdopen(sys.stdout.fileno(), if sys.stderr.name == sys.stderr = os.fdopen(sys.stderr.fileno(),
def write_flush(args, w=stdout.write): w(args) stdout.flush()
import sys myFile= open( "a.log", "w", 0 ) sys.stdout= myFile
import sys; sys.stdout = sys.stderr print "Hello World!"
_orig_print = print def print(*args, **kwargs): _orig_print(*args, flush=True, **kwargs)
for tz in pytz.all_timezones: print tz Africa/Abidjan Africa/Accra Africa/Addis_Ababa Africa/Algiers Africa/Asmara Africa/Asmera Africa/Bamako Africa/Bangui Africa/Banjul Africa/Bissau Africa/Blantyre Africa/Brazzaville Africa/Bujumbura Africa/Cairo Africa/Casablanca Africa/Ceuta Africa/Conakry Africa/Dakar Africa/Dar_es_Salaam Africa/Djibouti Africa/Douala Africa/El_Aaiun Africa/Freetown Africa/Gaborone Africa/Harare Africa/Johannesburg Africa/Juba Africa/Kampala Africa/Khartoum Africa/Kigali Africa/Kinshasa Africa/Lagos Africa/Libreville Africa/Lome Africa/Luanda Africa/Lubumbashi Africa/Lusaka Africa/Malabo Africa/Maputo Africa/Maseru Africa/Mbabane Africa/Mogadishu Africa/Monrovia Africa/Nairobi Africa/Ndjamena Africa/Niamey Africa/Nouakchott Africa/Ouagadougou Africa/Porto-Novo Africa/Sao_Tome Africa/Timbuktu Africa/Tripoli Africa/Tunis Africa/Windhoek America/Adak America/Anchorage America/Anguilla America/Antigua America/Araguaina America/Argentina/Buenos_Aires America/Argentina/Catamarca America/Argentina/ComodRivadavia America/Argentina/Cordoba America/Argentina/Jujuy America/Argentina/La_Rioja America/Argentina/Mendoza America/Argentina/Rio_Gallegos America/Argentina/Salta America/Argentina/San_Juan America/Argentina/San_Luis America/Argentina/Tucuman America/Argentina/Ushuaia America/Aruba America/Asuncion America/Atikokan America/Atka America/Bahia America/Bahia_Banderas America/Barbados America/Belem America/Belize America/Blanc-Sablon America/Boa_Vista America/Bogota America/Boise America/Buenos_Aires America/Cambridge_Bay America/Campo_Grande America/Cancun America/Caracas America/Catamarca America/Cayenne America/Cayman America/Chicago America/Chihuahua America/Coral_Harbour America/Cordoba America/Costa_Rica America/Creston America/Cuiaba America/Curacao America/Danmarkshavn America/Dawson America/Dawson_Creek America/Denver America/Detroit America/Dominica America/Edmonton America/Eirunepe America/El_Salvador America/Ensenada America/Fort_Wayne America/Fortaleza America/Glace_Bay America/Godthab America/Goose_Bay America/Grand_Turk America/Grenada America/Guadeloupe America/Guatemala America/Guayaquil America/Guyana America/Halifax America/Havana America/Hermosillo America/Indiana/Indianapolis America/Indiana/Knox America/Indiana/Marengo America/Indiana/Petersburg America/Indiana/Tell_City America/Indiana/Vevay America/Indiana/Vincennes America/Indiana/Winamac America/Indianapolis America/Inuvik America/Iqaluit America/Jamaica America/Jujuy America/Juneau America/Kentucky/Louisville America/Kentucky/Monticello America/Knox_IN America/Kralendijk America/La_Paz America/Lima America/Los_Angeles America/Louisville America/Lower_Princes America/Maceio America/Managua America/Manaus America/Marigot America/Martinique America/Matamoros America/Mazatlan America/Mendoza America/Menominee America/Merida America/Metlakatla America/Mexico_City America/Miquelon America/Moncton America/Monterrey America/Montevideo America/Montreal America/Montserrat America/Nassau America/New_York America/Nipigon America/Nome America/Noronha America/North_Dakota/Beulah America/North_Dakota/Center America/North_Dakota/New_Salem America/Ojinaga America/Panama America/Pangnirtung America/Paramaribo America/Phoenix America/Port-au-Prince America/Port_of_Spain America/Porto_Acre America/Porto_Velho America/Puerto_Rico America/Rainy_River America/Rankin_Inlet America/Recife America/Regina America/Resolute America/Rio_Branco America/Rosario America/Santa_Isabel America/Santarem America/Santiago America/Santo_Domingo America/Sao_Paulo America/Scoresbysund America/Shiprock America/Sitka America/St_Barthelemy America/St_Johns America/St_Kitts America/St_Lucia America/St_Thomas America/St_Vincent America/Swift_Current America/Tegucigalpa America/Thule America/Thunder_Bay America/Tijuana America/Toronto America/Tortola America/Vancouver America/Virgin America/Whitehorse America/Winnipeg America/Yakutat America/Yellowknife Antarctica/Casey Antarctica/Davis Antarctica/DumontDUrville Antarctica/Macquarie Antarctica/Mawson Antarctica/McMurdo Antarctica/Palmer Antarctica/Rothera Antarctica/South_Pole Antarctica/Syowa Antarctica/Vostok Arctic/Longyearbyen Asia/Aden Asia/Almaty Asia/Amman Asia/Anadyr Asia/Aqtau Asia/Aqtobe Asia/Ashgabat Asia/Ashkhabad Asia/Baghdad Asia/Bahrain Asia/Baku Asia/Bangkok Asia/Beirut Asia/Bishkek Asia/Brunei Asia/Calcutta Asia/Choibalsan Asia/Chongqing Asia/Chungking Asia/Colombo Asia/Dacca Asia/Damascus Asia/Dhaka Asia/Dili Asia/Dubai Asia/Dushanbe Asia/Gaza Asia/Harbin Asia/Hebron Asia/Ho_Chi_Minh Asia/Hong_Kong Asia/Hovd Asia/Irkutsk Asia/Istanbul Asia/Jakarta Asia/Jayapura Asia/Jerusalem Asia/Kabul Asia/Kamchatka Asia/Karachi Asia/Kashgar Asia/Kathmandu Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Kuala_Lumpur Asia/Kuching Asia/Kuwait Asia/Macao Asia/Macau Asia/Magadan Asia/Makassar Asia/Manila Asia/Muscat Asia/Nicosia Asia/Novokuznetsk Asia/Novosibirsk Asia/Omsk Asia/Oral Asia/Phnom_Penh Asia/Pontianak Asia/Pyongyang Asia/Qatar Asia/Qyzylorda Asia/Rangoon Asia/Riyadh Asia/Saigon Asia/Sakhalin Asia/Samarkand Asia/Seoul Asia/Shanghai Asia/Singapore Asia/Taipei Asia/Tashkent Asia/Tbilisi Asia/Tehran Asia/Tel_Aviv Asia/Thimbu Asia/Thimphu Asia/Tokyo Asia/Ujung_Pandang Asia/Ulaanbaatar Asia/Ulan_Bator Asia/Urumqi Asia/Vientiane Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Bermuda Atlantic/Canary Atlantic/Cape_Verde Atlantic/Faeroe Atlantic/Faroe Atlantic/Jan_Mayen Atlantic/Madeira Atlantic/Reykjavik Atlantic/South_Georgia Atlantic/St_Helena Atlantic/Stanley Australia/ACT Australia/Adelaide Australia/Brisbane Australia/Broken_Hill Australia/Canberra Australia/Currie Australia/Darwin Australia/Eucla Australia/Hobart Australia/LHI Australia/Lindeman Australia/Lord_Howe Australia/Melbourne Australia/NSW Australia/North Australia/Perth Australia/Queensland Australia/South Australia/Sydney Australia/Tasmania Australia/Victoria Australia/West Australia/Yancowinna Brazil/Acre Brazil/DeNoronha Brazil/East Brazil/West CET CST6CDT Canada/Atlantic Canada/Central Canada/East-Saskatchewan Canada/Eastern Canada/Mountain Canada/Newfoundland Canada/Pacific Canada/Saskatchewan Canada/Yukon Chile/Continental Chile/EasterIsland Cuba EET EST EST5EDT Egypt Eire Etc/GMT Etc/GMT+0 Etc/GMT+1 Etc/GMT+10 Etc/GMT+11 Etc/GMT+12 Etc/GMT+2 Etc/GMT+3 Etc/GMT+4 Etc/GMT+5 Etc/GMT+6 Etc/GMT+7 Etc/GMT+8 Etc/GMT+9 Etc/GMT-0 Etc/GMT-1 Etc/GMT-10 Etc/GMT-11 Etc/GMT-12 Etc/GMT-13 Etc/GMT-14 Etc/GMT-2 Etc/GMT-3 Etc/GMT-4 Etc/GMT-5 Etc/GMT-6 Etc/GMT-7 Etc/GMT-8 Etc/GMT-9 Etc/GMT0 Etc/Greenwich Etc/UCT Etc/UTC Etc/Universal Etc/Zulu Europe/Amsterdam Europe/Andorra Europe/Athens Europe/Belfast Europe/Belgrade Europe/Berlin Europe/Bratislava Europe/Brussels Europe/Bucharest Europe/Budapest Europe/Chisinau Europe/Copenhagen Europe/Dublin Europe/Gibraltar Europe/Guernsey Europe/Helsinki Europe/Isle_of_Man Europe/Istanbul Europe/Jersey Europe/Kaliningrad Europe/Kiev Europe/Lisbon Europe/Ljubljana Europe/London Europe/Luxembourg Europe/Madrid Europe/Malta Europe/Mariehamn Europe/Minsk Europe/Monaco Europe/Moscow Europe/Nicosia Europe/Oslo Europe/Paris Europe/Podgorica Europe/Prague Europe/Riga Europe/Rome Europe/Samara Europe/San_Marino Europe/Sarajevo Europe/Simferopol Europe/Skopje Europe/Sofia Europe/Stockholm Europe/Tallinn Europe/Tirane Europe/Tiraspol Europe/Uzhgorod Europe/Vaduz Europe/Vatican Europe/Vienna Europe/Vilnius Europe/Volgograd Europe/Warsaw Europe/Zagreb Europe/Zaporozhye Europe/Zurich GB GB-Eire GMT GMT+0 GMT-0 GMT0 Greenwich HST Hongkong Iceland Indian/Antananarivo Indian/Chagos Indian/Christmas Indian/Cocos Indian/Comoro Indian/Kerguelen Indian/Mahe Indian/Maldives Indian/Mauritius Indian/Mayotte Indian/Reunion Iran Israel Jamaica Japan Kwajalein Libya MET MST MST7MDT Mexico/BajaNorte Mexico/BajaSur Mexico/General NZ NZ-CHAT Navajo PRC PST8PDT Pacific/Apia Pacific/Auckland Pacific/Chatham Pacific/Chuuk Pacific/Easter Pacific/Efate Pacific/Enderbury Pacific/Fakaofo Pacific/Fiji Pacific/Funafuti Pacific/Galapagos Pacific/Gambier Pacific/Guadalcanal Pacific/Guam Pacific/Honolulu Pacific/Johnston Pacific/Kiritimati Pacific/Kosrae Pacific/Kwajalein Pacific/Majuro Pacific/Marquesas Pacific/Midway Pacific/Nauru Pacific/Niue Pacific/Norfolk Pacific/Noumea Pacific/Pago_Pago Pacific/Palau Pacific/Pitcairn Pacific/Pohnpei Pacific/Ponape Pacific/Port_Moresby Pacific/Rarotonga Pacific/Saipan Pacific/Samoa Pacific/Tahiti Pacific/Tarawa Pacific/Tongatapu Pacific/Truk Pacific/Wake Pacific/Wallis Pacific/Yap Poland Portugal ROC ROK Singapore Turkey UCT US/Alaska US/Aleutian US/Arizona US/Central US/East-Indiana US/Eastern US/Hawaii US/Indiana-Starke US/Michigan US/Mountain US/Pacific US/Pacific-New US/Samoa UTC Universal W-SU WET Zulu
In [40]: import pytz In [41]: pytz.all_timezones Out[42]: [ ...]
In [45]: len(pytz.common_timezones) Out[45]: 403 In [46]: len(pytz.all_timezones) Out[46]: 563
import datetime tz = pytz.timezone( ct = datetime.datetime.now(tz=tz) >>> ct.isoformat() 2017-01-13T11:29:22.601991-05:00
my_ct = datetime.datetime.now(tz=pytz.UTC) new_ct = my_ct.astimezone(tz) >>> new_ct.isoformat() 2017-01-13T11:29:22.601991-05:00
import pytz import dateutil.tz from datetime import datetime print((datetime(2017,2,13,14,29,29, tzinfo=pytz.timezone( - datetime(2017,2,13,14,29,29, tzinfo=pytz.timezone( .total_seconds()) print((datetime(2017,2,13,14,29,29, tzinfo=dateutil.tz.gettz( - datetime(2017,2,13,14,29,29, tzinfo=dateutil.tz.tzutc())) .total_seconds()) -29160.0 -28800.0
>>> results = ["1", "2", "3"] >>> results = [int(i) for i in results] >>> results [1, 2, 3]
def str_list_to_int_list(str_list): n = 0 while n < len(str_list): str_list[n] = int(str_list[n]) n += 1 return(str_list)
>>> results = ["1", "2", "3"] >>> str_list_to_int_list(results) [1, 2, 3]
Searching for lxml Reading http: Reading http: Best match: lxml 2.3 Downloading http: Processing lxml-2.3.tgz Running lxml-2.3/setup.py -q bdist_egg --dist-dir /tmp/easy_install-7UdQOZ/lxml-2.3/egg-dist-tmp-GacQGy Building lxml version 2.3. Building without Cython. ERROR: /bin/sh: xslt-config: not found ** make sure the development packages of libxml2 and libxslt are installed ** Using build configuration of libxslt In file included from src/lxml/lxml.etree.c:227:0: src/lxml/etree_defs.h:9:31: fatal error: libxml/xmlversion.h: No such file or directory compilation terminated.
<successful connection info> ==> SYST ... done. ==> PWD ... done. ==> TYPE I ... done. ==> CWD (1) /libxml2 ... done. ==> SIZE libxml2-sources-2.6.27.tar.gz ... done. ==> PASV ... done. ==> RETR libxml2-sources-2.6.27.tar.gz ... No such file `libxml2-sources-2.6.27.tar.gz
checking for libxml libraries >= 2.6.27... configure: error: Could not find libxml2 anywhere, check ftp:
apt-get install libxml2-dev libxslt1-dev python-dev
sudo apt-get install libxml2-dev libxslt-dev python-dev lib32z1-dev
sudo apt-get install libxml2-dev libxslt-dev python-dev zlib1g-dev
config.vm.provider "virtualbox" do |vb| vb.memory = 1024 end
sudo yum install python-setuptools sudo easy_install pip
sudo yum install python34-setuptools sudo easy_install pip
sudo apt-get install python3-setuptools ca-certificates sudo easy_install3 pip
wget http: python distribute_setup.py easy_install pip
ganesh@Ganesh:~$ python3 Python 3.6.6 (default, Sep 12 2018, 18:26:19) [GCC 8.0.1 20180414 (experimental) [trunk revision 259383]] on linux Type "help", "copyright", "credits" or "license" for more information. >>>
virtualenv -p /usr/local/bin/python3.3 ENV --verbose
sudo apt-get install build-essential libncursesw5-dev libssl-dev libgdbm-dev libc6-dev libsqlite3-dev tk-dev
wget https: tar xvf Python-3.4.0.tar.xz cd Python-3.4.0 ./configure make make test sudo make install
wget https: unzip distribute-0.7.3.zip cd distribute-0.7.3 sudo setup.py install sudo easy_install-3.4 pip sudo pip3.4 install virtualenv sudo pip3.4 install virtualenvwrapper mkvirtualenv py3 python --version Python 3.4.1
sudo yum upgrade python-setuptools sudo yum install python-pip python-wheel
sudo dnf upgrade python-setuptools sudo dnf install python-pip python-wheel
sudo zypper install python-pip python-setuptools python-wheel
sudo zypper install python3-pip python3-setuptools python3-wheel
>>> import matplotlib.pyplot as plt Traceback (most recent call last): File "<stdin>", line 1, in <module> File " _backend_mod, new_figure_manager, draw_if_interactive, _show = pylab_setup() File " globals(),locals(),[backend_name],0) File " from matplotlib.backends import _macosx **RuntimeError**: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends.
import tensorflow as tf from tensorflow.python.saved_model import tag_constants with tf.Graph().as_default(): with tf.Session as sess: ... inputs = { "batch_size_placeholder": batch_size_placeholder, "features_placeholder": features_placeholder, "labels_placeholder": labels_placeholder, } outputs = {"prediction": model_output} tf.saved_model.simple_save( sess, )
graph = tf.Graph() with restored_graph.as_default(): with tf.Session as sess: tf.saved_model.loader.load( sess, [tag_constants.SERVING], ) batch_size_placeholder = graph.get_tensor_by_name( features_placeholder = graph.get_tensor_by_name( labels_placeholder = graph.get_tensor_by_name( prediction = restored_graph.get_tensor_by_name( sess.run(prediction, feed_dict={ batch_size_placeholder: some_value, features_placeholder: some_other_value, labels_placeholder: another_value })
import os import shutil import numpy as np import tensorflow as tf from tensorflow.python.saved_model import tag_constants def model(graph, input_tensor): """Create the model which consists of a bidirectional rnn (GRU(10)) followed by a dense classifier Args: graph (tf.Graph): Tensors input_tensor (tf.Tensor): Tensor fed as input to the model Returns: tf.Tensor: the model """ cell = tf.nn.rnn_cell.GRUCell(10) with graph.as_default(): ((fw_outputs, bw_outputs), (fw_state, bw_state)) = tf.nn.bidirectional_dynamic_rnn( cell_fw=cell, cell_bw=cell, inputs=input_tensor, sequence_length=[10] * 32, dtype=tf.float32, swap_memory=True, scope=None) outputs = tf.concat((fw_outputs, bw_outputs), 2) mean = tf.reduce_mean(outputs, axis=1) dense = tf.layers.dense(mean, 5, activation=None) return dense def get_opt_op(graph, logits, labels_tensor): """Create optimization operation from model Args: graph (tf.Graph): Tensors logits (tf.Tensor): The model labels_tensor (tf.Tensor): Target labels Returns: tf.Operation: the operation performing a stem of Adam optimizer """ with graph.as_default(): with tf.variable_scope( loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits( logits=logits, labels=labels_tensor, name= name="mean-xent" ) with tf.variable_scope( opt_op = tf.train.AdamOptimizer(1e-2).minimize(loss) return opt_op if __name__ == np.random.seed(0) features = np.random.randn(64, 10, 30) labels = np.eye(5)[np.random.randint(0, 5, (64,))] graph1 = tf.Graph() with graph1.as_default(): tf.set_random_seed(0) batch_size_ph = tf.placeholder(tf.int64, name= features_data_ph = tf.placeholder(tf.float32, [None, None, 30], labels_data_ph = tf.placeholder(tf.int32, [None, 5], dataset = tf.data.Dataset.from_tensor_slices((features_data_ph, labels_data_ph)) dataset = dataset.batch(batch_size_ph) iterator = tf.data.Iterator.from_structure(dataset.output_types, dataset.output_shapes) dataset_init_op = iterator.make_initializer(dataset, name= input_tensor, labels_tensor = iterator.get_next() logits = model(graph1, input_tensor) opt_op = get_opt_op(graph1, logits, labels_tensor) with tf.Session(graph=graph1) as sess: tf.global_variables_initializer().run(session=sess) for epoch in range(3): batch = 0 sess.run( dataset_init_op, feed_dict={ features_data_ph: features, labels_data_ph: labels, batch_size_ph: 32 }) values = [] while True: try: if epoch < 2: _, value = sess.run([opt_op, logits]) print( batch += 1 else: values.append(sess.run(logits)) print( batch += 1 except tf.errors.OutOfRangeError: break print( cwd = os.getcwd() path = os.path.join(cwd, shutil.rmtree(path, ignore_errors=True) inputs_dict = { "batch_size_ph": batch_size_ph, "features_data_ph": features_data_ph, "labels_data_ph": labels_data_ph } outputs_dict = { "logits": logits } tf.saved_model.simple_save( sess, path, inputs_dict, outputs_dict ) print( graph2 = tf.Graph() with graph2.as_default(): with tf.Session(graph=graph2) as sess: print( tf.saved_model.loader.load( sess, [tag_constants.SERVING], path ) print( labels_data_ph = graph2.get_tensor_by_name( features_data_ph = graph2.get_tensor_by_name( batch_size_ph = graph2.get_tensor_by_name( restored_logits = graph2.get_tensor_by_name( dataset_init_op = graph2.get_operation_by_name( sess.run( dataset_init_op, feed_dict={ features_data_ph: features, labels_data_ph: labels, batch_size_ph: 32 } ) restored_values = [] for i in range(2): restored_values.append(sess.run(restored_logits)) print( valid = all((v == rv).all() for v, rv in zip(values, restored_values)) print(
$ python3 save_and_restore.py Epoch 0, batch 0 | Sample value: [-0.13851789 -0.3087595 0.12804556 0.20013677 -0.08229901] Epoch 0, batch 1 | Sample value: [-0.00555491 -0.04339041 -0.05111827 -0.2480045 -0.00107776] Epoch 1, batch 0 | Sample value: [-0.19321944 -0.2104792 -0.00602257 0.07465433 0.11674127] Epoch 1, batch 1 | Sample value: [-0.05275984 0.05981954 -0.15913513 -0.3244143 0.10673307] Epoch 2, batch 0 | Final inference | Sample value: [-0.26331693 -0.13013336 -0.12553 -0.04276478 0.2933622 ] Epoch 2, batch 1 | Final inference | Sample value: [-0.07730117 0.11119192 -0.20817074 -0.35660955 0.16990358] Saving... INFO:tensorflow:Assets added to graph. INFO:tensorflow:No assets to write. INFO:tensorflow:SavedModel written to: b Ok Restoring... INFO:tensorflow:Restoring parameters from b Ok Restored values: [-0.26331693 -0.13013336 -0.12553 -0.04276478 0.2933622 ] Restored values: [-0.07730117 0.11119192 -0.20817074 -0.35660955 0.16990358] Inferences match: True
import tensorflow as tf w1 = tf.placeholder("float", name="w1") w2 = tf.placeholder("float", name="w2") b1= tf.Variable(2.0,name="bias") feed_dict ={w1:4,w2:8} w3 = tf.add(w1,w2) w4 = tf.multiply(w3,b1,name="op_to_restore") sess = tf.Session() sess.run(tf.global_variables_initializer()) saver = tf.train.Saver() print sess.run(w4,feed_dict) saver.save(sess,
import tensorflow as tf sess=tf.Session() saver = tf.train.import_meta_graph( saver.restore(sess,tf.train.latest_checkpoint( print(sess.run( graph = tf.get_default_graph() w1 = graph.get_tensor_by_name("w1:0") w2 = graph.get_tensor_by_name("w2:0") feed_dict ={w1:13.0,w2:17.0} op_to_restore = graph.get_tensor_by_name("op_to_restore:0") print sess.run(op_to_restore,feed_dict)
w1 = tf.Variable(tf.truncated_normal(shape=[10]), name= w2 = tf.Variable(tf.truncated_normal(shape=[20]), name= tf.add_to_collection( tf.add_to_collection( saver = tf.train.Saver() sess = tf.Session() sess.run(tf.global_variables_initializer()) saver.save(sess,
sess = tf.Session() new_saver = tf.train.import_meta_graph( new_saver.restore(sess, tf.train.latest_checkpoint( all_vars = tf.get_collection( for v in all_vars: v_ = sess.run(v) print(v_)
x = tf.placeholder(tf.float32) y = tf.placeholder(tf.float32) w = tf.Variable(tf.zeros([1, 1], dtype=tf.float32)) b = tf.Variable(tf.ones([1, 1], dtype=tf.float32)) y_hat = tf.add(b, tf.matmul(x, w)) ...more setup for optimization and what not... saver = tf.train.Saver() with tf.Session() as sess: sess.run(tf.initialize_all_variables()) if FLAGS.train: for i in xrange(FLAGS.training_steps): ...training loop... if (i + 1) % FLAGS.checkpoint_steps == 0: saver.save(sess, FLAGS.checkpoint_dir + global_step=i+1) else: ckpt = tf.train.get_checkpoint_state(FLAGS.checkpoint_dir) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess, ckpt.model_checkpoint_path) else: ...no checkpoint found... batch_x = ...load some data... predictions = sess.run(y_hat, feed_dict={x: batch_x})
import tensorflow as tf x = tf.placeholder("float", name="x") w = tf.Variable(2.0, name="w") b = tf.Variable(0.0, name="bias") h = tf.multiply(x, w) y = tf.add(h, b, name="y") sess = tf.Session() sess.run(tf.global_variables_initializer()) export_path = builder = tf.saved_model.builder.SavedModelBuilder(export_path) tensor_info_x = tf.saved_model.utils.build_tensor_info(x) tensor_info_y = tf.saved_model.utils.build_tensor_info(y) prediction_signature = ( tf.saved_model.signature_def_utils.build_signature_def( inputs={ outputs={ method_name=tf.saved_model.signature_constants.PREDICT_METHOD_NAME)) builder.add_meta_graph_and_variables( sess, [tf.saved_model.tag_constants.SERVING], signature_def_map={ tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: prediction_signature }, ) builder.save()
import tensorflow as tf sess=tf.Session() signature_key = tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY input_key = output_key = export_path = meta_graph_def = tf.saved_model.loader.load( sess, [tf.saved_model.tag_constants.SERVING], export_path) signature = meta_graph_def.signature_def x_tensor_name = signature[signature_key].inputs[input_key].name y_tensor_name = signature[signature_key].outputs[output_key].name x = sess.graph.get_tensor_by_name(x_tensor_name) y = sess.graph.get_tensor_by_name(y_tensor_name) y_out = sess.run(y, {x: 3.0})
W1 = tf.Variable(tf.truncated_normal([6, 6, 1, K], stddev=0.1), name="W1") B1 = tf.Variable(tf.constant(0.1, tf.float32, [K]), name="B1") Similarly, W2, B2, W3, .....
model_saver = tf.train.Saver() model_saver.save(session, "saved_models/CNN_New.ckpt")
with tf.Session(graph=graph_cnn) as session: model_saver.restore(session, "saved_models/CNN_New.ckpt") print("Model restored.") print(
with tf.Session() as sess: saver.restore(sess, tf.train.latest_checkpoint( sess.run(tf.global_variables_initializer()) graph = tf.get_default_graph() W1 = graph.get_tensor_by_name( W1_value = session.run(W1)
... saver = tf.train.Saver() with tf.Session() as sess: ... saver.save(sess, "/tmp/my_great_model") with tf.Session() as sess: saver.restore(sess, "/tmp/my_great_model") ...
saver = tf.train.import_meta_graph("/tmp/my_great_model.meta") with tf.Session() as sess: saver.restore(sess, "/tmp/my_great_model") ...
... graph = tf.get_default_graph() gvars = graph.get_collection(tf.GraphKeys.GLOBAL_VARIABLES) assign_ops = [graph.get_operation_by_name(v.op.name + "/Assign") for v in gvars] init_values = [assign_op.inputs[1] for assign_op in assign_ops] with tf.Session() as sess: ... gvars_state = sess.run(gvars) feed_dict = {init_value: val for init_value, val in zip(init_values, gvars_state)} sess.run(assign_ops, feed_dict=feed_dict)
python /path/to/tensorflow/tensorflow/python/tools/inspect_checkpoint.py --file_name=/path/to/pretrained_model/model.ckpt
graph = ... saver = tf.train.Saver() with ... as sess: saver.save(sess,
graph = ... saver = tf.train.Saver() with ... as sess: saver.restore(sess, tf.train.latest_checkpoint(
graph = ... for op in [ ... ]: tf.add_to_collection( saver = tf.train.Saver() with ... as sess: saver.save(sess,
with ... as sess: saver = tf.train.import_meta_graph( saver.restore(sess, tf.train.latest_checkpoint( ops = tf.get_collection(
saver = tf.train.Saver() save_file = with tf.Session() as sess: sess.run(tf.global_variables_initializer()) saver.save(sess, save_file)
saver = tf.train.Saver() save_file = with tf.Session() as sess: sess.run(tf.global_variables_initializer()) saver.restore(sess, save_file)
import tensorflow as tf import os tf.enable_eager_execution() checkpoint_directory = "/tmp/training_checkpoints" checkpoint_prefix = os.path.join(checkpoint_directory, "ckpt") checkpoint = tf.train.Checkpoint(optimizer=optimizer, model=model) status = checkpoint.restore(tf.train.latest_checkpoint(checkpoint_directory)) for _ in range(num_training_steps): optimizer.minimize( ... ) status.assert_consumed() checkpoint.save(file_prefix=checkpoint_prefix)
self.saver = tf.train.Saver() with tf.Session() as sess: sess.run(tf.global_variables_initializer()) ... self.saver.save(sess, filename)
saver = tf.train.import_meta_graph(filename) name = with tf.Session() as sess: saver.restore(sess, name) print(sess.run(
optimizer = tf.train.AdamOptimizer() global_step = tf.train.get_or_create_global_step() model = tf.keras.Sequential([ tf.keras.layers.Dense(10, activation=tf.nn.relu, input_shape=(4,)), tf.keras.layers.Dense(10, activation=tf.nn.relu, kernel_initializer= tf.keras.layers.Dense(3) ]) s = tfe.Saver([model]) s.restore(file_prefix="/tmp/iris-1")
INFO:tensorflow:Restoring parameters from /tmp/iris-1 --------------------------------------------------------------------------- ValueError... --> names, slices, dtypes = zip(*restore_specs)
__author__ = "Barack Obama" __copyright__ = "Copyright 2009, Planet Earth"
__author__ = "Rob Knight, Gavin Huttley, and Peter Maxwell" __copyright__ = "Copyright 2007, The Cogent Project" __credits__ = ["Rob Knight", "Peter Maxwell", "Gavin Huttley", "Matthew Wakefield"] __license__ = "GPL" __version__ = "1.0.1" __maintainer__ = "Rob Knight" __email__ = "rob@spot.colorado.edu" __status__ = "Production"
$ python -c "import django; print(django.get_version())" 2.0
>>> import django >>> print(django.get_version()) 1.6.1
>>> from distutils.version import StrictVersion >>> StrictVersion( True
josh@villaroyale:~/code/djangosite$ pip freeze | grep Django Django==1.4.3
django-admin --version python manage.py --version pip freeze | grep django
>>>from django import get_version >>> get_version()
>>> from django.utils import version >>> version.get_version() ... 1.9 >>> version.get_complete_version() ... (1, 9, 0,
>>> import pkg_resources; >>> pkg_resources.get_distribution(
>>> from distutils.version import LooseVersion, StrictVersion >>> LooseVersion("2.3.1") < LooseVersion("10.1.2") True >>> StrictVersion("2.3.1") < StrictVersion("10.1.2") True >>> StrictVersion("2.3.1") > StrictVersion("10.1.2") False
from nine import versions versions.DJANGO_1_7 versions.DJANGO_LTE_1_7 versions.DJANGO_GTE_1_7 versions.DJANGO_GTE_1_8 versions.DJANGO_GTE_1_4 versions.DJANGO_LTE_1_6
>>> import django >>> print(django.get_version()) 2.1
Django version Python versions 1.0 2.3, 2.4, 2.5, 2.6 1.1 2.3, 2.4, 2.5, 2.6 1.2 2.4, 2.5, 2.6, 2.7 1.3 2.4, 2.5, 2.6, 2.7 1.4 2.5, 2.6, 2.7 1.5 2.6.5, 2.7 and 3.2.3, 3.3 (experimental) 1.6 2.6.5, 2.7 and 3.2.3, 3.3 1.11 2.7, 3.4, 3.5, 3.6, 3.7 (added in 1.11.17) 2.0 3.4, 3.5, 3.6, 3.7 2.1, 2.2 3.5, 3.6, 3.7
>>> import django >>> print(django.get_version()) 2.1 >>> django.VERSION (2, 1, 4,
from my_package.timing.danger.internets import function_of_love
>>> import xml >>> type(xml) <type >>> xml.etree.ElementTree Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: >>> import xml.etree >>> type(xml.etree) <type >>> xml.etree.ElementTree Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: >>> import xml.etree.ElementTree >>> type(xml.etree.ElementTree) <type >>> xml.etree.ElementTree.parse <function parse at 0x00B135B0>
import a a ⇒ <module a.b ⇒ AttributeError: module import a.b.c a.b ⇒ <module a.b.c ⇒ <module
import a.b.c ⇒ ImportError: No module named import a.b a ⇒ <module a.__path__ ⇒ _NamespacePath([ a.b ⇒ <module a.b.__path__ ⇒ AttributeError:
item = someSortOfSelection() if item in myList: doMySpecialFunction(item)
matches = [x for x in lst if fulfills_some_condition(x)] matches = (x for x in lst if x > 6)
first_or_default = next((x for x in lst if ...), None)
next((i for i, x in enumerate(lst) if [condition on x]), [default value])
def first_true(iterable, default=False, pred=None): """Returns the first true value in the iterable. If no true value is found, returns *default* If *pred* is not None, returns the first item for which pred(item) is true. """ return next(filter(pred, iterable), default)
>>> first_true([2,3,4,5], None, lambda x: x%2==1) 3
list = [10, 20, 30, 40, 50] n = int(input("\nEnter a Number to search from the list : ")) if n in list : print("\nMatch found") else : print("\nMatch not found")
your_list = [11,22,23,44,55] filter(lambda x:your_list[x]>30,range(len(your_list)))
>>> a = 256 >>> b = 256 >>> a is b True >>> a = 257 >>> b = 257 >>> a is b False >>> 257 is 257 True
>>> a = 256 >>> b = 256 >>> id(a) 9987148 >>> id(b) 9987148 >>> a = 257 >>> b = 257 >>> id(a) 11662816 >>> id(b) 11662828
>>> a = 1000 >>> a == 1000 True >>> a != 5000 True >>> a is 1000 False
SENTINEL_SINGLETON = object() def foo(keyword_argument=None): if keyword_argument is None: print( bar() bar(keyword_argument) bar( def bar(keyword_argument=SENTINEL_SINGLETON): if keyword_argument is SENTINEL_SINGLETON: print( else: print( foo()
no argument given to foo no argument given to bar argument to bar: None argument to bar: baz
In [29]: a = 3 In [30]: b = 3 In [31]: id(a) Out[31]: 500729144 In [32]: id(b) Out[32]: 500729144
PyObject * PyLong_FromLong(long ival) { CHECK_SMALL_INT(ival); if (ival < 0) { abs_ival = 0U-(unsigned long)ival; sign = -1; } else { abs_ival = (unsigned long)ival; } if (!(abs_ival >> PyLong_SHIFT)) { v = _PyLong_New(1); if (v) { Py_SIZE(v) = sign; v->ob_digit[0] = Py_SAFE_DOWNCAST( abs_ival, unsigned long, digit); } return (PyObject*)v; }
do if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) { \ return get_small_int((sdigit)ival); \ } while(0)
if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS)
PyObject *v; assert(-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS); v = (PyObject *)&small_ints[ival + NSMALLNEGINTS]; Py_INCREF(v);
/* Small integers are preallocated in this array so that they can be shared. The integers that are preallocated are those in the range -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive). */ static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
for (ival = -NSMALLNEGINTS; ival < NSMALLPOSINTS; ival++, v++) { }
>>> codeObj = compile("257 is 257", "blah!", "exec") >>> codeObj.co_consts (257, None)
>>> import dis >>> dis.dis(codeObj) 1 0 LOAD_CONST 0 (257) 3 LOAD_CONST 0 (257) 6 COMPARE_OP 8 (is)
In [1]: id(255) Out[1]: 146349024 In [2]: id(255) Out[2]: 146349024 In [3]: id(257) Out[3]: 146802752 In [4]: id(257) Out[4]: 148993740 In [5]: a=255 In [6]: b=255 In [7]: c=257 In [8]: d=257 In [9]: id(a), id(b), id(c), id(d) Out[9]: (146349024, 146349024, 146783024, 146804020)
class Unequal: def __eq__(self, other): return False
import numpy, numbers assert not issubclass(numpy.int16,numbers.Number) assert issubclass(int,numbers.Number)
>>> s = b = >>> s == b, s is b, id(s), id(b) (True, True, 4555519392, 4555519392)
>>> s = >>> b = >>> s == b, s is b, id(s), id(b) (True, True, 4555519392, 4555519392)
>>> s1 = b1 = >>> s1 == b1, s1 is b1, id(s1), id(b1) (True, True, 4555308080, 4555308080) >>> s1 = >>> b1 = >>> s1 == b1, s1 is b1, id(s1), id(b1) (True, False, 4555308176, 4555308272)
>>> c = 257 >>> d = 257 >>> c is d False >>> e, f = 258, 258 >>> e is f True
>>> def f(): i, j = 258, 258 >>> dis.dis(f) 1 0 LOAD_CONST 2 ((128, 128)) 2 UNPACK_SEQUENCE 2 4 STORE_FAST 0 (i) 6 STORE_FAST 1 (j) 8 LOAD_CONST 0 (None) 10 RETURN_VALUE >>> f.__code__.co_consts (None, 128, (128, 128)) >>> id(f.__code__.co_consts[1], f.__code__.co_consts[2][0], f.__code__.co_consts[2][1]) 4305296480, 4305296480, 4305296480
some_list = [ if any("abc" in s for s in some_list):
matchers = [ matching = [s for s in my_list if any(xs in s for xs in matchers)]
[el for el in lst if isinstance(el, collections.Iterable) and (st in el)]
for item in my_list: if item.find("abc") != -1: print item
my_list = [ for item in my_list: if (item.find( print (
mylist=[ pattern=re.compile(r pattern.findall(mylist)
In [1]: t = ["abc_%s" % number for number in range(10000)] In [2]: %timeit any("9999" in string for string in t) 1000 loops, best of 3: 420 µs per loop In [3]: %timeit "9999" in ",".join(t) 10000 loops, best of 3: 103 µs per loop
a = [ aa = [ string for string in a if "abc" in string] print(aa) Output => [
>>> myString = >>> myString.find( 2 >>> myString.find( -1
>>> myString = >>> myString.index( 2 >>> myString.index( Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: substring not found
s = c = print [pos for pos, char in enumerate(s) if char == c]
>>> s="mystring" >>> s.index("r") 4 >>> s.find("r") 4
>>> for i,c in enumerate(s): ... if "r"==c: print i ... 4
filename_without_extension = complete_name[:complete_name.rfind(
def charposition(string, char): pos = [] for n in range(len(string)): if string[n] == char: pos.append(n) return pos s = "sentence" print(charposition(s,
import more_itertools as mit s = "supercalifragilisticexpialidocious" list(mit.locate(s, lambda x: x == "i"))
code1 class Foo: code2 def spam..... code3 for code4..: code5 x()
code1 class Foo: code2 def spam..... code3 for code4..: code5 x()
global_var1 = [] global_var2 = 1 def func(): global_var1.append(4) global_var2 = 2 local1 = 4 def embedded_func(): local1 = 5 print local1 embedded_func() print local1
global_var = 4 def change_global(): global global_var global_var = global_var + 1
x = 0 class X(object): y = x x = x + 1 z = x def method(self): print(self.x) print(x) print(y) inst = X() print(inst.x, inst.y, inst.z, x)
x = 5 def foobar(): global x print(x) x += 1 foobar() print(x)
x = 5 y = 13 def make_closure(): x = 42 y = 911 def func(): global x print(x, y) x += 1 return func func = make_closure() func() print(x, y)
def make_closure(): value = [0] def get_next_value(): value[0] += 1 return value[0] return get_next_value get_next = make_closure() print(get_next()) print(get_next())
def make_closure(): value = 0 def get_next_value(): nonlocal value value += 1 return value return get_next_value get_next = make_closure()
from __future__ import print_function x = 100 print("1. Global x:", x) class Test(object): y = x print("2. Enclosed y:", y) x = x + 1 print("3. Enclosed x:", x) def method(self): print("4. Enclosed self.x", self.x) print("5. Global x", x) try: print(y) except NameError as e: print("6.", e) def method_local_ref(self): try: print(x) except UnboundLocalError as e: print("7.", e) x = 200 print("8. Local x", x) inst = Test() inst.method() inst.method_local_ref()
x= 0 def fun1(): x= 1 def fun2(): x= 2 def fun3(): return x return fun3() return fun2() print fun1(), x 2 0
class LessThanZeroException(Exception): pass class variable(object): def __init__(self, value=0): self.__x = value def __set__(self, obj, value): if value < 0: raise LessThanZeroException( self.__x = value def __get__(self, obj, objType): return self.__x class MyClass(object): x = variable() >>> m = MyClass() >>> m.x = 10 >>> m.x -= 20 Traceback (most recent call last): File "<stdin>", line 1, in <module> File "my.py", line 7, in __set__ raise LessThanZeroException( LessThanZeroException: x is less than zero
def mymethod(listOfTuples): assert(all(type(tp)==tuple for tp in listOfTuples))
class XLessThanZeroException(Exception): pass def CheckX(x): if x < 0: raise XLessThanZeroException() def foo(x): CheckX(x)
def SumToN(n): if n <= 0: raise ValueError, "N must be greater than or equal to 0" else: return RecursiveSum(n) def RecursiveSum(n): assert(n >= 0) if n == 0: return 0 return RecursiveSum(n - 1) + n
def mymethod(listOfTuples): assert(all(type(tp)==tuple for tp in listOfTuples))
def mymethod(listOfTuples): assert(type(listOfTuples[0])==tuple)
str = strNull = if __debug__: if not str: raise AssertionError(strNull) print str if __debug__: print print ------------------------------------------------------ Output: hello Pyhton! FileName ..................... hello FilePath ..................... C:/Python\hello.py
str = strNull = if __debug__: if not str: raise AssertionError(strNull) print str if __debug__: print print ------------------------------------------------------ Output: AssertionError: NULL String
try: assert False raise Exception( except AssertionError: pass
import inspect, os print inspect.getfile(inspect.currentframe()) print os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
print os.path.abspath(inspect.stack()[0][1]) print os.path.dirname(os.path.abspath(inspect.stack()[0][1]))
import sys import os import inspect print "Python " + sys.version print print __file__ print sys.argv[0] print inspect.stack()[0][1] print sys.path[0] print print os.path.realpath(__file__) print os.path.abspath(__file__) print os.path.basename(__file__) print os.path.basename(os.path.realpath(sys.argv[0])) print print sys.path[0] print os.path.abspath(os.path.split(sys.argv[0])[0]) print os.path.dirname(os.path.abspath(__file__)) print os.path.dirname(os.path.realpath(sys.argv[0])) print os.path.dirname(__file__) print print inspect.getfile(inspect.currentframe()) print os.path.abspath(inspect.getfile(inspect.currentframe())) print os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) print print os.path.abspath(inspect.stack()[0][1]) print os.path.dirname(os.path.abspath(inspect.stack()[0][1])) print
import os os.path.dirname(__file__) os.path.abspath(__file__) os.path.basename(__file__)
import os,sys PROJECT_PATH = os.path.abspath(os.path.split(sys.argv[0])[0])
import os os.path.dirname(os.path.abspath(__file__))
import inspect,os inspect.stack()[0] => (<frame object at 0x00AC2AC0>, os.path.abspath (inspect.stack()[0][1]) =>
import os,sys filename=os.path.basename(os.path.realpath(sys.argv[0])) dirname=os.path.dirname(os.path.realpath(sys.argv[0]))
print os.path.dirname( inspect.getfile(inspect.currentframe()))
import inspect, os def getRootDirectory(_file_=None): """ Get the directory of the root execution file Can help: http: For eclipse user with unittest or debugger, the function search for the correct folder in the stack You can pass __file__ (with 4 underscores) if you want the caller directory """ if _file_ is None: rootFile = inspect.stack()[-1][1] folder = os.path.abspath(rootFile) if ("/pysrc" in folder) & ("org.python.pydev" in folder): previous = None for el in inspect.stack(): currentFile = os.path.abspath(el[1]) if ("unittest/case.py" in currentFile) | ("org.python.pydev" in currentFile): break previous = currentFile folder = previous return os.path.dirname(folder) else: return os.path.dirname(os.path.realpath(_file_))
import inspect, os print inspect.getfile(inspect.currentframe()) print os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
import inspect, os print(inspect.getfile(inspect.currentframe())) print(os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) )
filename = testscript.py file_name = __file__[2:-3]
import os import wx print(os.getcwd()) icon = wx.Icon(os.getcwd() + self.SetIcon(icon)
module/ lib/ __init__.py module.py tests/ test_module.py test_module2.py
import sys import os sys.path.append( os.path.dirname( os.path.dirname( os.path.abspath(__file__) ) ) )
import unittest import env from lib import module if __name__ == unittest.main()
if __name__ == import tests.thisModule tests.thisModule.runtests
find_packages("src", exclude=["*.tests", "*.tests.*", "tests.*", "tests"])
<Main Package> / \ / \ lib tests / \ [module1.py, module2.py, [ut_module1.py, ut_module2.py, module3.py module4.py, ut_module3.py, ut_module.py] __init__.py]
myPackage/ myapp/ moduleA/ __init__.py module_A.py moduleB/ __init__.py module_B.py setup.py
myPackage/ myapp/ moduleA/ __init__.py module_A.py moduleB/ __init__.py module_B.py test/ unit/ myapp/ moduleA/ module_A_test.py moduleB/ module_B_test.py integration/ myapp/ moduleA/ module_A_test.py moduleB/ module_B_test.py setup.py
myintvariable = 1 os.environ[ strauss = int(os.environ.get( debussy = int(os.environ.get( print "%s %u, %s %u" % (
>>> import os >>> os.environ.has_key( True >>> os.environ.has_key( False >>> os.environ[ >>> os.environ.has_key( True >>> os.environ.get(
import re import system import os def setEnvBat(batFilePath, verbose = False): SetEnvPattern = re.compile("set (\w+)(?:=)(.*)$", re.MULTILINE) SetEnvFile = open(batFilePath, "r") SetEnvText = SetEnvFile.read() SetEnvMatchList = re.findall(SetEnvPattern, SetEnvText) for SetEnvMatch in SetEnvMatchList: VarName=SetEnvMatch[0] VarValue=SetEnvMatch[1] if verbose: print "%s=%s"%(VarName,VarValue) os.environ[VarName]=VarValue
with modified_environ(DEBUSSY="1"): call_my_function()
Python 2.7.8 In [1]: %timeit ([1]*1000000).insert(0, 0) 100 loops, best of 3: 4.62 ms per loop In [2]: %timeit ([1]*1000000)[0:0] = [0] 100 loops, best of 3: 4.55 ms per loop In [3]: %timeit [0] + [1]*1000000 100 loops, best of 3: 8.04 ms per loop
>>> import collections >>> d = collections.deque( >>> d deque([ >>> d.appendleft( >>> d deque([
>>> from collections import deque >>> d2 = deque( >>> d2.extendleft( >>> d2 deque([
import timeit from collections import deque def list_insert_0(): l = [] for i in range(20): l.insert(0, i) def list_slice_insert(): l = [] for i in range(20): l[:0] = [i] def list_add(): l = [] for i in range(20): l = [i] + l def deque_appendleft(): d = deque() for i in range(20): d.appendleft(i) def deque_extendleft(): d = deque() d.extendleft(range(20))
>>> min(timeit.repeat(list_insert_0)) 2.8267281929729506 >>> min(timeit.repeat(list_slice_insert)) 2.5210217320127413 >>> min(timeit.repeat(list_add)) 2.0641671380144544 >>> min(timeit.repeat(deque_appendleft)) 1.5863927800091915 >>> min(timeit.repeat(deque_extendleft)) 0.5352169770048931
def import_to_orm(name, save=False, recurse=False): pass
def import_to_orm(name, save=False, recurse=False): if recurse and not save: raise ValueError("save must be True if recurse is True")
$ python -c Traceback (most recent call last): File "<string>", line 1, in <module> TypeError: sum expected at least 1 arguments, got 0
def read_single_keypress(): """Waits for a single keypress on stdin. This is a silly function to call if you need to do it a lot because it has to store stdin then read the single keystroke then revert stdin back after reading the keystroke. Returns the character of the key that was pressed (zero on KeyboardInterrupt which can happen when a signal gets handled) """ import termios, fcntl, sys, os fd = sys.stdin.fileno() flags_save = fcntl.fcntl(fd, fcntl.F_GETFL) attrs_save = termios.tcgetattr(fd) attrs = list(attrs_save) attrs[0] &= ~(termios.IGNBRK | termios.BRKINT | termios.PARMRK | termios.ISTRIP | termios.INLCR | termios. IGNCR | termios.ICRNL | termios.IXON ) attrs[1] &= ~termios.OPOST attrs[2] &= ~(termios.CSIZE | termios. PARENB) attrs[2] |= termios.CS8 attrs[3] &= ~(termios.ECHONL | termios.ECHO | termios.ICANON | termios.ISIG | termios.IEXTEN) termios.tcsetattr(fd, termios.TCSANOW, attrs) fcntl.fcntl(fd, fcntl.F_SETFL, flags_save & ~os.O_NONBLOCK) try: ret = sys.stdin.read(1) except KeyboardInterrupt: ret = finally: termios.tcsetattr(fd, termios.TCSAFLUSH, attrs_save) fcntl.fcntl(fd, fcntl.F_SETFL, flags_save) return ret
try: input("Press enter to continue") except SyntaxError: pass
import termios, fcntl, sys, os fd = sys.stdin.fileno() oldterm = termios.tcgetattr(fd) newattr = termios.tcgetattr(fd) newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO termios.tcsetattr(fd, termios.TCSANOW, newattr) oldflags = fcntl.fcntl(fd, fcntl.F_GETFL) fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK) try: while 1: try: c = sys.stdin.read(1) print "Got character", repr(c) except IOError: pass finally: termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm) fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
import curses stdscr = curses.initscr() c = stdscr.getch() print curses.endwin()
def wait_key(): result = None if os.name == import msvcrt result = msvcrt.getch() else: import termios fd = sys.stdin.fileno() oldterm = termios.tcgetattr(fd) newattr = termios.tcgetattr(fd) newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO termios.tcsetattr(fd, termios.TCSANOW, newattr) try: result = sys.stdin.read(1) except IOError: pass finally: termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm) return result
while True: choice = raw_input("> ") if choice == print "You win" input("yay") break
myapp/ __init__.py commands/ __init__.py command1.py command2.py foo.py bar.py
command = sys.argv[1] try: command_module = __import__("myapp.commands.%s" % command, fromlist=["myapp.commands"]) except ImportError: command_module.run()
>>> moduleNames = [ >>> moduleNames [ >>> modules = map(__import__, moduleNames)
imp.load_source(name, path) imp.load_compiled(name, path)
import imp import os def load_from_file(filepath): class_inst = None expected_class = mod_name,file_ext = os.path.splitext(os.path.split(filepath)[-1]) if file_ext.lower() == py_mod = imp.load_source(mod_name, filepath) elif file_ext.lower() == py_mod = imp.load_compiled(mod_name, filepath) if hasattr(py_mod, expected_class): class_inst = getattr(py_mod, expected_class)() return class_inst
import os import imp def importFromURI(uri, absl): mod = None if not absl: uri = os.path.normpath(os.path.join(os.path.dirname(__file__), uri)) path, fname = os.path.split(uri) mname, ext = os.path.splitext(fname) if os.path.exists(os.path.join(path,mname)+ try: return imp.load_compiled(mname, uri) except: pass if os.path.exists(os.path.join(path,mname)+ try: return imp.load_source(mname, uri) except: pass return mod
>>>import imp; >>>fp, pathname, description = imp.find_module("/home/test_module"); >>>test_module = imp.load_module("test_module", fp, pathname, description); >>>print test_module.print_hello();
import sys, glob sys.path.append( fl = glob.glob( modulist = [] adapters=[] for i in range(len(fl)): fl[i] = fl[i].split( fl[i] = fl[i][0:(len(fl[i])-3)] modulist.append(getattr(__import__(fl[i]),fl[i])) adapters.append(modulist[i]())
class modu1(): def __init__(self): self.x=1 print self.x
for char in line: if char in " ?.!/;:": line.replace(char,
translation_table = dict.fromkeys(map(ord, unicode_line = unicode_line.translate(translation_table)
unicode_line = unicode_line.translate({ord(c): None for c in
import string line = line.translate(string.maketrans(
>>> string = "ab1cd1ef" >>> string.replace("1","") >>>
>>> >>> a = "a!b@c >>> b = "!@ >>> for char in b: ... a = a.replace(char,"") ... >>> print a abcd >>>
>>> line = "H E?.LL!/;O:: " >>> for char in ... line = line.replace(char, ... >>> print line HELLO
>>> import string >>> import re >>> >>> phrase = >>> allow = string.letters + string.digits + >>> re.sub(
for char in line: if char in " ?.!/;:": line = line.replace(char,
line = filter(lambda char: char not in " ?.!/;:", line)
>>> help(filter) Help on built-in function filter in module __builtin__: filter(...) filter(function or None, sequence) -> list, tuple, or string Return those items of sequence for which function(item) is true. If function is None, return the items that are true. If sequence is a tuple or string, return the same type, else return a list.
sList = list(s) intsList = list(string.digits) obj = filter(lambda x: operator.contains(intsList, x), sList)))
target_chars = "".join([i for i in s if i in some_list])
target_chars = "".join([i for i in s if i not in some_list])
def remove(str_, chars): """Removes each char in `chars` from `str_`. Args: str_: String to remove characters from chars: String of to-be removed characters Returns: A copy of str_ with `chars` removed Example: remove("What?!?: darn;", " ?.!:;") => """ try: return str_.translate(None, chars) except TypeError: table = {ord(char): None for char in chars} return str_.translate(table)
def attempt1(string): return "".join([v for v in string if v not in ("a", "e", "i", "o", "u")]) def attempt2(string): for v in ("a", "e", "i", "o", "u"): string = string.replace(v, "") return string def attempt3(string): import re for v in ("a", "e", "i", "o", "u"): string = re.sub(v, "", string) return string def attempt4(string): return string.replace("a", "").replace("e", "").replace("i", "").replace("o", "").replace("u", "") for attempt in [attempt1, attempt2, attempt3, attempt4]: print(attempt("murcielago"))
import timeit K = 1000000 for i in range(1,5): t = timeit.Timer( f"attempt{i}( setup=f"from __main__ import attempt{i}" ).repeat(1, K) print(f"attempt{i}",min(t))
attempt1 2.2334518376057244 attempt2 1.8806643818474513 attempt3 7.214925774955572 attempt4 1.7271184513757465
import re strs = "how^ much for{} the maple syrup? $20.99? That print strs nstr = re.sub(r print nstr nestr = re.sub(r print nestr
def text_cleanup(text): new = "" for i in text: if i not in " ?.!/;:": new += i return new
import re def string_cleanup(x, notwanted): for item in notwanted: x = re.sub(item, return x line = "<title>My example: <strong>A text %very% $clean!!</strong></title>" print("Uncleaned: ", line) html_elements = ["<title>", "</title>", "<strong>", "</strong>"] line = string_cleanup(line, html_elements) print("1st clean: ", line) special_chars = ["[!@ line = string_cleanup(line, special_chars) print("2nd clean: ", line)
Uncleaned: <title>My example: <strong>A text %very% $clean!!</strong></title> 1st clean: My example: A text %very% $clean!! 2nd clean: My example: A text very clean
words = "things" removed = "%s%s" % (words[:3], words[-1:])
words = "control" removed = "%s%s" % (words[:2], words[-2:])
words = "impacts" removed = "%s%s%s" % (words[1], words[3:5], words[-1])
for char in line: if char in " ?.!/;:": line = line.replace(char,
ipstring ="text with symbols!@ opstring= for i in ipstring: if i.isalnum()==1 or i== opstring+=i pass print opstring
os.rename(file_name, file_name.translate({ord(c): None for c in
charlist = list(set(string.digits+string.ascii_uppercase) - set( return
def rm_char(original_str, need2rm): return original_str.translate(str.maketrans(
def strip(s,chars): if len(s)==1: return "" if s in chars else s return strip(s[0:int(len(s)/2)],chars) + strip(s[int(len(s)/2):len(s)],chars)
line = "a,b,c,d,e" alpha = list(line) while alpha.remove( finalString = print(finalString)
wget https: python ./get-pip.py python3 ./get-pip.py
$ pip --version pip 9.0.1 from /home/myhomedir/myvirtualenvdir/lib/python2.7/dist-packages (python 2.7) $ pip3 --version pip 9.0.1 from /home/myhomedir/myvirtualenvdir/lib/python3.4/site-packages (python 3.4)
ubuntu@mymachine-:~/mydir$ sudo pip install --upgrade pip Traceback (most recent call last): File "/usr/bin/pip", line 9, in <module> from pip import main ImportError: cannot import name main
python -c "import urllib.request; exec(urllib.request.urlopen(
result = ([ a for a,b in original ], [ b for a,b in original ])
result = (( a for a,b in original ), ( b for a,b in original ))
>>> original = [( >>> tuple([list(tup) for tup in zip(*original)]) ([
list1, list2 = [list(tup) for tup in zip(*original)]
def unzip(zipped): """Inverse of built-in zip function. Args: zipped: a list of tuples Returns: a tuple of lists Example: a = [1, 2, 3] b = [4, 5, 6] zipped = list(zip(a, b)) assert zipped == [(1, 4), (2, 5), (3, 6)] unzipped = unzip(zipped) assert unzipped == ([1, 2, 3], [4, 5, 6]) """ unzipped = () if len(zipped) == 0: return unzipped dim = len(zipped[0]) for i in range(dim): unzipped = unzipped + ([tup[i] for tup in zipped], ) return unzipped
res1 = list(zip(*original)) res2 = tuple(map(list, zip(*original)))
from collections import deque seq = ((a1, b1, …), (a2, b2, …), …) width = len(seq[0]) output = [deque(len(seq))] * width for element in seq: for s, item in zip(output, element): s.append(item)
def transpose_finite_iterable(iterable): return zip(*iterable)
| |a_00| |a_10| ... |a_n0| | | |a_01| |a_11| ... |a_n1| | | |... | |... | ... |... | | | |a_0i| |a_1i| ... |a_ni| | | |... | |... | ... |... | |
| |a_00| |a_01| ... |a_0i| ... | | |a_10| |a_11| ... |a_1i| ... | | |... | |... | ... |... | ... | | |a_n0| |a_n1| ... |a_ni| ... |
>>> from itertools import count >>> iterable = [count(), count()] >>> result = transpose_finite_iterable(iterable) >>> next(result) (0, 0) >>> next(result) (1, 1)
>>> transpose_finite_iterable(result) ... hangs ... Traceback (most recent call last): File "...", line 1, in ... File "...", line 2, in transpose_finite_iterable MemoryError
def transpose_finite_iterables(iterable): iterator = iter(iterable) try: first_elements = next(iterator) except StopIteration: return () queues = [deque([element]) for element in first_elements] def coordinate(queue): while True: if not queue: try: elements = next(iterator) except StopIteration: return for sub_queue, element in zip(queues, elements): sub_queue.append(element) yield queue.popleft() return tuple(map(coordinate, queues))
>>> from itertools import count >>> iterable = [count(), count()] >>> result = transpose_finite_iterables(transpose_finite_iterable(iterable)) >>> result (<generator object transpose_finite_iterables.<locals>.coordinate at ...>, <generator object transpose_finite_iterables.<locals>.coordinate at ...>) >>> next(result[0]) 0 >>> next(result[0]) 1
from collections import (abc, deque) from functools import singledispatch @singledispatch def transpose(object_): raise TypeError( .format(type=type)) @transpose.register(abc.Iterable) def transpose_finite_iterables(object_): iterator = iter(object_) try: first_elements = next(iterator) except StopIteration: return () queues = [deque([element]) for element in first_elements] def coordinate(queue): while True: if not queue: try: elements = next(iterator) except StopIteration: return for sub_queue, element in zip(queues, elements): sub_queue.append(element) yield queue.popleft() return tuple(map(coordinate, queues)) def transpose_finite_iterable(object_): yield from zip(*object_) try: transpose.register(abc.Collection, transpose_finite_iterable) except AttributeError: transpose.register(abc.Mapping, transpose_finite_iterable) transpose.register(abc.Sequence, transpose_finite_iterable) transpose.register(abc.Set, transpose_finite_iterable)
import numpy as np ... transpose.register(np.ndarray, np.transpose)
>>> array = np.arange(4).reshape((2,2)) >>> transpose(array) array([[0, 2], [1, 3]])
>>> original = [( >>> tuple(map(list, transpose(original))) ([
>>> from lz.transposition import transpose >>> list(map(tuple, transpose(zip(range(10), range(10, 20))))) [(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), (10, 11, 12, 13, 14, 15, 16, 17, 18, 19)]
pitchers = [( ( ( first_names, last_names = zip(*pitchers) In [45]: first_names Out[45]: ( In [46]: last_names Out[46]: (
def squares(start, stop): for i in range(start, stop): yield i * i generator = squares(a, b)
class Squares(object): def __init__(self, start, stop): self.start = start self.stop = stop def __iter__(self): return self def next(self): if self.start >= self.stop: raise StopIteration current = self.start * self.start self.start += 1 return current iterator = Squares(a, b)
def a_function(): "when called, returns generator object" yield
>>> import collections, types >>> issubclass(types.GeneratorType, collections.Iterator) True
>>> def a_function(): "just a function definition with yield in it" yield >>> type(a_function) <class >>> a_generator = a_function() >>> type(a_generator) <class
>>> isinstance(a_generator, collections.Iterator) True
>>> issubclass(collections.Iterator, collections.Iterable) True
>>> collections.Iterable() Traceback (most recent call last): File "<pyshell collections.Iterable() TypeError: Can
>>> all(isinstance(element, collections.Iterable) for element in ( (), [], {}, set(), frozenset(), True
>>> collections.Iterator() Traceback (most recent call last): File "<pyshell collections.Iterator() TypeError: Can
>>> collections.Iterator() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: Can
>>> all(isinstance(iter(element), collections.Iterator) for element in ( (), [], {}, set(), frozenset(), True
class Yes(collections.Iterator): def __init__(self, stop): self.x = 0 self.stop = stop def __iter__(self): return self def next(self): if self.x < self.stop: self.x += 1 return else: raise StopIteration __next__ = next
>>> stop = 4 >>> for i, y1, y2, y3 in zip(range(stop), Yes(stop), yes(stop), ( ... print( ... 0: yes == yes == yes 1: yes == yes == yes 2: yes == yes == yes 3: yes == yes == yes
>>> def foo(): ... print "begin" ... for i in range(3): ... print "before yield", i ... yield i ... print "after yield", i ... print "end" ... >>> f = foo() >>> f.next() begin before yield 0 0 >>> f.next() after yield 0 before yield 1 1 >>> f.next() after yield 1 before yield 2 2 >>> f.next() after yield 2 end Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration >>>
def fib(max): a, b = 0, 1 for i in range(max): yield a a, b = b, a + b print(fib(10)) for i in fib(10): print(i) print(next(myfib)) print(next(myfib)) print(next(myfib)) print(next(myfib))
class Fib: def __init__(self,max): self.current=0 self.next=1 self.max=max self.count=0 def __iter__(self): return self def __next__(self): if self.count>self.max: raise StopIteration else: self.current,self.next=self.next,(self.current+self.next) self.count+=1 return self.next-self.current def __str__(self): return "Generator object" itobj=Fib(4) print(itobj) for i in Fib(4): print(i) print(next(itobj)) print(next(itobj)) print(next(itobj))
def myGeneratorList(n): for i in range(n): yield i def myIterableList(n): ll = n*[None] for i in range(n): ll[i] = i return ll ll1 = myGeneratorList(10) ll2 = myIterableList(10) for i1, i2 in zip(ll1, ll2): print("{} {}".format(i1, i2)) ll1 = myGeneratorList(10) ll2 = myIterableList(10) print("{} {}".format(len(list(ll1)), len(ll2))) print("{} {}".format(len(list(ll1)), len(ll2))) ll1 = list(myGeneratorList(10)) ll2 = myIterableList(10) print("{} {}".format(len(list(ll1)), len(ll2))) print("{} {}".format(len(list(ll1)), len(ll2)))
C:\>python -v import zipimport import site import os import nt ...
>>> import imp >>> imp.find_module( (None, >>> imp.find_module( (None,
import os help(os) Help on module os: NAME os - OS routines for Mac, NT, or Posix depending on what system we FILE /usr/lib/python2.6/os.py MODULE DOCS http: DESCRIPTION This exports: - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc. - os.path is one of the modules posixpath, or ntpath - os.name is
cdp () { cd "$(python -c "import os.path as _, ${1}; \ print _.dirname(_.realpath(${1}.__file__[:-1]))" )" }
$ getpmpath twisted /usr/lib64/python2.6/site-packages/twisted/__init__.pyc $ getpmpath twisted.web /usr/lib64/python2.6/site-packages/twisted/web/__init__.pyc
File "C:\Users\Administrator\Documents\Mibot\oops\blinkserv.py", line 82, in __init__ self.serv = socket(AF_INET,SOCK_STREAM) TypeError:
>>> import socket >>> socket <module >>> socket.socket <class >>> >>> from socket import socket >>> socket <class
from mypackage.bin import myscript ... myscript(...)
from mypackage.bin.myscript import myscript ... myscript(...)
setup.py scripts/ script1 mypackage/ bin/ script1.py subpackage1/ subpackage_etc/
>>> from socket import * >>> serv = socket(AF_INET,SOCK_STREAM) >>> import socket >>> serv = socket(AF_INET,SOCK_STREAM) Traceback (most recent call last): File "<input>", line 1, in <module> TypeError:
Traceback (most recent call last): File "/Users/ubuntu/.virtualenvs/virtualenv/bin/mycli", line 11, in <module> load_entry_point( TypeError:
from setuptools import setup setup ( entry_points = { }, )
from setuptools import setup setup ( entry_points = { }, )
import argparse parser = argparse.ArgumentParser(description="My parser") parser.add_argument("--my_bool", type=bool) cmd_line = ["--my_bool", "False"] parsed_args = parser.parse(cmd_line)
def str2bool(v): if v.lower() in ( return True elif v.lower() in ( return False else: raise argparse.ArgumentTypeError(
parser.add_argument("--nice", type=str2bool, nargs= const=True, default=NICE, help="Activate nice mode.")
parser.add_argument( parser.add_argument( parser.set_defaults(feature=True)
def t_or_f(arg): ua = str(arg).upper() if return True elif return False else: pass
feature_parser = parser.add_mutually_exclusive_group(required=False) feature_parser.add_argument( feature_parser.add_argument( parser.set_defaults(feature=True)
def add_bool_arg(parser, name, default=False): group = parser.add_mutually_exclusive_group(required=False) group.add_argument( group.add_argument( parser.set_defaults(**{name:default}) add_bool_arg(parser, add_bool_arg(parser,
def str2bool(v): return v.lower() in ("yes", "true", "t", "1") p = argparse.ArgumentParser() p.register( p.add_argument( p.parse_args( Namespace(b=False)
def str2bool(v): return v.lower() in ("yes", "true", "t", "1")
import argparse parser = argparse.ArgumentParser(description="Parse bool") parser.add_argument("--do-something", default=False, action="store_true" , help="Flag to do something") args = parser.parse_args() if args.do_something == True: print("Do something") else: print("Don print("Check that args.do_something=" + str(args.do_something) + " is always a bool")
add_boolean_argument(parser, parser.parse_args([]) parser.parse_args([ parser.parse_args([ parser.parse_args([ parser.parse_args([ parser.parse_args([
def _str_to_bool(s): """Convert string to bool (in argparse context).""" if s.lower() not in [ raise ValueError( return { def add_boolean_argument(parser, name, default=False): group = parser.add_mutually_exclusive_group() group.add_argument( group.add_argument(
class FlagAction(argparse.Action): def __init__(self, option_strings, dest, default=None, required=False, help=None, metavar=None, positive_prefixes=[ self.positive_strings = set() self.negative_strings = set() for string in option_strings: assert re.match(r suffix = string[2:] for positive_prefix in positive_prefixes: self.positive_strings.add(positive_prefix + suffix) for negative_prefix in negative_prefixes: self.negative_strings.add(negative_prefix + suffix) strings = list(self.positive_strings | self.negative_strings) super(FlagAction, self).__init__(option_strings=strings, dest=dest, nargs=0, const=None, default=default, type=bool, choices=None, required=required, help=help, metavar=metavar) def __call__(self, parser, namespace, values, option_string=None): if option_string in self.positive_strings: setattr(namespace, self.dest, True) else: setattr(namespace, self.dest, False)
parser.add_argument( ENSURE = config.ensure is None
from SomeOtherProduct.SomeModule import SomeClass def speak(self): return "ook ook eee eee eee!" SomeClass.speak = speak
import pandas as pd def just_foo_cols(self): return [x for x in self.columns if pd.DataFrame.just_foo_cols = just_foo_cols df = pd.DataFrame([list(range(4))], columns=["A","foo","foozball","bar"]) df.just_foo_cols() del pd.DataFrame.just_foo_cols
def just_foo_cols(self): return [x for x in self.columns if
df = pd.DataFrame([list(range(4))], columns=["A","foo","foozball","bar"]) df.just_foo_cols() del pd.DataFrame.just_foo_cols
import datasource def get_data(self): raise datasource.DataRetrievalError datasource.Structure.get_data = get_data
def setUp(self): self.real_get_data = datasource.Structure.get_data datasource.Structure.get_data = get_data def tearDown(self): datasource.Structure.get_data = self.real_get_data
data = { data_json = simplejson.dumps(data) payload = { r = requests.post("http:
class Root(object): def __init__(self, content): self.content = content print self.content exposed = True def GET(self): cherrypy.response.headers[ return simplejson.dumps(self.content) def POST(self): self.content = simplejson.loads(cherrypy.request.body.read())
>>> import requests >>> r = requests.post( >>> r.status_code 200 >>> r.json() {
url = "http: data = { headers = { r = requests.post(url, data=json.dumps(data), headers=headers)
url = "http: datas = {"cardno":"6248889874650987","systemIdentify":"s08","sourceChannel": 12} headers = { rsp = requests.post(url, json=datas, headers=headers)
class Root(object): def __init__(self, content): self.content = content print self.content exposed = True def GET(self): cherrypy.response.headers[ return simplejson.dumps(self.content) @cherrypy.tools.json_in() @cherrypy.tools.json_out() def POST(self): self.content = cherrypy.request.json return {
import requests r = requests.post( headers = { print(r.status_code)
>>> newdict = {1:0, 2:0, 3:0} >>> newdict.keys() [1, 2, 3]
newlist = list() for i in newdict.keys(): newlist.append(i)
>>> newdict = {1:0, 2:0, 3:0} >>> [*newdict] [1, 2, 3]
%timeit [*newdict] 1000000 loops, best of 3: 249 ns per loop %timeit list(newdict) 1000000 loops, best of 3: 508 ns per loop %timeit [k for k in newdict] 1000000 loops, best of 3: 574 ns per loop
>>> d = dict(zip([ >>> [key.split(", ") for key in d.keys()] [[
>>> newdict = {1:0, 2:0, 3:0} >>> [k for k in newdict.keys()] [1, 2, 3]
>>> from operator import itemgetter >>> list(map(itemgetter(0), dd.items())) [1, 2, 3]
>>> list(set(newdict)) [1, 2, 3] >>> list(tuple(newdict)) [1, 2, 3]
>>> parsed_results.keys() dict_keys([ >>> things2plot = [key.split( >>> things2plot [ >>> for key in parsed_results.keys(): ... print(key.split( ... [ [
import yaml with open("example.yaml", try: print(yaml.load(stream)) except yaml.YAMLError as exc: print(exc)
import yaml import io data = { with io.open( yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True) with open("data.yaml", data_loaded = yaml.load(stream) print(data == data_loaded)
a list: - 1 - 42 - 3.141 - 1337 - help - € a string: bla another dict: foo: bar key: value the answer: 42
import ruamel.yaml as yaml with open("example.yaml") as stream: try: print(yaml.safe_load(stream)) except yaml.YAMLError as exc: print(exc)
from ruamel.yaml import YAML from pathlib import Path path = Path( yaml = YAML(typ= data = yaml.load(path)
from ruamel import yaml data = yaml.safe_load(open( data[
from ruamel import yaml with open(filename, read_data = yaml.load(fp)
import sys import yaml def main(argv): with open(argv[0]) as stream: try: return 0 except yaml.YAMLError as exc: print(exc) return 1 if __name__ == "__main__": sys.exit(main(sys.argv[1:]))
start = time.clock() ... do something elapsed = (time.clock() - start)
start = time.time() ... do something elapsed = (time.time() - start)
using time(): 1 requests, response time: 14.1749382019 ms 2 requests, response time: 8.01301002502 ms 3 requests, response time: 8.01491737366 ms 4 requests, response time: 8.41021537781 ms 5 requests, response time: 8.38804244995 ms
1 requests, response time: 10.0 ms 2 requests, response time: 0.0 ms 3 requests, response time: 0.0 ms 4 requests, response time: 10.0 ms 5 requests, response time: 0.0 ms 6 requests, response time: 0.0 ms 7 requests, response time: 0.0 ms 8 requests, response time: 0.0 ms
import time def t_time(): start=time.time() time.sleep(0.1) return (time.time()-start) def t_clock(): start=time.clock() time.sleep(0.1) return (time.clock()-start) counter_time=0 counter_clock=0 for i in range(1,100): counter_time += t_time() for i in range(1,100): counter_clock += t_clock() print "time() =",counter_time/100 print "clock() =",counter_clock/100
import timeit import time clock_list = [] time_list = [] test1 = """ def test(v=time.clock()): s = time.clock() - v def test(v=time.time()): s = time.time() - v """ def test_it(Range) : for i in range(Range) : clk = timeit.timeit(test1, number=10000) clock_list.append(clk) tml = timeit.timeit(test2, number=10000) time_list.append(tml) test_it(100) print "Clock Min: %f Max: %f Average: %f" %(min(clock_list), max(clock_list), sum(clock_list)/float(len(clock_list))) print "Time Min: %f Max: %f Average: %f" %(min(time_list), max(time_list), sum(time_list)/float(len(time_list)))
>>> start = time.time(); time.sleep(0.5); (time.time() - start) 0.5005500316619873
>>> start = time.time(); time.sleep(0.5); (time.time() - start) 0.5
from decimal import Decimal pos_inf = Decimal( neg_inf = Decimal(
import traceback try: 1/0 except Exception: traceback.print_exc()
Traceback (most recent call last): File "C:\scripts\divide_by_zero.py", line 4, in <module> 1/0 ZeroDivisionError: division by zero
>>> try: ... raise Exception( ... except Exception as inst: ... print type(inst) ... print inst.args ... print inst ... x, y = inst ... print ... print ... <type ( ( x = spam y = eggs
def srepr(arg): if isinstance(arg, basestring): return repr(arg) try: return except TypeError: return repr(arg)
def is_sequence(arg): return (not hasattr(arg, "strip") and hasattr(arg, "__getitem__") or hasattr(arg, "__iter__")) def srepr(arg): if is_sequence(arg): return return repr(arg)
H = "Hello" if type(H) is list or type(H) is tuple: else
import collections if isinstance(obj, collections.Sequence) and not isinstance(obj, basestring): print "obj is a sequence (list, tuple, etc) but not a string or unicode"
import collections.abc if isinstance(obj, collections.abc.Sequence) and not isinstance(obj, str): print("obj is a sequence (list, tuple, etc) but not a string or unicode")
def is_array(var): return isinstance(var, (list, tuple))
import types if isinstance(lst, types.ListType) or isinstance(lst, types.TupleType):
import typing if isinstance(lst, typing.List) or isinstance(lst, typing.Tuple):
def is_sequence(seq): """Returns a true if its input is a collections.Sequence (except strings). Args: seq: an input sequence. Returns: True if the sequence is a not a string and is a collections.Sequence. """ return (isinstance(seq, collections.Sequence) and not isinstance(seq, six.string_types))
def assertIsIterable(self, item): if isinstance(item, basestring): raise AssertionError("type %s is not iterable" % type(item)) try: for x in item: break; except TypeError: raise AssertionError("type %s is not iterable" % type(item))
>>> console_routers = >>> any([isinstance(console_routers, list), isinstance(console_routers, tuple)]) False >>> >>> console_routers = ( >>> any([isinstance(console_routers, list), isinstance(console_routers, tuple)]) True >>> console_routers = list( >>> any([isinstance(console_routers, list), isinstance(console_routers, tuple)]) True
from typing import List def isit(value): return isinstance(value, List) isit([1, 2, 3]) isit("test") isit({"Hello": "Mars"}) isit((1, 2))
from typing import List, Tuple def isit(value): return isinstance(value, List) or isinstance(value, Tuple)
for i in some_var: if type(i) == type(list()): elif type(i) == type(tuple()): elif type(i) == type(str()):
@Singleton class Foo: def __init__(self): print f = Foo() f = Foo.instance() g = Foo.instance() print f is g
class Singleton: def __init__(self, decorated): self._decorated = decorated def instance(self): try: return self._instance except AttributeError: self._instance = self._decorated() return self._instance def __call__(self): raise TypeError( def __instancecheck__(self, inst): return isinstance(inst, self._decorated)
class Singleton(object): _instance = None def __new__(cls, *args, **kwargs): if not cls._instance: cls._instance = super(Singleton, cls).__new__( cls, *args, **kwargs) return cls._instance if __name__ == s1 = Singleton() s2 = Singleton() if (id(s1) == id(s2)): print "Same" else: print "Different"
class Borg: __shared_state = {} def __init__(self): self.__dict__ = self.__shared_state
class Singleton(type): def __init__(cls, name, bases, dict): super(Singleton, cls).__init__(name, bases, dict) cls.instance = None def __call__(cls,*args,**kw): if cls.instance is None: cls.instance = super(Singleton, cls).__call__(*args, **kw) return cls.instance class MyClass(object): __metaclass__ = Singleton
def singleton(cls): instances = {} def getinstance(): if cls not in instances: instances[cls] = cls() return instances[cls] return getinstance @singleton class MyClass: ...
def singleton(cls): obj = cls() cls.__new__ = staticmethod(lambda cls: obj) try: del cls.__init__ except AttributeError: pass return cls
@singleton class Duck(object): pass if Duck() is Duck(): print "It works!" else: print "It doesn
class foo: x = 1 @classmethod def increment(cls, y = 1): cls.x += y
class Singleton(object): def __new__(cls, *args, **kwds): it = cls.__dict__.get("__it__") if it is not None: return it cls.__it__ = it = object.__new__(cls) it.init(*args, **kwds) return it def init(self, *args, **kwds): pass
class Singleton(object): def __new__(cls, *args, **kwds): """ >>> s = Singleton() >>> p = Singleton() >>> id(s) == id(p) True """ self = "__self__" if not hasattr(cls, self): instance = object.__new__(cls) instance.init(*args, **kwds) setattr(cls, self, instance) return getattr(cls, self) def init(self, *args, **kwds): pass
class Bus(Singleton): def init(self, label=None, *args, **kwds): self.label = label self.channels = [Channel("system"), Channel("app")] ...
_data_controller = None def GetDataController(): global _data_controller if _data_controller is None: _data_controller = DataController() return _data_controller
def singleton(cls): instances = {} def getinstance(): if cls not in instances: instances[cls] = cls() return instances[cls] return getinstance @singleton class MyClass: ...
class NothingSpecial: pass _the_one_and_only = None def TheOneAndOnly(): global _the_one_and_only if not _the_one_and_only: _the_one_and_only = NothingSpecial() return _the_one_and_only
class NothingSpecial: pass THE_ONE_AND_ONLY = NothingSpecial()
class Singleton_group(object): __instances_args_dict = {} def __new__(cls, *args, **kwargs): if not cls.__instances_args_dict.get((cls.__name__, args, str(kwargs))): cls.__instances_args_dict[(cls.__name__, args, str(kwargs))] = super(Singleton_group, cls).__new__(cls, *args, **kwargs) return cls.__instances_args_dict.get((cls.__name__, args, str(kwargs))) class test(Singleton_group): def __init__(self, salute): self.salute = salute a = test( b = test( c = test( d = test( e = test( f = test( id(a) 3070148780L id(b) 3070148908L id(c) 3070148780L b == d True b._Singleton_group__instances_args_dict {( ( (
class Singleton(object[,...]): staticVar1 = None staticVar2 = None def __init__(self): if self.__class__.staticVar1==None : else:
def getSystemContext(contextObjList=[]): if len( contextObjList ) == 0: contextObjList.append( Context() ) pass return contextObjList[0] class Context(object):
class Singleton: __single = None def __init__( self ): if Singleton.__single: raise Singleton.__single Singleton.__single = self
class void:pass a = void(); a.__class__ = Singleton
class Singleton: def __new__(cls): raise AssertionError
class Singeltone(type): instances = dict() def __call__(cls, *args, **kwargs): if cls.__name__ not in Singeltone.instances: Singeltone.instances[cls.__name__] = type.__call__(cls, *args, **kwargs) return Singeltone.instances[cls.__name__] class Test(object): __metaclass__ = Singeltone inst0 = Test() inst1 = Test() print(id(inst1) == id(inst0))
class singleton(object): def __init__(self, cls): self.__dict__[ instances = {} def __call__(self): if self.cls not in self.instances: self.instances[self.cls] = self.cls() return self.instances[self.cls] def __getattr__(self, attr): return getattr(self.__dict__[ def __setattr__(self, attr, value): return setattr(self.__dict__[
>>> class Test: ... def __repr__(self): ... return "Test()" ... def __str__(self): ... return "member of Test" ... >>> t = Test() >>> t Test() >>> print(t) member of Test
class Test: def __init__(self, a, b): self.a = a self.b = b def __repr__(self): return "<Test a:%s b:%s>" % (self.a, self.b) def __str__(self): return "From str method of Test: a is %s, b is %s" % (self.a, self.b)
>>> t = Test(123, 456) >>> t <Test a:123 b:456> >>> print repr(t) <Test a:123 b:456> >>> print(t) From str method of Test: a is 123, b is 456 >>> print(str(t)) From str method of Test: a is 123, b is 456
def __repr__(self): return "<%s instance at %s>" % (self.__class__.__name__, id(self))
class Element: def __init__(self, name, symbol, number): self.name = name self.symbol = symbol self.number = number def __str__(self): return str(self.__class__) + ": " + str(self.__dict__)
class Test(object): def __init__(self, a, b): self._a = a self._b = b def __str__(self): return "An instance of class Test with state: a=%s b=%s" % (self._a, self._b) def __repr__(self): return
x = Test( print print print y = eval(repr(x)) print print print
Human readable: An instance of class Test with state: a=hello b=world Object representation: Test("hello","world") Human readable: An instance of class Test with state: a=hello b=world Object representation: Test("hello","world")
class Foobar(): def __init__(self): print "Foobar object is created." def __repr__(self): return "Type what do you want to see here." a = Foobar() print a
class Printable: def __repr__(self): from pprint import pformat return "<" + type(self).__name__ + "> " + pformat(vars(self), indent=4, width=1) class MyClass(Printable): pass my_obj = MyClass() my_obj.msg = "Hello" my_obj.number = "46" print(my_obj)
class Element: def __init__(self, name, symbol, number): self.name = name self.symbol = symbol self.number = number def __str__(self): return str(self.__class__) + elem = Element( print(elem)
<class name = my_name symbol = some_symbol number = 3
class Element: def __init__(self, name, symbol, number): self.name = name self.symbol = symbol self.number = number def __str__(self): return "{}: {}\nAtomic Number: {}\n".format(self.name, self.symbol, self.number class Hydrogen(Element): def __init__(self): super().__init__(name = "Hydrogen", symbol = "H", number = "1")
def __init__(self, name): self.company_name = name def __str__(self): return "I am the Founder of Adiprogrammer!"
class Address( ): __init__( self ) self.mName = self.mAddress = a = Address() print a or print printClass( a )
def foo(): string = ("this is an " "implicitly joined " "string")
def trim(docstring): if not docstring: return lines = docstring.expandtabs().splitlines() indent = sys.maxint for line in lines[1:]: stripped = line.lstrip() if stripped: indent = min(indent, len(line) - len(stripped)) trimmed = [lines[0].strip()] if indent < sys.maxint: for line in lines[1:]: trimmed.append(line[indent:].rstrip()) while trimmed and not trimmed[-1]: trimmed.pop() while trimmed and not trimmed[0]: trimmed.pop(0) return
import textwrap def frobnicate(param): prepare_the_comfy_chair(param) log_message = textwrap.dedent( ) weebly(param, log_message) ruckford(param)
def foo(): string = ("line one\n" "line two" "\n" "line three\n")
def example(): long_string = Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip.\ return long_string print example()
def func(*args, **kwargs): string = ]) print(string) return
def foo(): return "{}\n"\ "freq: {}\n"\ "temp: {}\n".format( time, freq, temp )
import string def myfunction(): """ line 1 of docstring line 2 of docstring line 3 of docstring""" print str(string.replace(myfunction.__doc__,
"""line 1 of docstring line 2 of docstring line 3 of docstring""" print string.replace(myfunction.__doc__,
class Lstrip(object): def __rsub__(self, other): import re return re.sub( msg = Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. print msg def lstrip_docstring(func): func.__doc__ = func.__doc__ - Lstrip() return func @lstrip_docstring def foo(): Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. pass print foo.__doc__
part = "".join([ "\x00\x00\x00\x00\x0C\x00\x00\x00\xFF\x00\x00\x00\x00\x00\x00\x00" "\x00\x00\x00\x00\x0C\x00\x00\x00\x00\xFF\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x0C\x00\x00\x00\x00\x00\xFF\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x0C\x00\x00\x00\x00\x00\x00\xFF\x00\x00\x00\x00", ])
T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]
T2 = [[int(column) for column in row] for row in T1]
T1 = (( ( ( new_list = list(list(int(a) for a in b) for b in T1 if a.isdigit())
T3=[] for i in range(0,len(T1)): T3.append([]) for j in range(0,len(T1[i])): b=int(T1[i][j]) T3[i].append(b) print T3
def is_number(var): try: if var == int(var): return True except Exception: return False x = "1" y = "test" x_test = is_number(x) print(x_test)
c = input( print (int(float(c))) print (round(float(c)))
def parse_int(s): try: res = int(eval(str(s))) if type(res) == int: return res except: return
val = parse_int( val = parse_int( val = parse_int( val = parse_int( val = parse_int(
from functools import partial map(partial(map, int), T1)
def oldmap(f, iterable): return list(map(f, iterable)) oldmap(partial(oldmap, int), T1)
T1 = (( ( ( new_list = list(list(int(a) for a in b if a.isdigit()) for b in T1) print(new_list)
>>> map(chr, [66, 53, 0, 94]) <map object at 0x00AF5570>
lmap = lambda func, *iterable: list(map(func, *iterable))
__global_map = map lmap = lambda func, *iterable: list(__global_map(func, *iterable)) map = lmap x = [1, 2, 3] map(str, x) map = __global_map map(str, x)
>>> %%timeit -r5 ordinals = list(range(45)) ... list(map(chr, ordinals)) ... 3.91 µs ± 60.2 ns per loop (mean ± std. dev. of 5 runs, 100000 loops each) >>> %%timeit -r5 ordinals = list(range(45)) ... [*map(chr, ordinals)] ... 3.84 µs ± 219 ns per loop (mean ± std. dev. of 5 runs, 100000 loops each) >>> %%timeit -r5 ordinals = list(range(45)) ... [*bytes(ordinals).decode( ... 1.43 µs ± 49.7 ns per loop (mean ± std. dev. of 5 runs, 1000000 loops each) >>> %%timeit -r5 ordinals = list(range(45)) ... bytes(ordinals).decode( ... 781 ns ± 15.9 ns per loop (mean ± std. dev. of 5 runs, 1000000 loops each)
li = [] for x in map(chr,[66,53,0,94]): li.append(x) print (li) >>>[
b = li = [] for x in map(int,map(int, re.findall( li.append(x) print (li) >>>[1, 72, 474]
pip freeze | grep -v "^-e" | xargs pip uninstall -y
alias pipuninstallall="pip uninstall -y -r <(pip freeze)"
pip list --local | py -x "print(x.split()[0])" | xargs pip uninstall -y
pip freeze > reqs.txt rmvirtualenv MYENV mkvirtualenv MYENV pip install -r reqs.txt
pip freeze > unins && pip uninstall -y -r unins && del unins
pip freeze > unins && pip uninstall -y -r unins && rm unins
pip uninstall [options] <package> ... pip uninstall [options] -r <requirements file> ...
from sys import stderr from pip.commands.uninstall import UninstallCommand from pip import get_installed_distributions pip_uninstall = UninstallCommand() options, args = pip_uninstall.parse_args([ package.project_name for package in get_installed_distributions() if not package.location.endswith( ]) options.yes = True try: print pip_uninstall.run(options, args) except OSError as e: if e.errno != 13: raise e print >> stderr, "You lack permissions to uninstall this package. Perhaps run with sudo? Exiting." exit(13)
from pip import get_installed_distributions from os import system for i in get_installed_distributions(): system("pip3 uninstall {} -y -q".format(i.key))
virtualenv --clear /Users/you/.virtualenvs/projectx
find /usr/lib/python2.7/ |while read f; do if ! rpm -qf "$f" &> /dev/null; then echo "$f" fi done |xargs rm -fr
find /usr/lib/python2.7/ |while read f; do if ! dpkg-query -S "$f" &> /dev/null; then echo "$f" fi done |xargs rm -fr
find /usr/lib/python2.7 -type d -empty |xargs rm -fr
x = numpy.fromfile(file=open("data"), dtype=float).reshape((100, 100, 100))
from numpy import arange from timeit import Timer Nelements = 10000 Ntimeits = 10000 x = arange(Nelements) y = range(Nelements) t_numpy = Timer("x.sum()", "from __main__ import x") t_list = Timer("sum(y)", "from __main__ import y") print("numpy: %.3e" % (t_numpy.timeit(Ntimeits)/Ntimeits,)) print("list: %.3e" % (t_list.timeit(Ntimeits)/Ntimeits,))
class Package: def __init__(self): self.files = [] def __del__(self): for file in self.files: os.unlink(file)
def __enter__(self) def __exit__(self, exc_type, exc_value, traceback)
class Package: def __init__(self): self.files = [] def __enter__(self): return self def __exit__(self, exc_type, exc_value, traceback): for file in self.files: os.unlink(file)
class PackageResource: def __enter__(self): class Package: ... self.package_obj = Package() return self.package_obj def __exit__(self, exc_type, exc_value, traceback): self.package_obj.cleanup()
@contextlib.contextmanager def packageResource(): class Package: ... package = Package() yield package package.cleanup()
class Package(object): def __new__(cls, *args, **kwargs): @contextlib.contextmanager def packageResource(): package = super(Package, cls).__new__(cls) package.__init__(*args, **kwargs) yield package package.cleanup() def __init__(self, *args, **kwargs): ...
class Package(object): def __new__(cls, *args, **kwargs): package = super(Package, cls).__new__(cls) package.__init__(*args, **kwargs) return contextlib.closing(package)
import atexit import os class Package: def __init__(self): self.files = [] atexit.register(self.cleanup) def cleanup(self): print("Running cleanup...") for file in self.files: print("Unlinking file: {}".format(file))
$ python >>> from package import * >>> p = Package() >>> q = Package() >>> q.files = [ >>> quit() Running cleanup... Unlinking file: a Unlinking file: b Unlinking file: c Running cleanup...
from weakref import proxy class MyList(list): pass class Package: def __init__(self): self.__del__.im_func.files = MyList([1,2,3,4]) self.files = proxy(self.__del__.im_func.files) def __del__(self): print self.__del__.im_func.files
class SkeletonFixture: def __init__(self): pass def __enter__(self): return self def __exit__(self, exc_type, exc_value, traceback): pass def method(self): pass with SkeletonFixture() as fixture: fixture.method()
Traceback (most recent call last): File "tests/simplestpossible.py", line 17, in <module> fixture.method() AttributeError:
format_spec ::= [[fill]align][sign][ fill ::= <any character> align ::= "<" | ">" | "=" | "^" sign ::= "+" | "-" | " " width ::= integer precision ::= integer type ::= "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"
"hello" + " ".join([" " for x in range(1,10)]) output -->
>>> string = >>> for s in range(0,5): ... string += ... >>> string
virtualenv -p /usr/bin/python3 py3env source py3env/bin/activate pip install package-name
sudo apt-get install curl curl https: sudo pip3 install MODULE_NAME
curl https: pip2 install package-name curl https: pip3 install package-name
$ pip-2.7 install PACKAGENAME $ pip-3.2 install PACKAGENAME
sudo aptitude install python3-pip pip-3.2 install --user pkg
sudo aptitude install python3-pip python3.3 python3.3 -m pip.runner install --user pkg
jon-mint python3.3 ip: /bin/ip /sbin/ip /usr/share/man/man8/ip.8.gz /usr/share/man/man7/ip.7.gz
jon-mint python3.3 Downloading/unpacking pexpect Downloading pexpect-3.2.tar.gz (131kB): 131kB downloaded Running setup.py (path:/tmp/pip_build_root/pexpect/setup.py) egg_info for package pexpect Installing collected packages: pexpect Running setup.py install for pexpect Successfully installed pexpect Cleaning up...
wget http: python3.3 -m distribute_setup install --user easy_install-3.3 --user pip
wget http: tar xJf ./Python-3.3.5.tar.xz cd ./Python-3.3.5 ./configure --prefix=/opt/python3.3 make && sudo make install
>>> with open( ... read_data = f.read() >>> f.closed True
groups = [] uniquekeys = [] for k, g in groupby(data, keyfunc): groups.append(list(g)) uniquekeys.append(k)
from itertools import groupby things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")] for key, group in groupby(things, lambda x: x[0]): for thing in group: print "A %s is a %s." % (thing[1], key) print " "
for key, group in groupby(things, lambda x: x[0]): listOfThings = " and ".join([thing[1] for thing in group]) print key + "s: " + listOfThings + "."
groups = [] uniquekeys = [] for k, g in groupby(data, keyfunc): groups.append(list(g)) uniquekeys.append(k)
[(c,len(list(cgen))) for c,cgen in groupby(some_string)]
>>> def print_groupby(iterable, key=None): ... for k, g in it.groupby(iterable, key): ... print("key:
>>> print_groupby("BCAACACAADBBB") key: key: key: key: key: key: key: key: key: >>> print_groupby(sorted("BCAACACAADBBB")) key: key: key: key: >>> key = lambda x: x.islower() >>> print_groupby(sorted("bCAaCacAADBbB"), key) key: key:
[do_something(list(g)) for _, g in groupby(lxml_elements, key=criteria_func)]
for key, igroup in itertools.groupby(xrange(12), lambda x: x print key, list(igroup)
def chunker(items, chunk_size): for _key, group in itertools.groupby(enumerate(items), lambda x: x[0] yield (g[1] for g in group) with open( for chunk in chunker(fobj): process(chunk)
xx = range(10) yy = [0, 0, 0, 1, 1, 1, 0, 0, 0, 0] for group in itertools.groupby(iter(xx), lambda x: yy[x]): print group[0], list(group[1])
for x in list(groupby(range(10))): print(list(x[1]))
def groupbylist(*args, **kwargs): return [(k, list(g)) for k, g in groupby(*args, **kwargs)]
from itertools import groupby things = [("vehicle", "bear"), ("animal", "duck"), ("animal", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")] for key, group in groupby(things, lambda x: x[0]): for thing in group: print "A %s is a %s." % (thing[1], key) print " "
A bear is a vehicle. A duck is a animal. A cactus is a animal. A speed boat is a vehicle. A school bus is a vehicle.
from itertools import groupby [(c,len(list(cs))) for c,cs in groupby(
name = list( name.sort() [(c,len(list(cs))) for c,cs in groupby(name)]
groupby(iterable[, keyfunc]) -> create an iterator which returns (key, sub-iterator) grouped by each value of key(value).
import itertools def grouper(iterable, n): def coroutine(n): yield for i in itertools.count(): for j in range(n): yield i groups = coroutine(n) next(groups) for c, objs in itertools.groupby(iterable, groups.send): yield c, list(objs) list(grouper(range(10), 3))
[(0, [0, 1, 2]), (1, [3, 4, 5]), (2, [6, 7, 8]), (3, [9])]
from itertools import groupby val = [{ { { for pin, list_data in groupby(sorted(val, key=lambda k: k[ ... print pin ... for rec in list_data: ... print rec ... o/p: 560076 { { 560078 {
from itertools import groupby myinput = input() myoutput = [] for k,g in groupby(myinput): myoutput.append((len(list(g)),int(k))) print(*myoutput)
def groupby(data): kv = {} for k,v in data: if k not in kv: kv[k]=[v] else: kv[k].append(v) return kv Run on ipython: In [10]: data = [( In [11]: groupby(data) Out[11]: {
>>> numpy.arange(10000) array([ 0, 1, 2, ..., 9997, 9998, 9999]) >>> numpy.arange(10000).reshape(250,40) array([[ 0, 1, 2, ..., 37, 38, 39], [ 40, 41, 42, ..., 77, 78, 79], [ 80, 81, 82, ..., 117, 118, 119], ..., [9880, 9881, 9882, ..., 9917, 9918, 9919], [9920, 9921, 9922, ..., 9957, 9958, 9959], [9960, 9961, 9962, ..., 9997, 9998, 9999]])
import numpy numpy.set_printoptions(threshold=numpy.nan)
import numpy as np np.set_printoptions(threshold=np.inf)
>>> numpy.arange(100).reshape(25,4).tolist() [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31], [32, 33, 34, 35], [36, 37, 38, 39], [40, 41, 42, 43], [44, 45, 46, 47], [48, 49, 50, 51], [52, 53, 54, 55], [56, 57, 58, 59], [60, 61, 62, 63], [64, 65, 66, 67], [68, 69, 70, 71], [72, 73, 74, 75], [76, 77, 78, 79], [80, 81, 82, 83], [84, 85, 86, 87], [88, 89, 90, 91], [92, 93, 94, 95], [96, 97, 98, 99]]
import numpy as np np.set_printoptions(threshold=np.nan)
def fullprint(*args, **kwargs): from pprint import pprint import numpy opt = numpy.get_printoptions() numpy.set_printoptions(threshold= pprint(*args, **kwargs) numpy.set_printoptions(**opt)
import numpy as np class fullprint: def __init__(self, **kwargs): if kwargs[ self.opt = kwargs def __enter__(self): self._opt = np.get_printoptions() np.set_printoptions(**self.opt) def __exit__(self, type, value, traceback): np.set_printoptions(**self._opt) a = np.arange(1001) with fullprint(): print(a) print(a) with fullprint(threshold=None, edgeitems=10): print(a)
import StringIO sio = StringIO.StringIO() numpy.savetxt(sio, numpy.arange(10000)) s = sio.getvalue() print s
0.000000000000000000e+00 1.000000000000000000e+00 2.000000000000000000e+00 3.000000000000000000e+00 ...
import numpy as np from contextlib import contextmanager @contextmanager def show_complete_array(): oldoptions = np.get_printoptions() np.set_printoptions(threshold=np.inf) try: yield finally: np.set_printoptions(**oldoptions)
a = np.arange(1001) print(a) with show_complete_array(): print(a) print(a)
import numpy as np np.set_printoptions(linewidth=2000) Mat = np.arange(20000,20150).reshape(2,75) print(Mat)
with numpy.printoptions(threshold=numpy.inf): print(arr)
a = numpy.arange(10000).reshape(250,40) print(numpy.array2string(a, threshold=numpy.nan, max_line_width=numpy.nan))
>>> np.set_printoptions(edgeitems=3,infstr= ... linewidth=75, nanstr= ... suppress=False, threshold=1000, formatter=None)
>>> class ContainsEverything: def __init__(self): return None def __contains__(self, *elem, **k): return True >>> a = ContainsEverything() >>> 3 in a True >>> a in a True >>> False in a True >>> False not in a False >>>
$validateValue=$_POST[ $validateId=$_POST[ $validateError=$_POST[ $arrayToJs = array(); $arrayToJs[0] = $validateId; $arrayToJs[1] = $validateError; if($validateValue =="Testuser"){ $arrayToJs[2] = "true"; echo } else{ for($x=0;$x<1000000;$x++){ if($x == 990000){ $arrayToJs[2] = "false"; echo } } }
def validate_user(request): if request.method == vld_value = request.POST.get( vld_id = request.POST.get( vld_error = request.POST.get( array_to_js = [vld_id, vld_error, False] if vld_value == "TestUser": array_to_js[2] = True x = simplejson.dumps(array_to_js) return HttpResponse(x) else: array_to_js[2] = False x = simplejson.dumps(array_to_js) error = return render_to_response( return render_to_response(
import json from django.http import HttpResponse response_data = {} response_data[ response_data[
return HttpResponse(json.dumps(response_data), content_type="application/json")
from django.http import JsonResponse return JsonResponse({
from django.http import JsonResponse return JsonResponse({
from django.utils import simplejson from django.http import HttpResponse def some_view(request): to_json = { "key1": "value1", "key2": "value2" } return HttpResponse(simplejson.dumps(to_json), mimetype=
from django.utils import simplejson class JsonResponse(HttpResponse): def __init__(self, content, mimetype= super(JsonResponse, self).__init__( content=simplejson.dumps(content), mimetype=mimetype, status=status, content_type=content_type, )
from django.http import JsonResponse def some_view(request): return JsonResponse({"key": "value"})
from django.http import JsonResponse ... return JsonResponse(array_to_js, safe=False)
from django.http import HttpResponse import json class JsonResponse(HttpResponse): def __init__(self, content={}, mimetype=None, status=None, content_type= super(JsonResponse, self).__init__(json.dumps(content), mimetype=mimetype, status=status, content_type=content_type)
from django.http import JsonResponse def your_view(request): json_object = { return JsonResponse(json_object)
from django.core import serializers json_serializer = serializers.get_serializer("json")() response = json_serializer.serialize(list, ensure_ascii=False, indent=2, use_natural_keys=True) return HttpResponse(response, mimetype="application/json")
$.ajax({ url: dataType : cache: false, success: function(data) { alert( } });
class Ajax(webapp2.RequestHandler): def get(self): my_response = { datos = json.dumps(my_response) self.response.headers.add_header( self.response.out.write(datos)
from django.http import JsonResponse def profile(request): data = { } return JsonResponse(data)
import json from django.http import HttpResponse def profile(request): data = { } dump = json.dumps(data) return HttpResponse(dump, content_type=
from django.views import View from django.http import JsonResponse class JsonView(View): def get(self, request): return JsonResponse({
from rest_framework.views import APIView from rest_framework.response import Response class JsonView(APIView): def get(self, request): return Response({
import json class MyJsonView(View): def get(self, *args, **kwargs): resp = { return HttpResponse(json.dumps(resp), mimetype="application/json" )
def view(request): if request.method == print request.body data = request.body return HttpResponse(json.dumps(data))
<!DOCTYPE html> <html> <head> <script src="http: <script> $(document).ready(function(){ $(" selected = $(" $.ajax({ type: dataType: contentType: url: data: { }, success: function(result) { document.write(result) } }); }); }); </script> </head> <body> <form> {{data}} <br> Select your favorite fruit: <select id="mySelect"> <option value="apple" selected >Select fruit</option> <option value="apple">Apple</option> <option value="orange">Orange</option> <option value="pineapple">Pineapple</option> <option value="banana">Banana</option> </select> </form> </body> </html>
def your_method(request): your_json = [{ return HttpResponse(your_json,
def your_method(request): response = request.get( return HttpResponse(response,
>>> today = datetime.datetime(2017, 10, 20) >>> today.get_weekday()
>>> import datetime >>> datetime.datetime.today() datetime.datetime(2012, 3, 23, 23, 24, 55, 173504) >>> datetime.datetime.today().weekday() 4
from datetime import date import calendar my_date = date.today() calendar.day_name[my_date.weekday()]
def weekDay(year, month, day): offset = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334] week = [ afterFeb = 1 if month > 2: afterFeb = 0 aux = year - 1700 - afterFeb dayOfWeek = 5 dayOfWeek += (aux + afterFeb) * 365 dayOfWeek += aux / 4 - aux / 100 + (aux + 100) / 400 dayOfWeek += offset[month - 1] + (day - 1) dayOfWeek %= 7 return dayOfWeek, week[dayOfWeek] print weekDay(2013, 6, 15) == (6, print weekDay(1969, 7, 20) == (0, print weekDay(1945, 4, 30) == (1, print weekDay(1900, 1, 1) == (1, print weekDay(1789, 7, 14) == (2,
import datetime dt = day, month, year = (int(x) for x in dt.split( ans = datetime.date(year, month, day) print ans.strftime("%A")
>>> from datetime import date >>> datetime.datetime.today().strftime(
import datetime def dow(date): days=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"] dayNumber=date.weekday() print days[dayNumber]
import datetime DayL = [ date = DayL[datetime.date(year,month,day).weekday()] + print(date)
def dow(year,month,day): m, q = month, day if m == 1: m = 13 year -= 1 elif m == 2: m = 14 year -= 1 K = year % 100 J = year f = (q + int(13*(m + 1)/5.0) + K + int(K/4.0)) fg = f + int(J/4.0) - 2 * J fj = f + 5 - J if year > 1582: h = fg % 7 else: h = fj % 7 if h == 0: h = 7 return h
days = ["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"] days[calendar.weekday(2017,12,22)]
["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"][calendar.weekday(2017,12,22)]
import datetime today = datetime.date.today() sunday = today - datetime.timedelta(today.weekday()+1) for i in range(7): tmp_date = sunday + datetime.timedelta(i) print tmp_date.toordinal()%7 + 1,
1 == Sunday 2 == Monday 3 == Tuesday 4 == Wednesday 5 == Thursday 6 == Friday 7 == Saturday
import datetime,time ls={ dt=datetime.datetime.strptime(ls[1], "%m/%d/%Y") print(dt) print(dt.month) print(dt.year)
import calendar a=calendar.weekday(year,month,day) days=["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"] print(days[a])
months = { dates = { ranges = { def getValue(val, dic): if(len(val)==4): for k,v in dic.items(): x,y=int(k.split( val = int(val) if(val>=x and val<=y): return v else: return dic[val] def getDate(val): return (list(dates.keys())[list(dates.values()).index(val)]) def main(myDate): dateArray = myDate.split( date,month,year = dateArray[2],dateArray[1],dateArray[0] date = int(date) month_v = getValue(month, months) year_2 = int(year[2:]) div = year_2 year_v = getValue(year, ranges) sumAll = date+month_v+year_2+div+year_v val = (sumAll)%7 str_date = getDate(val) print( if __name__ == "__main__": testDate = main(testDate)
my_dict.keys()[0] -> key of "first" element my_dict.values()[0] -> value of "first" element my_dict.items()[0] -> (key, value) tuple of "first" element
d = {1:1, 2:2, 3:3, 4:4, 10:10, 100:100} print d.keys() print sorted(d.keys()) d[ d[ print d.keys() print sorted(d.keys()) d[0.001] = 0.001 d[3.14] = d[2.71] = print d.keys() print sorted(d.keys())
class mydict(dict): def __getitem__(self, value): if isinstance(value, int): return self.get(list(self)[value]) else: return self.get(value) d = mydict({ d[0] d[1] d[
month points points_h1 time year 0 NaN 50 NaN 5:00 2010 1 february 25 NaN 6:00 NaN 2 january 90 NaN 9:00 NaN 3 june NaN 20 NaN NaN
In [8]: d = [{ ...: { ...: { ...: { In [12]: pd.DataFrame.from_dict(d) Out[12]: month points points_h1 time year 0 NaN 50.0 NaN 5:00 2010.0 1 february 25.0 NaN 6:00 NaN 2 january 90.0 NaN 9:00 NaN 3 june NaN 20.0 NaN NaN
np.random.seed(0) data = pd.DataFrame( np.random.choice(10, (3, 4)), columns=list( print(data) [{ { {
pd.DataFrame(data) A B C D 0 5 0 3 3 1 7 9 3 5 2 2 4 7 6
data_c = [ { { { pd.DataFrame.from_dict(data_c, orient= A B C D 0 5 0 3 3 1 7 9 3 5 2 2 4 7 6
data_i ={ 0: { 1: { 2: { pd.DataFrame.from_dict(data_i, orient= A B C D 0 5 0 3 3 1 7 9 3 5 2 2 4 7 6
pd.DataFrame(data, index=[ A B C D a 5 0 3 3 b 7 9 3 5 c 2 4 7 6
data2 = [ { { { pd.DataFrame(data2) A B C D E F 0 5.0 NaN 3.0 3.0 NaN NaN 1 7.0 9.0 NaN NaN NaN 5.0 2 NaN 4.0 7.0 NaN 6.0 NaN
pd.DataFrame(data2, columns=[ A D F 0 5.0 3.0 NaN 1 7.0 NaN 5.0 2 NaN NaN NaN
pd.DataFrame.from_dict(data2, orient= ValueError: cannot use columns parameter with orient=
rows_to_select = {0, 2} for i in reversed(range(len(data2))): if i not in rows_to_select: del data2[i] pd.DataFrame(data2) A B C D E 0 5.0 NaN 3 3.0 NaN 1 NaN 4.0 7 NaN 6.0
pd.io.json.json_normalize(data) A B C D 0 5 0 3 3 1 7 9 3 5 2 2 4 7 6 pd.io.json.json_normalize(data2) A B C D E 0 5.0 NaN 3 3.0 NaN 1 NaN 4.0 7 NaN 6.0
pd.io.json.json_normalize(data_nested, record_path= meta=[ name population state shortname info.governor 0 Dade 12345 Florida FL Rick Scott 1 Broward 40000 Florida FL Rick Scott 2 Palm Beach 60000 Florida FL Rick Scott 3 Summit 1234 Ohio OH John Kasich 4 Cuyahoga 1337 Ohio OH John Kasich
$ ls cheese_cheese_type.bar cheese_cheese_type.foo $ python >>> import os >>> for filename in os.listdir("."): ... if filename.startswith("cheese_"): ... os.rename(filename, filename[7:]) ... >>> $ ls cheese_type.bar cheese_type.foo
from os import rename, listdir badprefix = "cheese_" fnames = listdir( for fname in fnames: if fname.startswith(badprefix*2): rename(fname, fname.replace(badprefix,
from glob import glob from os import rename for fname in glob( rename(fname, fname[8:])
import os for fileName in os.listdir("."): os.rename(fileName, fileName.replace("CHEESE_CHEESE_", "CHEESE_"))
import os for dpath, dnames, fnames in os.walk( for f in fnames: os.chdir(dpath) if f.startswith( os.rename(f, f.replace(
import os import shutil for file in os.listdir(dirpath): newfile = os.path.join(dirpath, file.split("_",1)[1]) shutil.move(os.path.join(dirpath,file),newfile)
In [1] files = !ls In [2] for f in files: newname = process_filename(f) mv $f $newname
import os paths = (os.path.join(root, filename) for root, _, filenames in os.walk( for filename in filenames) for path in paths: newname = path.replace( if newname != path: os.rename(path, newname)
Summary-building-mobile-apps-ionic-framework-angularjs-m7-08.mp4 m7-08_Summary-building-mobile-apps-ionic-framework-angularjs.mp4
rename_files_regex.py . "([^\.]+?)-(m\\d+-\\d+)" "\\2_\\1"
rename_files_regex.py . "([^\.]+?)-(m\\d+-\\d+)" "\\2_\\1" --write
file_list = os.listdir("/Users/tedfuller/Desktop/prank/") print(file_list) working_location = os.chdir("/Users/tedfuller/Desktop/prank/") working_location = os.getcwd() print(working_location) for file_name in file_list: os.rename(file_name, file_name.translate(str.maketrans("","",string.digits)))
import os for afile in os.listdir( filename, file_extension = os.path.splitext(afile) if not file_extension == os.rename(afile, filename +
import os import re import subprocess def available_cpu_count(): """ Number of available virtual or physical CPUs on this system, i.e. user/real as output by time(1) when called with an optimally scaling userspace-only program""" try: m = re.search(r open( if m: res = bin(int(m.group(1).replace( if res > 0: return res except IOError: pass try: import multiprocessing return multiprocessing.cpu_count() except (ImportError, NotImplementedError): pass try: import psutil return psutil.cpu_count() except (ImportError, AttributeError): pass try: res = int(os.sysconf( if res > 0: return res except (AttributeError, ValueError): pass try: res = int(os.environ[ if res > 0: return res except (KeyError, ValueError): pass try: from java.lang import Runtime runtime = Runtime.getRuntime() res = runtime.availableProcessors() if res > 0: return res except ImportError: pass try: sysctl = subprocess.Popen([ stdout=subprocess.PIPE) scStdout = sysctl.communicate()[0] res = int(scStdout) if res > 0: return res except (OSError, ValueError): pass try: res = open( if res > 0: return res except IOError: pass try: pseudoDevices = os.listdir( res = 0 for pd in pseudoDevices: if re.match(r res += 1 if res > 0: return res except OSError: pass try: try: dmesg = open( except IOError: dmesgProcess = subprocess.Popen([ dmesg = dmesgProcess.communicate()[0] res = 0 while res += 1 if res > 0: return res except OSError: pass raise Exception(
import hwloc topology = hwloc.Topology() topology.load() print topology.get_nbobjs_by_type(hwloc.OBJ_CORE)
try: from java.lang import Runtime runtime = Runtime.getRuntime() res = runtime.availableProcessors() if res > 0: return res except ImportError: pass
import numexpr as ne print ne.detect_number_of_cores()
import commands n = commands.getoutput("grep -c processor /proc/cpuinfo")
import os import sys def cpu_count(): Returns the number of CPUs in the system if sys.platform == try: num = int(os.environ[ except (ValueError, KeyError): num = 0 elif comm = if sys.platform == comm = try: with os.popen(comm) as p: num = int(p.read()) except ValueError: num = 0 else: try: num = os.sysconf( except (ValueError, OSError, AttributeError): num = 0 if num >= 1: return num else: raise NotImplementedError(
from datetime import date d0 = date(2008, 8, 18) d1 = date(2008, 9, 26) delta = d1 - d0 print delta.days
from datetime import datetime date_format = "%m/%d/%Y" a = datetime.strptime( b = datetime.strptime( delta = b - a print delta.days
>>> import datetime >>> today = datetime.date.today() >>> someday = datetime.date(2008, 12, 25) >>> diff = someday - today >>> diff.days 86
>>> from datetime import datetime, timedelta >>> datetime(2008,08,18) - datetime(2008,09,26) datetime.timedelta(4)
Python 2.5.2 (r252:60911, Feb 22 2008, 07:57:53) [GCC 4.0.1 (Apple Computer, Inc. build 5363)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> import datetime >>> today = datetime.date.today() >>> print today 2008-09-01 >>> last_year = datetime.date(2007, 9, 1) >>> print today - last_year 366 days, 0:00:00
from datetime import datetime start_date = datetime.strptime( end_date = datetime.strptime( print abs((end_date-start_date).days)
import arrow a = arrow.get( b = arrow.get( delta = (b-a) print delta.days
daysOfMonths = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] def isLeapYear(year): return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0 def Count_Days(year1, month1, day1): if month1 ==2: if isLeapYear(year1): if day1 < daysOfMonths[month1-1]+1: return year1, month1, day1+1 else: if month1 ==12: return year1+1,1,1 else: return year1, month1 +1 , 1 else: if day1 < daysOfMonths[month1-1]: return year1, month1, day1+1 else: if month1 ==12: return year1+1,1,1 else: return year1, month1 +1 , 1 else: if day1 < daysOfMonths[month1-1]: return year1, month1, day1+1 else: if month1 ==12: return year1+1,1,1 else: return year1, month1 +1 , 1 def daysBetweenDates(y1, m1, d1, y2, m2, d2,end_day): if y1 > y2: m1,m2 = m2,m1 y1,y2 = y2,y1 d1,d2 = d2,d1 days=0 while(not(m1==m2 and y1==y2 and d1==d2)): y1,m1,d1 = Count_Days(y1,m1,d1) days+=1 if end_day: days+=1 return days def test(): test_cases = [((2012,1,1,2012,2,28,False), 58), ((2012,1,1,2012,3,1,False), 60), ((2011,6,30,2012,6,30,False), 366), ((2011,1,1,2012,8,8,False), 585 ), ((1994,5,15,2019,8,31,False), 9239), ((1999,3,24,2018,2,4,False), 6892), ((1999,6,24,2018,8,4,False),6981), ((1995,5,24,2018,12,15,False),8606), ((1994,8,24,2019,12,15,True),9245), ((2019,12,15,1994,8,24,True),9245), ((2019,5,15,1994,10,24,True),8970), ((1994,11,24,2019,8,15,True),9031)] for (args, answer) in test_cases: result = daysBetweenDates(*args) if result != answer: print "Test with data:", args, "failed" else: print "Test case passed!" test()
import datetime import dateutil.relativedelta date_and_time = datetime.datetime.now() date_only = date.today() time_only = datetime.datetime.now().time() result = date_and_time - datetime.timedelta(hours=26, minutes=25, seconds=10) result = date_only - dateutil.relativedelta.relativedelta(years=10) result = date_only - dateutil.relativedelta.relativedelta(months=10) result = date_only - dateutil.relativedelta.relativedelta(days=10) result = date_and_time - datetime.timedelta(hours=26, minutes=25, seconds=10) result.time()
from datetime import date def d(s): [month, day, year] = map(int, s.split( return date(year, month, day) def days(start, end): return (d(end) - d(start)).days print days(
from datetime import datetime Now = datetime.now() StartDate = datetime.strptime(str(Now.year) + NumberOfDays = (Now - StartDate) print(NumberOfDays.days) print(datetime.now().timetuple().tm_yday) print(Now.strftime(
comm= Junk, or working code that I need to comment.
In [19]: id(a) Out[19]: 34019256 In [20]: id(b) Out[20]: 34019256 In [21]: id(c) Out[21]: 34019256
In [22] a = a + 1 In [23]: id(a) Out[23]: 34019232 In [24]: id(b) Out[24]: 34019256 In [25]: id(c) Out[25]: 34019256
accented_string = u import unidecode unaccented_string = unidecode.unidecode(accented_string)
import unicodedata def strip_accents(s): return if unicodedata.category(c) !=
import unicodedata def remove_accents(input_str): nfkd_form = unicodedata.normalize( only_ascii = nfkd_form.encode( return only_ascii
import unicodedata def remove_accents(input_str): nfkd_form = unicodedata.normalize( return u"".join([c for c in nfkd_form if not unicodedata.combining(c)])
encoding = "utf-8" byte_string = b"café" unicode_string = byte_string.decode(encoding)
import re import unicodedata def strip_accents(text): try: text = unicode(text, except (TypeError, NameError): pass text = unicodedata.normalize( text = text.encode( text = text.decode("utf-8") return str(text) def text_to_id(text): text = strip_accents(text.lower()) text = re.sub( text = re.sub( return text
text_to_id("Montréal, über, 12.89, Mère, Françoise, noël, 889") >>>
import unicodedata as ud def rmdiacritics(char): Return the base character of char, by "removing" any diacritics like accents or curls and strokes and the like. desc = ud.name(unicode(char)) cutoff = desc.find( if cutoff != -1: desc = desc[:cutoff] return ud.lookup(desc)
import sys reload(sys) sys.setdefaultencoding("utf-8") import csv import unicodedata def remove_accents(input_str): nkfd_form = unicodedata.normalize( return u"".join([c for c in nkfd_form if not unicodedata.combining(c)]) with open( read = csv.reader(f) for row in read: for element in row: print remove_accents(element)
def strip_accents(string, accents=( accents = set(map(unicodedata.lookup, accents)) chars = [c for c in unicodedata.normalize( return unicodedata.normalize(
string_with_newlines = import re print re.match( print re.match( string_with_newlines) print re.match( re.MULTILINE) print re.search( string_with_newlines) print re.search( re.MULTILINE) m = re.compile( print m.match(string_with_newlines) print m.match(string_with_newlines, pos=4) print m.search(string_with_newlines, re.MULTILINE)
a = "123abc" t = re.match("[a-z]+",a) t = re.search("[a-z]+",a)
import random import re import string import time LENGTH = 10 LIST_SIZE = 1000000 def generate_word(): word = [random.choice(string.ascii_lowercase) for _ in range(LENGTH)] word = return word wordlist = [generate_word() for _ in range(LIST_SIZE)] start = time.time() [re.search( print( start = time.time() [re.match( print(
>>> a = "123abc" >>> re.match("[a-z]+",a) None >>> re.search("[a-z]+",a) abc
import matplotlib.pyplot as plt x = [1, 2, 3, 4, 5] y = [1, 4, 9, 16, 25] fig = plt.figure() fig.add_subplot(111) plt.scatter(x, y) plt.show()
import matplotlib.pyplot as plt fig = plt.figure() fig.add_subplot(221) fig.add_subplot(222) fig.add_subplot(223) fig.add_subplot(224) plt.show()
fig = plt.figure() fig.add_subplot(1, 2, 1) fig.add_subplot(2, 2, 2) fig.add_subplot(2, 2, 4) plt.show()
`fig.add_subplot(111)` `fig.add_subplot(211)` *and* `fig.add_subplot(212)`
sudo pip uninstall requests sudo pip uninstall urllib3 sudo yum remove python-urllib3 sudo yum remove python-requests
sudo yum install python-urllib3 sudo yum install python-requests
$ pip install pip-review $ pip-review --local --interactive
arr = [] arr = [1, "eels"] arr = [1, 2, 3, 4, 5, 6] arr[0] arr[-1] length = len(arr) arr.append(8) arr.insert(6, 7)
import numpy as np a = np.ones((3,2)) b = np.array([1,2,3]) c = np.linspace(2,3,100) print(a*1.5) print(a.T+b)
list_01 = [4, 6.2, 7-2j, list_01 Out[85]: [4, 6.2, (7-2j),
from array import array float_array = array("f",values)
values = [1,2,3] values = (1,2,3) values = np.array([1,2,3], wrong_values = array(
print(float_array) print(float_array[1]) print(isinstance(float_array[1],float))
values = [1,2,3] int_array = array("i",values) int_array.append(float(1))
int_array = array( data = [11,22,33,44,55] sample = [] for i in int_array: sample.append(data[i])
import numpy as np numpy_int_array = np.array([1,2,3], for i in numpy_int_array: print(type(i)) numpy_int_array_2 = np.append(numpy_int_array,int(1)) numpy_float_array = np.append(numpy_int_array,float(1)) numpy_str_array = np.append(numpy_int_array,"1") data = [11,22,33,44,55] sample = [] for i in numpy_int_array_2: sample.append(data[i])
int_numpy_array = np.array([1,2,float(3)], int_numpy_array_2 = np.array([1,2,3.9], invalid_array = np.array([1,2,"string"], str_numpy_array = np.array([1,2,3], print(str_numpy_array) print([type(i) for i in str_numpy_array])
data = [1.2,3.4,5.6] list_1 = np.array(data, list_2 = [int(i) for i in data] print(list_1 == list_2)
>>> a = range(12) >>> a [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] >>> a[7] 6
import numpy as np a = np.array([1, 2, 3, 4]) a = np.array([int(x) for x in input().split()])
import numpy a = numpy.asarray([ [1,2,3], [4,5,6], [7,8,9] ]) numpy.savetxt("foo.csv", a, delimiter=",")
import pandas as pd pd.DataFrame(np_array).to_csv("file_path.csv")
import numpy as np a = np.asarray([ [1,2,3], [4,5,6], [7,8,9] ]) a.tofile(
import numpy as np with open( fp.write( col1,col2,col3 1,100.1,string1 2,222.2,second string ar = np.recfromcsv( print(repr(ar)) with open( fp.write( np.savetxt(fp, ar,
import csv with open( writer = csv.writer(fp, quoting=csv.QUOTE_NONNUMERIC) writer.writerow(ar.dtype.names) writer.writerows(ar.tolist())
for x in np.nditer(a.T, order= file.write(str(x)) file.write("\n")
writer= csv.writer(file, delimiter= for x in np.nditer(a.T, order= row.append(str(x)) writer.writerow(row)
csv_rows = ["{},{}".format(i, j) for i, j in array] csv_text = "\n".join(csv_rows) with open( f.write(csv_text)
narr = np.array([[1,2], [3,4], [5,6]], dtype=np.int32)
1.000000000000000000e+00,2.000000000000000000e+00 3.000000000000000000e+00,4.000000000000000000e+00 5.000000000000000000e+00,6.000000000000000000e+00
import csv person = [[ [ [ [ [ [ csv.register_dialect( delimiter = quoting=csv.QUOTE_NONE, skipinitialspace=True) with open( writer = csv.writer(f, dialect= for row in person: writer.writerow(row) f.close()
for i in xrange(0, len(ints), 4): foo += ints[i] * ints[i + 1] + ints[i + 2] * ints[i + 3]
while ints: foo += ints[0] * ints[1] + ints[2] * ints[3] ints[0:4] = []
from itertools import izip_longest def grouper(iterable, n, fillvalue=None): args = [iter(iterable)] * n return izip_longest(*args, fillvalue=fillvalue)
def chunker(seq, size): return (seq[pos:pos + size] for pos in range(0, len(seq), size))
text = "I am a very, very helpful text" for group in chunker(text, 7): print repr(group), print animals = [ for group in chunker(animals, 3): print group
chunkSize= 4 for i in xrange(0, len(ints), chunkSize): chunk = ints[i:i+chunkSize]
import itertools def chunks(iterable,size): it = iter(iterable) chunk = tuple(itertools.islice(it,size)) while chunk: yield chunk chunk = tuple(itertools.islice(it,size)) for x1,x2,x3,x4 in chunks(ints,4): foo += x1 + x2 + x3 + x4 for chunk in chunks(ints,4): foo += sum(chunk)
import itertools def chunks2(iterable,size,filler=None): it = itertools.chain(iterable,itertools.repeat(filler,size-1)) chunk = tuple(itertools.islice(it,size)) while len(chunk) == size: yield chunk chunk = tuple(itertools.islice(it,size)) for x1,x2,x3,x4 in chunks2(ints,4,0): foo += x1 + x2 + x3 + x4
from itertools import izip_longest def chunker(iterable, chunksize, filler): return izip_longest(*[iter(iterable)]*chunksize, fillvalue=filler)
def chunker(seq, size): res = [] for el in seq: res.append(el) if len(res) == size: yield res res = [] if res: yield res
>>> list(chunker([i for i in range(10)], 3)) [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]
>>> list(chunker(set([i for i in range(10)]), 3)) [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]
>>> list(chunker((i for i in range(10)), 3)) [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]
def grouper(n, iterable, fillvalue=None): args = [iter(iterable)] * n return itertools.izip_longest(fillvalue=fillvalue, *args)
def grouper(size, iterable): i = iter(iterable) while True: out = [] try: for _ in range(size): out.append(i.next()) except StopIteration: yield out break yield out
def grouper(size, iterable): it = iter(iterable) while True: group = tuple(itertools.islice(it, None, size)) if not group: break yield group
def grouper(n, iterable, fillvalue=None): args = [iter(iterable)] * n for i in itertools.izip_longest(fillvalue=fillvalue, *args): if tuple(i)[-1] == fillvalue: yield tuple(v for v in i if v != fillvalue) else: yield i
it = iter([1, 2, 3, 4, 5, 6, 7, 8, 9]) for chunk in zip(it, it, it, it): print chunk >>> (1, 2, 3, 4) >>> (5, 6, 7, 8)
>>> def chunker(iterable, chunksize): ... return map(None,*[iter(iterable)]*chunksize)
>>> s = >>> chunker(s, 3) [( >>> chunker(s, 4) [( >>> chunker(s, 5) [(
>>> def chunker(iterable, chunksize): ... return zip(*[iter(iterable)]*chunksize)
>>> s = >>> chunker(s, 3) [( >>> chunker(s, 4) [( >>> chunker(s, 5) [(
>>> from itertools import izip >>> def chunker(iterable, chunksize): ... return izip(*[iter(iterable)]*chunksize)
>>> from itertools import chain, izip, repeat >>> def chunker(iterable, chunksize, fillvalue=None): ... it = chain(iterable, repeat(fillvalue, chunksize-1)) ... args = [it] * chunksize ... return izip(*args)
from iteration_utilities import grouper seq = list(range(20)) for group in grouper(seq, 4): print(group)
(0, 1, 2, 3) (4, 5, 6, 7) (8, 9, 10, 11) (12, 13, 14, 15) (16, 17, 18, 19)
from iteration_utilities import grouper seq = list(range(17)) for group in grouper(seq, 4): print(group) for group in grouper(seq, 4, fillvalue=None): print(group) for group in grouper(seq, 4, truncate=True): print(group)
def get_chunk(iterable, chunk_size): result = [] for item in iterable: result.append(item) if len(result) == chunk_size: yield tuple(result) result = [] if len(result) > 0: yield tuple(result) for x in get_chunk([1,2,3,4,5,6,7,8,9,10], 3): print x (1, 2, 3) (4, 5, 6) (7, 8, 9) (10,)
data = [...] chunk_size = 10000 chunks = [data[i:i+chunk_size] for i in xrange(0,len(data),chunk_size)] for chunk in chunks: ...
from itertools import islice def group(it, size): it = iter(it) return iter(lambda: tuple(islice(it, size)), ())
from itertools import islice, chain, repeat def group_pad(it, size, pad=None): it = chain(iter(it), repeat(pad)) return iter(lambda: tuple(islice(it, size)), (pad,) * size)
_no_pad = object() def group(it, size, pad=_no_pad): if pad == _no_pad: it = iter(it) sentinel = () else: it = chain(iter(it), repeat(pad)) sentinel = (pad,) * size return iter(lambda: tuple(islice(it, size)), sentinel)
ints = array([1, 2, 3, 4, 5, 6, 7, 8]) for int1, int2 in ints.reshape(-1, 2): print(int1, int2)
def chunkiter(iterable, size): def inneriter(first, iterator, size): yield first for _ in xrange(size - 1): yield iterator.next() it = iter(iterable) while True: yield inneriter(it.next(), it, size) In [2]: i = chunkiter( In [3]: for ii in i: for c in ii: print c, print ...: a b c d e f g h
def group_by(iterable, size): """Group an iterable into lists that don >>> group_by([1,2,3,4,5], 2) [[1, 2], [3, 4], [5]] """ sublist = [] for index, item in enumerate(iterable): if index > 0 and index % size == 0: yield sublist sublist = [] sublist.append(item) if sublist: yield sublist
from funcy import partition for a, b, c, d in partition(4, ints): foo += a * b * c * d
>>> for k, g in itertools.groupby(xrange(35), lambda x: x/10): ... list(g)
... 0 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 1 [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 2 [20, 21, 22, 23, 24, 25, 26, 27, 28, 29] 3 [30, 31, 32, 33, 34] >>>
for k,g in itertools.groupby(xrange(35), lambda x: x/10): for i in g:
messages = a_generator_which_would_not_be_smart_as_a_list for idx, batch in groupby(messages, lambda x: x/1000): batch_request = BatchHttpRequest() for message in batch: batch_request.add(self.service.users().messages().modify(userId= http = httplib2.Http() self.credentials.authorize(http) batch_request.execute(http=http)
def chunker(iterable, chunksize): return zip(*[iter(iterable)]*chunksize)
class IteratorExhausted(Exception): pass def translate_StopIteration(iterable, to=IteratorExhausted): for i in iterable: yield i raise to def custom_zip(*iterables, reductor=tuple): iterators = tuple(map(translate_StopIteration, iterables)) while True: try: yield reductor(next(i) for i in iterators) except IteratorExhausted: break
def chunker(data, size, reductor=tuple): return custom_zip(*[iter(data)]*size, reductor=reductor)
>>> for i in chunker( ... print(repr(i)) ... ( ( >>> for i in chunker( ... print(repr(i)) ...
def chunks(seq, size): it = iter(seq) while True: ret = tuple(it.next() for _ in range(size)) if len(ret) == size: yield ret else: raise StopIteration()
>>> def foo(): ... i = 0 ... while True: ... i += 1 ... yield i ... >>> c = chunks(foo(), 3) >>> c.next() (1, 2, 3) >>> c.next() (4, 5, 6) >>> list(chunks( [(
def chunker(iterable, n): """Yield iterable in chunk sizes. >>> chunks = chunker( >>> chunks.next() [ >>> chunks.next() [ """ it = iter(iterable) while True: chunk = [] for i in range(n): try: chunk.append(it.next()) except StopIteration: yield chunk raise StopIteration yield chunk if __name__ == import doctest doctest.testmod()
def chunk_iter(iterable, chunk_size): it = iter(iterable) while True: chunk = tuple(next(it) for _ in range(chunk_size)) if not chunk: break yield chunk
from itertools import zip_longest _UNDEFINED = object() def chunker(iterable, chunksize, fillvalue=_UNDEFINED): """ Collect data into chunks and optionally pad it. Performance worsens as `chunksize` approaches 1. Inspired by: https: """ args = [iter(iterable)] * chunksize chunks = zip_longest(*args, fillvalue=fillvalue) yield from ( filter(lambda val: val is not _UNDEFINED, chunk) if chunk[-1] is _UNDEFINED else chunk for chunk in chunks ) if fillvalue is _UNDEFINED else chunks
def split_seq(seq, size): newseq = [] splitsize = 1.0/size*len(seq) for i in range(size): newseq.append(seq[int(round(i*splitsize)):int(round((i+1)*splitsize))]) return newseq
l1 = range(0, 4) l2 = range(4, 8) l3 = range(8, 12) l4 = range(12, 16) for i1, i2, i3, i4 in zip(l1, l2, l3, l4): ...
>>> print l1 [0, 1, 2, 3] >>> print l2 [4, 5, 6, 7] >>> print l3 [8, 9, 10, 11] >>> print l4 [12, 13, 14, 15] >>> print zip(l1, l2, l3, l4) [(0, 4, 8, 12), (1, 5, 9, 13), (2, 6, 10, 14), (3, 7, 11, 15)]
from itertools import izip for i1, i2, i3, i4 in izip(l1, l2, l3, l4): ...
for a, b, c, d in zip(x[0::4], x[1::4], x[2::4], x[3::4]): ... do something with a, b, c and d ...
def chunker(iterable, size, reductor, condition): it = iter(iterable) def chunk_generator(): return (next(it) for _ in range(size)) chunk = reductor(chunk_generator()) while condition(chunk): yield chunk chunk = reductor(chunk_generator())
groupby(iterable, (lambda x,y: (lambda z: x.next()/y))(count(),100))
for k,v in groupby(bigdata, (lambda x,y: (lambda z: x.next()/y))(count(),100))): cursor.executemany(sql, v)
D:\workspace\numpy>python Python 2.4.4 ( Type "help", "copyright", "credits" or "license" for more information. >>> Ellipsis Ellipsis
>>> a array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16]]) >>> a[:2,:2] array([[1, 2], [5, 6]])
class MyClass(object): """Example of a doctest Ellipsis >>> thing = MyClass() >>> >>> type(thing) <class """ pass
def partial(func: Callable[..., str], *args) -> Callable[..., str]:
class C(object): def __getitem__(self, k): return k assert C()[0] == 0 assert C()[0, 1] == (0, 1) assert C()[1:2:3] == slice(1, 2, 3) assert C()[...] is Ellipsis assert C()[1, 2:3:4, ..., 6] == (1, slice(2,3,4), Ellipsis, 6)
date_handler = lambda obj: ( obj.isoformat() if isinstance(obj, (datetime.datetime, datetime.date)) else None ) json.dumps(datetime.datetime.now(), default=date_handler)
def handler(obj): if hasattr(obj, return obj.isoformat() elif isinstance(obj, ...): return ... else: raise TypeError,
import json import datetime class DateTimeJSONEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, datetime.datetime): return obj.isoformat() else: return super(DateTimeJSONEncoder, self).default(obj)
>>> DateTimeJSONEncoder().encode([datetime.datetime.now()])
date = datetime.datetime.now() >>> json = dumps(dict(foo= >>> json >>> loads(json) {u u
__all__ = [ import datetime try: import json except ImportError: import simplejson as json class JSONDateTimeEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, (datetime.date, datetime.datetime)): return obj.isoformat() else: return json.JSONEncoder.default(self, obj) def datetime_decoder(d): if isinstance(d, list): pairs = enumerate(d) elif isinstance(d, dict): pairs = d.items() result = [] for k,v in pairs: if isinstance(v, basestring): try: v = datetime.datetime.strptime(v, except ValueError: try: v = datetime.datetime.strptime(v, except ValueError: pass elif isinstance(v, (dict, list)): v = datetime_decoder(v) result.append((k, v)) if isinstance(d, list): return [x[1] for x in result] elif isinstance(d, dict): return dict(result) def dumps(obj): return json.dumps(obj, cls=JSONDateTimeEncoder) def loads(obj): return json.loads(obj, object_hook=datetime_decoder) if __name__ == mytimestamp = datetime.datetime.utcnow() mydate = datetime.date.today() data = dict( foo = 42, bar = [mytimestamp, mydate], date = mydate, timestamp = mytimestamp, struct = dict( date2 = mydate, timestamp2 = mytimestamp ) ) print repr(data) jsonstring = dumps(data) print jsonstring print repr(loads(jsonstring))
import datetime date = datetime.datetime.today() json =
import json import datetime json.JSONEncoder.default = lambda self,obj: (obj.isoformat() if isinstance(obj, datetime.datetime) else None)
>>> from datetime import datetime >>> d = datetime.strptime( >>> d datetime.datetime(2016, 1, 8, 19, 0, 0, 123000) >>> d.isoformat() +
> $filter( "2016-01-08 20:00:00" > $filter( "2016-01-08 19:00:00"
import time, json from datetime import datetime as dt your_date = dt.now() data = json.dumps(time.mktime(your_date.timetuple())*1000) return data
def default(obj): if hasattr(obj, "json") and callable(getattr(obj, "json")): return obj.json() if hasattr(obj, "isoformat") and callable(getattr(obj, "isoformat")): if not obj.utcoffset(): tzinfo = datetime.now(timezone.utc).astimezone().tzinfo obj = obj.replace(tzinfo=tzinfo) obj = obj.astimezone(timezone.utc) obj = obj.replace(tzinfo=None) return obj.isoformat() + "Z" elif hasattr(obj, "__str__") and callable(getattr(obj, "__str__")): return str(obj) else: print("obj:", obj) raise TypeError(obj) def dump(j, io): json.dump(j, io, indent=2, default=default)
>>> timeit.timeit( 0.37095273281943264 >>> timeit.timeit( 0.5577236771712819
>>> x=[5] >>> y=[x] * 4 >>> y [[5], [5], [5], [5]] >>> y[0][0] = 6 >>> y [[6], [6], [6], [6]]
>>> l = [0] * 4 >>> l[0] += 1 >>> l [1, 0, 0, 0] >>> l = [frozenset()] * 4 >>> l[0] |= set( >>> l [frozenset([
>>> json.JSONDecoder(object_pairs_hook=collections.OrderedDict).decode( OrderedDict([( >>>
>>> import json >>> from collections import OrderedDict >>> data = json.loads( >>> print json.dumps(data, indent=4) { "foo": 1, "bar": 2 } >>>
my_ordered_dict = json.loads(json_str, object_pairs_hook=collections.OrderedDict)
import simplejson as json import ordereddict my_ordered_dict = json.loads(json_str, object_pairs_hook=ordereddict.OrderedDict)
import json data = json.loads( print(json.dumps(data, indent=4))
{ "fiddle": { "bar": 2, "foo": 1 }, "bar": 2, "foo": 1 }
{ "foo": 1, "bar": 2, "fiddle": { "bar": 2, "foo": 1 } }
import json from collections import OrderedDict with open( metrics_types = json.load(fp, object_pairs_hook=OrderedDict)
import os print(os.path.dirname(os.path.realpath(__file__)))
import os import sys def get_script_path(): return os.path.dirname(os.path.realpath(sys.argv[0]))
import os dn = os.path.dirname(os.path.realpath(__file__))
import os,sys pwd = os.path.dirname(__file__) sys.path.append(pwd)
import os script_dir = os.path.dirname(os.path.realpath(__file__)) + os.sep
import os import sys def get_script_directory(): path = os.path.realpath(sys.argv[0]) if os.path.isdir(path): return path else: return os.path.dirname(path)
def get_script_path(for_file = None): path = os.path.dirname(os.path.realpath(sys.argv[0] or return path if not for_file else os.path.join(path, for_file)
import os exec_filepath = os.path.realpath(__file__) exec_dirpath = exec_filepath[0:len(exec_filepath)-len(os.path.basename(__file__))]
def int_to_bin_string(i): if i == 0: return "0" s = while i: if i & 1 == 1: s = "1" + s else: s = "0" + s i return s
t1 = time() for i in range(1000000): binary(i) t2 = time() print(t2 - t1)
t1 = time() for i in range(1000000): t2 = time() print(t2 - t1)
n=42 assert "-101010" == format(-n, assert "-101010" == "{0:b}".format(-n) assert "-101010" == (lambda x: x >= 0 and str(bin(x))[2:] or "-" + str(bin(x))[3:])(-n) assert "0b101010" == bin(n) assert "101010" == bin(n)[2:]
def int2bin(val): res= while val>0: res += str(val&1) val=val>>1 return res[::-1]
def int2bin(val): res= while val>0: res = chr((val&1) + 0x30) + res val=val>>1 return res
Examples -------- >>> a = np.array([[2], [7], [23]], dtype=np.uint8) >>> a array([[ 2], [ 7], [23]], dtype=uint8) >>> b = np.unpackbits(a, axis=1) >>> b array([[0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
def binary(decimal) : otherBase = "" while decimal != 0 : otherBase = str(decimal % 2) + otherBase decimal return otherBase print binary(10)
def inttobinary(number): if number == 0: return str(0) result ="" while (number != 0): remainder = number%2 number = number/2 result += str(remainder) return result[::-1]
def dectobin(number): bin = while (number >= 1): number, rem = divmod(number, 2) bin = bin + str(rem) return bin
def dec2bin(d): b = bin(d) return b def dec2hex(d): h = hex(d) return h def bin2dec(b): bin_numb="{0:b}".format(b) d = eval(bin_numb) return d,bin_numb def bin2hex(b): h = hex(b) return h def hex2dec(h): d = int(h) return d def hex2bin(h): b = bin(h) return b numb_dec = 99 numb_bin = 0b0111 numb_hex = 0xFF res_dec2bin = dec2bin(numb_dec) res_dec2hex = dec2hex(numb_dec) res_bin2dec,bin_numb = bin2dec(numb_bin) res_bin2hex = bin2hex(numb_bin) res_hex2dec = hex2dec(numb_hex) res_hex2bin = hex2bin(numb_hex) print( print( print( print( print( print(
def to_bin(dec): flag = True bin_str = while flag: remainder = dec % 2 quotient = dec / 2 if quotient == 0: flag = False bin_str += str(remainder) dec = quotient bin_str = bin_str[::-1] return bin_str
def toBin(num): if num == 0: return "" return toBin(num print ([(toBin(i)) for i in range(10)]) [
try: while True: p = "" a = input() while a != 0: l = a % 2 b = a - l a = b / 2 p = str(l) + p print(p) except: print ("write 1 number")
for i in range(17): print("{0:>2}: binary is {0:>08b}".format(i))
for i in range(17): print("{0:>2}: Hexa Decimal is {0:>0x}".format(i))
import numpy as np E_mat = np.tile(E,[1,M]) M_order = pow(2,(M-1-np.array(range(M)))).T bindata = np.remainder(np.floor(E_mat /M_order).astype(np.int),2)
f = str(bin(10)) c = [] c.append("".join(map(int, f[2:]))) print c
def intToBin(n): if(n < 0): print "Sorry, invalid input." elif(n == 0): print n else: result = "" while(n != 0): result += str(n%2) n /= 2 print result[::-1]
def intToBin(n): if(n < 0): return -1 elif(n == 0): return str(n) else: result = "" while(n != 0): result += str(n%2) n /= 2 return result[::-1]
t = 1 while t > 0: binaryNumber = input("Enter a binary No.") convertedNumber = int(binaryNumber, 2) print(convertedNumber) print("")
def int2bin(integer, digits): if integer >= 0: return bin(integer)[2:].zfill(digits) else: return bin(2**digits + integer)[2:]
>>> int2bin(10, 8) >>> int2bin(-10, 8) >>> int2bin(-128, 8) >>> int2bin(127, 8)
class Pizza(object): def __init__(self): self.toppings = [] def __call__(self, topping): self.toppings.append(topping()) def __repr__(self): return str(self.toppings) pizza = Pizza() @pizza def cheese(): return @pizza def sauce(): return print pizza
from flask import Flask app = Flask(__name__) @app.route("/") def hello(): return "Hello World!"
rule = "/" view_func = hello def add_url_rule(self, rule, endpoint=None, view_func=None, **options): pass
def decorator(func): return func @decorator def some_func(): pass
def decorator(func): return func def some_func(): pass some_func = decorator(some_func)
class Mat(list): def __matmul__(self, B): A = self return Mat([[sum(A[i][k]*B[k][j] for k in range(len(B))) for j in range(len(B[0])) ] for i in range(len(A))]) A = Mat([[1,3],[7,5]]) B = Mat([[6,8],[4,2]]) print(A @ B)
def decorated_function(): decorated_function = decorator(decorated_function)
~$ grep -C 1 "@" cpython/Grammar/Grammar decorator: decorators: decorator+ -- testlist_star_expr: (test|star_expr) ( augassign: ( -- arith_expr: term (( term: factor (( factor: (
def f(...): ... f = staticmethod(f) @staticmethod def f(...): ...
object.__add__(self, other) object.__sub__(self, other) object.__mul__(self, other) object.__matmul__(self, other) object.__truediv__(self, other) object.__floordiv__(self, other)
S = (H @ beta - r).T @ inv(H @ V @ H.T) @ (H @ beta - r)
S = dot((dot(H, beta) - r).T, dot(inv(dot(dot(H, V), H.T)), dot(H, beta) - r))
>>> from numpy import array, matrix >>> array([[1,2,3]]).T @ array([[1,2,3]]) array([[1, 2, 3], [2, 4, 6], [3, 6, 9]]) >>> array([[1,2,3]]) @ array([[1,2,3]]).T array([[14]]) >>> matrix([1,2,3]).T @ matrix([1,2,3]) matrix([[1, 2, 3], [2, 4, 6], [3, 6, 9]]) >>> matrix([1,2,3]) @ matrix([1,2,3]).T matrix([[14]])
>>> m = matrix([1,2,3]) >>> m @= m.T Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: In-place matrix multiplication is not (yet) supported. Use
>>> m = matrix([1,2,3]) >>> m @= m.T >>> m matrix([[14]])
In [9]: def read_a_book(): ...: return "I am reading the book: " ...: In [10]: read_a_book() Out[10]:
def add_a_book(func): def wrapper(): return func() + "Python Cookbook" return wrapper
In [14]: read_a_book = add_a_book(read_a_book) In [15]: read_a_book() Out[15]:
@add_a_book def read_a_book(): return "I am reading the book: " In [17]: read_a_book() Out[17]:
import numpy as np def forward(xi, W1, b1, W2, b2): z1 = W1 @ xi + b1 a1 = sigma(z1) z2 = W2 @ a1 + b2 return z2, a1
df = pandas.DataFrame({ y = 10 df >> query( df.query(
class User(db.Models): def get_present_name(self): return self.name or def activate(self): self.status = self.save()
class User(db.Models): def get_present_name(self): return remote_api.request_user_name(self.uid) or def activate(self): self.status = self.save() send_mail(
def activate_user(user_id): user = User.objects.get(pk=user_id) user.active = True user.save() send_mail(...)
class ActivateUserForm(forms.Form): user_id = IntegerField(widget = UsernameSelectWidget, verbose_name="Select a user to activate") def clean_user_id(self): user_id = self.cleaned_data[ if User.objects.get(pk=user_id).active: raise ValidationError("This user cannot be activated") return user_id def execute(self): user_id = self.cleaned_data[ user = User.objects.get(pk=user_id) user.active = True user.save() send_mail(...)
@register.filter def friendly_name(user): return remote_api.get_cached_name(user.id)
def inactive_users(): return User.objects.filter(active=False) def users_called_publysher(): for user in User.objects.all(): if remote_api.get_cached_name(user.id) == "publysher": yield user
class InactiveUserManager(models.Manager): def get_queryset(self): query_set = super(InactiveUserManager, self).get_queryset() return query_set.filter(active=False) class InactiveUser(User): """ >>> for user in InactiveUser.objects.all(): … assert user.active is False """ objects = InactiveUserManager() class Meta: proxy = True
class InactiveUserDistribution(models.Model): country = CharField(max_length=200) inactive_user_count = IntegerField(default=0)
class ActivateUserForm(forms.Form): def execute(self): query_model = InactiveUserDistribution.objects.get_or_create(country=user.country) query_model.inactive_user_count -= 1 query_model.save()
user_activated = Signal(providing_args = [ user_deactivated = Signal(providing_args = [
class ActivateUserForm(forms.Form): def execute(self): user_activated.send_robust(sender=self, user=user)
class InactiveUserDistribution(models.Model): @receiver(user_activated) def on_user_activated(sender, **kwargs): user = kwargs[ query_model = InactiveUserDistribution.objects.get_or_create(country=user.country) query_model.inactive_user_count -= 1 query_model.save()
class Book: author = models.ForeignKey(User) title = models.CharField(max_length=125) class Meta: app_label = "library"
from library.models import Book def get_books(limit=None, **filters): if limit: return Book.objects.filter(**filters)[:limit] return Book.objects.filter(**filters)
from library.services import get_books class BookListView(ListView): queryset = get_books()
class UserManager(models.Manager): def create_user(self, username, ...): def create_superuser(self, username, ...): def activate(self, username): def activate_in_bulk(self, queryset):
class User(db.Models): def get_present_name(self): return remote_api.request_user_name(self.uid) or
class User(db.Models): def get_present_name(self): for backend in get_backends(): try: return backend.get_present_name(self) except: pass return None
.... from app.logic.user import UserLogic class User(models.Model, UserLogic): field1 = models.AnyField(....) ... field definitions ...
if False: from main.models import User class UserLogic(object): def logic_function(self: ... code with hinting working normally ...
class ThingsKeeper def __init__(self): self.__things = [] def things(self): return self.__things def safer(self): return self.__things[:]
>>>foo = [ >>>print ",".join(foo) a,b,c >>>print ",".join([]) >>>print ",".join([ a
import StringIO import csv l = [ line = StringIO.StringIO() writer = csv.writer(line) writer.writerow(l) csvcontent = line.getvalue()
>>> import io >>> s = io.StringIO() >>> print(*alist, file=s, sep= >>> s.getvalue() "a, 1, (2,
>>> l = [1, "foo", 4 ,"bar"] >>> ",".join(str(bit) for bit in l)
>>> my_list = [ >>> ",".join([str(i) for i in my_list if i])
from itertools import imap l = [1, "foo", 4 ,"bar"] ",".join(imap(str, l))
>>> myList = [[ >>> myList = >>> print "Output:", myList Output: Apple,Orange
>>> myList = [[ >>> myList = >>> print "Output:", myList Output: Apple,Orange
myList = [ myList = print "Output:", myList Output: Apple,Orange
import csv with open( writer = csv.writer(f) writer.writerow(l)
String = "Once:Upon:a:Time:A:Long:Time:Ago" ding = String.split( ring = (" , ").join(ding) print(ring)
>>> from itertools import imap, ifilter >>> l = [ >>> a,b,1 >>> m = [ >>>
l = [15, 18, 2, 36, 12, 78, 5, 6, 9] print reduce(lambda x, y: x + y, l)
l = [15, 18, 2, 36, 12, 78, 5, 6, 9] print reduce(lambda x, y: x + y, l) / len(l)
l = [15, 18, 2, 36, 12, 78, 5, 6, 9] sum(l) / float(len(l))
l = [15, 18, 2, 36, 12, 78, 5, 6, 9] import numpy as np print np.mean(l)
from statistics import mean l = [15, 18, 2, 36, 12, 78, 5, 6, 9] mean(l)
list = [11, 13, 12, 15, 17] import statistics as s s.mean(list)
>>> reduce(lambda x, y: x + y / float(len(l)), l, 0) 20.111111111111114
def list_mean(n): summing = float(sum(n)) count = float(len(n)) if n == []: return False return float(summing/count)
>>> l = [15, 18, 2, 36, 12, 78, 5, 6, 9] >>> running_average = reduce(lambda aggr, elem: (aggr[0] + elem, aggr[1]+1), l, (0.0,0)) >>> running_average[0] (181.0, 9) >>> running_average[0]/running_average[1] 20.111111111111111
>>> l = [15, 18, 2, 36, 12, 78, 5, 6, 9] >>> print reduce(lambda x, y: x + y, l) / len(l) 20 >>> sum(l)/len(l) 20
>>> print reduce(lambda x, y: x + y, l) / float(len(l)) 20.1111111111 >>> print sum(l)/float(len(l)) 20.1111111111
from scipy import stats l = [15, 18, 2, 36, 12, 78, 5, 6, 9] print(stats.describe(l))
L = [15, 18, 2, 36, 12, 78, 5, 6, 9] total = 0 def average(numbers): total = sum(numbers) total = float(total) return total / len(numbers) print average(L)
>>> import pandas as pd >>> l = [15, 18, 2, 36, 12, 78, 5, 6, 9] >>> pd.Series(l).mean() 20.11111111111111 >>>
l = [15, 18, 2, 36, 12, 78, 5, 6, 9] l = map(float,l) print
from operator import truediv L = [15, 18, 2, 36, 12, 78, 5, 6, 9] def sum_and_count(x, y): try: return (x[0] + y, x[1] + 1) except TypeError: return (x + y, 2) truediv(*reduce(sum_and_count, L)) 20.11111111111111
import itertools,operator list(itertools.accumulate(l,operator.add)).pop(-1) / len(l)
numbers = [0,1,2,3] numbers[0] = input("Please enter a number") numbers[1] = input("Please enter a second number") numbers[2] = input("Please enter a third number") numbers[3] = input("Please enter a fourth number") print (numbers) print ("Finding the Avarage") avarage = int(numbers[0]) + int(numbers[1]) + int(numbers[2]) + int(numbers [3]) / 4 print (avarage)
Traceback (most recent call last): File "/var/www/mydir/virtualenvs/dev/bin/pip", line 5, in <module> from pkg_resources import load_entry_point ImportError: No module named pkg_resources
sh setuptools-0.6c11-py2.6.egg --install-dir /var/www/mydir/virtualenvs/dev/lib/python2.6/site-packages
sudo apt-get install --reinstall python-pkg-resources
pip install --upgrade setuptools pip install --upgrade distribute
$ deactivate $ rmvirtualenv yourenv $ mkvirtualenv yourenv --distribute $ workon yourenv $ pip install -r requirements.txt
pip install --force-reinstall -U setuptools pip install --force-reinstall -U pip
Installing easy_install script to /path/env/bin error: /path/env/bin/easy_install: Permission denied
sudo chmod -R a+rwx /path/to/my/venv/lib/python2.7/site-packages/
$ sudo wget https: $ tar -zxvf setuptools-0.6c11.tar.gz $ cd setuptools-0.6c11/ $ sudo python setup.py build $ sudo python setup.py install $ sudo pip install --upgrade setuptools
sudo apt-get install python-setuptools python-dev build-essential sudo easy_install pip pip install --upgrade setuptools
~/RepoDir/TestProject$ virtualenv TestEnvironmentDir
Python 2.6.1 (r261:67515, Jun 24 2010, 21:47:49) [GCC 4.2.1 (Apple Inc. build 5646)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> import datetime >>> import pytz >>> unaware = datetime.datetime(2011,8,15,8,15,12,0) >>> unaware datetime.datetime(2011, 8, 15, 8, 15, 12) >>> aware = datetime.datetime(2011,8,15,8,15,12,0,pytz.UTC) >>> aware datetime.datetime(2011, 8, 15, 8, 15, 12, tzinfo=<UTC>) >>> aware == unaware Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can
>>> unaware.astimezone(pytz.UTC) Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: astimezone() cannot be applied to a naive datetime >>>
>>> unaware.replace(tzinfo=pytz.UTC) datetime.datetime(2011, 8, 15, 8, 15, 12, tzinfo=<UTC>) >>> unaware == aware Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can >>>
import datetime import pytz unaware = datetime.datetime(2011, 8, 15, 8, 15, 12, 0) aware = datetime.datetime(2011, 8, 15, 8, 15, 12, 0, pytz.UTC) now_aware = pytz.utc.localize(unaware) assert aware == now_aware
from datetime import datetime from datetime import timezone dt = datetime.now() dt.replace(tzinfo=timezone.utc) print(dt.replace(tzinfo=timezone.utc).isoformat())
try: from datetime import timezone utc = timezone.utc except ImportError: class UTC(tzinfo): def utcoffset(self, dt): return timedelta(0) def tzname(self, dt): return "UTC" def dst(self, dt): return timedelta(0) utc = UTC()
from pytz import timezone localtz = timezone( dt_aware = localtz.localize(dt_unware)
from django.utils import timezone dt_aware = timezone.make_aware(dt_unaware, timezone.get_current_timezone())
def make_tz_aware(dt, tz= tz = dt.tzinfo or tz try: tz = pytz.timezone(tz) except AttributeError: pass return tz.localize(dt, is_dst=is_dst)
localdatetime_aware = tz.localize(datetime_nonaware)
import pytz from datetime import datetime pytz.timezone(
datetime.datetime(2017, 11, 3, 7, 44, 51, 908574, tzinfo=<DstTzInfo
from dateutil import tz import datetime dt_unaware = datetime.datetime(2017, 6, 24, 12, 24, 36) dt_aware = dt_unaware.replace(tzinfo=tz.tzlocal())
from datetime import datetime import pytz naive = datetime.now() aware = naive.replace(tzinfo=pytz.UTC)
import datetime import saturn unaware = datetime.datetime(2011, 8, 15, 8, 15, 12, 0) now_aware = saturn.fix_naive(unaware) now_aware_madrid = saturn.fix_naive(unaware,
def match(pattern, string, flags=0): return _compile(pattern, flags).match(string) def _compile(*key): cachekey = (type(key[0]),) + key p = _cache.get(cachekey) if p is not None: return p if len(_cache) >= _MAXCACHE: _cache.clear() _cache[cachekey] = p return p
$ python -m timeit -s "import re" "re.match( 100000 loops, best of 3: 3.82 usec per loop $ python -m timeit -s "import re; h=re.compile( 1000000 loops, best of 3: 1.26 usec per loop
% python -m timeit -s "import re" "re.match( 1000000 loops, best of 3: 0.661 usec per loop % python -m timeit -s "import re; h=re.compile( 1000000 loops, best of 3: 0.285 usec per loop % python -m timeit -s "import re" "h=re.compile( 1000000 loops, best of 3: 0.65 usec per loop % python --version Python 3.6.5 :: Anaconda, Inc.
~$ for x in 1 10 100 1000 10000 100000 1000000; do python -m timeit -n $x -s 1 loops, best of 3: 3.1 usec per loop 10 loops, best of 3: 2.41 usec per loop 100 loops, best of 3: 2.24 usec per loop 1000 loops, best of 3: 2.21 usec per loop 10000 loops, best of 3: 2.23 usec per loop 100000 loops, best of 3: 2.24 usec per loop 1000000 loops, best of 3: 2.31 usec per loop
~$ for x in 1 10 100 1000 10000 100000 1000000; do python -m timeit -n $x -s 1 loops, best of 3: 1.91 usec per loop 10 loops, best of 3: 0.691 usec per loop 100 loops, best of 3: 0.701 usec per loop 1000 loops, best of 3: 0.684 usec per loop 10000 loops, best of 3: 0.682 usec per loop 100000 loops, best of 3: 0.694 usec per loop 1000000 loops, best of 3: 0.702 usec per loop
import re import time def timed(func): def wrapper(*args): t = time.time() result = func(*args) t = time.time() - t print return result return wrapper regularExpression = r testString = "average 2 never" @timed def noncompiled(): a = 0 for x in xrange(1000000): m = re.match(regularExpression, testString) a += int(m.group(1)) return a @timed def compiled(): a = 0 rgx = re.compile(regularExpression) for x in xrange(1000000): m = rgx.match(testString) a += int(m.group(1)) return a @timed def reallyCompiled(): a = 0 rgx = re.sre_compile.compile(regularExpression) for x in xrange(1000000): m = rgx.match(testString) a += int(m.group(1)) return a @timed def compiledInLoop(): a = 0 for x in xrange(1000000): rgx = re.compile(regularExpression) m = rgx.match(testString) a += int(m.group(1)) return a @timed def reallyCompiledInLoop(): a = 0 for x in xrange(10000): rgx = re.sre_compile.compile(regularExpression) m = rgx.match(testString) a += int(m.group(1)) return a r1 = noncompiled() r2 = compiled() r3 = reallyCompiled() r4 = compiledInLoop() r5 = reallyCompiledInLoop() print "r1 = ", r1 print "r2 = ", r2 print "r3 = ", r3 print "r4 = ", r4 print "r5 = ", r5 </pre> And here is the output on my machine: <pre> $ regexTest.py noncompiled took 4.555 seconds. compiled took 2.323 seconds. reallyCompiled took 2.325 seconds. compiledInLoop took 4.620 seconds. reallyCompiledInLoop took 4.074 seconds. r1 = 2000000 r2 = 2000000 r3 = 2000000 r4 = 2000000 r5 = 20000
noncompiled took 4.555 seconds. compiledInLoop took 4.620 seconds. compiled took 2.323 seconds.
class Foo: regex = re.compile( def my_function(text) return regex.match(text)
def match(pattern, string, flags=0): return _compile(pattern, flags).match(string) def fullmatch(pattern, string, flags=0): return _compile(pattern, flags).fullmatch(string) def search(pattern, string, flags=0): return _compile(pattern, flags).search(string) def sub(pattern, repl, string, count=0, flags=0): return _compile(pattern, flags).sub(repl, string, count) def subn(pattern, repl, string, count=0, flags=0): return _compile(pattern, flags).subn(repl, string, count) def split(pattern, string, maxsplit=0, flags=0): return _compile(pattern, flags).split(string, maxsplit) def findall(pattern, string, flags=0): return _compile(pattern, flags).findall(string) def finditer(pattern, string, flags=0): return _compile(pattern, flags).finditer(string)
_cache = {} _pattern_type = type(sre_compile.compile("", 0)) _MAXCACHE = 512 def _compile(pattern, flags): try: p, loc = _cache[type(pattern), pattern, flags] if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE): return p except KeyError: pass if isinstance(pattern, _pattern_type): if flags: raise ValueError( "cannot process flags argument with a compiled pattern") return pattern if not sre_compile.isstring(pattern): raise TypeError("first argument must be string or compiled pattern") p = sre_compile.compile(pattern, flags) if not (flags & DEBUG): if len(_cache) >= _MAXCACHE: _cache.clear() if p.flags & LOCALE: if not _locale: return p loc = _locale.setlocale(_locale.LC_CTYPE) else: loc = None _cache[type(pattern), pattern, flags] = p, loc return p
number_pattern = re.compile(r assign_pattern = re.compile(r identifier_pattern = re.compile(r whitespace_pattern = re.compile(r if whitespace_pattern.match(s): business_logic_rule_1() if assign_pattern.match(s): business_logic_rule_2()
>>> from dis import dis >>> with open( f.read(8) dis(marshal.load(f)) 1 0 LOAD_CONST 0 (-1) 3 LOAD_CONST 1 (None) 6 IMPORT_NAME 0 (re) 9 STORE_NAME 0 (re) 3 12 LOAD_NAME 0 (re) 15 LOAD_ATTR 1 (compile) 18 LOAD_CONST 2 ( 21 CALL_FUNCTION 1 24 STORE_NAME 2 (lc_vowels) 27 LOAD_CONST 1 (None) 30 RETURN_VALUE
import re import time rgx = re.compile( str = "average 2 never" a = 0 t = time.time() for i in xrange(1000000): if re.match( a += 1 print time.time() - t
import re import time import fpformat Regex1 = re.compile( Regex2 = re.compile( TimesToDo = 1000 TestString = "" for i in range(1000): TestString += "abababdedfg" StartTime = time.time() for i in range(TimesToDo): Regex1.search(TestString) Seconds = time.time() - StartTime print "Alternation takes " + fpformat.fix(Seconds,3) + " seconds" StartTime = time.time() for i in range(TimesToDo): Regex2.search(TestString) Seconds = time.time() - StartTime print "Character Class takes " + fpformat.fix(Seconds,3) + " seconds" Alternation takes 2.299 seconds Character Class takes 0.107 seconds
import re import time import fpformat TimesToDo = 1000 TestString = "" for i in range(1000): TestString += "abababdedfg" StartTime = time.time() for i in range(TimesToDo): re.search( Seconds = time.time() - StartTime print "Alternation takes " + fpformat.fix(Seconds,3) + " seconds" StartTime = time.time() for i in range(TimesToDo): re.search( Seconds = time.time() - StartTime print "Character Class takes " + fpformat.fix(Seconds,3) + " seconds" Alternation takes 2.508 seconds Character Class takes 0.109 seconds
[x for x in data if compare(patternPhrases, x[columnIndex])]
[x for x in data if compare(patternPhrases, x[columnIndex])]
>>> ipr = r >>> average(*timeit.repeat("re.match(ipr, 1.5077415757028423 >>> ipr = re.compile(ipr) >>> average(*timeit.repeat("re.match(ipr, 1.8324008992184038 >>> average(*timeit.repeat("ipr.match( 0.9187896518778871
regex_object = re.compile(r match_object = regex_object.search( match_object.group() output: Out[60]: V.S. re.search(r Out[61]:
example_string = "The room number of her room is 26A7B." find_alpha_numeric_string = re.compile(r"\b\w+\b")
""" Re.py: Re.match = re.match + cache efficiency: re.py does this already (but what readability, inline / separate: matter of taste """ import re cache = {} _re_type = type( re.compile( "" )) def match( pattern, str, *opt ): """ Re.match = re.match + cache re.compile( pattern ) """ if type(pattern) == _re_type: cpat = pattern elif pattern in cache: cpat = cache[pattern] else: cpat = cache[pattern] = re.compile( pattern, *opt ) return cpat.match( str )
>>> timeit.timeit(setup=""" ... import re ... f=lambda x, y: x.match(y) ... h=re.compile( ... """, stmt="f(h, 0.32881879806518555 >>> timeit.timeit(setup=""" ... import re ... f=lambda x, y: re.compile(x).match(y) ... """, stmt="f( 0.809190034866333
from re import compile as _Re class TYPO: def text_has_foobar( self, text ): return self._text_has_foobar_re_search( text ) is not None _text_has_foobar_re_search = _Re( r"""(?i)foobar""" ).search TYPO = TYPO()
import re class Typo: def text_has_foobar( self, text ): return re.compile( r"""(?i)foobar""" ).search( text ) is not None
$ cat bla.py u = unicode( s = u.encode( print s $ python bla.py File "bla.py", line 1 SyntaxError: Non-ASCII character
import time millis = int(round(time.time() * 1000)) print millis
import time current_milli_time = lambda: int(round(time.time() * 1000))
from datetime import datetime dt = datetime.now() dt.microsecond
def TimestampMillisec64(): return int((datetime.datetime.utcnow() - datetime.datetime(1970, 1, 1)).total_seconds() * 1000)
import time as time_ def millis(): return int(round(time_.time() * 1000))
from datetime import datetime from datetime import timedelta start_time = datetime.now() def millis(): dt = datetime.now() - start_time ms = (dt.days * 24 * 60 * 60 + dt.seconds) * 1000 + dt.microseconds / 1000.0 return ms
import datetime def get_epochtime_ms(): return round(datetime.datetime.utcnow().timestamp() * 1000) import timeutil timeutil.get_epochtime_ms()
import os d = [os.path.join(d, o) for o in os.listdir(d) if os.path.isdir(os.path.join(d,o))]
from glob import glob glob("/path/to/directory/*/")
subfolders = [f.path for f in os.scandir(folder) if f.is_dir() ]
d= filter(lambda x: os.path.isdir(os.path.join(d, x)), os.listdir(d))
import os print("root prints out directories only from what you specified") print("dirs prints out sub-directories from root") print("files prints out all files from root and directories") print("*" * 20) for root, dirs, files in os.walk("/var/log"): print(root) print(dirs) print(files)
from pathlib import WindowsPath def SubDirPath (d): return [f for f in d.iterdir() if f.is_dir()] subdirs = SubDirPath(WindowsPath(r print(subdirs)
print("\nWe are listing out only the directories in current directory -") directories_in_curdir = filter(os.path.isdir, os.listdir(os.curdir)) print(directories_in_curdir)
files = filter(os.path.isfile, os.listdir(os.curdir)) print("\nThe following are the list of all files in the current directory -") print(files)
>>> import os >>> inf = os.walk( >>> [x[0] for x in inf] [
from pathlib import Path paths = list(Path( file = paths[0] file.name file.stem file.parent file.suffix
from pathlib import Path p = Path( [f for f in p.iterdir() if f.is_dir()] list(p.glob(
import os test_directory = <your_directory> for child in os.listdir(test_directory): test_path = os.path.join(test_directory, child) if os.path.isdir(test_path): print test_path
import os def get_subdirs(dir): "Get a list of immediate subdirectories" return next(os.walk(dir))[1] def get_subfiles(dir): "Get a list of immediate subfiles" return next(os.walk(dir))[2]
import os, pprint pprint.pprint([os.path.join(os.path.abspath(path), x[0]) \ for x in os.walk(os.path.abspath(path))])
def get_dirlist(rootdir): dirlist = [] with os.scandir(rootdir) as rit: for entry in rit: if not entry.name.startswith( dirlist.append(entry.path) dirlist.sort() return dirlist
def get_dirlist(rootdir): dirlist = [] with os.scandir(rootdir) as rit: for entry in rit: if not entry.name.startswith( dirlist.append(entry.path) dirlist += get_dirlist(entry.path) dirlist.sort() return dirlist
import os d= folders = list(filter(lambda x: os.path.isdir(os.path.join(d, x)), os.listdir(d)))
def flatten(x): result = [] for el in x: if hasattr(el, "__iter__") and not isinstance(el, basestring): result.extend(flatten(el)) else: result.append(el) return result flatten(L)
def flatten(l): for el in l: if isinstance(el, collections.Iterable) and not isinstance(el, basestring): for sub in flatten(el): yield sub else: yield el
def flatten(l): for el in l: if isinstance(el, collections.Iterable) and not isinstance(el, (str, bytes)): yield from flatten(el) else: yield el
def flatten(x): if isinstance(x, collections.Iterable): return [a for i in x for a in flatten(i)] else: return [x]
def genflat(l, ltypes=collections.Sequence): l = list(l) i = 0 while i < len(l): while isinstance(l[i], ltypes): if not l[i]: l.pop(i) i -= 1 break else: l[i:i + 1] = l[i] yield l[i] i += 1
def genflat(l, ltypes=collections.Sequence): l = list(l) while l: while l and isinstance(l[0], ltypes): l[0:1] = l[0] if l: yield l.pop(0)
def flatten(L): for item in L: try: yield from flatten(item) except TypeError: yield item list(flatten([[[1, 2, 3], [4, 5]], 6])) >>>[1, 2, 3, 4, 5, 6]
import itertools as IT import collections def flatten(iterable, ltypes=collections.Iterable): remainder = iter(iterable) while True: first = next(remainder) if isinstance(first, ltypes) and not isinstance(first, basestring): remainder = IT.chain(first, remainder) else: yield first
print(list(IT.islice(flatten(IT.repeat(1)),10))) print(list(IT.islice(flatten(IT.chain(IT.repeat(2,3), {10,20,30}, IT.repeat(1),)),10))) print(list(flatten([[1,2,[3,4]]]))) seq = ([[chr(i),chr(i-32)] for i in xrange(ord( print(list(flatten(seq)))
def infinitely_nested(): while True: yield IT.chain(infinitely_nested(), IT.repeat(1)) print(list(IT.islice(flatten(infinitely_nested()), 10)))
flatten = lambda *n: (e for a in n for e in (flatten(*a) if isinstance(a, (tuple, list)) else (a,)))
l1 = [ l2 = [0, 1, (2, 3), [[4, 5, (6, 7, (8,), [9]), 10]], (11,)] print list(flatten(l1, -2, -1, l2)) [
import re def Flatten(TheList): a = str(TheList) b,crap = re.subn(r c = b.split() d = [int(x) for x in c] return(d)
def flatten(xs): res = [] def loop(ys): for i in ys: if isinstance(i, list): loop(i) else: res.append(i) loop(xs) return res
def flatten(iterable): try: for item in iterable: yield from flatten(item) except TypeError: yield iterable
>>> L = [[[1, 2, 3], [4, 5]], 6] >>> def flatten(iterable): try: for item in iterable: yield from flatten(item) except TypeError: yield iterable >>> list(flatten(L)) [1, 2, 3, 4, 5, 6] >>>
def flatten(iterable): for item in iterable: try: yield from flatten(item) except TypeError: yield item
>>> L = [[[1, 2, 3], [4, 5]], 6] >>> list(flatten(L)) [1, 2, 3, 4, 5, 6] >>> list(flatten(123)) Traceback (most recent call last): File "<pyshell list(flatten(123)) File "<pyshell for item in iterable: TypeError: >>>
>>> from iteration_utilities import deepflatten >>> L = [[[1, 2, 3], [4, 5]], 6] >>> list(deepflatten(L)) [1, 2, 3, 4, 5, 6] >>> list(deepflatten(L, types=list)) [1, 2, 3, 4, 5, 6]
>>> %timeit list(deepflatten(L)) 12.6 µs ± 298 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) >>> %timeit list(deepflatten(L, types=list)) 8.7 µs ± 139 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) >>> %timeit list(flatten(L)) 86.4 µs ± 4.42 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) >>> %timeit list(flatten(L)) 107 µs ± 2.99 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) >>> %timeit list(genflat(L, list)) 23.1 µs ± 710 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
def flat(l): ret = [] for i in l: if isinstance(i, list) or isinstance(i, tuple): ret.extend(flat(i)) else: ret.append(i) return ret
def flatten(TheList): listIsNested = True while listIsNested: keepChecking = False Temp = [] for element in TheList: if isinstance(element,list): Temp.extend(element) keepChecking = True else: Temp.append(element) listIsNested = keepChecking TheList = Temp[:] return TheList
def flatten(seq): l = [] for elt in seq: t = type(elt) if t is tuple or t is list: for elt2 in flatten(elt): l.append(elt2) else: l.append(elt) return l
from copy import deepcopy def flatten_list(nested_list): """Flatten an arbitrarily nested list, without recursion (to avoid stack overflows). Returns a new list, the original list is unchanged. >> list(flatten_list([1, 2, 3, [4], [], [[[[[[[[[5]]]]]]]]]])) [1, 2, 3, 4, 5] >> list(flatten_list([[1, 2], 3])) [1, 2, 3] """ nested_list = deepcopy(nested_list) while nested_list: sublist = nested_list.pop(0) if isinstance(sublist, list): nested_list = sublist + nested_list else: yield sublist
def flatten(l): return flatten(l[0]) + (flatten(l[1:]) if len(l) > 1 else []) if type(l) is list else [l]
>>> flatten([1,[2,3],4]) [1, 2, 3, 4] >>> flatten([1, [2, 3], 4, [5, [6, { [1, 2, 3, 4, 5, 6, { >>>
def flatten_list(seq): if not seq: return [] elif isinstance(seq[0],list): return (flatten_list(seq[0])+flatten_list(seq[1:])) else: return [seq[0]]+flatten_list(seq[1:]) print(flatten_list([1,2,[3,[4],5],[6,7]]))
flat_list = ast.literal_eval("[%s]"%re.sub("[\[\]]","",str(the_list)))
from collections import Iterable from itertools import imap, repeat, chain def flat(seqs, ignore=(int, long, float, basestring)): return repeat(seqs, 1) if any(imap(isinstance, repeat(seqs), ignore)) or not isinstance(seqs, Iterable) else chain.from_iterable(imap(flat, seqs))
def flat(seqs, ignore={int, long, float, str, unicode}): return repeat(seqs, 1) if type(seqs) in ignore or not isinstance(seqs, Iterable) else chain.from_iterable(imap(flat, seqs))
import random def test_flat(test_size=2000): def increase_depth(value, depth=1): for func in xrange(depth): value = repeat(value, 1) return value def random_sub_chaining(nested_values): for values in nested_values: yield chain((values,), chain.from_iterable(imap(next, repeat(nested_values, random.randint(1, 10))))) expected_values = zip(xrange(test_size), imap(str, xrange(test_size))) nested_values = random_sub_chaining((increase_depth(value, depth) for depth, value in enumerate(expected_values))) assert not any(imap(cmp, chain.from_iterable(expected_values), flat(chain(((),), nested_values, ((),))))) >>> test_flat() >>> list(flat([[[1, 2, 3], [4, 5]], 6])) [1, 2, 3, 4, 5, 6] >>> $ uname -a Darwin Samys-MacBook-Pro.local 13.3.0 Darwin Kernel Version 13.3.0: Tue Jun 3 21:27:35 PDT 2014; root:xnu-2422.110.17~1/RELEASE_X86_64 x86_64 $ python --version Python 2.7.5
import itertools from collections import Iterable def list_flatten(lst): flat_lst = [] for item in itertools.chain(lst): if isinstance(item, Iterable): item = list_flatten(item) flat_lst.extend(item) else: flat_lst.append(item) return flat_lst
def flatten(q, final): if not q: return if isinstance(q, list): if not isinstance(q[0], list): final.append(q[0]) else: flatten(q[0], final) flatten(q[1:], final) else: final.append(q)
def combine_nlist(nlist,init=0,combiner=lambda x,y: x+y): apply function: combiner to a nested list element by element(treated as flatten list) current_value=init for each_item in nlist: if isinstance(each_item,list): current_value =combine_nlist(each_item,current_value,combiner) else: current_value = combiner(current_value,each_item) return current_value
def flatten_nlist(nlist): return combine_nlist(nlist,[],lambda x,y:x+[y])
In [379]: flatten_nlist([1,2,3,[4,5],[6],[[[7],8],9],10]) Out[379]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
import re L = [[[1, 2, 3], [4, 5]], 6] flattened_list = re.sub("[\[\]]", "", str(L)).replace(" ", "").split(",") new_list = list(map(int, flattened_list)) print(new_list)
import morph list = [[[1, 2, 3], [4, 5]], 6] flattened_list = morph.flatten(list)
l=[1,2,[3,4],5,[6,7,8]] x=[] for i in l: if type(i) is list: x.extend(i) else: x.append(i) print x
def flatten(lst): return eval( L = [[[1, 2, 3], [4, 5]], 6] print(flatten(L))
def flatten(item, keepcls=(), keepobj=()): if not hasattr(item, yield item else: for i in item: for j in flatten(i, keepcls, keepobj + (item,)): yield j
>>> list(flatten([1, 2, [...], 3])) [1, 2, [1, 2, [...], 3], 3]
>>> list(flatten([[[1, 2, 3], [4, 5]], 6])) [1, 2, 3, 4, 5, 6]
>>> list(flatten([[1,2],[1,[1,2]],[1,2]])) [1, 2, 1, 1, 2, 1, 2]
>>> list(flatten((x for x in [1,2, set([3,(4,5),6])]))) [1, 2, 4, 5, 3, 6]
def f(E): if E==[]: return [] elif type(E) != list: return [E] else: a = f(E[0]) b = f(E[1:]) a.extend(b) return a
def flatten(lst): if lst: car,*cdr=lst if isinstance(car,(list,tuple)): if cdr: return flatten(car) + flatten(cdr) return flatten(car) if cdr: return [car] + flatten(cdr) return [car]
>>> a = [1, 2, 3, 5, 10, [1, 25, 11, [1, 0]]] >>> g = str(a).replace( >>> b = [int(x) for x in g.split(
def flat(l): def _flat(l, r): if type(l) is not list: r.append(l) else: for i in l: r = r + flat(i) return r return _flat(l, []) test = [[1], [[2]], [3], [[ print flat(test)
def flattener(left, right): try: res = reduce(flattener, right, left) except TypeError: left.append(right) res = left return res def flatten(seq): return reduce(flattener, seq, []) >>> nested_list = [0, [1], [[[[2]]]], [3, [], [4, 5]], [6, [7, 8], 9, [[[]], 10, []]], 11, [], [], [12]] >>> flatten(nested_list) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
[image for image in menuitem for menuitem in list_of_menuitems]
reduce(list.__add__, map(lambda x: list(x), list_of_menuitems))
>>> reduce(list.__add__, (list(mi) for mi in list_of_menuitems))
>>> [image for mi in list_of_menuitems for image in mi]
>>> from itertools import chain >>> list(chain(*list_of_menuitems))
>>> chain = itertools.chain.from_iterable([[1,2],[3],[5,89],[],[6]]) >>> print(list(chain)) >>> [1, 2, 3, 5, 89, 6]
>>> list_of_menuitems = [[ >>> import itertools >>> chain = itertools.chain(*list_of_menuitems) >>> print(list(chain)) [
for inner_list in outer_list: for item in inner_list: ...
[... for inner_list in outer_list for item in inner_list]
[image for menuitem in list_of_menuitems for image in menuitem]
from __future__ import print_function import collections import itertools import operator from timeit import Timer import sys import matplotlib.pyplot as pyplot def itertools_flatten(iter_lst): return list(itertools.chain(*iter_lst)) def itertools_iterable_flatten(iter_iter): return list(itertools.chain.from_iterable(iter_iter)) def reduce_flatten(iter_lst): return reduce(operator.add, map(list, iter_lst)) def reduce_lambda_flatten(iter_lst): return reduce(operator.add, map(lambda x: list(x), [i for i in iter_lst])) def comprehension_flatten(iter_lst): return list(item for iter_ in iter_lst for item in iter_) METHODS = [ def _time_test_assert(iter_lst): callables = (globals()[method + results = [callable(iter_lst) for callable in callables] if not all(result == results[0] for result in results[1:]): raise AssertionError def time_test(partition_count, item_count_per_partition, test_count=10000): """Run flatten methods on a list of :param:`partition_count` iterables. Normalize results over :param:`test_count` runs. :return: Mapping from method to (normalized) microseconds per pass. """ iter_lst = [[dict()] * item_count_per_partition] * partition_count print( print( _time_test_assert(iter_lst) test_str = result_by_method = {} for method in METHODS: setup_str = t = Timer(test_str, setup_str) per_pass = test_count * t.timeit(number=test_count) / test_count print( result_by_method[method] = per_pass return result_by_method if __name__ == if len(sys.argv) != 2: raise ValueError( item_count = int(sys.argv[1]) partition_counts = [] pass_times_by_method = collections.defaultdict(list) for partition_count in xrange(1, item_count): if item_count % partition_count != 0: continue items_per_partition = item_count / partition_count result_by_method = time_test(partition_count, items_per_partition) partition_counts.append(partition_count) for method, result in result_by_method.iteritems(): pass_times_by_method[method].append(result) for method, pass_times in pass_times_by_method.iteritems(): pyplot.plot(partition_counts, pass_times, label=method) pyplot.legend() pyplot.title( pyplot.xlabel( pyplot.ylabel( pyplot.show()
def flatten(x): result = [] for el in x: if hasattr(el, "__iter__") and not isinstance(el, basestring): result.extend(flatten(el)) else: result.append(el) return result
>>> from itertools import chain >>> list(chain.from_iterable(mi.image_set.all() for mi in h.get_image_menu()))
import itertools def itertools_flatten( aList ): return list( itertools.chain(*aList) ) from operator import add def reduce_flatten1( aList ): return reduce(add, map(lambda x: list(x), [mi for mi in aList])) def reduce_flatten2( aList ): return reduce(list.__add__, map(list, aList)) def comprehension_flatten( aList ): return list(y for x in aList for y in x)
itertools_flatten 0.00554 comprehension_flatten 0.00815 reduce_flatten2 0.01103 reduce_flatten1 0.01404
>>> list2d = ((1,2,3),(4,5,6), (7,), (8,9)) >>> reduce(operator.concat, list2d) (1, 2, 3, 4, 5, 6, 7, 8, 9)
>>> list2d = [[1,2,3],[4,5,6], [7], [8,9]] >>> reduce(operator.concat, list2d) [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list2d = [[1,2,3],[4,5,6], [7], [8,9]] >>> %timeit list(itertools.chain.from_iterable(list2d)) 1000000 loops, best of 3: 1.36 µs per loop
>>> list2d = ((1,2,3),(4,5,6), (7,), (8,9)) >>> %timeit reduce(operator.concat, list2d) 1000000 loops, best of 3: 492 ns per loop
reduce(list.__add__, map(list, [mi.image_set.all() for mi in list_of_menuitems]))
reduce(list.__add__, [list(mi.image_set.all()) for mi in list_of_menuitems])
sum([list(mi.image_set.all()) for mi in list_of_menuitems], [])
>>> join = lambda it: (y for x in it for y in x) >>> list(join([[1,2],[3,4,5],[]])) [1, 2, 3, 4, 5]
[image for menuitem in list_of_menuitems for image in menuitem.image_set.all()]
join(menuitem.image_set.all() for menuitem in list_of_menuitems)
l=[[1,2,3],[4,5,6], [7], [8,9]]*33 run("list(flatten(l))") 3732 function calls (3303 primitive calls) in 0.007 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.007 0.007 <string>:1(<module>) 429 0.001 0.000 0.001 0.000 cbook.py:475(iterable) 429 0.002 0.000 0.003 0.000 cbook.py:484(is_string_like) 429 0.002 0.000 0.006 0.000 cbook.py:565(is_scalar_or_string) 727/298 0.001 0.000 0.007 0.000 cbook.py:605(flatten) 429 0.000 0.000 0.001 0.000 core.py:5641(isMaskedArray) 858 0.001 0.000 0.001 0.000 {isinstance} 429 0.000 0.000 0.000 0.000 {iter} 1 0.000 0.000 0.000 0.000 {method l=[[1,2,3],[4,5,6], [7], [8,9]]*66 run("list(flatten(l))") 7461 function calls (6603 primitive calls) in 0.007 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.007 0.007 <string>:1(<module>) 858 0.001 0.000 0.001 0.000 cbook.py:475(iterable) 858 0.002 0.000 0.003 0.000 cbook.py:484(is_string_like) 858 0.002 0.000 0.006 0.000 cbook.py:565(is_scalar_or_string) 1453/595 0.001 0.000 0.007 0.000 cbook.py:605(flatten) 858 0.000 0.000 0.001 0.000 core.py:5641(isMaskedArray) 1716 0.001 0.000 0.001 0.000 {isinstance} 858 0.000 0.000 0.000 0.000 {iter} 1 0.000 0.000 0.000 0.000 {method l=[[1,2,3],[4,5,6], [7], [8,9]]*99 run("list(flatten(l))") 11190 function calls (9903 primitive calls) in 0.010 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.010 0.010 <string>:1(<module>) 1287 0.002 0.000 0.002 0.000 cbook.py:475(iterable) 1287 0.003 0.000 0.004 0.000 cbook.py:484(is_string_like) 1287 0.002 0.000 0.009 0.000 cbook.py:565(is_scalar_or_string) 2179/892 0.001 0.000 0.010 0.000 cbook.py:605(flatten) 1287 0.001 0.000 0.001 0.000 core.py:5641(isMaskedArray) 2574 0.001 0.000 0.001 0.000 {isinstance} 1287 0.000 0.000 0.000 0.000 {iter} 1 0.000 0.000 0.000 0.000 {method l=[[1,2,3],[4,5,6], [7], [8,9]]*132 run("list(flatten(l))") 14919 function calls (13203 primitive calls) in 0.013 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.013 0.013 <string>:1(<module>) 1716 0.002 0.000 0.002 0.000 cbook.py:475(iterable) 1716 0.004 0.000 0.006 0.000 cbook.py:484(is_string_like) 1716 0.003 0.000 0.011 0.000 cbook.py:565(is_scalar_or_string) 2905/1189 0.002 0.000 0.013 0.000 cbook.py:605(flatten) 1716 0.001 0.000 0.001 0.000 core.py:5641(isMaskedArray) 3432 0.001 0.000 0.001 0.000 {isinstance} 1716 0.001 0.000 0.001 0.000 {iter} 1 0.000 0.000 0.000 0.000 {method
l=[[1,2,3],[4,5,6], [7], [8,9]]*33 run("flattenlist(l)") 564 function calls (432 primitive calls) in 0.000 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 133/1 0.000 0.000 0.000 0.000 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.000 0.000 0.000 0.000 <string>:1(<module>) 429 0.000 0.000 0.000 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method l=[[1,2,3],[4,5,6], [7], [8,9]]*66 run("flattenlist(l)") 1125 function calls (861 primitive calls) in 0.001 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 265/1 0.001 0.000 0.001 0.001 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.000 0.000 0.001 0.001 <string>:1(<module>) 858 0.000 0.000 0.000 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method l=[[1,2,3],[4,5,6], [7], [8,9]]*99 run("flattenlist(l)") 1686 function calls (1290 primitive calls) in 0.001 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 397/1 0.001 0.000 0.001 0.001 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.000 0.000 0.001 0.001 <string>:1(<module>) 1287 0.000 0.000 0.000 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method l=[[1,2,3],[4,5,6], [7], [8,9]]*132 run("flattenlist(l)") 2247 function calls (1719 primitive calls) in 0.002 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 529/1 0.001 0.000 0.002 0.002 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.000 0.000 0.002 0.002 <string>:1(<module>) 1716 0.001 0.000 0.001 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method l=[[1,2,3],[4,5,6], [7], [8,9]]*1320 run("flattenlist(l)") 22443 function calls (17163 primitive calls) in 0.016 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 5281/1 0.011 0.000 0.016 0.016 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.000 0.000 0.016 0.016 <string>:1(<module>) 17160 0.005 0.000 0.005 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method
l=[[1,2,3],[4,5,6], [7], [8,9]]*1320 new=[l]*33 run("flattenlist(new)") 740589 function calls (566316 primitive calls) in 0.418 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 174274/1 0.281 0.000 0.417 0.417 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.001 0.001 0.418 0.418 <string>:1(<module>) 566313 0.136 0.000 0.136 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method new=[l]*66 run("flattenlist(new)") 1481175 function calls (1132629 primitive calls) in 0.809 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 348547/1 0.542 0.000 0.807 0.807 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.002 0.002 0.809 0.809 <string>:1(<module>) 1132626 0.266 0.000 0.266 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method new=[l]*99 run("flattenlist(new)") 2221761 function calls (1698942 primitive calls) in 1.211 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 522820/1 0.815 0.000 1.208 1.208 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.002 0.002 1.211 1.211 <string>:1(<module>) 1698939 0.393 0.000 0.393 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method new=[l]*132 run("flattenlist(new)") 2962347 function calls (2265255 primitive calls) in 1.630 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 697093/1 1.091 0.000 1.627 1.627 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.003 0.003 1.630 1.630 <string>:1(<module>) 2265252 0.536 0.000 0.536 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method new=[l]*1320 run("flattenlist(new)") 29623443 function calls (22652523 primitive calls) in 16.103 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 6970921/1 10.842 0.000 16.069 16.069 <ipython-input-55-39b139bad497>:4(flattenlist) 1 0.034 0.034 16.103 16.103 <string>:1(<module>) 22652520 5.227 0.000 5.227 0.000 {isinstance} 1 0.000 0.000 0.000 0.000 {method
typ=(list,tuple) def flattenlist(d): thelist = [] for x in d: if not isinstance(x,typ): thelist += [x] else: thelist += flattenlist(x) return thelist
def list_or_tuple(l): return isinstance(l,(list,tuple)) def flatten(seq,predicate=list_or_tuple): for i in seq: if predicate(seq): for j in flatten(i): yield j else: yield i
list_of_list = [range(10)]*1000 %timeit flat_list=[]; map(flat_list.extend, list_of_list) %timeit flat_list=list(itertools.chain.from_iterable(list_of_list)) %timeit flat_list=[i for sublist in list_of_list for i in sublist] %timeit flat_list=reduce(list.__add__,list_of_list)
list_of_list = [range(1000)]*10 %timeit flat_list=[]; map(flat_list.extend, list_of_list) %timeit flat_list=list(itertools.chain.from_iterable(list_of_list))
class SquaredRange(object): def __init__(self, n): self.range = range(n) def __iter__(self): for i in self.range: yield i**2 list_of_list = [SquaredRange(5)]*3 flat_list = [] map(flat_list.extend, list_of_list) print flat_list
import collections def flatten(o, flatten_condition=lambda i: isinstance(i, collections.Iterable) and not isinstance(i, str)): result = [] for i in o: if flatten_condition(i): result.extend(flatten(i, flatten_condition)) else: result.append(i) return result
from operator import add reduce(add, map(lambda x: list(x.image_set.all()), [mi for mi in list_of_menuitems]))
a = [[1, 2, 3], [4, 5, 6] b = [i[x] for i in a for x in range(len(i))] print b
def flat_list(list_to_flat): if not isinstance(list_to_flat, list): yield list_to_flat else: for item in list_to_flat: yield from flat_list(item)
>>> a = [1, [2, 3], [1, [2, 3, [1, [2, 3]]]]] >>> print(list(flat_list(a))) [1, 2, 3, 1, 2, 3, 1, 2, 3]
def is_iterable(item): return isinstance(item, list) or isinstance(item, tuple) def flatten(items): for i in items: if is_iterable(item): for m in flatten(i): yield m else: yield i
>>> flattener = re.compile("\ >>> flattener <_sre.SRE_Pattern object at 0x10d439ca8> >>> stred = str(in_list) >>> outed = flattener.findall(stred)
import numpy as np print np.concatenate([[1,2],[3],[5,89],[],[6]]) print list(np.concatenate([[1,2],[3],[5,89],[],[6]]))
import morph list = [[1,2],[3],[5,89],[],[6]] flattened_list = morph.flatten(list)
>>> [ Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError:
a = [ try: b = except AttributeError: import string b = string.join(a,
>>> from operator import concat >>> a = [ >>> reduce(concat, a)
import io a = [ out = io.StringIO() out.writelines(a) print(out.getvalue())
g = [ f= for i in range(0,len(g)): f=f+g[i] print f
sh: mysql_config: command not found Traceback (most recent call last): File "setup.py", line 15, in <module> metadata, options = get_config() File "/usr/lib/python2.5/MySQL-python-1.2.3/setup_posix.py", line 43, in get_config libs = mysql_config("libs_r") File "/usr/lib/python2.5/MySQL-python-1.2.3/setup_posix.py", line 24, in mysql_config raise EnvironmentError("%s not found" % (mysql_config.path,)) EnvironmentError: mysql_config not found
... _mysql.c:29:20: error fatal: Python.h: No existe el archivo o el directorio compilación terminada. error: command
pip install mysql-python Installing collected packages: mysql-python Running setup.py install for mysql-python building gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -Dversion_info=(1,2,4, In file included from _mysql.c:44:0: /usr/include/mysql/my_config.h:422:0: aviso: se redefinió "HAVE_WCSCOLL" [activado por defecto] /usr/include/python2.7/pyconfig.h:890:0: nota: esta es la ubicación de la definición previa gcc -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions -Wl,-Bsymbolic-functions -Wl,-z,relro build/temp.linux-x86_64-2.7/_mysql.o -L/usr/lib/x86_64-linux-gnu -lmysqlclient_r -lpthread -lz -lm -lrt -ldl -o build/lib.linux-x86_64-2.7/_mysql.so Successfully installed mysql-python Cleaning up...
sudo yum install mysql-devel gcc gcc-devel python-devel sudo easy_install mysql-python
sudo PATH=/usr/local/mysql/bin/:$PATH pip install mysql-python
15 warnings generated. clang -bundle -undefined dynamic_lookup -Wl,-F. build/temp.macosx-10.8-intel-2.7/_mysql.o -L/usr/local/mysql/lib -lmysqlclient_r -lz -lm -lmygcc -o build/lib.macosx-10.8-intel-2.7/_mysql.so -arch x86_64 Successfully installed mysql-python Cleaning up...
sudo apt-get install libmysqlclient-dev sudo apt-get install python-dev sudo python setup.py install
sudo ln -s /usr/local/zend/mysql/bin/mysql_config /usr/sbin/
sudo ln -s /usr/local/mysql/bin/mysql_config /usr/sbin/
Error: The `brew link` step did not complete successfully
ln -s /usr/local/Cellar/mysql/<< VERSION >>/bin/mysql_config /usr/local/mysql/bin/mysql_config
gcc ... -I/usr/include/python2.7 ... _mysql.c:29:20: error: Python.h: No such file or directory
$ sudo apt-get install python-dev $ venv/bin/pip install MySQL-python
sudo apt-get update sudo apt-get -y upgrade sudo apt-get install -y python3-pip sudo apt-get install build-essential libssl-dev libffi-dev python3-dev
sudo apt-get install -y python3-venv pyvenv my_env source my_env/bin/activate
import sys, time stdout = sys.stdout BAILOUT = 16 MAX_ITERATIONS = 1000 class Iterator(object) : def __init__(self): print for y in xrange(-39, 39): stdout.write( for x in xrange(-39, 39): if self.mandelbrot(x/40.0, y/40.0) : stdout.write( else: stdout.write( def mandelbrot(self, x, y): cr = y - 0.5 ci = x zi = 0.0 zr = 0.0 for i in xrange(MAX_ITERATIONS) : temp = zr * zi zr2 = zr * zr zi2 = zi * zi zr = zr2 - zi2 + cr zi = temp + temp + ci if zi2 + zr2 > BAILOUT: return i return 0 t = time.time() Iterator() print
import time from sys import stdout BAILOUT = 16 MAX_ITERATIONS = 1000 def mandelbrot(dim_1, dim_2): cr1 = dim_1 - 0.5 ci1 = dim_2 zi1 = 0.0 zr1 = 0.0 for i in xrange(MAX_ITERATIONS) : temp = zr1 * zi1 zr2 = zr1 * zr1 zi2 = zi1 * zi1 zr1 = zr2 - zi2 + cr1 zi1 = temp + temp + ci1 if zi2 + zr2 > BAILOUT: return i return 0 def execute() : print for dim_1 in xrange(-39, 39): stdout.write( for dim_2 in xrange(-39, 39): if mandelbrot(dim_1/40.0, dim_2/40.0) : stdout.write( else: stdout.write( START_TIME = time.time() execute() print
./python_mandelbrot.py:4:11: E401 multiple imports on one line ./python_mandelbrot.py:10:1: E302 expected 2 blank lines, found 1 ./python_mandelbrot.py:10:23: E203 whitespace before ./python_mandelbrot.py:15:80: E501 line too long (108 characters) ./python_mandelbrot.py:23:1: W291 trailing whitespace ./python_mandelbrot.py:41:5: E301 expected 1 blank line, found 3
************* Module python_mandelbrot C: 15: Line too long (108/80) C: 61: Line too long (85/80) C: 1: Missing docstring C: 5: Invalid name "stdout" (should match (([A-Z_][A-Z0-9_]*)|(__.*__))$) C: 10:Iterator: Missing docstring C: 15:Iterator.__init__: Invalid name "y" (should match [a-z_][a-z0-9_]{2,30}$) C: 17:Iterator.__init__: Invalid name "x" (should match [a-z_][a-z0-9_]{2,30}$) [...] and a very long report with useful stats like : Duplication ----------- +-------------------------+------+---------+-----------+ | |now |previous |difference | +=========================+======+=========+===========+ |nb duplicated lines |0 |0 |= | +-------------------------+------+---------+-----------+ |percent duplicated lines |0.000 |0.000 |= | +-------------------------+------+---------+-----------+
class ExampleClass: def __init__(self, **kwargs): self.val = kwargs[ self.val2 = kwargs.get(
def __init__(self, val2="default value", **kwargs):
def f(**kwargs): foo = kwargs.pop( bar = kwargs.pop( ...etc...
def testFunc( **kwargs ): options = { options.update(kwargs) print options testFunc( option1= testFunc( option2=
class ExampleClass( object ): def __init__(self, **kwargs): self.val = kwargs.get( self.val2 = kwargs.get(
class ExampleClass( object ): def __init__(self, val="default1", val2="default2"): self.val = val self.val2 = val2
class ExampleClass( object ): def __init__(self, **kwargs): self.val = "default1" self.val2 = "default2" if "val" in kwargs: self.val = kwargs["val"] self.val2 = 2*self.val elif "val2" in kwargs: self.val2 = kwargs["val2"] self.val = self.val2 / 2 else: raise TypeError( "must provide val= or val2= parameter values" )
class Exampleclass(object): def __init__(self, **kwargs): for k in kwargs.keys(): if k in [acceptable_keys_list]: self.__setattr__(k, kwargs[k])
def my_func(arg1, arg2, arg3): ... so something ... kwargs = { my_func(**kwargs)
class ExampleClass: def __init__(self, **kwargs): arguments = { arguments.update(kwargs) self.val = arguments[ self.val2 = arguments[
class ExampleClass: def __init__(self, **kwargs): kwargs.setdefault( kwargs.setdefault(
class ExampleClass(object): __acceptable_keys_list = [ def __init__(self, **kwargs): [self.__setattr__(key, kwargs.get(key)) for key in self.__acceptable_keys_list]
def method(foo, bar=None, *args, **kwargs): do_something_with(foo, bar) some_other_function(*args, **kwargs)
unknown_args = user_args.keys() - default_args.keys() if unknown_args: raise TypeError( args.update(kwargs)
class ExampleClass(object): def __init__(self, x, y, **kwargs): self.x = x self.y = y self.attributes = kwargs def SomeFunction(self): if dosomething()
from xml.etree import ElementTree def indent(elem, level=0): i = "\n" + level*" " j = "\n" + (level-1)*" " if len(elem): if not elem.text or not elem.text.strip(): elem.text = i + " " if not elem.tail or not elem.tail.strip(): elem.tail = i for subelem in elem: indent(subelem, level+1) if not elem.tail or not elem.tail.strip(): elem.tail = j else: if level and (not elem.tail or not elem.tail.strip()): elem.tail = j return elem root = ElementTree.parse( indent(root) ElementTree.dump(root)
from lxml import etree def prettyPrintXml(xmlFilePathToPrettyPrint): assert xmlFilePathToPrettyPrint is not None parser = etree.XMLParser(resolve_entities=False, strip_cdata=False) document = etree.parse(xmlFilePathToPrettyPrint, parser) document.write(xmlFilePathToPrettyPrint, pretty_print=True, encoding=
@staticmethod def union(*sets): union = OrderedSet() union.union(*sets) return union def union(self, *sets): for set in sets: self |= set
import collections class OrderedSet(collections.OrderedDict, collections.MutableSet): def update(self, *args, **kwargs): if kwargs: raise TypeError("update() takes no keyword arguments") for s in args: for e in s: self.add(e) def add(self, elem): self[elem] = None def discard(self, elem): self.pop(elem, None) def __le__(self, other): return all(e in other for e in self) def __lt__(self, other): return self <= other and self != other def __ge__(self, other): return all(e in self for e in other) def __gt__(self, other): return self >= other and self != other def __repr__(self): return def __str__(self): return difference = property(lambda self: self.__sub__) difference_update = property(lambda self: self.__isub__) intersection = property(lambda self: self.__and__) intersection_update = property(lambda self: self.__iand__) issubset = property(lambda self: self.__le__) issuperset = property(lambda self: self.__ge__) symmetric_difference = property(lambda self: self.__xor__) symmetric_difference_update = property(lambda self: self.__ixor__) union = property(lambda self: self.__or__)
>>> from boltons.setutils import IndexedSet >>> x = IndexedSet(list(range(4)) + list(range(8))) >>> x IndexedSet([0, 1, 2, 3, 4, 5, 6, 7]) >>> x - set(range(2)) IndexedSet([2, 3, 4, 5, 6, 7]) >>> x[-1] 7 >>> fcr = IndexedSet( >>>
from sortedcontainers import SortedSet help(SortedSet)
>>> from collections_extended import setlist >>> sl = setlist( >>> sl setlist(( >>> sl[3] >>> sl[-1] >>> True >>> sl.index( 4 >>> sl.insert(1, ValueError >>> sl.index( 4
>>> keywords = [ >>> from collections import OrderedDict >>> list(OrderedDict.fromkeys(keywords).keys()) [
>>> s = set([0, 1, 2, 99, 4, 40, 3, 20, 24, 100, 60]) >>> sorted(s) [0, 1, 2, 3, 4, 20, 24, 40, 60, 99, 100]
if(not new_element in my_list): my_list.append(new_element)
import os, errno def silentremove(filename): try: os.remove(filename) except OSError as e: if e.errno != errno.ENOENT: raise
import contextlib with contextlib.suppress(FileNotFoundError): os.remove(filename)
from glob import glob import os for filename in glob("*.csv"): os.remove(filename)
os.path.exists("gogogo.php") and os.remove("gogogo.php")
import os from contextlib import suppress with suppress(OSError): os.remove(filename)
def remove_if_exists(filename): if os.path.exists(filename): os.remove(filename)
if os.path.isfile(os.path.join(path, filename)): os.remove(os.path.join(path, filename))
rm --help | grep "force" -f, --force ignore nonexistent files and arguments, never prompt
import os, subprocess fileToRemove = if os.path.isfile(fileToRemove): subprocess.run([ subprocess.run([
C:\Users\AppData\Local\Programs\Python\Python36 C:\Users\AppData\Local\Programs\Python\Python36\Scripts
C:\Users\YOURNAME>python Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] on win32 Type "help", "copyright", "credits" or "license" for more information.
(tensorflow)$ export TF_BINARY_URL=https: (tensorflow)$ export TF_BINARY_URL=https: (tensorflow)$ export TF_BINARY_URL=https: (tensorflow)$ export TF_BINARY_URL=https: (tensorflow)$ export TF_BINARY_URL=https: (tensorflow)$ export TF_BINARY_URL=https: (tensorflow)$ export TF_BINARY_URL=https: (tensorflow)$ export TF_BINARY_URL=https: (tensorflow)$ export TF_BINARY_URL=https:
(tensorflow)$ pip install --upgrade $TF_BINARY_URL (tensorflow)$ pip3 install --upgrade $TF_BINARY_URL
Collecting pip Using cached pip-9.0.1-py2.py3-none-any.whl Installing collected packages: pip Found existing installation: pip 7.1.2 Uninstalling pip-7.1.2: Successfully uninstalled pip-7.1.2 Successfully installed pip-9.0.1
export TF_BINARY_URL=https: pip3 install --upgrade $TF_BINARY_URL
cp tensorflow-1.11.0-cp36-cp36m-linux_x86_64.whl tensorflow-1.11.0-cp37-cp37m-linux_x86_64.whl pip install tensorflow-1.11.0-cp37-cp37m-linux_x86_64.whl
Microsoft Windows [Version 10.0.16299.371] (c) 2017 Microsoft Corporation. All rights reserved. C:\>python3 -m pip install --upgrade pip Requirement already up-to-date: pip in d:\python\v3\lib\site-packages (10.0.0) C:\>python3 -m pip -V pip 10.0.0 from D:\Python\V3\lib\site-packages\pip (python 3.6) C:\>python3 -m pip install --upgrade tensorflow Collecting tensorflow Could not find a version that satisfies the requirement tensorflow (from versions: ) No matching distribution found for tensorflow
Microsoft Windows [Version 10.0.16299.371] (c) 2017 Microsoft Corporation. All rights reserved. C:\>python3 -m pip install --upgrade pip Requirement already up-to-date: pip in d:\python\v3\lib\site-packages (10.0.0) C:\>python3 -m pip -V pip 10.0.0 from D:\Python\V3_5\lib\site-packages\pip (python 3.5.2) C:\>python3 -m pip install --upgrade tensorflow Collecting tensorflow Downloading .... ....
Collecting tensorflow Could not find a version that satisfies the requirement tensorflow (from versions: ) No matching distribution found for tensorflow
brew uninstall python3 brew install python3 python3 --version pip install tensorflow pip install jupyter ipython notebook
C:\> pip3 install --upgrade tensorflow To install the GPU version of TensorFlow, enter the following command: C:\> pip3 install --upgrade tensorflow-gpu
midlen = len(oldstr)/2 newstr = oldstr[:midlen] + oldstr[midlen+1:]
original = "EXAMPLE" removed = original.replace("M", "")
s = "this is a string" l = list(s) l[1] = "" l[1:2] = [] del(l[1]) p = l.index("a") del(l[p]) s = "".join(l)
card = random.choice(cards) cardsLeft = cards.replace(card,
import UserString s = UserString.MutableString("EXAMPLE") >>> type(s) <type del s[3] s = str(s)
def kill_char(string, n): begin = string[:n] end = string[n+1:] return begin + end print kill_char("EXAMPLE", 3)
import requests udid = 123456 url = s = requests.Session() s.verify = False resp = s.get(url, stream=True) content = resp.content
for line in resp.iter_lines(): line = line.replace("[", "") line = line.replace("]", "") line = line.replace(
print listofvalues[0] print listofvalues[1] print listofvalues[2]
from random import randint def shuffle_word(word): newWord="" for i in range(0,len(word)): pos=randint(0,len(word)-1) newWord += word[pos] word = word[:pos]+word[pos+1:] return newWord word = "Sarajevo" print(shuffle_word(word))
main_string = main_string.replace(sub_str, replace_with, 1)
>>> a = { "a" : 1, "b" : 2 } >>> b = { "c" : 3, "d" : 4 } >>> a { >>> b {
def extend(a,b): """Create a new dictionary with a without overwriting. >>> extend({ { """ return dict(b,**a)
>>> import datetime >>> str(datetime.timedelta(seconds=666))
m, s = divmod(seconds, 60) h, m = divmod(m, 60) print "%d:%02d:%02d" % (h, m, s)
>>> import time >>> time.strftime("%H:%M:%S", time.gmtime(666))
>>> import datetime >>> "{:0>8}".format(datetime.timedelta(seconds=66)) >>> "{:0>8}".format(str(datetime.timedelta(seconds=66))) >>>
>>> "{:0>8}".format(datetime.timedelta(seconds=666777)) >>> "{:0>8}".format(str(datetime.timedelta(seconds=666777))) >>>
>>> "{}".format(datetime.timedelta(seconds=66)) >>>
>>> import time >>> time.strftime("%H:%M:%S", time.gmtime(666777)) >>>
>>> "{:0>8}".format(datetime.timedelta(seconds=620000)) >>> "{:0>8}".format(str(datetime.timedelta(seconds=620000))) >>>
import humanfriendly humanfriendly.format_timespan(secondsPassed)
my_time = (datetime(1970,1,1) + timedelta(seconds=my_seconds)).time()
my_time = (datetime.fromordinal(1) + timedelta(seconds=my_seconds)).time()
def sec2time(sec, n_msec=3): if hasattr(sec, return [sec2time(s) for s in sec] m, s = divmod(sec, 60) h, m = divmod(m, 60) d, h = divmod(h, 24) if n_msec > 0: pattern = else: pattern = r if d == 0: return pattern % (h, m, s) return (
$ sec2time(10, 3) Out: $ sec2time(1234567.8910, 0) Out: $ sec2time(1234567.8910, 4) Out: $ sec2time([12, 345678.9], 3) Out: [
from selenium import webdriver wd = webdriver.Firefox()
WebElement element = driver.findElement(By.id("foo")); String contents = (String)((JavascriptExecutor)driver).executeScript("return arguments[0].innerHTML;", element);
elem = driver.find_element_by_xpath(" source_code = elem.get_attribute("outerHTML")
elem = wd.find_element_by_css_selector( html = wd.execute_script("return arguments[0].innerHTML;", elem)
innerHTML = sel.get_eval("window.document.getElementById(
driver.get("http: body_html = driver.find_element_by_xpath("/html/body") print body_html.text
WebElement element = driver.findElement(By.id("foo")); String contents = (String)((JavascriptExecutor)driver).executeScript("return arguments[0].innerHTML;", element);
def getSize(fileobject): fileobject.seek(0,2) size = fileobject.tell() return size file = open( print getSize(file)
import os def getSize(filename): st = os.stat(filename) return st.st_size
E:\FinReporter\FM_EXT.py:449: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_index,col_indexer] = value instead quote_df[
def _decode_stock_quote(list_of_150_stk_str): from cStringIO import StringIO str_of_all = "".join(list_of_150_stk_str) quote_df = pd.read_csv(StringIO(str_of_all), sep= quote_df.rename(columns={ quote_df = quote_df.ix[:,[0,3,2,1,4,5,8,9,30,31]] quote_df[ quote_df[ quote_df[ quote_df[ quote_df[ quote_df[ quote_df[ return quote_df
E:\FinReporter\FM_EXT.py:449: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_index,col_indexer] = value instead quote_df[ E:\FinReporter\FM_EXT.py:450: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_index,col_indexer] = value instead quote_df[ E:\FinReporter\FM_EXT.py:453: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_index,col_indexer] = value instead quote_df[
In [1]: df = DataFrame(np.random.randn(5, 2), columns=list( In [2]: dfa = df.ix[:, [1, 0]] In [3]: dfa.is_copy Out[3]: True In [4]: dfa[ /usr/local/bin/ipython:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_index,col_indexer] = value instead
df = pd.DataFrame({"a": [1,2,3,4], "b": [1,1,2,2]})
quote_df = pd.read_csv(StringIO(str_of_all), sep= quote_df.rename(columns={ quote_df = quote_df.ix[:,[0,3,2,1,4,5,8,9,30,31]]
columns = [ df = pd.read_csv(StringIO(str_of_all), sep= df.columns = columns
np.random.seed(0) df = pd.DataFrame(np.random.choice(10, (3, 5)), columns=list( df A B C D E 0 5 0 3 3 7 1 9 3 5 2 4 2 7 6 8 8 1
df[df.A > 5][ df.__getitem__(df.A > 5).__setitem__(
df2 = df[[ df2[ /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/IPython/__main__.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead df2 A 0 2.5 1 4.5 2 3.5
class ChainedAssignent: def __init__(self, chained=None): acceptable = [ None, assert chained in acceptable, "chained must be in " + str(acceptable) self.swcw = chained def __enter__( self ): self.saved_swcw = pd.options.mode.chained_assignment pd.options.mode.chained_assignment = self.swcw return self def __exit__(self, *args): pd.options.mode.chained_assignment = self.saved_swcw
with ChainedAssignent(chained= df2[ SettingWithCopyError: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead
A B C D E 0 5 0 3 3 7 1 1000 3 5 2 4 2 1000 6 8 8 1
df.A[df.A > 5] = 1000 df[df.A > 5][ df.loc[df.A 5][
df.loc[1, df.iloc[1, 3] = 12345 df.at[1, df.iat[1, 3] = 12345
/opt/anaconda3/lib/python3.6/site-packages/ipykernel/__main__.py:54: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http:
>> data1 = { >> df1 = pd.DataFrame(data1) >> df1 A B 0 111 121 1 112 122 2 113 123 >> df2 = df1 >> df2 A B 0 111 121 1 112 122 2 113 123 >> df1.drop( >> df2 B 0 121 1 122 2 123
>> data1 = { >> df1 = pd.DataFrame(data1) >> df1 A B 0 111 121 1 112 122 2 113 123 >> import copy >> df2 = copy.deepcopy(df1) >> df2 A B 0 111 121 1 112 122 2 113 123 >> df1.drop( >> df2 A B 0 111 121 1 112 122 2 113 123
>> data1 = { >> df1 = pd.DataFrame(data1) >> df1 A B 0 111 121 1 112 122 2 113 123 >> df2 = df1 >> df2 A B 0 111 121 1 112 122 2 113 123 >> df2.drop( >> df1 B 0 121 1 122 2 123
>> data1 = { >> df1 = pd.DataFrame(data1) >> df1 A B 0 111 121 1 112 122 2 113 123 >> import copy >> df2 = copy.deepcopy(df1) >> df2 A B 0 111 121 1 112 122 2 113 123 >> df2.drop( >> df1 A B 0 111 121 1 112 122 2 113 123
return ( pd.read_csv(StringIO(str_of_all), sep= .rename(columns={ .ix[:,[0,3,2,1,4,5,8,9,30,31]] .assign( TClose=lambda df: df[ RT=lambda df: 100 * (df[ TVol=lambda df: df[ TAmt=lambda df: df[ STK_ID=lambda df: df[ STK_Name=lambda df: df[ TDate=lambda df: df.TDate.map(lambda x: x[0:4]+x[5:7]+x[8:10]), ) )
def update_old_dataframe(old_dataframe, new_dataframe): for new_index, new_row in new_dataframe.iterrorws(): old_dataframe.loc[new_index] = update_row(old_dataframe.loc[new_index], new_row) def update_row(old_row, new_row): for field in [list_of_columns]: old_row[field] = new_row[field] return old_row
(x*2 for x in range(256)) [x*2 for x in range(256)]
def gen(): return (something for something in get_some_stuff()) print gen()[:2] print [5,6] + gen()
logfile = open("hugefile.txt","r") entry_lines = [(line,len(line)) for line in logfile if line.startswith("ENTRY")]
logfile = open("hugefile.txt","r") entry_lines = ((line,len(line)) for line in logfile if line.startswith("ENTRY"))
long_entries = ((line,length) for (line,length) in entry_lines if length > 80)
outfile = open("filtered.txt","a") for entry,length in long_entries: outfile.write(entry)
sum(x*2 for x in xrange(256)) dict( ((k, some_func(k) for k in some_list_of_keys) )
>>> mylist = ["a", "b", "c"] >>> gen = (elem + "1" for elem in mylist) >>> mylist.clear() >>> for x in gen: print (x)
import mincemeat def mapfn(k,v): for w in v: yield def reducefn(k,v): r1=sum(v) r2=len(v) print r2 m=r1/r2 std=0 for i in range(r2): std+=pow(abs(v[i]-m),2) res=pow((std/r2),0.5) return r1,r2,res
s1 = list(); for i in range(0,9): s1[i] = i print s1
>>> l = [None] * 10 >>> l [None, None, None, None, None, None, None, None, None, None]
>>> l[1] = 5 >>> l [None, 5, None, None, None, None, None, None, None, None]
>>> l = range(10) >>> l [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> def display(): ... s1 = [] ... for i in range(9): ... s1.append(i) ... return s1 ... >>> print display() [0, 1, 2, 3, 4, 5, 6, 7, 8]
>>> def display(): ... return [x**2 for x in range(9)] ... >>> print display() [0, 1, 4, 9, 16, 25, 36, 49, 64]
>>> l = [None] * 10 >>> l [None, None, None, None, None, None, None, None, None, None]
>>> a = [[]]*10 >>> a [[], [], [], [], [], [], [], [], [], []] >>> a[0].append(0) >>> a [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0]] >>>
def init_list_of_objects(size): list_of_objects = list() for i in range(0,size): list_of_objects.append( list() ) return list_of_objects >>> a = init_list_of_objects(10) >>> a [[], [], [], [], [], [], [], [], [], []] >>> a[0].append(0) >>> a [[0], [], [], [], [], [], [], [], [], []] >>>
>>> [ [random.random() for _ in range(2) ] for _ in range(5)] >>> [[0.7528051908943816, 0.4325669600055032], [0.510983236521753, 0.7789949902294716], [0.09475179523690558, 0.30216475640534635], [0.3996890132468158, 0.6374322093017013], [0.3374204010027543, 0.4514925173253973]]
x = length_of_your_list a = [None]*x a = [None for _ in xrange(x)]
>>> from timeit import timeit >>> timeit("[None]*100",number=10000) 0.023542165756225586 >>> timeit("[None for _ in xrange(100)]",number=10000) 0.07616496086120605
>>> timeit("range(100)",number=10000) 0.012513160705566406
def display(): s1 = list(); for i in range(0, 9): s1[i] = i return s1
def create_list(): result = list() for i in range(10): result[i] = i return result
empty = [] row = int(input()) for i in range(row): temp = list(map(int, input().split())) empty.append(temp) for i in empty: for j in i: print(j, end= print(
nd_array = [] for i in range(30): nd_array.append(np.zeros(shape = (32,1))) new_array = [] for i in range(len(lines)): new_array.append(nd_array) new_array = np.asarray(new_array) for i in range(len(lines)): splits = lines[i].split( for j in range(len(splits)): new_array[i,j] = final_embeddings[dictionary[str(splits[j])]-1].reshape(32,1)
import random numrand=[] for i in range(0,10): a = random.randint(1,50) numrand.append(a) print(a,i) print(numrand)
def createEmptyList(length,fill=None): return a (empty) list of a given length Example: print createEmptyList(3,-1) >> [-1, -1, -1] print createEmptyList(4) >> [None, None, None, None] return [fill] * length
class NoneDict(dict): def __getitem__(self, key): return dict.get(self, key) >>> foo = NoneDict([(1,"asdf"), (2,"qwerty")]) >>> foo[1] >>> foo[2] >>> foo[3] is None True
from collections import defaultdict d = defaultdict(lambda: None) print d[
try: <to do something with d[key]> except KeyError: <deal with it not being there>
class MyDict(dict): def __missing__(self, key): return None
a = numpy.array((xa ,ya, za)) b = numpy.array((xb, yb, zb))
from scipy.spatial import distance a = (1, 2, 3) b = (4, 5, 6) dst = distance.euclidean(a, b)
import matplotlib import numpy import perfplot from scipy.spatial import distance def linalg_norm(data): a, b = data return numpy.linalg.norm(a-b, axis=1) def sqrt_sum(data): a, b = data return numpy.sqrt(numpy.sum((a-b)**2, axis=1)) def scipy_distance(data): a, b = data return list(map(distance.euclidean, a, b)) def mpl_dist(data): a, b = data return list(map(matplotlib.mlab.dist, a, b)) def sqrt_einsum(data): a, b = data a_min_b = a - b return numpy.sqrt(numpy.einsum( perfplot.show( setup=lambda n: numpy.random.rand(2, n, 3), n_range=[2**k for k in range(20)], kernels=[linalg_norm, scipy_distance, mpl_dist, sqrt_sum, sqrt_einsum], logx=True, logy=True, xlabel= )
def dist(x,y): return numpy.sqrt(numpy.sum((x-y)**2)) a = numpy.array((xa,ya,za)) b = numpy.array((xb,yb,zb)) dist_a_b = dist(a,b)
sP = set(points) pA = point distances = np.linalg.norm(sP - pA, ord=2, axis=1.)
def distance(pointA, pointB): dist = np.linalg.norm(pointA - pointB) return dist
>>> dis.dis(distance) 2 0 LOAD_GLOBAL 0 (np) 2 LOAD_ATTR 1 (linalg) 4 LOAD_ATTR 2 (norm) 6 LOAD_FAST 0 (pointA) 8 LOAD_FAST 1 (pointB) 10 BINARY_SUBTRACT 12 CALL_FUNCTION 1 14 STORE_FAST 2 (dist) 3 16 LOAD_FAST 2 (dist) 18 RETURN_VALUE
def distance(pointA, pointB, _norm=np.linalg.norm): return _norm(pointA - pointB)
>>> dis.dis(distance) 2 0 LOAD_FAST 2 (_norm) 2 LOAD_FAST 0 (pointA) 4 LOAD_FAST 1 (pointB) 6 BINARY_SUBTRACT 8 CALL_FUNCTION 1 10 RETURN_VALUE
def distance(pointA, pointB): return ( ((pointA.x - pointB.x) ** 2) + ((pointA.y - pointB.y) ** 2) + ((pointA.z - pointB.z) ** 2) ) ** 0.5
print("The target is %.2fm away" % (distance(a, b)))
def sort_things_by_distance(origin, things): return things.sort(key=lambda thing: distance(origin, thing)) def in_range(origin, range, things): things_in_range = [] for thing in things: if distance(origin, thing) <= range: things_in_range.append(thing)
dist = root ( x^2 + y^2 + z^2 ) :. dist^2 = x^2 + y^2 + z^2 and sq(N) < sq(M) iff M > N and sq(N) > sq(M) iff N > M and sq(N) = sq(M) iff N == M
def distance_sq(left, right): return ( ((left.x - right.x) ** 2) + ((left.y - right.y) ** 2) + ((left.z - right.z) ** 2) ) def sort_things_by_distance(origin, things): return things.sort(key=lambda thing: distance_sq(origin, thing)) def in_range(origin, range, things): things_in_range = [] range_sq = range**2 for thing in things: if distance_sq(origin, thing) <= range_sq: things_in_range.append(thing)
def in_range(origin, range, things): range_sq = range**2 yield from (thing for thing in things if distance_sq(origin, thing) <= range_sq)
for nearby in in_range(origin, walking_distance, hotdog_stands): print("%s %.2fm" % (nearby.name, distance(origin, nearby)))
def in_range_with_dist_sq(origin, range, things): range_sq = range**2 for thing in things: dist_sq = distance_sq(origin, thing) if dist_sq <= range_sq: yield (thing, dist_sq)
def in_range_all_the_things(origin, range, things): range_sq = range**2 for thing in things: dist_sq = (origin.x - thing.x) ** 2 if dist_sq <= range_sq: dist_sq += (origin.y - thing.y) ** 2 if dist_sq <= range_sq: dist_sq += (origin.z - thing.z) ** 2 if dist_sq <= range_sq: yield thing
def in_range_all_the_things(origin, range, things): range_sq = range**2 if len(things) >= 4096: for thing in things: dist_sq = (origin.x - thing.x) ** 2 if dist_sq <= range_sq: dist_sq += (origin.y - thing.y) ** 2 if dist_sq <= range_sq: dist_sq += (origin.z - thing.z) ** 2 if dist_sq <= range_sq: yield thing elif len(things) > 32: for things in things: dist_sq = (origin.x - thing.x) ** 2 if dist_sq <= range_sq: dist_sq += (origin.y - thing.y) ** 2 + (origin.z - thing.z) ** 2 if dist_sq <= range_sq: yield thing else: ... just calculate distance and range-check it ...
info = in_range_with_dist_sq(origin, walking_distance, hotdog_stands) info = (stand, dist_sq**0.5 for stand, dist_sq in info) for stand, dist in info: print("%s %.2fm" % (stand, dist))
import numpy as np import matplotlib as plt a = np.array([1, 2, 3]) b = np.array([2, 3, 4]) dis = plt.mlab.dist(a, b)
from math import sqrt a = (1, 2, 3) b = (4, 5, 6) print sqrt(sum( (a - b)**2 for a, b in zip(a, b)))
import math import numpy from random import uniform def fastest_calc_dist(p1,p2): return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2 + (p2[2] - p1[2]) ** 2) def math_calc_dist(p1,p2): return math.sqrt(math.pow((p2[0] - p1[0]), 2) + math.pow((p2[1] - p1[1]), 2) + math.pow((p2[2] - p1[2]), 2)) def numpy_calc_dist(p1,p2): return numpy.linalg.norm(numpy.array(p1)-numpy.array(p2)) TOTAL_LOCATIONS = 1000 p1 = dict() p2 = dict() for i in range(0, TOTAL_LOCATIONS): p1[i] = (uniform(0,1000),uniform(0,1000),uniform(0,1000)) p2[i] = (uniform(0,1000),uniform(0,1000),uniform(0,1000)) total_dist = 0 for i in range(0, TOTAL_LOCATIONS): for j in range(0, TOTAL_LOCATIONS): dist = fastest_calc_dist(p1[i], p2[j]) total_dist += dist print total_dist
a = numpy.array((xa, ya, za)) b = numpy.array((xb, yb, zb)) tmp = a - b sum_squared = numpy.dot(tmp.T, tmp) result sqrt(sum_squared)
a = numpy.array((xa,ya,za)) b = numpy.array((xb,yb,zb)) distance = (np.dot(a-b,a-b))**.5
def distance(v1,v2): return sum([(x-y)**2 for (x,y) in zip(v1,v2)])**(0.5)
import numpy as np from scipy.spatial import distance input_arr = np.array([[0,3,0],[2,0,0],[0,1,3],[0,1,2],[-1,0,1],[1,1,1]]) test_case = np.array([0,0,0]) dst=[] for i in range(0,6): temp = distance.euclidean(test_case,input_arr[i]) dst.append(temp) print(dst)
import math x = [1, 2, 6] y = [-2, 3, 2] dist = math.sqrt(sum([(xi-yi)**2 for xi,yi in zip(x, y)])) 5.0990195135927845
import math dist = math.hypot(math.hypot(xa-xb, ya-yb), za-zb)
def findEuclideanDistance(a, b): euclidean_distance = a - b euclidean_distance = np.sum(np.multiply(euclidean_distance, euclidean_distance)) euclidean_distance = np.sqrt(euclidean_distance) return euclidean_distance
from python import math dist((1, 2, 6), (-2, 3, 2))
$ python -m pip install fish $ .env/bin/python -m pip install fish $ python-3.6 -m pip install fish
$ pip-2.5 install myfoopackage $ pip-2.6 install otherpackage $ pip-2.7 install mybarpackage
$ pip2.6 install otherpackage $ pip2.7 install mybarpackage
pip2.7 install mysql-connector-python --allow-external mysql-connector-python
$ sudo easy_install-2.7 pip Searching for pip Best match: pip 1.1 Adding pip 1.1 to easy-install.pth file Installing pip-2.7 script to /usr/local/bin Using /usr/lib/python2.7/dist-packages Processing dependencies for pip Finished processing dependencies for pip $ sudo pip-2.7 install django Downloading/unpacking django Downloading Django-1.5.1.tar.gz (8.0Mb): 8.0Mb downloaded Running setup.py egg_info for package django warning: no previously-included files matching warning: no previously-included files matching Installing collected packages: django Running setup.py install for django changing mode of build/scripts-2.7/django-admin.py from 644 to 755 warning: no previously-included files matching warning: no previously-included files matching changing mode of /usr/local/bin/django-admin.py to 755 Successfully installed django Cleaning up... $ python Python 2.7.3 (default, Sep 26 2012, 21:51:14) [GCC 4.7.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> import django >>>
python2 -m pip install SomePackage python2.7 -m pip install SomePackage python3 -m pip install SomePackage python3.4 -m pip install SomePackage python3.5 -m pip install SomePackage python3.6 -m pip install SomePackage
py -2 -m pip install SomePackage py -2.7 -m pip install SomePackage py -3 -m pip install SomePackage py -3.4 -m pip install SomePackage
python2.7 -m pip install SomePackage python3.4 -m pip install SomePackage
py -2.7 -m pip install SomePackage py -3.4 -m pip install SomePackage
$HOME/ python_versions/ : download Python-*.tgz packages here and "tar xvf" them. You Python-3.4.8/ Python-3.6.5/ Python-3.x.y/ ...
mkdir root ./configure --prefix=$PWD/root make -j 2 make install virtualenv --no-site-packages -p root/bin/python3.x env
env_python3x.bash: echo "type deactivate to exit" source $HOME/python_versions/Python-3.x.y/env/bin/activate
import re import sys from pip._internal import main if __name__ == sys.argv[0] = re.sub(r sys.exit(main())
import time from entity import Ent from vector import Vect
from vector import Vect from physics import Physics class Ent: def tick(self, dt):
Traceback (most recent call last): File "main.py", line 2, in <module> from entity import Ent File ".../entity.py", line 5, in <module> from physics import Physics File ".../physics.py", line 2, in <module> from entity import Ent ImportError: cannot import name Ent
import SomeModule def someFunction(arg): from some.dependency import DependentClass
import x class cls: def __init__(self): self.y = x.y
from test.a import a1 def b1(): print( a1() def b2(): print( if __name__ == b1()
while True: while True: ok = get_input("Is this ok? (y/n)") if ok == "y" or ok == "Y": break 2 if ok == "n" or ok == "N": break
for a in xrange(10): for b in xrange(20): if something(a, b): break else: continue break
class GetOutOfLoop( Exception ): pass try: done= False while not done: isok= False while not (done or isok): ok = get_input("Is this ok? (y/n)") if ok in ("y", "Y") or ok in ("n", "N") : done= True raise GetOutOfLoop except GetOutOfLoop: pass
from contextlib import contextmanager @contextmanager def nested_break(): class NestedBreakException(Exception): pass try: yield NestedBreakException except NestedBreakException: pass
with nested_break() as mylabel: while True: print "current state" while True: ok = raw_input("Is this ok? (y/n)") if ok == "y" or ok == "Y": raise mylabel if ok == "n" or ok == "N": break print "more processing"
from goto import goto, label while True: while True: ok = get_input("Is this ok? (y/n)") if ok == "y" or ok == "Y": goto .breakall if ok == "n" or ok == "N": break label .breakall
breaker = False while True: while True: if conditionMet: breaker = True break if breaker: break
keeplooping=True while keeplooping: while keeplooping: if finisheddoingstuff(): keeplooping=False
def loop(): while True: while True: ok = get_input("Is this ok? (y/n)") if ok == "y" or ok == "Y": return if ok == "n" or ok == "N": break
try: for outer in range(100): for inner in range(100): if break_early(): raise StopIteration except StopIteration: pass
def it(rows, cols, images): i = 0 for r in xrange(rows): for c in xrange(cols): if i >= len(images): return yield r, c, images[i] i += 1 for r, c, image in it(rows=4, cols=4, images=[ ... do something with r, c, image ...
dejaVu = True while dejaVu: while True: ok = raw_input("Is this ok? (y/n)") if ok == "y" or ok == "Y" or ok == "n" or ok == "N": dejaVu = False break
def user_confirms(): while True: answer = input("Is this OK? (y/n) ").strip().lower() if answer in "yn": return answer == "y" def main(): while True: if user_confirms(): break
while True: ok = "" while ok != "y" and ok != "n": ok = get_input("Is this ok? (y/n)") if ok == "n" or ok == "N": break else: break
for i, j in ((i, j) for i in A for j in B): print(i , j) if (some_condition): break
for x in array: for y in dont_use_these_values: if x.value==y: array.remove(x) continue do some other stuff with x
for x in array: for y in dont_use_these_values: if x.value==y: array.remove(x) continue for x in array: do some other stuff with x
break_label = None while True: while True: ok = get_input("Is this ok? (y/n)") if ok == "y" or ok == "Y": break_label = "outer" break if ok == "n" or ok == "N": break if break_label: if break_label != "inner": break break_label = None if break_label: if break_label != "outer": break break_label = None
break_levels = 0 while True: while True: ok = get_input("Is this ok? (y/n)") if ok == "y" or ok == "Y": break_levels = 1 break if ok == "n" or ok == "N": break if break_levels: break_levels -= 1 break if break_levels: break_levels -= 1 break
break_level = 0 while break_level < 2: while break_level < 1: ok = get_input("Is this ok? (y/n)") if ok == "y" or ok == "Y": break_level = 2 if ok == "n" or ok == "N": break_level = 1
while True: break_statement=0 while True: ok = raw_input("Is this ok? (y/n)") if ok == "n" or ok == "N": break if ok == "y" or ok == "Y": break_statement=1 break if break_statement==1: break
def myloop(): for i in range(1,6,1): print( for j in range(1,11,2): print( for k in range(1,21,4): print( if i%3==0 and j%3==0 and k%3==0: return myloop()
done = False for i in range(1,6,1): print( for j in range(1,11,2): print( for k in range(1,21,4): print( if i%3==0 and j%3==0 and k%3==0: done = True break if done: break if done: break
def is_prime(number): foo = bar = number def return_here(): nonlocal foo, bar init_bar = bar while foo > 0: bar = init_bar while bar >= foo: if foo*bar == number: return bar -= 1 foo -= 1 return_here() if foo == 1: print(number, else: print(number,
>>> is_prime(67) 67 is prime >>> is_prime(117) 117 = 13 * 9 >>> is_prime(16) 16 = 4 * 4
x = True y = True while x == True: while y == True: ok = get_input("Is this ok? (y/n)") if ok == "y" or ok == "Y": x,y = False,False if ok == "n" or ok == "N": break
from itertools import repeat inputs = (get_input("Is this ok? (y/n)") for _ in repeat(None)) response = (i.lower()=="y" for i in inputs if i.lower() in ("y", "n")) while True: if next(response): break
for i in range(n): for j in range(n): val = x[i, j] break for i, j in np.ndindex(n, n): val = x[i, j] break
breaker = False while True: while True: ok = get_input("Is this ok? (y/n)") breaker+= (ok.lower() == "y") break if breaker: break
class BreakLoop(Exception): def __init__(self, counter): Exception.__init__(self, self.counter = counter for counter1 in range(6): try: thousand = counter1 * 1000 for counter2 in range(6): try: hundred = counter2 * 100 for counter3 in range(6): try: ten = counter3 * 10 for counter4 in range(6): try: unit = counter4 value = thousand + hundred + ten + unit if unit == 4 : raise BreakLoop(4) if ten == 30: raise BreakLoop(3) if hundred == 500: raise BreakLoop(2) if thousand == 2000: raise BreakLoop(1) print( except BreakLoop as bl: if bl.counter != 4: raise bl except BreakLoop as bl: if bl.counter != 3: raise bl except BreakLoop as bl: if bl.counter != 2: raise bl except BreakLoop as bl: pass
Variable_That_Counts_To_Three=1 while 1==1: shouldbreak= Variable_That_Counts_To_Five=0 while 2==2: Variable_That_Counts_To_Five+=1 print(Variable_That_Counts_To_Five) if Variable_That_Counts_To_Five == 5: if Variable_That_Counts_To_Three == 3: shouldbreak= break print( Variable_That_Counts_To_Three+=1 if shouldbreak == break print( This breaks out of two loops!
import urllib2.request response = urllib2.urlopen("http: html = response.read() print(html)
from urllib.request import urlopen html = urlopen("http: print(html)
try: from urllib.request import urlopen except ImportError: from urllib2 import urlopen html = urlopen("http: print(html.read())
import urllib.request url = "http: request = urllib.request.Request(url) response = urllib.request.urlopen(request) print (response.read().decode(
import urllib.request wp = urllib.request.urlopen("http: pw = wp.read() print(pw)
import urllib import sys wp = urllib.urlopen("http: for line in wp: sys.stdout.write(line)
In [1]: import urllib In [2]: urllib. urllib.ContentTooShortError urllib.ftpwrapper urllib.socket urllib.test1 urllib.FancyURLopener urllib.getproxies urllib.splitattr urllib.thishost urllib.MAXFTPCACHE urllib.getproxies_environment urllib.splithost urllib.time urllib.URLopener urllib.i urllib.splitnport urllib.toBytes urllib.addbase urllib.localhost urllib.splitpasswd urllib.unquote urllib.addclosehook urllib.noheaders urllib.splitport urllib.unquote_plus urllib.addinfo urllib.os urllib.splitquery urllib.unwrap urllib.addinfourl urllib.pathname2url urllib.splittag urllib.url2pathname urllib.always_safe urllib.proxy_bypass urllib.splittype urllib.urlcleanup urllib.base64 urllib.proxy_bypass_environment urllib.splituser urllib.urlencode urllib.basejoin urllib.quote urllib.splitvalue urllib.urlopen urllib.c urllib.quote_plus urllib.ssl urllib.urlretrieve urllib.ftpcache urllib.re urllib.string urllib.ftperrors urllib.reporthook urllib.sys
In [2]: import urllib. urllib.error urllib.parse urllib.request urllib.response urllib.robotparser In [2]: import urllib.error. urllib.error.ContentTooShortError urllib.error.HTTPError urllib.error.URLError In [2]: import urllib.parse. urllib.parse.parse_qs urllib.parse.quote_plus urllib.parse.urldefrag urllib.parse.urlsplit urllib.parse.parse_qsl urllib.parse.unquote urllib.parse.urlencode urllib.parse.urlunparse urllib.parse.quote urllib.parse.unquote_plus urllib.parse.urljoin urllib.parse.urlunsplit urllib.parse.quote_from_bytes urllib.parse.unquote_to_bytes urllib.parse.urlparse In [2]: import urllib.request. urllib.request.AbstractBasicAuthHandler urllib.request.HTTPSHandler urllib.request.AbstractDigestAuthHandler urllib.request.OpenerDirector urllib.request.BaseHandler urllib.request.ProxyBasicAuthHandler urllib.request.CacheFTPHandler urllib.request.ProxyDigestAuthHandler urllib.request.DataHandler urllib.request.ProxyHandler urllib.request.FTPHandler urllib.request.Request urllib.request.FancyURLopener urllib.request.URLopener urllib.request.FileHandler urllib.request.UnknownHandler urllib.request.HTTPBasicAuthHandler urllib.request.build_opener urllib.request.HTTPCookieProcessor urllib.request.getproxies urllib.request.HTTPDefaultErrorHandler urllib.request.install_opener urllib.request.HTTPDigestAuthHandler urllib.request.pathname2url urllib.request.HTTPErrorProcessor urllib.request.url2pathname urllib.request.HTTPHandler urllib.request.urlcleanup urllib.request.HTTPPasswordMgr urllib.request.urlopen urllib.request.HTTPPasswordMgrWithDefaultRealm urllib.request.urlretrieve urllib.request.HTTPRedirectHandler In [2]: import urllib.response. urllib.response.addbase urllib.response.addclosehook urllib.response.addinfo urllib.response.addinfourl
import urllib.request htmlfile = urllib.request.urlopen("http: htmltext = htmlfile.read() print(htmltext)
import io import urllib.request response = urllib.request.urlopen("http: text = io.TextIOWrapper(response)
import urllib.request url = "https: request = urllib.request.Request(url) response = urllib.request.urlopen(request) data_content = response.read() print(data_content)
a_variable = (anything you can put within these parentheses is an expression)
>>> a = 5 >>> eval( 42 >>> exec( >>> exec( >>> a 47 >>> eval( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1 a = 47 ^ SyntaxError: invalid syntax
>>> eval(compile( >>> eval(compile( 42 >>> exec(compile( >>>
>>> compile( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1 for i in range(3): print(i) ^ SyntaxError: invalid syntax
>>> compile( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1 for i in range(3): print(i) ^ SyntaxError: invalid syntax
>>> program = for i in range(3): print("Python is cool") >>> exec(program) Python is cool Python is cool Python is cool >>>
>>> a = 2 >>> my_calculation = >>> result = eval(my_calculation) >>> result 84
>>> def my_func(arg): ... print("Called with %d" % arg) ... return arg * 2 ... >>> exec( Called with 42 >>> eval( Called with 42 84 >>>
>>> exec( 0 1 2 >>> eval( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1 for i in range(3): print(i) ^ SyntaxError: invalid syntax
>>> g = dict() >>> l = dict() >>> exec( >>> g[ 123 >>> l {
>>> dis.dis(compile( 1 0 LOAD_NAME 0 (a) 3 LOAD_NAME 1 (b) 6 BINARY_ADD 7 RETURN_VALUE
>>> dis.dis(compile( 1 0 LOAD_NAME 0 (a) 3 LOAD_NAME 1 (b) 6 BINARY_ADD 7 POP_TOP <- discard result 8 LOAD_CONST 0 (None) <- load None on stack 11 RETURN_VALUE <- return top of stack
>>> exec(compile( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1 a = 5 ^ SyntaxError: multiple statements found while compiling a single statement
>>> eval( Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1 for i in range(3): print("Python is cool") ^ SyntaxError: invalid syntax
>>> code = compile( >>> eval(code) Python is cool Python is cool Python is cool
Python 2.7.11+ (default, Apr 17 2016, 14:00:29) [GCC 5.3.1 20160413] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> a = exec( File "<stdin>", line 1 a = exec( ^ SyntaxError: invalid syntax
>>> call_later(exec, File "<stdin>", line 1 call_later(exec, ^ SyntaxError: invalid syntax
>>> [exec(i) for i in [ File "<stdin>", line 1 [exec(i) for i in [ ^ SyntaxError: invalid syntax
shell1$ echo shell2$ python >>> import mymodule >>> mymodule.x() version 1 shell2$ echo >>> reload(mymodule) <module >>> mymodule.x() version 2
shell1$ echo shell2$ python >>> import mymodule >>> mymodule.x() version 1 >>> x = mymodule.x >>> x() version 1 >>> x is mymodule.x True shell2$ echo >>> reload(mymodule) <module >>> mymodule.x() version 2 >>> x() version 1 >>> x is mymodule.x False
try: import simplejson as json except ImportError: import json
import json import simplejson from timeit import repeat NUMBER = 100000 REPEAT = 10 def compare_json_and_simplejson(data): compare_json_and_simplejson.data = data compare_json_and_simplejson.dump = json.dumps(data) assert json.dumps(data) == simplejson.dumps(data) result = min(repeat("json.dumps(compare_json_and_simplejson.data)", "from __main__ import json, compare_json_and_simplejson", repeat = REPEAT, number = NUMBER)) print " json dumps {} seconds".format(result) result = min(repeat("simplejson.dumps(compare_json_and_simplejson.data)", "from __main__ import simplejson, compare_json_and_simplejson", repeat = REPEAT, number = NUMBER)) print "simplejson dumps {} seconds".format(result) assert json.loads(compare_json_and_simplejson.dump) == data result = min(repeat("json.loads(compare_json_and_simplejson.dump)", "from __main__ import json, compare_json_and_simplejson", repeat = REPEAT, number = NUMBER)) print " json loads {} seconds".format(result) result = min(repeat("simplejson.loads(compare_json_and_simplejson.dump)", "from __main__ import simplejson, compare_json_and_simplejson", repeat = REPEAT, number = NUMBER)) print "simplejson loads {} seconds".format(result) print "Complex real world data:" COMPLEX_DATA = { compare_json_and_simplejson(COMPLEX_DATA) print "\nSimple data:" SIMPLE_DATA = [1, 2, 3, "asasd", { compare_json_and_simplejson(SIMPLE_DATA)
$ python test_serialization_speed.py -------------------- Encoding Tests -------------------- Encoding: 100000 x { [ json] 1.12385 seconds for 100000 runs. avg: 0.011239ms [simplejson] 0.44356 seconds for 100000 runs. avg: 0.004436ms [ cjson] 0.09593 seconds for 100000 runs. avg: 0.000959ms Encoding: 10000 x { [ json] 7.76628 seconds for 10000 runs. avg: 0.776628ms [simplejson] 0.51179 seconds for 10000 runs. avg: 0.051179ms [ cjson] 0.44362 seconds for 10000 runs. avg: 0.044362ms -------------------- Decoding Tests -------------------- Decoding: 100000 x {"m": "asdsasdqwqw", "t": 3} [ json] 3.32861 seconds for 100000 runs. avg: 0.033286ms [simplejson] 0.37164 seconds for 100000 runs. avg: 0.003716ms [ cjson] 0.03893 seconds for 100000 runs. avg: 0.000389ms Decoding: 10000 x {"m": [["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19], ["0", 1, "2", 3, "4", 5, "6", 7, "8", 9, "10", 11, "12", 13, "14", 15, "16", 17, "18", 19]], "t": 3} [ json] 37.26270 seconds for 10000 runs. avg: 3.726270ms [simplejson] 0.56643 seconds for 10000 runs. avg: 0.056643ms [ cjson] 0.33007 seconds for 10000 runs. avg: 0.033007ms
>>> import collections, simplejson, json >>> TupleClass = collections.namedtuple("TupleClass", ("a", "b")) >>> value = TupleClass(1, 2) >>> json.dumps(value) >>> simplejson.dumps(value) >>> simplejson.dumps(value, namedtuple_as_object=False)
>>> from json import JSONDecoder >>> jd = JSONDecoder() >>> jd.decode("""{ "a":"b" }""") {u
>>> from simplejson import JSONDecoder >>> jd = JSONDecoder() >>> jd.decode("""{ "a":"b" }""") {
>>> from simplejson import JSONDecoder >>> jd = JSONDecoder() >>> jd.decode(unicode("""{ "a":"b" }""", "utf-8")) {u
>>> jd.decode(unicode("""{ "a": "ξηθννββωφρες" }""")) Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeDecodeError:
>>> {1,4,5}.__class__ <class >>> {}.__class__ <type
a=set([1,2,3, a={1,2,3, a=set() a.clear() if a==set(): if len(a)==0:
import locale locale.setlocale(locale.LC_ALL, assert sorted((u key=cmp_to_key(locale.strcoll)) == [u
mylist.sort(key=lambda x: x.lower()) mylist.sort(key=str.lower)
import locale locale.setlocale(locale.LC_ALL, assert sorted((u assert sorted((u
items = ["love", "like", "play", "cool", "my"] sorted(items2)
names = [ print ("The solution for this is about this names being sorted:",sorted(names, key=lambda name:name.lower()))
package/ __init__.py subpackage1/ __init__.py moduleX.py moduleY.py subpackage2/ __init__.py moduleZ.py moduleA.py
package/ __init__.py subpackage1/ __init__.py moduleX.py moduleA.py
if __package__ is None or __package__ == import foo else: from . import foo
from __future__ import print_function if __package__: print( from .fileA import f1, f2 from .fileB import Class3 else: print( import os, sys _i = os.path.dirname(os.path.abspath(__file__)) if _i not in sys.path: print( sys.path.insert(0, _i) else: print( del _i from fileA import f1, f2 from fileB import Class3 ... all the code as usual ... if __name__ == import doctest, sys ret = doctest.testmod() sys.exit(0 if ret.failed == 0 else 1)
$ python3 lib.routine Package named [...]/runpy.py:125: RuntimeWarning: after import of package this may result in unpredictable behaviour warn(RuntimeWarning(msg)) Package named
import os, sys _i = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) if _i not in sys.path: sys.path.insert(0, _i) else: _i = None from sub.fileA import f1, f2 from sub.fileB import Class3 if _i: sys.path.remove(_i) del _i
import sys parent_module = sys.modules[ if __name__ == from codex import Codex from dblogger import DbLogger else: from .codex import Codex from .dblogger import DbLogger
import os import sys parent_dir_name = os.path.dirname(os.path.dirname(os.path.realpath(__file__))) sys.path.append(parent_dir_name + "/your_dir") import your_script your_script.a_function()
import inspect import imp import os def get_script_dir(follow_symlinks=True): script_path = inspect.getabsfile(get_script_dir) if follow_symlinks: script_path = os.path.realpath(script_path) return os.path.dirname(script_path) PARENT_PATH = os.path.dirname(get_script_dir()) (x_file, x_path, x_desc) = imp.find_module( module_x = imp.load_module( function = module_x.my_function VALUE = module_x.MY_CONST
if __name__ == from os import sys, path PARENT_DIR = path.dirname(path.dirname(path.abspath(__file__))) sys.path.append(PARENT_DIR) from subpackage1.moduleX import *
>>> t = array([1, 1, 1, 2, 2, 3, 8, 3, 8, 8]) >>> nonzero(t == 8) (array([6, 8, 9]),) >>> nonzero(t == 8)[0][0] 6
>>> nonzero(r_[1, diff(t)[:-1]]) (array([0, 3, 5, 6, 7, 8]),)
>>> st = sorted(t) >>> nonzero(r_[1, diff(st)[:-1]]) (array([0, 3, 5, 7]),)
l = [1,2,3,4,5] a = numpy.array(l) i = a.tolist().index(2) print i
a = numpy.arange(100) other_array[first_array > 50]
from numba import njit import numpy as np @njit def index(array, item): for idx, val in np.ndenumerate(array): if val == item: return idx
>>> arr1 = np.ones((100, 100, 100)) >>> arr1[2, 2, 2] = 2 >>> index(arr1, 2) (2, 2, 2) >>> arr2 = np.ones(20) >>> arr2[5] = 2 >>> index(arr2, 2) (5,)
>>> tuple(np.argwhere(arr1 == 2)[0]) (2, 2, 2) >>> tuple(np.argwhere(arr2 == 2)[0]) (5,)
In [1]: from numpy import * In [2]: x = arange(125).reshape((5,5,5)) In [3]: y = indices(x.shape) In [4]: locs = y[:,x >= 120] In [5]: pts = hsplit(locs, len(locs[0])) In [6]: for pt in pts: .....: print( 4, 4, 0 4, 4, 1 4, 4, 2 4, 4, 3 4, 4, 4
def ndindex(ndarray, item): if len(ndarray.shape) == 1: try: return [ndarray.tolist().index(item)] except: pass else: for i, subarray in enumerate(ndarray): try: return [i] + ndindex(subarray, item) except: pass In [1]: ndindex(x, 103) Out[1]: [4, 0, 3]
In [67]: l=range(100) In [68]: l.index(2) Out[68]: 2
In [69]: a = np.arange(100) In [70]: next((idx for idx, val in np.ndenumerate(a) if val==2)) Out[70]: (2L,)
In [77]: next((idx for idx, val in np.ndenumerate(a) if val==400),None)
In [71]: np.argmax(a==2) Out[71]: 2 In [72]: np.where(a==2) Out[72]: (array([2], dtype=int64),) In [73]: np.nonzero(a==2) Out[73]: (array([2], dtype=int64),)
In [285]: a = np.arange(100000) In [286]: %timeit next((idx for idx, val in np.ndenumerate(a) if val==0)) 100000 loops, best of 3: 17.6 µs per loop In [287]: %timeit np.argmax(a==0) 1000 loops, best of 3: 254 µs per loop In [288]: %timeit np.where(a==0)[0][0] 1000 loops, best of 3: 314 µs per loop
arr = np.array([1, 1, 1, 2, 3, 3, 4]) i = np.searchsorted(arr, 3)
if arr[i] == 3: print("present") else: print("not present")
>>> import numpy as np >>> x = np.arange(100) >>> next(i for i, x_i in enumerate(x) if x_i == 2) 2
>>> x = np.arange(100).reshape(10,10) >>> next((i,j) for i, x_i in enumerate(x) ... for j, x_ij in enumerate(x_i) if x_ij == 2) (0, 2)
sequence_of_arrays = [[0, 1], [1, 2], [-5, 0]] arrays_to_query = [[-5, 0], [1, 0]] import numpy_indexed as npi idx = npi.indices(sequence_of_arrays, arrays_to_query, missing=-1) print(idx)
your_list = [11, 22, 23, 44, 55] result = filter(lambda x:your_list[x]>30, range(len(your_list))) import numpy as np your_numpy_array = np.array([11, 22, 23, 44, 55]) result = filter(lambda x:your_numpy_array [x]>30, range(len(your_list)))
class ThreadableMixin: def start_worker(self): threading.Thread(target=self.worker).start() def worker(self): try: self._worker() except tornado.web.HTTPError, e: self.set_status(e.status_code) except: logging.error("_worker problem", exc_info=True) self.set_status(500) tornado.ioloop.IOLoop.instance().add_callback(self.async_callback(self.results))
class Handler(tornado.web.RequestHandler, ThreadableMixin): def _worker(self): self.res = self.render_string("template.html", title = _("Title"), data = self.application.db.query("select ... where object_id=%s", self.object_id) )
def pdf_to_csv(filename): from cStringIO import StringIO from pdfminer.converter import LTTextItem, TextConverter from pdfminer.pdfparser import PDFDocument, PDFParser from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter class CsvConverter(TextConverter): def __init__(self, *args, **kwargs): TextConverter.__init__(self, *args, **kwargs) def end_page(self, i): from collections import defaultdict lines = defaultdict(lambda : {}) for child in self.cur_item.objs: if isinstance(child, LTTextItem): (_,_,x,y) = child.bbox line = lines[int(-y)] line[x] = child.text.encode(self.codec) for y in sorted(lines.keys()): line = lines[y] self.outfp.write(";".join(line[x] for x in sorted(line.keys()))) self.outfp.write("\n") rsrc = PDFResourceManager() outfp = StringIO() device = CsvConverter(rsrc, outfp, codec="utf-8") doc = PDFDocument() fp = open(filename, parser = PDFParser(fp) parser.set_document(doc) doc.set_parser(parser) doc.initialize( interpreter = PDFPageInterpreter(rsrc, device) for i, page in enumerate(doc.get_pages()): outfp.write("START PAGE %d\n" % i) interpreter.process_page(page) outfp.write("END PAGE %d\n" % i) device.close() fp.close() return outfp.getvalue()
def pdf_to_csv(filename): from cStringIO import StringIO from pdfminer.converter import LTChar, TextConverter from pdfminer.layout import LAParams from pdfminer.pdfparser import PDFDocument, PDFParser from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter class CsvConverter(TextConverter): def __init__(self, *args, **kwargs): TextConverter.__init__(self, *args, **kwargs) def end_page(self, i): from collections import defaultdict lines = defaultdict(lambda : {}) for child in self.cur_item.objs: if isinstance(child, LTChar): (_,_,x,y) = child.bbox line = lines[int(-y)] line[x] = child.text.encode(self.codec) for y in sorted(lines.keys()): line = lines[y] self.outfp.write(";".join(line[x] for x in sorted(line.keys()))) self.outfp.write("\n") rsrc = PDFResourceManager() outfp = StringIO() device = CsvConverter(rsrc, outfp, codec="utf-8", laparams=LAParams()) doc = PDFDocument() fp = open(filename, parser = PDFParser(fp) parser.set_document(doc) doc.set_parser(parser) doc.initialize( interpreter = PDFPageInterpreter(rsrc, device) for i, page in enumerate(doc.get_pages()): outfp.write("START PAGE %d\n" % i) if page is not None: interpreter.process_page(page) outfp.write("END PAGE %d\n" % i) device.close() fp.close() return outfp.getvalue()
def pdf_to_csv(filename): from cStringIO import StringIO from pdfminer.converter import LTChar, TextConverter from pdfminer.layout import LAParams from pdfminer.pdfparser import PDFDocument, PDFParser from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter class CsvConverter(TextConverter): def __init__(self, *args, **kwargs): TextConverter.__init__(self, *args, **kwargs) def end_page(self, i): from collections import defaultdict lines = defaultdict(lambda : {}) for child in self.cur_item._objs: if isinstance(child, LTChar): (_,_,x,y) = child.bbox line = lines[int(-y)] line[x] = child._text.encode(self.codec) for y in sorted(lines.keys()): line = lines[y] self.outfp.write(";".join(line[x] for x in sorted(line.keys()))) self.outfp.write("\n") rsrc = PDFResourceManager() outfp = StringIO() device = CsvConverter(rsrc, outfp, codec="utf-8", laparams=LAParams()) doc = PDFDocument() fp = open(filename, parser = PDFParser(fp) parser.set_document(doc) doc.set_parser(parser) doc.initialize( interpreter = PDFPageInterpreter(rsrc, device) for i, page in enumerate(doc.get_pages()): outfp.write("START PAGE %d\n" % i) if page is not None: interpreter.process_page(page) outfp.write("END PAGE %d\n" % i) device.close() fp.close() return outfp.getvalue()
import sys from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter from pdfminer.pdfpage import PDFPage from pdfminer.converter import XMLConverter, HTMLConverter, TextConverter from pdfminer.layout import LAParams from cStringIO import StringIO def pdfparser(data): fp = file(data, rsrcmgr = PDFResourceManager() retstr = StringIO() codec = laparams = LAParams() device = TextConverter(rsrcmgr, retstr, codec=codec, laparams=laparams) interpreter = PDFPageInterpreter(rsrcmgr, device) for page in PDFPage.get_pages(fp): interpreter.process_page(page) data = retstr.getvalue() print data if __name__ == pdfparser(sys.argv[1])
import sys from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter from pdfminer.pdfpage import PDFPage from pdfminer.converter import XMLConverter, HTMLConverter, TextConverter from pdfminer.layout import LAParams import io def pdfparser(data): fp = open(data, rsrcmgr = PDFResourceManager() retstr = io.StringIO() codec = laparams = LAParams() device = TextConverter(rsrcmgr, retstr, codec=codec, laparams=laparams) interpreter = PDFPageInterpreter(rsrcmgr, device) for page in PDFPage.get_pages(fp): interpreter.process_page(page) data = retstr.getvalue() print(data) if __name__ == pdfparser(sys.argv[1])
import pyPdf pdf = pyPdf.PdfFileReader(open(filename, "rb")) for page in pdf.pages: print page.extractText()
def pdf_to_csv(filename): from pdflib.page import TextItem, TextConverter from pdflib.pdfparser import PDFDocument, PDFParser from pdflib.pdfinterp import PDFResourceManager, PDFPageInterpreter class CsvConverter(TextConverter): def __init__(self, *args, **kwargs): TextConverter.__init__(self, *args, **kwargs) def end_page(self, i): from collections import defaultdict lines = defaultdict(lambda : {}) for child in self.cur_item.objs: if isinstance(child, TextItem): (_,_,x,y) = child.bbox line = lines[int(-y)] line[x] = child.text for y in sorted(lines.keys()): line = lines[y] self.outfp.write(";".join(line[x] for x in sorted(line.keys()))) self.outfp.write("\n") rsrc = PDFResourceManager() outfp = StringIO() device = CsvConverter(rsrc, outfp, "ascii") doc = PDFDocument() fp = open(filename, parser = PDFParser(doc, fp) doc.initialize( interpreter = PDFPageInterpreter(rsrc, device) for i, page in enumerate(doc.get_pages()): outfp.write("START PAGE %d\n" % i) interpreter.process_page(page) outfp.write("END PAGE %d\n" % i) device.close() fp.close() return outfp.getvalue()
>>> with open( ... doc = slate.PDF(f) ... >>> doc [..., ..., ...] >>> doc[1]
from cStringIO import StringIO from pdfminer.pdfinterp import PDFResourceManager, process_pdf from pdfminer.converter import TextConverter from pdfminer.layout import LAParams def to_txt(pdf_path): input_ = file(pdf_path, output = StringIO() manager = PDFResourceManager() converter = TextConverter(manager, output, laparams=LAParams()) process_pdf(manager, converter, input_) return output.getvalue()
def convert_pdf(path, outtype= import sys from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter, process_pdf from pdfminer.converter import XMLConverter, HTMLConverter, TextConverter, TagExtractor from pdfminer.layout import LAParams from pdfminer.pdfparser import PDFDocument, PDFParser from pdfminer.pdfdevice import PDFDevice from pdfminer.cmapdb import CMapDB outfile = path[:-3] + outtype outdir = debug = 0 password = pagenos = set() maxpages = 0 codec = pageno = 1 scale = 1 showpageno = True laparams = LAParams() for (k, v) in opts: if k == elif k == elif k == elif k == elif k == elif k == elif k == elif k == elif k == elif k == elif k == elif k == elif k == elif k == elif k == # CMapDB.debug = debug PDFResourceManager.debug = debug PDFDocument.debug = debug PDFParser.debug = debug PDFPageInterpreter.debug = debug PDFDevice.debug = debug # rsrcmgr = PDFResourceManager() if not outtype: outtype = if outfile: if outfile.endswith( outtype = elif outfile.endswith( outtype = elif outfile.endswith( outtype = if outfile: outfp = file(outfile, else: outfp = sys.stdout if outtype == device = TextConverter(rsrcmgr, outfp, codec=codec, laparams=laparams) elif outtype == device = XMLConverter(rsrcmgr, outfp, codec=codec, laparams=laparams, outdir=outdir) elif outtype == device = HTMLConverter(rsrcmgr, outfp, codec=codec, scale=scale, laparams=laparams, outdir=outdir) elif outtype == device = TagExtractor(rsrcmgr, outfp, codec=codec) else: return usage() fp = file(path, process_pdf(rsrcmgr, device, fp, pagenos, maxpages=maxpages, password=password) fp.close() device.close() outfp.close() return
In [25]: a = [] In [26]: s = In [27]: a += s In [28]: a Out[28]: [
In [36]: s = In [37]: a = map(lambda c: c, s) In [38]: a Out[38]: [
In [40]: a = map(lambda c: c if c.isalpha() else In [41]: a Out[41]: [
result = [] for character in string: result.append(character)
Python 2.7.6 (default, Mar 22 2014, 22:59:38) [GCC 4.8.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> t = >>> t[1]
>>> text = "My hovercraft is full of eels" >>> [text[i] for i in range(len(text))] [
/usr/lib64/python2.7/site.py /usr/lib64/python2.7/site.pyc /usr/lib64/python2.7/site.pyo
/root/Python-2.7.6/Lib/site.py /root/Python-2.7.6/Lib/site.pyc /root/Python-2.7.6/Lib/site.pyo /root/Python-2.7.6/Lib/test/test_site.py /usr/lib/python2.6/site-packages/site.py /usr/lib/python2.6/site-packages/site.pyc /usr/lib/python2.6/site-packages/site.pyo /usr/lib64/python2.6/site.py /usr/lib64/python2.6/site.pyc /usr/lib64/python2.6/site.pyo /usr/local/lib/python2.7/site.py /usr/local/lib/python2.7/site.pyc /usr/local/lib/python2.7/site.pyo /usr/local/lib/python2.7/test/test_site.py /usr/local/lib/python2.7/test/test_site.pyc /usr/local/lib/python2.7/test/test_site.pyo
In [1]: import sys In [2]: sys.version 2.7.11 |Anaconda 2.5.0 (64-bit)| (default, Dec 6 2015, 18:08:32) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] In [3]: sys.version_info sys.version_info(major=2, minor=7, micro=11, releaselevel= In [4]: sys.version_info >= (2,7) Out[4]: True In [5]: sys.version_info >= (3,) Out[5]: False
In [1]: import django In [2]: django.VERSION Out[2]: (1, 6, 1,
python sergio@tarro: Python 2.7.6 (default, Jun 22 2015, 17:58:13) [GCC 4.8.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>>
import platform import sys def linux_dist(): try: return platform.linux_distribution() except: return "N/A" print( % ( sys.version.split( str(platform.dist()), linux_dist(), platform.system(), platform.machine(), platform.platform(), platform.uname(), platform.version(), ))
python Python 3.6.0a4 (v3.6.0a4:017cf260936b, Aug 16 2016, 00:59:16) [MSC v.1900 64 bit (AMD64)] on win32 python -V Python 3.6.0a4 python --version Python 3.6.0a4
find /usr/lib/python2.7/site-packages -maxdepth 2 -name __init__.py | xargs pacman -Qo | grep
find /usr/local/lib/python2.7/dist-packages -maxdepth 2 -name __init__.py | xargs realpath | xargs dpkg -S 2>&1 | grep
find /usr/lib/python2.7/site-packages -maxdepth 2 -name __init__.py | xargs rpm -qf | grep
$ pip show jupyter Name: jupyter Version: 1.0.0 Summary: Jupyter metapackage. Install all the Jupyter components in one go. Home-page: http: Author: Jupyter Development Team Author-email: jupyter@googlegroups.org License: BSD Location: /usr/local/lib/python2.7/site-packages Requires: ipywidgets, nbconvert, notebook, jupyter-console, qtconsole, ipykernel
import pip from os.path import join for package in pip.get_installed_distributions(): print(package.location) print(join(package.location, package._get_metadata("top_level.txt")))
$ pip search selenium | egrep -B1 selenium - Python bindings for Selenium INSTALLED: 2.24.0 LATEST: 2.25.0 -- robotframework-selenium2library - Web testing library for Robot Framework INSTALLED: 1.0.1 (latest) $
find /usr/lib/python2.7/site-packages -maxdepth 2 -name __init__.py | xargs rpm -qf | grep
import pkg_resources distros = pkg_resources.AvailableDistributions() for key in distros: print distros[key]
printf "Installed with pip:"; pip list 2>/dev/null | gawk
user@pc:~ $ conda list # _ipyw_jlab_nb_ext_conf 0.1.0 py36h2fc01ae_0 alabaster 0.7.10 py36h174008c_0 amqp 2.2.2 <pip> anaconda 5.1.0 py36_2 anaconda-client 1.6.9 py36_0
user@pc:~ $ conda list | grep \<pip amqp 2.2.2 <pip> astroid 1.6.2 <pip> billiard 3.5.0.3 <pip> blinker 1.4 <pip> ez-setup 0.9 <pip> feedgenerator 1.9 <pip>
user@pc:~ $ conda list | awk amqp astroid billiard blinker ez-setup feedgenerator
>>> test = np.arange(9).reshape((3,3)) >>> test array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) >>> test[:,[0,2]] array([[0, 2], [3, 5], [6, 8]])
>>> np.hstack((test, test[:,[0]])) array([[1, 2, 1], [3, 4, 3], [5, 6, 5]])
arr_c1_ref = arr[:, 1] arr_c1_copy = arr[:, 1].copy()
A = np.random.randint(2, size=(10000,10000), dtype= A_c1_ref = A[:, 1] A_c1_copy = A[:, 1].copy()
A = np.asfortranarray(A) A_c1_ref = A[:, 1] A_c1_ref.strides[0] %timeit A_c1_ref.sum()
>>> test array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) >>> ncol = test.shape[1] >>> ncol 5L
>>> test[0:, 1:(ncol - 1)] array([[1, 2, 3], [6, 7, 8]])
from contextlib import contextmanager import os @contextmanager def working_directory(path): current_dir = os.getcwd() os.chdir(path) try: yield finally: os.chdir(current_dir) with working_directory("data/stuff"):
from contextlib import contextmanager import sys @contextmanager def redirected(**kwds): stream_names = ["stdin", "stdout", "stderr"] old_streams = {} try: for sname in stream_names: stream = kwds.get(sname, None) if stream is not None and stream != getattr(sys, sname): old_streams[sname] = getattr(sys, sname) setattr(sys, sname, stream) yield finally: for sname, stream in old_streams.iteritems(): setattr(sys, sname, stream) with redirected(stdout=open("/tmp/log.txt", "w")): print "Test entry 1" print "Test entry 2" print "Back to normal stdout again"
from tempfile import mkdtemp from shutil import rmtree @contextmanager def temporary_dir(*args, **kwds): name = mkdtemp(*args, **kwds) try: yield name finally: shutil.rmtree(name) with temporary_dir() as dirname:
with open("foo.txt") as foo_file: data = foo_file.read()
from contextlib import nested with nested(A(), B(), C()) as (X, Y, Z): do_something()
with open( for line in input_file: output_file.write(parse(line))
for row in lines: with open("outfile","a") as f: f.write(row)
with open("outfile","a") as f: for row in lines: f.write(row)
from decimal import localcontext with localcontext() as ctx: ctx.prec = 42 s = calculate_something() s = +s
conn = psycopg2.connect(DSN) with conn: with conn.cursor() as curs: curs.execute(SQL1) with conn: with conn.cursor() as curs: curs.execute(SQL2) conn.close()
with open(“file name”, “mode”) as file-var: processing statements
as3:~/ngokevin-site as3:~/ngokevin-site Traceback (most recent call last): File "/usr/local/bin/wok", line 4, in Engine() File "/usr/local/lib/python2.7/site-packages/wok/engine.py", line 104, in init self.load_pages() File "/usr/local/lib/python2.7/site-packages/wok/engine.py", line 238, in load_pages p = Page.from_file(os.path.join(root, f), self.options, self, renderer) File "/usr/local/lib/python2.7/site-packages/wok/page.py", line 111, in from_file page.meta[ File "/usr/local/lib/python2.7/site-packages/wok/renderers.py", line 46, in render return markdown(plain, Markdown.plugins) File "/usr/local/lib/python2.7/site-packages/markdown/init.py", line 419, in markdown return md.convert(text) File "/usr/local/lib/python2.7/site-packages/markdown/init.py", line 281, in convert source = unicode(source) UnicodeDecodeError:
as3:/usr/local/lib/python2.7/site-packages import sys reload(sys) sys.setdefaultencoding(
as3:~/ngokevin-site Python 2.7.6 (default, Dec 6 2013, 14:49:02) [GCC 4.4.5] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> import sys >>> reload(sys) <module >>> sys.getdefaultencoding() >>>
import io with io.open("my_utf8_file.txt", "r", encoding="utf-8") as my_file: my_unicode_string = my_file.read()
from backports import csv import io with io.open("my_utf8_file.txt", "r", encoding="utf-8") as my_file: for row in csv.reader(my_file): yield row
psycopg2.extensions.register_type(psycopg2.extensions.UNICODE) psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)
if isinstance(input_string, str): input_string = unicode(input_string,
if isinstance(input_string, str): input_string = input_string.decode( elif isinstance(input_string, unicode): input_string = input_string.encode(
_u = lambda t: t.decode( _uu = lambda *tt: tuple(_u(t) for t in tt) _u8 = lambda t: t.encode( _uu8 = lambda *tt: tuple(_u8(t) for t in tt)
text= utext=u print "==> with _u, _uu" print _u(text), type(_u(text)) print _u(utext), type(_u(utext)) print _uu(text, utext), type(_uu(text, utext)) print "==> with u8, uu8" print _u8(text), type(_u8(text)) print _u8(utext), type(_u8(utext)) print _uu8(text, utext), type(_uu8(text, utext)) print "Some unknown input %s" % _u(text) print "Multiple inputs %s, %s" % _uu(text, text) print u"Also works with formats: {}".format(_u(text)) print u"Also works with formats: {},{}".format(*_uu(text, text)) print "Also works with formats: {}".format(_u8(text)) print "Also works with formats: {},{}".format(*_uu8(text, text))
enc = sys.getdefaultencoding() file = open(menu, "r", encoding = enc)
train_df = pd.read_csv("Example.csv") train_data = train_df.values for i in train_data: print("ID :" + i[0]) text = i[1].decode("utf-8",errors="ignore").strip().lower() print("Text: " + text)
import numpy as np from tqdm import tqdm def load_glove(file): """Loads GloVe vectors in numpy array. Args: file (str): a path to a glove file. Return: dict: a dict of numpy arrays. """ embeddings_index = {} with open(file, encoding= for i, line in tqdm(enumerate(f)): values = line.split() word = coefs = np.asarray(values[-300:], dtype= embeddings_index[word] = coefs return embeddings_index EMBEDDING_PATH = embeddings = load_glove(EMBEDDING_PATH) np.save(
print (2/3) ----> 0 Python 2.7 print (2/3) ----> 0.6666666666666666 Python 3.5
print (4/2) ----> 2 Python 2.7 print (4/2) ----> 2.0 Python 3.5
from __future__ import division print (2/3) ----> 0.6666666666666666 print (4/2) ----> 2.0
>>>print 5 2 >>> print 5.0 2.0 >>>print 5 2.0 >>>print 5.0 2.0
"b-staged divinylsiloxane-bis-benzocyclobutene [124221-30-3], mesitylene [000108-67-8]; polymerized 1,2-dihydro-2,2,4- trimethyl quinoline [026780-96-1]"
>>> import re >>> delimiters = "a", "...", "(c)" >>> example = "stackoverflow (c) is awesome... isn >>> regexPattern = >>> regexPattern >>> re.split(regexPattern, example) [
def split(delimiters, string, maxsplit=0): import re regexPattern = return re.split(regexPattern, string, maxsplit)
>>> a= >>> import re >>> re.split( [ >>> b= >>> re.split( [
import re pattern = re.compile(r";|, ") pattern = re.compile(r"[;,] ") print pattern.split(text)
import logging try: 1/0 except ZeroDivisionError as e: logging.error(e)
import logging try: 1/0 except ZeroDivisionError as e: logging.exception("message")
ERROR:root:message Traceback (most recent call last): File "<stdin>", line 2, in <module> ZeroDivisionError: integer division or modulo by zero
import logging try: 1/0 except ZeroDivisionError: logging.exception("Deliberate divide by zero traceback")
>>> import logging >>> try: ... 1/0 ... except ZeroDivisionError: ... logging.exception("Deliberate divide by zero traceback") ... ERROR:root:Deliberate divide by zero traceback Traceback (most recent call last): File "<stdin>", line 2, in <module> ZeroDivisionError: integer division or modulo by zero
try: except Exception as e: logging.fatal(e, exc_info=True)
import traceback def log_traceback(ex, ex_traceback=None): if ex_traceback is None: ex_traceback = ex.__traceback__ tb_lines = [ line.rstrip( traceback.format_exception(ex.__class__, ex, ex_traceback)] exception_logger.log(tb_lines)
try: except Exception as ex: _, _, ex_traceback = sys.exc_info() log_traceback(ex, ex_traceback)
try: x = get_number() except Exception as ex: log_traceback(ex)
import logging logger = logging.getLogger( def log_app_error(e: BaseException, level=logging.ERROR) -> None: e_traceback = traceback.format_exception(e.__class__, e, e.__traceback__) traceback_lines = [] for line in [line.rstrip( traceback_lines.extend(line.splitlines()) logger.log(level, traceback_lines.__str__())
ex_traceback = [ for line in ex_traceback: print(line)
my_logger = logging.getLogger( my_logger.setLevel(logging.INFO) graylog_handler = graypy.GELFHandler( graylog_handler.setLevel(logging.INFO) my_logger.addHandler(graylog_handler)
try: 1/0 except ZeroDivisionError, e: my_logger.exception(e)
from functools import wraps from typing import Callable, TypeVar, Optional import logging A = TypeVar( def fallible(*exceptions, logger=None) \ -> Callable[[Callable[..., A]], Callable[..., Optional[A]]]: def fwrap(f: Callable[..., A]) -> Callable[..., Optional[A]]: @wraps(f) def wrapped(*args, **kwargs): try: return f(*args, **kwargs) except exceptions: message = f if logger: logger.exception(message) if logger is None: logging.exception(message) return None return wrapped return fwrap
In [1] from fallible import fallible In [2]: @fallible(ArithmeticError) ...: def div(a, b): ...: return a / b ...: ...: In [3]: div(1, 2) Out[3]: 0.5 In [4]: res = div(1, 0) ERROR:root:called <function div at 0x10d3c6ae8> with *args=(1, 0) and **kwargs={} Traceback (most recent call last): File "/Users/user/fallible.py", line 17, in wrapped return f(*args, **kwargs) File "<ipython-input-17-e056bd886b5c>", line 3, in div return a / b In [5]: repr(res)
from traceback import format_exc try: 1/0 except Exception: print
for filename in os.listdir(directory): if filename.endswith(".asm") or filename.endswith(".py"): continue else: continue
directory = os.fsencode(directory_in_str) for file in os.listdir(directory): filename = os.fsdecode(file) if filename.endswith(".asm") or filename.endswith(".py"): continue else: continue
from pathlib import Path pathlist = Path(directory_in_str).glob( for path in pathlist: path_in_str = str(path)
import os for subdir, dirs, files in os.walk(rootdir): for file in files: filepath = subdir + os.sep + file if filepath.endswith(".asm"): print (filepath)
import glob for filepath in glob.iglob( print(filepath)
from pathlib import Path asm_pths = [pth for pth in Path.cwd().iterdir() if pth.suffix ==
asm_paths = [] for pth in Path.cwd().iterdir(): if pth.suffix == asm_pths.append(pth)
import collections import os DirectoryIndex = collections.namedtuple( for file_name in DirectoryIndex(*next(os.walk( file_path = os.path.join(path, file_name)
import os path = folder = os.fsencode(path) filenames = [] for file in os.listdir(folder): filename = os.fsdecode(file) if filename.endswith( ( filenames.append(filename) filenames.sort()
import sys print("The Python version is %s.%s.%s" % sys.version_info[:3])
sys.version_info sys.version_info(major=3, minor=2, micro=2, releaselevel=
version = ".".join(map(str, sys.version_info[:3])) print(version)
>>> print "Hello, World!" File "<stdin>", line 1 print "Hello, World!" ^ SyntaxError: Missing parentheses in call to
>>> print "Hello, World!" File "<stdin>", line 1 print "Hello, World!" ^ SyntaxError: invalid syntax
>>> import sys >>> print >> sys.stderr, 1, 2, 3,; print >> sys.stderr, 4, 5, 6 1 2 3 4 5 6
>>> import sys >>> print(1, 2, 3, file=sys.stderr, end=" "); print(4, 5, 6, file=sys.stderr) 1 2 3 4 5 6
>>> print "Hello!" File "<stdin>", line 1 print "Hello!" ^ SyntaxError: Missing parentheses in call to
>>> print >> sys.stderr Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unsupported operand type(s) for >>:
(local directory)/site-packages/toolkit/interface.py
(local directory)/site-packages/toolkit/examples/mountain.py
Traceback (most recent call last): File "mountain.py", line 28, in ? from toolkit.interface import interface ImportError: No module named toolkit.interface
.:/usr/lib/python .:/usr/lib/python2.6 .:/usr/lib/python2.7 and etc.
sudo chmod 755 /usr/local/lib/python2.7/dist-packages/*.so
Traceback (most recent call last): File "bash\bash.py", line 454, in main import bosh File "Wrye Bash Launcher.pyw", line 63, in load_module mod = imp.load_source(fullname,filename+ext,fp) File "bash\bosh.py", line 69, in <module> from game.oblivion.RecordGroups import MobWorlds, MobDials, MobICells, \ ImportError: No module named RecordGroups
Booklet -> __init__.py -> Booklet.py -> Question.py default -> __init_.py -> main.py
from Booklet import Question from Question import Question from Booklet.Question import Question from Booklet.Question import * import Booklet.Question
from booklet.Booklet import Booklet from booklet.Question import Question from booklet.Question import AnotherClass
class MyStruct(): def __init__(self, field1, field2, field3): self.field1 = field1 self.field2 = field2 self.field3 = field3
from collections import namedtuple MyStruct = namedtuple("MyStruct", "field1 field2 field3")
m = MyStruct(field1="foo", field2="bar", field3="baz")
>>> class Bunch: ... def __init__(self, **kwds): ... self.__dict__.update(kwds) ... >>> mystruct = Bunch(field1=value1, field2=value2)
class Sample: name = average = 0.0 values = None s1 = Sample() s1.name = "sample 1" s1.values = [] s1.values.append(1) s1.values.append(2) s1.values.append(3) s2 = Sample() s2.name = "sample 2" s2.values = [] s2.values.append(4) for v in s1.values: print v print "***" for v in s2.values: print v
from dataclasses import dataclass @dataclass class Point: x: float y: float z: float = 0.0 p = Point(1.5, 2.5) print(p)
from typing import NamedTuple class MyStruct(NamedTuple): foo: str bar int baz: list qux: User my_item = MyStruct( print(my_item)
class Struct: def __init__ (self, *argv, **argd): if len(argd): self.__dict__.update (argd) else: attrs = filter (lambda x: x[0:2] != "__", dir(self)) for n in range(len(argv)): setattr(self, attrs[n], argv[n]) class Point3dStruct (Struct): x = 0 y = 0 z = 0 pt1 = Point3dStruct() pt1.x = 10 print pt1.x print "-"*10 pt2 = Point3dStruct(5, 6) print pt2.x, pt2.y print "-"*10 pt3 = Point3dStruct (x=1, y=2, z=3) print pt3.x, pt3.y, pt3.z print "-"*10
>>> from ctypes import * >>> class POINT(Structure): ... _fields_ = [("x", c_int), ... ("y", c_int)] ... >>> point = POINT(10, 20) >>> print point.x, point.y 10 20 >>> point = POINT(y=5) >>> print point.x, point.y 0 5 >>> POINT(1, 2, 3) Traceback (most recent call last): File "<stdin>", line 1, in ? ValueError: too many initializers >>> >>> class RECT(Structure): ... _fields_ = [("upperleft", POINT), ... ("lowerright", POINT)] ... >>> rc = RECT(point) >>> print rc.upperleft.x, rc.upperleft.y 0 5 >>> print rc.lowerright.x, rc.lowerright.y 0 0 >>>
class Point: __slots__ = ["x", "y"] def __init__(self, x, y): self.x = x self.y = y
class Point: def __init__(self, x, y): self.x = x self.y = y p1 = Point(3,5) p1.z = 8 print(p1.z)
class Point: __slots__ = ["x", "y"] def __init__(self, x, y): self.x = x self.y = y p1 = Point(3,5) p1.z = 8
class Map(dict): def __init__(self, **kwargs): super(Map, self).__init__(**kwargs) self.__dict__ = self
struct = Map(field1= self.assertEquals( self.assertEquals(42, struct[
obj = cstruct() obj.var_i = 50 obj.var_f = 50.00 obj.var_str = "fifty" print "cstruct: obj i=%d f=%f s=%s" %(obj.var_i, obj.var_f, obj.var_str)
obj_array = [cstruct() for i in range(10)] obj_array[0].var_i = 10 obj_array[0].var_f = 10.00 obj_array[0].var_str = "ten" for i in range(10): print "cstruct: obj_array i=%d f=%f s=%s" %(obj_array[i].var_i, obj_array[i].var_f, obj_array[i].var_str)
class Struct: "A structure that can have any fields defined." def __init__(self, **entries): self.__dict__.update(entries)
>>> options = Struct(answer=42, linelen=80, font= >>> options.answer 42
def argumentsToAttributes(method): argumentNames = method.func_code.co_varnames[1:] defaultsDict = {} defaults = method.func_defaults if method.func_defaults else () for i, default in enumerate(defaults, start = len(argumentNames) - len(defaults)): defaultsDict[argumentNames[i]] = default def newMethod(self, *args, **kwargs): for name, value in zip(argumentNames, args): setattr(self, name, value) for name in argumentNames[len(args):]: setattr(self, name, kwargs.get(name, defaultsDict[name])) method(self, *args, **kwargs) return newMethod
class A(object): @argumentsToAttributes def __init__(self, a, b = print(self.a) print(self.b) print(self.c) A(
class MyStruct(type): def __call__(cls, *args, **kwargs): names = cls.__init__.func_code.co_varnames[1:] self = type.__call__(cls, *args, **kwargs) for name, value in zip(names, args): setattr(self , name, value) for name, value in kwargs.iteritems(): setattr(self , name, value) return self
>>> class MyClass(object): __metaclass__ = MyStruct def __init__(self, a, b, c): pass >>> my_instance = MyClass(1, 2, 3) >>> my_instance.a 1 >>>
>>> def init_all_args(fn): @wraps(fn) def wrapped_init(self, *args, **kwargs): names = fn.func_code.co_varnames[1:] for name, value in zip(names, args): setattr(self, name, value) for name, value in kwargs.iteritems(): setattr(self, name, value) return wrapped_init >>> class Test(object): @init_all_args def __init__(self, a, b): pass >>> a = Test(1, 2) >>> a.a 1 >>>
class Employee: pass john = Employee() john.name = john.dept = john.salary = 1000
class Employee: def __init__ (self): self.name = None self.dept = None self.salary = None
class struct: def __init__(self, *sequential, **named): fields = dict(zip(sequential, [None]*len(sequential)), **named) self.__dict__.update(fields) def __repr__(self): return str(self.__dict__)
mystruct1 = struct("field1", "field2", "field3") mystruct2 = struct(field1=1, field2=2, field3=3)
_class_template = """\ class {typename}: def __init__(self, *args, **kwargs): fields = {field_names!r} for x in fields: setattr(self, x, None) for name, value in zip(fields, args): setattr(self, name, value) for name, value in kwargs.items(): setattr(self, name, value) def __repr__(self): return str(vars(self)) def __setattr__(self, name, value): if name not in {field_names!r}: raise KeyError("invalid name: %s" % name) object.__setattr__(self, name, value) """ def struct(typename, field_names): class_definition = _class_template.format( typename = typename, field_names = field_names) namespace = dict(__name__= exec(class_definition, namespace) result = namespace[typename] result._source = class_definition return result
Person = struct( generic = Person() michael = Person( jones = Person(lastname = In [168]: michael.middlename = Traceback (most recent call last): File "<ipython-input-168-b31c393c0d67>", line 1, in <module> michael.middlename = File "<string>", line 19, in __setattr__ KeyError:
typedef struct { int x; int y; } Point; after generating pythonic class... p = Point(x=0x1234, y=0x5678) p.packed == "\x34\x12\x00\x00\x78\x56\x00\x00"
import cstruct2py parser = cstruct2py.c2py.Parser() parser.parse_file(
a = A() a.x = 45 print a buf = a.packed b = A(buf) print b c = A( print c print repr(c)
d = dict{} d[field1] = field1 d[field2] = field2 d[field2] = field3
class myStruct: def __init__(self, **kwds): self.x=0 self.__dict__.update(kwds) def __repr__(self): args = [ return a=myStruct() b=myStruct(x=3,y= c=myStruct(x= >>> a myStruct(x=0) >>> b myStruct(x=3, y= >>> c myStruct(x=
>>> import ast >>> x = u >>> x = ast.literal_eval(x) >>> x [ >>> x = [n.strip() for n in x] >>> x [
>>> import ast >>> ast.literal_eval( ["A", "B", "C", " D"]
import ast l = ast.literal_eval( l = [i.strip() for i in l]
import re x = u junkers = re.compile( result = junkers.sub( print result ---> [u
x = u list_string = str(x) import numpy as np print np.array(list_string)
>>> from pyparsing import * >>> x =u >>> LBR,RBR = map(Suppress,"[]") >>> qs = quotedString.setParseAction(removeQuotes, lambda t: t[0].strip()) >>> qsList = LBR + delimitedList(qs) + RBR >>> print qsList.parseString(x).asList() [u
>print byteify(json.loads(u >print byteify(json.loads(u"[ [ [
def parse_strlist(sl): import re clean = re.sub("[\[\],\s]","",sl) splitted = re.split("[\ values_only = [s for s in splitted if s != return values_only
from time import time import re import json my_str = str(list(range(19))) print(my_str) reps = 100000 start = time() for i in range(0, reps): re.findall("\w+", my_str) print("Regex method:\t", (time() - start) / reps) start = time() for i in range(0, reps): json.loads(my_str) print("json method:\t", (time() - start) / reps) start = time() for i in range(0, reps): ast.literal_eval(my_str) print("ast method:\t\t", (time() - start) / reps) start = time() for i in range(0, reps): [n.strip() for n in my_str] print("strip method:\t", (time() - start) / reps) regex method: 6.391477584838867e-07 json method: 2.535374164581299e-06 ast method: 2.4425282478332518e-05 strip method: 4.983267784118653e-06
>>> mylist=[1,2,3,4,5, >>> strlist=str(mylist) [ >>> mylistfromstring=(strlist[1:-1].split( >>> mylistfromstring[3] >>> for entry in mylistfromstring: ... print(entry) ... type(entry) ... 1 <class 2 <class 3 <class 4 <class 5 <class <class <class
def principal_period(s): i = (s+s).find(s, 1, -1) return None if i == -1 else s[:i]
import re REPEATER = re.compile(r"(.+?)\1+$") def repeated(s): match = REPEATER.match(s) return match.group(1) if match else None
examples = [ ] for e in examples: sub = repeated(e) if sub: print("%r: %r" % (e, sub)) else: print("%r does not repeat." % e)
from math import sqrt, floor def divquot(n): if n > 1: yield 1, n swapped = [] for d in range(2, int(floor(sqrt(n))) + 1): q, r = divmod(n, d) if r == 0: yield d, q swapped.append((q, d)) while swapped: yield swapped.pop() def repeats(s): n = len(s) for d, q in divquot(n): sl = s[0:d] if sl * q == s: return sl return None
mean performance: 0.0003 david_zhang 0.0009 zero 0.0013 antti 0.0013 tigerhawk_2 0.0015 carpetpython 0.0029 tigerhawk_1 0.0031 davidism 0.0035 saksham 0.0046 shashank 0.0052 riad 0.0056 piotr median performance: 0.0003 david_zhang 0.0008 zero 0.0013 antti 0.0013 tigerhawk_2 0.0014 carpetpython 0.0027 tigerhawk_1 0.0031 davidism 0.0038 saksham 0.0044 shashank 0.0054 riad 0.0058 piotr
mean performance: 0.0006 david_zhang 0.0036 tigerhawk_2 0.0036 antti 0.0037 zero 0.0039 carpetpython 0.0052 shashank 0.0056 piotr 0.0066 davidism 0.0120 tigerhawk_1 0.0177 riad 0.0283 saksham median performance: 0.0004 david_zhang 0.0018 zero 0.0022 tigerhawk_2 0.0022 antti 0.0024 carpetpython 0.0043 davidism 0.0049 shashank 0.0055 piotr 0.0061 tigerhawk_1 0.0077 riad 0.0109 saksham
mean performance: 0.0123 shashank 0.0375 david_zhang 0.0376 piotr 0.0394 carpetpython 0.0479 antti 0.0488 tigerhawk_2 0.2269 tigerhawk_1 0.2336 davidism 0.7239 saksham 3.6265 zero 6.0111 riad median performance: 0.0107 tigerhawk_2 0.0108 antti 0.0109 carpetpython 0.0135 david_zhang 0.0137 tigerhawk_1 0.0150 shashank 0.0229 saksham 0.0255 piotr 0.0721 davidism 0.1080 zero 1.8539 riad
def repeat(string): for i in range(1, len(string) if not len(string)%len(string[0:i]) and string[0:i]*(len(string) return string[0:i]
def repeat(string): l = len(string) for i in range(1, len(string) if l%i: continue s = string[0:i] if s*(l return s
print(repeat( print(repeat( print(repeat( print(repeat( print(repeat( print(repeat(
def shortest_repeat(orig_value): if not orig_value: return None value = orig_value while True: len_half = len(value) first_half = value[:len_half] if first_half != value[len_half:]: break value = first_half len_value = len(value) split = value.split for i in (i for i in range(1, len_value if not any(split(value[:i])): return value[:i] return value if value != orig_value else None
def prefix_function(s): n = len(s) pi = [0] * n for i in xrange(1, n): j = pi[i - 1] while(j > 0 and s[i] != s[j]): j = pi[j - 1] if (s[i] == s[j]): j += 1 pi[i] = j; return pi
def riad(s): n = len(s) pi = [0] * n for i in xrange(1, n): j = pi[i - 1] while(j > 0 and s[i] != s[j]): j = pi[j - 1] if (s[i] == s[j]): j += 1 pi[i] = j; k = n - pi[-1] return s[:k] if (n != k and n % k == 0) else None
def get_shortest_repeat(string): length = len(string) for i in range(1, length if length % i: continue candidate = string[:i] if string == candidate * (length return candidate return None
def check_repeat(s): for i in range(1, len(s)): substr = s[:i] ratio = len(s)/len(substr) if substr * ratio == s: print return print >>> check_repeat( Repeating on "2547" >>> check_repeat( Repeating on "abcde"
def repeats(string): n = len(string) tried = set([]) best = None nums = [i for i in xrange(2, int(n**0.5) + 1) if n % i == 0] nums = [n/i for i in nums if n/i!=i] + list(reversed(nums)) + [1] for s in nums: if all(t%s for t in tried): print if string[:s]*(n/s)==string: best = s else: tried.add(s) if best: return string[:best]
>>> repeats( Trying repeating string of length: 4 None >>> repeats( Trying repeating string of length: 8 Trying repeating string of length: 4
def principal_period(s): for j in range(int(len(s)/2)): idx = (s[j:]+s[j:]).find(s[j:], 1, -1) if idx != -1: if s[:j] == s[j:][:idx][-j:]: break return None if idx == -1 else s[j:][:idx] principal_period( >>>
print "Enter a string...." mainstring=raw_input(">") if(mainstring== print "Invalid string" exit() charlist=list(mainstring) strarr= print "Length of your string :",len(mainstring) for i in range(0,len(mainstring)): strarr=strarr+charlist[i] splitlist=mainstring.split(strarr) count = 0 for j in splitlist: if j == count+=1 if count == len(splitlist): break if count == len(splitlist): if count == 2: print "No repeating Sub-String found in string %r"%(mainstring) else: print "Sub-String %r repeats in string %r"%(strarr,mainstring) else : print "No repeating Sub-String found in string %r"%(mainstring)
import os.path from flask import Flask, Response app = Flask(__name__) app.config.from_object(__name__) def root_dir(): return os.path.abspath(os.path.dirname(__file__)) def get_file(filename): try: src = os.path.join(root_dir(), filename) return open(src).read() except IOError as exc: return str(exc) @app.route( def metrics(): content = get_file( return Response(content, mimetype="text/html") @app.route( @app.route( def get_resource(path): mimetypes = { ".css": "text/css", ".html": "text/html", ".js": "application/javascript", } complete_path = os.path.join(root_dir(), path) ext = os.path.splitext(path)[1] mimetype = mimetypes.get(ext, "text/html") content = get_file(complete_path) return Response(content, mimetype=mimetype) if __name__ == app.run(port=80)
from flask import Flask, request, send_from_directory app = Flask(__name__, static_url_path= @app.route( def send_js(path): return send_from_directory( if __name__ == "__main__": app.run()
from flask import Flask, request app = Flask(__name__, static_url_path= @app.route( def root(): return app.send_static_file(
<link rel="stylesheet" type="text/css" href="/static/style.css">
@app.route( def projects(): return render_template("projects.html", title =
app = Flask(__name__, static_url_path= static_folder= template_folder=
<link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
app = Flask(__name__) @app.route( def static_file(path): return app.send_static_file(path)
from flask import Flask, request app = Flask(__name__, static_url_path= @app.route( def root(): return app.send_static_file( if __name__ == app.run(debug=True)
<!DOCTYPE html> <html> <head> <title>Hello World!</title> </head> <body> <div> <p> This is a test. </p> </div> </body> </html>
@app.route( def static_file(path): return app.send_static_file(path)
backend/ | |------ui/ | |------------------build/ <-- | |--<proj |----vendors/ <-- angular.js and others here | |-- folders> |----src/ <-- your js | |----index.html <-- your SPA entrypoint |------<proj |------ folders> | |------view.py <-- Flask app here
... root = os.path.join(os.path.dirname(os.path.abspath(__file__)), "ui", "build") @app.route( def static_proxy(path): return send_from_directory(root, path) @app.route( def redirect_to_index(): return send_from_directory(root, ...
from server.AppStarter import AppStarter import os static_folder_root = os.path.join(os.path.dirname(os.path.abspath(__file__)), "client") app = AppStarter() app.register_routes_to_resources(static_folder_root) app.run(__name__)
from flask import Flask, send_from_directory from flask_restful import Api, Resource from server.ApiResources.TodoList import TodoList from server.ApiResources.Todo import Todo class AppStarter(Resource): def __init__(self): self._static_files_root_folder_path = self._app = Flask(__name__) self._api = Api(self._app) def _register_static_server(self, static_files_root_folder_path): self._static_files_root_folder_path = static_files_root_folder_path self._app.add_url_rule( self._app.add_url_rule( def register_routes_to_resources(self, static_files_root_folder_path): self._register_static_server(static_files_root_folder_path) self._api.add_resource(TodoList, self._api.add_resource(Todo, def _goto_index(self): return self._serve_page("index.html") def _serve_page(self, file_relative_path_to_root): return send_from_directory(self._static_files_root_folder_path, file_relative_path_to_root) def run(self, module_name): if module_name == self._app.run(debug=True)
from flask import redirect, url_for ... @app.route( def metrics(): return redirect(url_for(
from flask import Flask app = Flask(__name__) @app.route( def hello_world(): data = open( return data if __name__ == app.run(host=
datetime.datetime(*time.strptime("2007-03-04T21:08:12", "%Y-%m-%dT%H:%M:%S")[:6])
import dateutil.parser yourdate = dateutil.parser.parse(datestring)
datetime.datetime.strptime("2007-03-04T21:08:12Z", "%Y-%m-%dT%H:%M:%SZ")
datetime.datetime.strptime(timestamp.translate(None,
import re conformed_timestamp = re.sub(r"[:]|([-](?!((\d{2}[:]\d{2})|(\d{4}))$))", datetime.datetime.strptime(conformed_timestamp, "%Y%m%dT%H%M%S.%f%z" )
import re import datetime conformed_timestamp = re.sub(r"[:]|([-](?!((\d{2}[:]\d{2})|(\d{4}))$))", split_timestamp = re.split(r"[+|-]",conformed_timestamp) main_timestamp = split_timestamp[0] if len(split_timestamp) == 3: sign = split_timestamp[1] offset = split_timestamp[2] else: sign = None offset = None output_datetime = datetime.datetime.strptime(main_timestamp +"Z", "%Y%m%dT%H%M%S.%fZ" ) if offset: offset_delta = datetime.timedelta(hours=int(sign+offset[:-2]), minutes=int(sign+offset[-2:])) output_datetime = output_datetime + offset_delta
>>> import arrow >>> arrow.get( datetime.datetime(2014, 11, 13, 14, 53, 18, 694072, tzinfo=tzoffset(None, 0))
import datetime import pytz import dateutil.parser utc = pytz.utc BERLIN = pytz.timezone( def to_iso8601(when=None, tz=BERLIN): if not when: when = datetime.datetime.now(tz) if not when.tzinfo: when = tz.localize(when) _when = when.strftime("%Y-%m-%dT%H:%M:%S.%f%z") return _when[:-8] + _when[-5:] def from_iso8601(when=None, tz=BERLIN): _when = dateutil.parser.parse(when) if not _when.tzinfo: _when = tz.localize(_when) return _when
import datetime, time def convert_enddate_to_seconds(self, ts): """Takes ISO 8601 format(string) and converts into epoch time.""" dt = datetime.datetime.strptime(ts[:-7], datetime.timedelta(hours=int(ts[-5:-3]), minutes=int(ts[-2:]))*int(ts[-6:-5]+ seconds = time.mktime(dt.timetuple()) + dt.microsecond/1000000.0 return seconds
>>> import datetime, time >>> ts = >>> dt = datetime.datetime.strptime(ts[:-7], >>> seconds = time.mktime(dt.timetuple()) + dt.microsecond/1000000.0 >>> seconds 1348990310.26
import datetime import time # # def TimeToISO8601(seconds): strKv = datetime.datetime.fromtimestamp(seconds).strftime( strKv = strKv + "T" strKv = strKv + datetime.datetime.fromtimestamp(seconds).strftime( strKv = strKv +"Z" return strKv # # def ISO8601ToTime(strISOTime): K1 = 0 K2 = 9999999999 K3 = 0 counter = 0 while counter < 95: K3 = (K1 + K2) / 2 strK4 = TimeToISO8601(K3) if strK4 < strISOTime: K1 = K3 if strK4 > strISOTime: K2 = K3 counter = counter + 1 return K3 # # def ISO8601ToDateTime(strISOTime): return time.gmtime(ISO8601ToTime(strISOTime)) Test = "2014-09-27T12:05:06.9876" print ("The test value is: " + Test) Ans = ISO8601ToTime(Test) print ("The answer in seconds is: " + str(Ans)) print ("And a Python datetime object is: " + str(ISO8601ToDateTime(Test)))
if [[ "$string" =~ ^hello ]]; then do something here fi
aString = "hello world" aString.startswith("hello")
regex=re.compile( if re.match(regex, somestring): print("Yes")
>>> import math >>> math.ceil(4500/1000) 4.0 >>> math.ceil(4500/1000.0) 5.0
>>> math.floor(4.4), math.floor(4.5), math.floor(5.4), math.floor(5.5) (4.0, 4.0, 5.0, 5.0) >>> round(4.4), round(4.5), round(5.4), round(5.5) (4.0, 5.0, 5.0, 6.0) >>> math.ceil(4.4), math.ceil(4.5), math.ceil(5.4), math.ceil(5.5) (5.0, 5.0, 6.0, 6.0)
from decimal import * print(int(Decimal(2.3).quantize(Decimal(
>>> def roundup(number): ... return round(number+.5) >>> roundup(2.3) 3 >>> roundup(19.00000000001) 20
def ceil(fl): return int(fl) + (1 if fl-int(fl) else 0) def ceil(self, fl): return int(fl) + (1 if fl-int(fl) else 0)
def roundUp(num): return round(num + 0.49) testCases = list(x*0.1 for x in range(0, 50)) print(testCases) for test in testCases: print("{:5.2f} -> {:5.2f}".format(test, roundUp(test)))
def int_ceil(a, b): return (a - 1) >>> int_ceil(19, 5) 4 >>> int_ceil(20, 5) 4 >>> int_ceil(21, 5) 5
>>> round_up = lambda num: int(num + 1) if int(num) != num else int(num) >>> round_up(2.0) 2 >>> round_up(2.1) 3
import matplotlib.pyplot as plt plt.rcParams.update({
import matplotlib.pyplot as plt ax = plt.subplot(111, xlabel= for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()): item.set_fontsize(20)
import matplotlib.pyplot as plt SMALL_SIZE = 8 MEDIUM_SIZE = 10 BIGGER_SIZE = 12 plt.rc( plt.rc( plt.rc( plt.rc( plt.rc( plt.rc( plt.rc(
import matplotlib SMALL_SIZE = 8 matplotlib.rc( matplotlib.rc(
import numpy as np import matplotlib.pyplot as plt import matplotlib.font_manager as font_manager title_font = { axis_font = { font_path = font_prop = font_manager.FontProperties(fname=font_path, size=14) ax = plt.subplot() for label in (ax.get_xticklabels() + ax.get_yticklabels()): label.set_fontname( label.set_fontsize(13) x = np.linspace(0, 10) y = x + np.random.normal(x) plt.plot(x, y, plt.xlabel("x axis", **axis_font) plt.ylabel("y axis", **axis_font) plt.title("Misc graph", **title_font) plt.legend(loc= plt.text(0, 0, "Misc text", **title_font) plt.show()
import numpy as np import matplotlib.pyplot as plt import matplotlib.font_manager as font_manager import matplotlib.ticker matplotlib.ticker._mathdefault = lambda x: font_path = font_prop = font_manager.FontProperties(fname=font_path, size=14) ax = plt.subplot() x = np.linspace(0, 10) y = x + np.random.normal(x) plt.plot(x, y, for label in (ax.get_xticklabels() + ax.get_yticklabels()): label.set_fontproperties(font_prop) label.set_fontsize(13) plt.title("Exponentially decaying oscillations", fontproperties=font_prop, size=16, verticalalignment= plt.xlabel("Time", fontproperties=font_prop) plt.ylabel("Amplitude", fontproperties=font_prop) plt.text(0, 0, "Misc text", fontproperties=font_prop) lgd = plt.legend(loc= lgd.set_title("Legend", prop=font_prop) plt.show()
import matplotlib.pyplot as plt import numpy as np fig = plt.figure(figsize=(4,3)) ax = fig.add_subplot(111) x = np.linspace(0,6.28,21) ax.plot(x, np.sin(x), ax.set_title("Oscillator Output") ax.set_xlabel("Time (s)") ax.set_ylabel("Output (V)") ax.grid(True) ax.legend(loc=1) fig.savefig(
import matplotlib.pyplot as plt import matplotlib.font_manager as fm fontPath = "/usr/share/fonts/abc.ttf" font = fm.FontProperties(fname=fontPath, size=10) font2 = fm.FontProperties(fname=fontPath, size=24) fig = plt.figure(figsize=(32, 24)) fig.text(0.5, 0.93, "This is my Title", horizontalalignment= plot = fig.add_subplot(1, 1, 1) plot.xaxis.get_label().set_fontproperties(font) plot.yaxis.get_label().set_fontproperties(font) plot.legend(loc= for label in (plot.get_xticklabels() + plot.get_yticklabels()): label.set_fontproperties(font)
import json from matplotlib import pyplot as plt, rcParams s = json.load(open("example_file.json") rcParams.update(s)
{ "lines.linewidth": 2.0, "axes.edgecolor": " "patch.linewidth": 0.5, "legend.fancybox": true, "axes.color_cycle": [ " " " " " " " ], "axes.facecolor": " "axes.labelsize": "large", "axes.grid": true, "patch.edgecolor": " "axes.titlesize": "x-large", "svg.fonttype": "path", "examples.directory": "" }
import matplotlib.pyplot as plt plt.figure(figsize=(4,3)) plt.savefig(
>>> s = >>> t = iter(s) >>> next(t) >>> next(t) >>> next(t) >>> next(t) Traceback (most recent call last): ... StopIteration >>> iter(t) is t
class IterableExample(object): def __iter__(self): return self def next(self): pass
class Iterator(object): def next(self): pass class Iterable(object): def __iter__(self): return Iterator()
class SmartIterableExample(object): def create_iterator(self): pass def __iter__(self): return self.create_iterator()
>>> a = [1, 2, 3] >>> b1 = iter(a) >>> b2 = iter(a) >>> next(b1) 1 >>> next(b1) 2 >>> next(b2) 1 >>> next(b1) 3 >>> next(b1) Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration >>> b1 = iter(a) >>> next(b1) 1
>>> X = [1,2,3,4,5] >>> next(X) Traceback (most recent call last): File "<pyshell next(X) TypeError:
>>> X = [1,2,3,4,5] >>> bricks_kit = [1,2,3,4,5] >>> white_piece_of_paper = iter(bricks_kit) >>> next(white_piece_of_paper) 1 >>> next(white_piece_of_paper) 2 >>>
sequence + | v def __getitem__(self, index: int): + ... | raise IndexError | | | def __iter__(self): | + ... | | return <iterator> | | | | +--> or <-----+ def __next__(self): + | + ... | | | raise StopIteration v | | iterable | | + | | | | v | +----> and +-------> iterator | ^ v | iter(<iterable>) +----------------------+ | def generator(): | + yield 1 | | generator_expression +-+ | | +-> generator() +-> generator_iterator +-+
>>> s = >>> it = iter(s) >>> it <iterator object at 0x00A1DB50> >>> next(it) >>> next(it) >>> next(it) >>> next(it) Traceback (most recent call last): File "<stdin>", line 1, in <module> next(it) StopIteration
class Reverse: def __init__(self, data): self.data = data self.index = len(data) def __iter__(self): return self def __next__(self): if self.index == 0: raise StopIteration self.index = self.index - 1 return self.data[self.index] >>> rev = Reverse( >>> iter(rev) <__main__.Reverse object at 0x00A1DB50> >>> for char in rev: ... print(char) ... m a p s
iterable = [1, 2] iterator = iter(iterable) print(iterator.__next__()) print(iterator.__next__())
>>> y.next() 1 >>> y.next() 2 >>> y.next() 3 >>> y.next() 4 >>> y.next() StopIteration
import inspect def foo(): print(inspect.stack()[0][3])
from __future__ import print_function import sys import inspect def what_is_my_name(): print(inspect.stack()[0][0].f_code.co_name) print(inspect.stack()[0][3]) print(inspect.currentframe().f_code.co_name) print(sys._getframe().f_code.co_name)
$ python -m timeit -s 1000 loops, best of 3: 499 usec per loop $ python -m timeit -s 1000 loops, best of 3: 497 usec per loop $ python -m timeit -s 10000000 loops, best of 3: 0.1 usec per loop $ python -m timeit -s 10000000 loops, best of 3: 0.135 usec per loop
import inspect def Foo(): print inspect.stack()[0][3] Foo2 = Foo >>> Foo() Foo >>> Foo2() Foo
functionNameAsString = sys._getframe().f_code.co_name
import inspect myself = lambda: inspect.stack()[1][3]
from functools import wraps def tmp_wrap(func): @wraps(func) def tmp(*args, **kwargs): print func.__name__ return func(*args, **kwargs) return tmp @tmp_wrap def my_funky_name(): print "STUB" my_funky_name()
import sys currentFuncName = lambda n=0: sys._getframe(n + 1).f_code.co_name def testFunction(): print "You are in function:", currentFuncName() print "This function def invokeTest(): testFunction() invokeTest()
import inspect def whoami(): return inspect.stack()[1][3] def whosdaddy(): return inspect.stack()[2][3] def foo(): print "hello, I bar() def bar(): print "hello, I foo() bar()
import sys def func_name(): return sys._getframe(1).f_code.co_name class A(object): def __init__(self): pass def test_class_func_name(self): print(func_name()) def test_func_name(): print(func_name())
import inspect def bar(): print("My name is", inspect.stack()[0][3])
from __future__ import print_function import inspect def bar(): print("my name is
def my_function(name=None): return name def get_function_name(function): return function(name=function.__name__) >>> get_function_name(my_function)
import sys def myFunctionsHere(): print(sys._getframe().f_code.co_name) myFunctionsHere()
def safe_super(_class, _inst): try: return getattr(super(_class, _inst), _inst.__fname__) except: return (lambda *x,**kx: None) def with_name(function): def wrap(self, *args, **kwargs): self.__fname__ = function.__name__ return function(self, *args, **kwargs) return wrap
class A(object): def __init__(): super(A, self).__init__() @with_name def test(self): print safe_super(A, self)() class B(object): def __init__(): super(B, self).__init__() @with_name def test(self): print safe_super(B, self)() class C(A, B): def __init__(): super(C, self).__init__() @with_name def test(self): print safe_super(C, self)()
import sys def thisFunctionName(): return sys._getframe(1).f_code.co_name
import sys def foo(): print(eval(sys._getframe().f_code.co_name).__doc__)
>>> print (quit) Use quit() or Ctrl-Z plus Return to exit >>>
>>> print (exit) Use exit() or Ctrl-Z plus Return to exit >>>
>>> exit Use exit() or Ctrl-D (i.e. EOF) to exit >>> exit() $
from matplotlib import pyplot as plt fig = plt.figure() plt.plot(data) fig.suptitle( plt.xlabel( plt.ylabel( fig.savefig(
from matplotlib import pyplot as plt fig = plt.figure() plt.plot(data) fig.suptitle( plt.xlabel( plt.ylabel( fig.savefig(
import matplotlib.pylab as pylab params = { pylab.rcParams.update(params)
import matplotlib.pyplot as plt fig, ax = plt.subplots() x = [0, 1, 2] y = [0, 3, 9] ax.plot(x,y) fig.suptitle( ax.set_xlabel( ax.set_ylabel( ax.xaxis.label.set_size(20) plt.draw()
import matplotlib.pyplot as plt fig = plt.Figure() ax = fig.add_subplot(111) ax.set_title(
>>> original = dict(a=1, b=2) >>> new = original.copy() >>> new.update({ >>> original { >>> new {
>>> original = [1, 2, 3] >>> new = original >>> new.append(4) >>> new, original ([1, 2, 3, 4], [1, 2, 3, 4])
>>> a = {1: [1,2,3]} >>> b = a.copy() >>> a, b ({1: [1, 2, 3]}, {1: [1, 2, 3]}) >>> a[1].append(4) >>> a, b ({1: [1, 2, 3, 4]}, {1: [1, 2, 3, 4]})
>>> import copy >>> c = copy.deepcopy(a) >>> a, c ({1: [1, 2, 3, 4]}, {1: [1, 2, 3, 4]}) >>> a[1].append(5) >>> a, c ({1: [1, 2, 3, 4, 5]}, {1: [1, 2, 3, 4]})
>>> new = original.copy() >>> >>> new = list(original)
original = dict(a=1, b=2, c=dict(d=4, e=5)) new = original.copy()
parent = {1: [1,2,3]} parent_copy = parent.copy() parent_reference = parent print id(parent),id(parent_copy),id(parent_reference) print id(parent[1]),id(parent_copy[1]),id(parent_reference[1]) parent_copy[1].append(4) parent_copy[2] = [ print parent, parent_copy, parent_reference
import numpy as np import cv2 fn = a = np.loadtxt(fn, np.float32, delimiter= samples, responses = a[:,1:], a[:,0] model = cv2.KNearest() retval = model.train(samples,responses) retval, results, neigh_resp, dists = model.find_nearest(samples, k = 10) print results.ravel()
import sys import numpy as np import cv2 im = cv2.imread( im3 = im.copy() gray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY) blur = cv2.GaussianBlur(gray,(5,5),0) thresh = cv2.adaptiveThreshold(blur,255,1,1,11,2) contours,hierarchy = cv2.findContours(thresh,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE) samples = np.empty((0,100)) responses = [] keys = [i for i in range(48,58)] for cnt in contours: if cv2.contourArea(cnt)>50: [x,y,w,h] = cv2.boundingRect(cnt) if h>28: cv2.rectangle(im,(x,y),(x+w,y+h),(0,0,255),2) roi = thresh[y:y+h,x:x+w] roismall = cv2.resize(roi,(10,10)) cv2.imshow( key = cv2.waitKey(0) if key == 27: sys.exit() elif key in keys: responses.append(int(chr(key))) sample = roismall.reshape((1,100)) samples = np.append(samples,sample,0) responses = np.array(responses,np.float32) responses = responses.reshape((responses.size,1)) print "training complete" np.savetxt( np.savetxt(
import cv2 import numpy as np samples = np.loadtxt( responses = np.loadtxt( responses = responses.reshape((responses.size,1)) model = cv2.KNearest() model.train(samples,responses) im = cv2.imread( out = np.zeros(im.shape,np.uint8) gray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY) thresh = cv2.adaptiveThreshold(gray,255,1,1,11,2) contours,hierarchy = cv2.findContours(thresh,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE) for cnt in contours: if cv2.contourArea(cnt)>50: [x,y,w,h] = cv2.boundingRect(cnt) if h>28: cv2.rectangle(im,(x,y),(x+w,y+h),(0,255,0),2) roi = thresh[y:y+h,x:x+w] roismall = cv2.resize(roi,(10,10)) roismall = roismall.reshape((1,100)) roismall = np.float32(roismall) retval, results, neigh_resp, dists = model.find_nearest(roismall, k = 1) string = str(int((results[0][0]))) cv2.putText(out,string,(x,y+h),0,1,(0,255,0)) cv2.imshow( cv2.imshow( cv2.waitKey(0)
$ arch -x86_64 /usr/bin/python2.6 -c 64bit True $ arch -i386 /usr/bin/python2.6 -c 64bit False
>>> import sys >>> "Python {:s} on {:s}".format(sys.version, sys.platform) >>> hex(sys.maxsize), sys.maxsize > 0x100000000 (
>>> import sys >>> "Python {:s} on {:s}".format(sys.version, sys.platform) >>> hex(sys.maxsize), sys.maxsize > 0x100000000 (
>>> import sys >>> "Python {:s} on {:s}".format(sys.version, sys.platform) >>> hex(sys.maxsize), sys.maxsize > 0x100000000 (
>>> import sys >>> "Python {:s} on {:s}".format(sys.version, sys.platform) >>> hex(sys.maxsize), sys.maxsize > 0x100000000 (
>>> import sys >>> "Python {:s} on {:s}".format(sys.version, sys.platform) >>> hex(sys.maxsize), sys.maxsize > 0x100000000 (
>>> import ctypes >>> ctypes.sizeof(ctypes.c_void_p) * 8 64
>>> import ctypes >>> ctypes.sizeof(ctypes.c_void_p) * 8 64
>>> import ctypes >>> ctypes.sizeof(ctypes.c_void_p) * 8 32
>>> import ctypes >>> ctypes.sizeof(ctypes.c_void_p) * 8 64
>>> import ctypes >>> ctypes.sizeof(ctypes.c_void_p) * 8 32
>>> import os >>> os.system("file {:s}".format(os.path.realpath(sys.executable))) /opt/OPSWbuildtools/2.0.6/bin/python2.7.global: Mach-O 64-bit executable x86_64
>>> import os >>> os.system("file {:s}".format(os.path.realpath(sys.executable))) /usr/bin/python3.5: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=59a8ef36ca241df24686952480966d7bc0d7c6ea, stripped
>>> import os >>> os.system("file {:s}".format(os.path.realpath(sys.executable))) /home/cfati/Work/Dev/Python-3.6.4/python: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5c3d4eeadbd13cd91445d08f90722767b0747de2, not stripped
>>> import os >>> os.environ["PROCESSOR_ARCHITECTURE"]
>>> import os >>> os.environ["PROCESSOR_ARCHITECTURE"]
C:\Users\xyz>python Python 2.7.6 (default, Nov XY ..., 19:24:24) **[MSC v.1500 64 bit (AMD64)] on win 32** Type "help", "copyright", "credits" or "license" for more information. >>>
$ arch -i386 /usr/local/bin/python2.7 Python 2.7.9 (v2.7.9:648dcafa7e5f, Dec 10 2014, 10:10:46) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> import platform, sys >>> platform.architecture(), sys.maxsize (( >>> ^D $ arch -x86_64 /usr/local/bin/python2.7 Python 2.7.9 (v2.7.9:648dcafa7e5f, Dec 10 2014, 10:10:46) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> import platform, sys >>> platform.architecture(), sys.maxsize ((
String str = "many fancy word \nhello \thi"; String whiteSpaceRegex = "\\s"; String[] words = str.split(whiteSpaceRegex); ["many", "fancy", "word", "hello", "hi"]
import re s = "many fancy word \nhello \thi" re.split(
>>> import re >>> s = "many fancy word \nhello \thi" >>> re.findall(r [
% cd ~/tmp % mkdir lib % touch lib/__init__.py % cat > lib/BoxTime.py << EOF heredoc> def foo(): heredoc> print "foo!" heredoc> EOF % tree lib lib ├── BoxTime.py └── __init__.py 0 directories, 2 files % python Python 2.7.6 (default, Mar 22 2014, 22:59:56) [GCC 4.8.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> from lib import BoxTime >>> BoxTime.foo() foo!
from anything.mylib import MyClass from anything.mylib import myfun instance = MyClass() result = myfun()
import sys, os sys.path.append(os.path.dirname(os.path.realpath(__file__)) + "/relative/path/to/your/lib/folder") import someFileNameWhichIsInTheFolder ... somefile.foo()
/root/anotherproject/utils.py /root/anotherproject/__init__.py
import sys, os sys.path.append(os.path.dirname(os.path.realpath(__file__)) + "/../anotherproject") import utils utils.foo()
from lib.BoxTime import bt_function ... bt_function()
list1 = "abcdefghij" list2 = list(list1) print(list2) list3 = list2[:-1] print(list3)
list1 = input ("Enter :") list2 = list(list1) print(list2) list3 = list2[:-1] print(list3)
list1 = input("Enter :") list2 = list1.split() print(list2) list3 = list2[:-1] print(list3)
df1 = pandas.DataFrame( { "Name" : ["Alice", "Bob", "Mallory", "Mallory", "Bob" , "Mallory"] , "City" : ["Seattle", "Seattle", "Portland", "Seattle", "Seattle", "Portland"] } )
City Name 0 Seattle Alice 1 Seattle Bob 2 Portland Mallory 3 Seattle Mallory 4 Seattle Bob 5 Portland Mallory
City Name Name City Alice Seattle 1 1 Bob Seattle 2 2 Mallory Portland 2 2 Seattle 1 1
City Name Name City Alice Seattle 1 1 Bob Seattle 2 2 Mallory Portland 2 2 Mallory Seattle 1 1
In [19]: type(g1) Out[19]: pandas.core.frame.DataFrame In [20]: g1.index Out[20]: MultiIndex([( (
In [21]: g1.add_suffix( Out[21]: Name City City_Count Name_Count 0 Alice Seattle 1 1 1 Bob Seattle 2 2 2 Mallory Portland 2 2 3 Mallory Seattle 1 1
In [36]: DataFrame({ Out[36]: Name City count 0 Alice Seattle 1 1 Bob Seattle 2 2 Mallory Portland 2 3 Mallory Seattle 1
import pandas as pd df1 = pd.DataFrame({"Name":["Alice", "Bob", "Mallory", "Mallory", "Bob" , "Mallory"], "City":["Seattle","Seattle","Portland","Seattle","Seattle","Portland"]}) print df1 # # g1 = df1.groupby(["Name", "City"], as_index=False).count() print g1 # #
print df1.groupby(["Name", "City"], as_index=False ).count() print df1.groupby(["Name", "City"]).count() print df1.groupby(["Name", "City"])[[ print df1.groupby(["Name", "City"]).size().reset_index(name=
import pandas as pd grouped_df = df1.groupby( [ "Name", "City"] ) pd.DataFrame(grouped_df.size().reset_index(name = "Group_Count"))
import numpy as np import pandas as pd df1 = pd.DataFrame({ "Name" : ["Alice", "Bob", "Mallory", "Mallory", "Bob" , "Mallory"] , "City" : ["Seattle", "Seattle", "Portland", "Seattle", "Seattle", "Portland"]}) df1[ df1[ df1.groupby([
df = df[ df = df.to_frame() df = df.reset_index(level=[
almo_grp_data = pd.DataFrame({ almo_slt_models_data.groupby( [ )[
df1.reset_index().groupby( [ "Name", "City"],as_index=False ).count()
df_grouped = df[[ df_grouped = df_grouped.groupby([ df_aggregated = df_grouped.size().to_frame( df_aggregated[ df_aggregated[ df_aggregated[ def manualAggregations(indices_array): temp_df = df.iloc[indices_array] return { } for name, group in df_grouped: ix = df_grouped.indices[name] calcDict = manualAggregations(ix) for key in calcDict: columns = list(name) df_aggregated.loc[(df_aggregated[ (df_aggregated[
pip install --install-option="--prefix=$PREFIX_PATH" package_name
PYTHONUSERBASE=/path/to/install/to pip install --user
PYTHONUSERBASE=/opt/mysterypackage-1.0/python-deps pip install --user --upgrade numpy scipy
export PYTHONPATH=/opt/mysterypackage-1.0/python-deps/lib64/python2.6/site-packages:$PYTHONPATH export PATH=/opt/mysterypackage-1.0/python-deps/bin:$PATH
pip install --install-option="--install-purelib=/python/packages" package_name
[install] install-option=--install-purelib=/python/packages
vim ~/.pydistutils.cfg [install] install-data=/usr/local/lib/python2.7 install-scripts=/usr/local/lib/python2.7/bin
$ pip install --root=/alternative/prefix/path package_name
error: install-base or install-platbase supplied, but installation scheme is incomplete
[install] install-base=$HOME install-purelib=python/lib install-platlib=python/lib.$PLAT install-scripts=python/scripts install-headers=python/include install-data=python/data
cmap = { def cxlate(country): try: ret = cmap[country] except: ret = return ret present = missing = print cxlate(present) print cxlate(missing) print cmap.get(present, print cmap.get(missing, print cmap.get(present,present) print cmap.get(missing,missing)
import types d = types.DictType.__new__(types.DictType, (), {})
dict_you_want = { your_key: old_dict[your_key] for your_key in your_keys }
unwanted = set(keys) - set(your_dict) for unwanted_key in unwanted: del your_dict[unwanted_key]
foodict = {k: v for k, v in mydict.items() if k.startswith(
>>> a = {1:1, 2:2, 3:3} >>> dict((key,value) for key, value in a.iteritems() if key == 1) {1: 1}
from funcy import project small_dict = project(big_dict, keys)
dictfilt = lambda x, y: dict([ (i,x[i]) for i in x if i in set(y) ])
my_dict = {"a":1,"b":2,"c":3,"d":4} wanted_keys = ("c","d") In [10]: dictfilt(my_dict, wanted_keys) Out[10]: {
filtered = dict(zip(keys, [orig[k] for k in keys]))
dict = { key: key * 10 for key in range(0, 100) } d1 = {} for key, value in dict.items(): if key % 2 == 0: d1[key] = value
dict = { key: key * 10 for key in range(0, 100) } d2 = {key: value for key, value in dict.items() if key % 2 == 0}
dict = { key: key * 10 for key in range(0, 100) } d3 = { key: dict[key] for key in dict.keys() if key % 2 == 0}
old_dict = { wanted_keys = [ new_dict = {k: old_dict[k] for k in set(wanted_keys) & set(old_dict.keys())} >>> new_dict {
default = None new_dict = {k: old_dict[k] if k in old_dict else default for k in wanted_keys} >>> new_dict {
def include_keys(dictionary, keys): key_set = set(keys) & set(dictionary.keys()) return {key: dictionary[key] for key in key_set}
def exclude_keys(dictionary, keys): key_set = set(dictionary.keys()) - set(keys) return {key: dictionary[key] for key in key_set}
[s.pop(k) for k in list(s.keys()) if k not in keep]
content = dict(k1= selection = [ filtered = filter(lambda i: i[0] in selection, content.items())
>>> convert( >>> convert( >>> convert( >>> convert( >>> convert( >>> convert( >>> convert(
first_cap_re = re.compile( all_cap_re = re.compile( def convert(name): s1 = first_cap_re.sub(r return all_cap_re.sub(r
>>> re.sub( >>> re.sub( >>> re.sub( >>> re.sub( >>> re.sub(
>>> a = re.compile( >>> a.sub(r >>> a.sub(r >>> a.sub(r >>> a.sub(r >>> a.sub(r
def to_snake_case(not_snake_case): final = for i in xrange(len(not_snake_case)): item = not_snake_case[i] if i < len(not_snake_case) - 1: next_char_will_be_underscored = ( not_snake_case[i+1] == "_" or not_snake_case[i+1] == " " or not_snake_case[i+1].isupper() ) if (item == " " or item == "_") and next_char_will_be_underscored: continue elif (item == " " or item == "_"): final += "_" elif item.isupper(): final += "_"+item.lower() else: final += item if final[0] == "_": final = final[1:] return final >>> to_snake_case("RegularExpressionsAreFunky") >>> to_snake_case("RegularExpressionsAre Funky") >>> to_snake_case("RegularExpressionsAre_Funky")
>>> from stringcase import pascalcase, snakecase >>> snakecase( >>> pascalcase(
def un_camel(text): """ Converts a CamelCase name into an under_score name. >>> un_camel( >>> un_camel( """ result = [] pos = 0 while pos < len(text): if text[pos].isupper(): if pos-1 > 0 and text[pos-1].islower() or pos-1 > 0 and \ pos+1 < len(text) and text[pos+1].islower(): result.append("_%s" % text[pos].lower()) else: result.append(text[pos].lower()) else: result.append(text[pos]) pos += 1 return "".join(result)
import re def convert (camel_input): words = re.findall(r return test_strings = [ ] for test_string in test_strings: print(convert(test_string))
camel_case camel_camel_case camel_2_camel_2_case get_http_response_code get_200_http_response_code get_http_200_response_code http_response_code response_http response_http_2 fun_awesome fun_awesome 10_cool_dudes 20_cool_dudes
>>> def un_camel(input): ... output = [input[0].lower()] ... for c in input[1:]: ... if c in ( ... output.append( ... output.append(c.lower()) ... else: ... output.append(c) ... return str.join( ... >>> un_camel("camel_case") >>> un_camel("CamelCase")
>>> un_camel = lambda i: i[0].lower() + str.join( >>> un_camel("camel_case") >>> un_camel("CamelCase")
def splitSymbol(s): si, ci, state = 0, 0, 0 state bits: 0: no yields 1: lower yields 2: lower yields - 1 4: upper yields 8: digit yields 16: other yields 32 : upper sequence mark for c in s: if c.islower(): if state & 1: yield s[si:ci] si = ci elif state & 2: yield s[si:ci - 1] si = ci - 1 state = 4 | 8 | 16 ci += 1 elif c.isupper(): if state & 4: yield s[si:ci] si = ci if state & 32: state = 2 | 8 | 16 | 32 else: state = 8 | 16 | 32 ci += 1 elif c.isdigit(): if state & 8: yield s[si:ci] si = ci state = 1 | 4 | 16 ci += 1 else: if state & 16: yield s[si:ci] state = 0 ci += 1 si = ci print( if state: yield s[si:ci] def camelcaseToUnderscore(s): return
def to_snake_case(s): snake = "".join(["_"+c.lower() if c.isupper() else c for c in s]) return snake[1:] if snake.startswith("_") else snake
def uncamelize(s): buff, l = for ltr in s: if ltr.isupper(): if buff: l.append(buff) buff = buff += ltr l.append(buff) return
class MapPrice(Model): price_before_vat = DecimalType(serialized_name= vat_rate = DecimalType(serialized_name= vat = DecimalType() total_price = DecimalType(serialized_name=
>>> import re >>> def camel_to_snake(string): ... groups = re.findall( ... return ... >>> camel_to_snake(
def f(s): return s.group(1).lower() + "_" + s.group(2).lower() p = re.compile("([A-Z]+[a-z]+)([A-Z]?)") print p.sub(f, "CamelCase") print p.sub(f, "getHTTPResponseCode")
p = re.compile("([A-Z]+[a-z]+)([A-Z]?)") print p.sub(lambda x: x.group(1).lower() + "_" + x.group(2).lower(), "CamelCase") print p.sub(lambda x: x.group(1).lower() + "_" + x.group(2).lower(), "getHTTPResponseCode")
"-".join(x.group(1).lower() if x.group(2) is None else x.group(1) \ for x in re.finditer("((^.[^A-Z]+)|([A-Z][^A-Z]+))", "stringToSplit"))
"-".join(x.group(1).lower() for x in re.finditer("(^[^A-Z]+|[A-Z][^A-Z]+)", "stringToSplit"))
def from_camel(name): name = name.replace("_", "") _cas = lambda _x : [_i.isupper() for _i in _x] seq = zip(_cas(name[1:-1]), _cas(name[2:])) ss = [_x + 1 for _x, (_i, _j) in enumerate(seq) if (_i, _j) == (False, True)] return "".join([ch + "_" if _x in ss else ch for _x, ch in numerate(name.lower())])
def camelify(out): return ( else x.lower()+"_" if i<len(out)-1 and x.islower() and out[i+1].isupper() else x.lower() for i,x in enumerate(list(out))])).lstrip(
CamelCamelCamelCase -> camel_camel_camel_case HTTPRequest -> http_request GetHTTPRequest -> get_http_request getHTTPRequest -> get_http_request
def convert(name): return reduce( lambda x, y: x + ( name ).lower()
def convert(name): return reduce( lambda x, y: x + ( name ).lower()
camelCaseCode =""" cv2.Matx33d ComputeZoomMatrix(const cv2.Point2d & zoomCenter, double zoomRatio) { auto mat = cv2.Matx33d::eye(); mat(0, 0) = zoomRatio; mat(1, 1) = zoomRatio; mat(0, 2) = zoomCenter.x * (1. - zoomRatio); mat(1, 2) = zoomCenter.y * (1. - zoomRatio); return mat; } """ import re def snake_case(name): s1 = re.sub( return re.sub( def lines(str): return str.split("\n") def unlines(lst): return "\n".join(lst) def words(str): return str.split(" ") def unwords(lst): return " ".join(lst) def map_partial(function): return lambda values : [ function(v) for v in values] import functools def compose(*functions): return functools.reduce(lambda f, g: lambda x: f(g(x)), functions, lambda x: x) snake_case_code = compose( unlines , map_partial(unwords), map_partial(map_partial(snake_case)), map_partial(words), lines ) print(snake_case_code(camelCaseCode))
import re def camelcase_to_underscore(s): return re.sub(r lambda m: s)
import re CC2US_RE = re.compile(r def _replace(match): return def camelcase_to_underscores(s): return CC2US_RE.sub(_replace, s)
def convert(camel_str): temp_list = [] for letter in camel_str: if letter.islower(): temp_list.append(letter) else: temp_list.append( temp_list.append(letter) result = "".join(temp_list) return result.lower()
text = "test" def harvester(text, case): X = case[0] text+ str(X) if __name__ == pool = multiprocessing.Pool(processes=6) case = RAW_DATASET pool.map(harvester(text,case),case, 1) pool.close() pool.join()
import multiprocessing from itertools import product def merge_names(a, b): return if __name__ == names = [ with multiprocessing.Pool(processes=3) as pool: results = pool.starmap(merge_names, product(names, repeat=2)) print(results)
import multiprocessing from itertools import product from contextlib import contextmanager def merge_names(a, b): return def merge_names_unpack(args): return merge_names(*args) @contextmanager def poolcontext(*args, **kwargs): pool = multiprocessing.Pool(*args, **kwargs) yield pool pool.terminate() if __name__ == names = [ with poolcontext(processes=3) as pool: results = pool.map(merge_names_unpack, product(names, repeat=2)) print(results)
import multiprocessing from functools import partial from contextlib import contextmanager @contextmanager def poolcontext(*args, **kwargs): pool = multiprocessing.Pool(*args, **kwargs) yield pool pool.terminate() def merge_names(a, b): return if __name__ == names = [ with poolcontext(processes=3) as pool: results = pool.map(partial(merge_names, b= print(results)
from functools import partial from itertools import repeat from multiprocessing import Pool, freeze_support def func(a, b): return a + b def main(): a_args = [1,2,3] second_arg = 1 with Pool() as pool: L = pool.starmap(func, [(1, 1), (2, 1), (3, 1)]) M = pool.starmap(func, zip(a_args, repeat(second_arg))) N = pool.map(partial(func, b=second_arg), a_args) assert L == M == N if __name__=="__main__": freeze_support() main()
import itertools from multiprocessing import Pool, freeze_support def func(a, b): print a, b def func_star(a_b): """Convert `f([1,2])` to `f(1,2)` call.""" return func(*a_b) def main(): pool = Pool() a_args = [1,2,3] second_arg = 1 pool.map(func_star, itertools.izip(a_args, itertools.repeat(second_arg))) if __name__=="__main__": freeze_support() main()
def multi_run_wrapper(args): return add(*args) def add(x,y): return x+y if __name__ == "__main__": from multiprocessing import Pool pool = Pool(4) results = pool.map(multi_run_wrapper,[(1,2),(2,3),(3,4)]) print results
from multiprocessing.dummy import Pool as ThreadPool def write(i, x): print(i, "---", x) a = ["1","2","3"] b = ["4","5","6"] pool = ThreadPool(2) pool.starmap(write, zip(a,b)) pool.close() pool.join()
import parmap y = [myfunction(x, argument1, argument2) for x in mylist] y = parmap.map(myfunction, mylist, argument1, argument2) z = [myfunction(x, y, argument1, argument2) for (x,y) in mylist] z = parmap.starmap(myfunction, mylist, argument1, argument2) listx = [1, 2, 3, 4, 5, 6] listy = [2, 3, 4, 5, 6, 7] param = 3.14 param2 = 42 listz = [] for (x, y) in zip(listx, listy): listz.append(myfunction(x, y, param1, param2)) listz = parmap.starmap(myfunction, zip(listx, listy), param1, param2)
import parmap def harvester(case, text): X = case[0] text+ str(X) if __name__ == "__main__": case = RAW_DATASET parmap.map(harvester, case, "test", chunksize=1)
Python 2.7.5 (default, Sep 30 2013, 20:15:49) [GCC 4.2.1 (Apple Inc. build 5566)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> def func(a,b): ... print a,b ... >>> >>> from pathos.multiprocessing import ProcessingPool >>> pool = ProcessingPool(nodes=4) >>> pool.map(func, [1,2,3], [1,1,1]) 1 1 2 1 3 1 [None, None, None] >>> >>> >>> result = pool.map(lambda x: x**2, range(10)) >>> result [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] >>> >>> >>> result = pool.amap(pow, [1,2,3], [4,5,6]) >>> result.get() [1, 32, 729] >>> >>> >>> result = pool.imap(pow, [1,2,3], [4,5,6]) >>> result <processing.pool.IMapIterator object at 0x110c2ffd0> >>> list(result) [1, 32, 729]
import itertools from multiprocessing import Pool def universal_worker(input_pair): function, args = input_pair return function(*args) def pool_args(function, *args): return zip(itertools.repeat(function), zip(*args))
pool = Pool(n_core) list_model = pool.map(universal_worker, pool_args(function, arg_0, arg_1, arg_2) pool.close() pool.join()
def unpack_args(func): from functools import wraps @wraps(func) def wrapper(args): if isinstance(args, dict): return func(**args) else: return func(*args) return wrapper @unpack_args def func(x, y): return x + y
np, xlist, ylist = 2, range(10), range(10) pool = Pool(np) res = pool.map(func, zip(xlist, ylist)) pool.close() pool.join()
from multiprocessing import Pool def f((a,b,c,d)): print a,b,c,d return a + b + c +d if __name__ == p = Pool(10) data = [(i+0,i+1,i+2,i+3) for i in xrange(10)] print(p.map(f, data)) p.close() p.join()
0 1 2 3 1 2 3 4 2 3 4 5 3 4 5 6 4 5 6 7 5 6 7 8 7 8 9 10 6 7 8 9 8 9 10 11 9 10 11 12 [6, 10, 14, 18, 22, 26, 30, 34, 38, 42]
from multiprocessing import Pool def func((i, (a, b))): print i, a, b return a + b pool = Pool(3) pool.map(func, [(0,(1,2)), (1,(2,3)), (2,(3, 4))])
import os from multiprocessing import Pool def task(args): print "PID =", os.getpid(), ", arg1 =", args[0], ", arg2 =", args[1] pool = Pool() pool.map(task, [ [1,2], [3,4], [5,6], [7,8] ])
import multiprocessing as mp def foo(q, h, w): q.put(h + print(h + if __name__ == ctx = mp.get_context( q = ctx.Queue() p = ctx.Process(target=foo, args=(q, p.start() print(q.get()) p.join()
def f1(args): a, b, c = args[0] , args[1] , args[2] return a+b+c if __name__ == "__main__": import multiprocessing pool = multiprocessing.Pool(4) result1 = pool.map(f1, [ [1,2,3] ]) print(result1)
from multiprocessing import Process, Pool, Manager text = "test" def harvester(text, case, q = None): X = case[0] res = text+ str(X) if q: q.put(res) return res def block_until(q, results_queue, until_counter=0): i = 0 while i < until_counter: results_queue.put(q.get()) i+=1 if __name__ == pool = multiprocessing.Pool(processes=6) case = RAW_DATASET m = Manager() q = m.Queue() results_queue = m.Queue() blocking_process = Process(block_until, (q, results_queue, len(case))) blocking_process.start() for c in case: try: res = pool.apply_async(harvester, (text, case, q = None)) res.get(timeout=0.1) except: pass blocking_process.join()
text = "test" def unpack(args): return args[0](*args[1:]) def harvester(text, case): X = case[0] text+ str(X) if __name__ == pool = multiprocessing.Pool(processes=6) case = RAW_DATASET args = [(harvester, text, c) for c in case] pool.map(unpack, args) pool.close() pool.join()
def fun(a,b): return a+b pool = multiprocessing.Pool(processes=6) b=233 pool.map(lambda x:fun(x,b),range(1000))
>>> from collections import defaultdict >>> s = >>> d = defaultdict(int) >>> for k in s: ... d[k] += 1 ... >>> d.items() [(
>>> s = [( >>> d = defaultdict(list) >>> for k, v in s: ... d[k].append(v) ... >>> d.items() [(
somedict = {} print(somedict[3]) someddict = defaultdict(int) print(someddict[3])
>>> d_int = defaultdict(int) >>> d_list = defaultdict(list) >>> def foo(): ... return ... >>> d_foo = defaultdict(foo) >>> d_int defaultdict(<type >>> d_list defaultdict(<type >>> d_foo defaultdict(<function foo at 0x7f34a0a69578>, {})
>>> d_int = defaultdict(int, a=10, b=12, c=13) >>> d_int defaultdict(<type
>>> kwargs = { >>> d_int = defaultdict(int, **kwargs) >>> d_int defaultdict(<type
>>> d_int[ 10 >>> d_int[ 0 >>> d_int defaultdict(<type
>>> d_int.default_factory = lambda: 1 >>> d_int[ 1 >>> d_int defaultdict(<function <lambda> at 0x7f34a0a91578>, {
>>> def foo(): ... return 2 >>> d_int.default_factory = foo >>> d_int[ 2 >>> d_int defaultdict(<function foo at 0x7f34a0a0a140>, {
>>> s = >>> d = defaultdict(int) >>> d.default_factory <type >>> for k in s: ... d[k] += 1 >>> d.items() [( >>> d defaultdict(<type
>>> s = [( >>> d = defaultdict(list) >>> d.default_factory <type >>> for k, v in s: ... d[k].append(v) >>> d.items() [( >>> d defaultdict(<type
class MyDict(defaultdict): def __missing__(self, key): value = [None, None] self[key] = value return value
from collections import defaultdict ice_cream = defaultdict(lambda: ice_cream = defaultdict(lambda: ice_cream[ ice_cream[ print(ice_cream[ >>>Chunky Monkey print(ice_cream[ >>>Vanilla
from collections import defaultdict def delete_nth_naive(array, n): ans = [] for num in array: if ans.count(num) < n: ans.append(num) return ans def delete_nth(array,n): result = [] counts = defaultdict(int) for i in array: if counts[i] < n: result.append(i) counts[i] += 1 return result x = [1,2,3,1,2,1,2,3] print(delete_nth(x, n=2)) print(delete_nth_naive(x, n=2))
>>> x = int >>> x <type >>> y = int(5) >>> y 5 >>> z = x(5) >>> z 5 >>> from collections import defaultdict >>> dd = defaultdict(int) >>> dd defaultdict(<type >>> dd = defaultdict(x) >>> dd defaultdict(<type >>> dd[ 0 >>> dd defaultdict(<type
>>> dd2 = defaultdict(0) Traceback (most recent call last): File "<pyshell dd2 = defaultdict(0) TypeError: first argument must be callable
>>> dd2 = defaultdict(lambda: 0) >>> dd2 defaultdict(<function <lambda> at 0x02C4C130>, {}) >>> dd2[ 0 >>> dd2 defaultdict(<function <lambda> at 0x02C4C130>, { >>>
>>> dd3 = defaultdict(lambda: 1) >>> dd3 defaultdict(<function <lambda> at 0x02C4C170>, {}) >>> dd3[ 1 >>> dd3 defaultdict(<function <lambda> at 0x02C4C170>, { >>>
import collections d = collections.defaultdict(int) for i in range(10): d[i] += i print(d) import collections d = {} for i in range(10): d[i] += i print(d)
option = 1 switch(option) { case 1: print case 2: print case 3: print default: return }
from collections import defaultdict def default_value(): return "Default Value" dd = defaultdict(default_value) dd[1] = dd[2] = dd[3] = print(dd[4]) print(dd[5]) print(dd[3])
>>> from collections import defaultdict >>> food_list = >>> food_count = defaultdict(int) >>> for food in food_list: ... food_count[food] += 1 ... defaultdict(<type >>>
import collections def default_factory(): return d = collections.defaultdict(default_factory, foo= print print print
$ python collections_defaultdict.py d: defaultdict(<function default_factory at 0x100468c80>, { foo => bar bar => default value
from collections import defaultdict d = defaultdict(list) d[ d[ d[ for i in d.items(): print i
pip install -I <package> pip install --ignore-installed <package>
$ sudo pip install --upgrade --no-deps --force-reinstall <packagename>
pip install --upgrade --no-deps --force-reinstall -r requirements.txt
def RepresentsInt(s): try: int(s) return True except ValueError: return False >>> print RepresentsInt("+123") True >>> print RepresentsInt("10.0") False
def check_int(s): if s[0] in ( return s[1:].isdigit() return s.isdigit()
import sys, time, re g_intRegex = re.compile(r"^([+-]?[1-9]\d*|0)$") testvals = [ 0, 1, -1, 1.0, -1.0, 1.1, -1.1, ] def isInt_try(v): try: i = int(v) except: return False return True def isInt_str(v): v = str(v).strip() return v== def isInt_re(v): import re if not hasattr(isInt_re, isInt_re.intRegex = re.compile(r"^([+-]?[1-9]\d*|0)$") return isInt_re.intRegex.match(str(v).strip()) is not None def isInt_re2(v): return g_intRegex.match(str(v).strip()) is not None def check_int(s): s = str(s) if s[0] in ( return s[1:].isdigit() return s.isdigit() def timeFunc(func, times): t1 = time.time() for n in range(times): for v in testvals: r = func(v) t2 = time.time() return t2 - t1 def testFuncs(funcs): for func in funcs: sys.stdout.write( "\t%s\t|" % func.__name__) print() for v in testvals: if type(v) == type( sys.stdout.write(" else: sys.stdout.write("%s" % str(v)) for func in funcs: sys.stdout.write( "\t\t%s\t|" % func(v)) sys.stdout.write("\r\n") if __name__ == print() print("tests..") testFuncs((isInt_try, isInt_str, isInt_re, isInt_re2, check_int)) print() print("timings..") print("isInt_try: %6.4f" % timeFunc(isInt_try, 10000)) print("isInt_str: %6.4f" % timeFunc(isInt_str, 10000)) print("isInt_re: %6.4f" % timeFunc(isInt_re, 10000)) print("isInt_re2: %6.4f" % timeFunc(isInt_re2, 10000)) print("check_int: %6.4f" % timeFunc(check_int, 10000))
timings.. isInt_try: 0.6426 isInt_str: 0.7382 isInt_re: 1.1156 isInt_re2: 0.5344 check_int: 0.3452
isInt_try | isInt_str | isInt_re | isInt_re2 | check_int | 0 True | True | True | True | True | 1 True | True | True | True | True | -1 True | True | True | True | True | 1.0 True | True | False | False | False | -1.0 True | True | False | False | False | 1.1 True | False | False | False | False | -1.1 True | False | False | False | False | <obj..> False | False | False | False | False | (1, 2, 3) False | False | False | False | False | [1, 2, 3] False | False | False | False | False | {
def isInt_float(s): try: return float(str(s)).is_integer() except: return False
import re def RepresentsInt(s): return re.match(r"[-+]?\d+$", s) is not None
def RepresentsInt(s): return re.match(r"[-+]?\d+(\.0*)?$", s) is not None
def isInteger(i): i = str(i) return i== def isIntegre(i): import re if not hasattr(isIntegre, print("I compile only once. Remove this line when you are confident in that.") isIntegre._re = re.compile(r"[-+]?\d+(\.0*)?$") return isIntegre._re.match(str(i)) is not None if __name__ == for obj in [ 0, 1, -1, 1.0, -1.0, 1.1, -1.1, ]: integer = ( integre = ( if isinstance(obj, str): obj = (" print("%30s is %14s is %14s" % (obj, integer, integre))
I compile only once. Remove this line when you are confident in that. 0 is an integer is an integre 1 is an integer is an integre -1 is an integer is an integre 1.0 is an integer is an integre -1.0 is an integer is an integre 1.1 is NOT an integer is NOT an integre -1.1 is NOT an integer is NOT an integre <object object at 0x103b7d0a0> is NOT an integer is NOT an integre (1, 2, 3) is NOT an integer is NOT an integre [1, 2, 3] is NOT an integer is NOT an integre {
import re INT_RE = re.compile(r"^[-]?\d+$") def RepresentsInt(s): return INT_RE.match(str(s)) is not None
>>> "+7".lstrip("-+").isdigit() True >>> "-7".lstrip("-+").isdigit() True >>> "7".lstrip("-+").isdigit() True >>> "13.4".lstrip("-+").isdigit() False
def is_int(val): return val[1].isdigit() and val.lstrip("-+").isdigit()
def is_int(test): import string return not (set(test) - set(string.digits))
def get_int(number): splits = number.split( if len(splits) > 2: return None if len(splits) == 2 and splits[1]: if get_int(splits[1]) != 0: return None int_part = splits[0].lstrip("+") if int_part.startswith( return get_int(int_part[1:]) * -1 return int_part.isdigit() and int(int_part)
tests = ["0", "0.0", "0.1", "1", "1.1", "1.0", "-1", "-1.1", "-1.0", "-0", "--0", "---3", for t in tests: print "get_int(%s) = %s" % (t, get_int(str(t)))
get_int(0) = 0 get_int(0.0) = 0 get_int(0.1) = None get_int(1) = 1 get_int(1.1) = None get_int(1.0) = 1 get_int(-1) = -1 get_int(-1.1) = None get_int(-1.0) = -1 get_int(-0) = 0 get_int(--0) = 0 get_int(---3) = -3 get_int(.3) = None get_int(--3.) = 3 get_int(+13) = 13 get_int(+-1.00) = -1 get_int(--+123) = 123 get_int(-0.000) = 0
def int_predicate(number): return get_int(number) is not None
def isInt_loop(v): v = str(v).strip() numbers = for i in v: if i not in numbers: return False return True def isInt_Digit(v): v = str(v).strip() return v.isdigit()
timings.. isInt_try: 0.4628 isInt_str: 0.3556 isInt_re: 0.4889 isInt_re2: 0.2726 isInt_loop: 0.1842 isInt_Digit: 0.1577
from random import shuffle numbers = [u nonumbers = [u testlist = numbers + nonumbers shuffle(testlist) testlist = np.array(testlist)
import numpy as np %timeit np.core.defchararray.isnumeric(testlist) 10000 loops, best of 3: 27.9 µs per loop
def check_num(s): try: int(s) return True except: return False def check_list(l): return [check_num(e) for e in l] %timeit check_list(testlist) 1000 loops, best of 3: 217 µs per loop
def int_check(a): if int(a) == a: return True else: return False
sentence = [ sent_str = "" for i in sentence: sent_str += str(i) + "-" sent_str = sent_str[:-1] print sent_str
>>> my_lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> my_lst_str = >>> print(my_lst_str)
>>> ",".join("12345").join(("(",")")) >>> lista=["(",")"] >>> ",".join("12345").join(lista)
from str import join sentence = [ join(sentence, "-")
In [1]: import numpy as np In [2]: arr = np.array([1, 3, 2, 4, 5]) In [3]: arr.argsort()[-3:][::-1] Out[3]: array([4, 3, 1])
>>> a = np.array([9, 4, 4, 3, 3, 9, 0, 4, 6, 0]) >>> a array([9, 4, 4, 3, 3, 9, 0, 4, 6, 0]) >>> ind = np.argpartition(a, -4)[-4:] >>> ind array([1, 5, 8, 0]) >>> a[ind] array([4, 9, 6, 9])
>>> import heapq >>> import numpy >>> a = numpy.array([1, 3, 2, 4, 5]) >>> heapq.nlargest(3, range(len(a)), a.take) [4, 3, 1]
>>> a = [1, 3, 2, 4, 5] >>> heapq.nlargest(3, range(len(a)), a.__getitem__) [4, 3, 1]
def largest_indices(ary, n): flat = ary.flatten() indices = np.argpartition(flat, -n)[-n:] indices = indices[np.argsort(-flat[indices])] return np.unravel_index(indices, ary.shape)
>>> xs = np.sin(np.arange(9)).reshape((3, 3)) >>> xs array([[ 0. , 0.84147098, 0.90929743], [ 0.14112001, -0.7568025 , -0.95892427], [-0.2794155 , 0.6569866 , 0.98935825]]) >>> largest_indices(xs, 3) (array([2, 0, 0]), array([2, 2, 1])) >>> xs[largest_indices(xs, 3)] array([ 0.98935825, 0.90929743, 0.84147098])
K = 4 a = np.array([0, 8, 0, 4, 5, 8, 8, 0, 4, 2]) np.argpartition(a,-K)[-K:] array([4, 1, 5, 6])
x = arr.shape[0] arr[np.repeat(np.arange(x), N), indices.ravel()].reshape(x, N)
indices = np.argsort(arr, axis=1)[:, -N:] x = arr.shape[0] arr[np.repeat(np.arange(x), N), indices.ravel()].reshape(x, N)
In [42]: a = np.random.randint(0, 20, (10, 10)) In [44]: a Out[44]: array([[ 7, 11, 12, 0, 2, 3, 4, 10, 6, 10], [16, 16, 4, 3, 18, 5, 10, 4, 14, 9], [ 2, 9, 15, 12, 18, 3, 13, 11, 5, 10], [14, 0, 9, 11, 1, 4, 9, 19, 18, 12], [ 0, 10, 5, 15, 9, 18, 5, 2, 16, 19], [14, 19, 3, 11, 13, 11, 13, 11, 1, 14], [ 7, 15, 18, 6, 5, 13, 1, 7, 9, 19], [11, 17, 11, 16, 14, 3, 16, 1, 12, 19], [ 2, 4, 14, 8, 6, 9, 14, 9, 1, 5], [ 1, 10, 15, 0, 1, 9, 18, 2, 2, 12]]) In [45]: np.argpartition(a, np.argmin(a, axis=0))[:, 1:] Out[45]: array([[4, 5, 6, 8, 0, 7, 9, 1, 2], [2, 7, 5, 9, 6, 8, 1, 0, 4], [5, 8, 1, 9, 7, 3, 6, 2, 4], [4, 5, 2, 6, 3, 9, 0, 8, 7], [7, 2, 6, 4, 1, 3, 8, 5, 9], [2, 3, 5, 7, 6, 4, 0, 9, 1], [4, 3, 0, 7, 8, 5, 1, 2, 9], [5, 2, 0, 8, 4, 6, 3, 1, 9], [0, 1, 9, 4, 3, 7, 5, 2, 6], [0, 4, 7, 8, 5, 1, 9, 2, 6]]) In [46]: np.argpartition(a, np.argmin(a, axis=0))[:, -3:] Out[46]: array([[9, 1, 2], [1, 0, 4], [6, 2, 4], [0, 8, 7], [8, 5, 9], [0, 9, 1], [1, 2, 9], [3, 1, 9], [5, 2, 6], [9, 2, 6]]) In [89]: a[np.repeat(np.arange(x), 3), ind.ravel()].reshape(x, 3) Out[89]: array([[10, 11, 12], [16, 16, 18], [13, 15, 18], [14, 18, 19], [16, 18, 19], [14, 14, 19], [15, 18, 19], [16, 17, 19], [ 9, 14, 14], [12, 15, 18]])
>>> A = np.random.randint(0,10,10) >>> A array([5, 1, 5, 5, 2, 3, 2, 4, 1, 0]) >>> B = np.zeros(3, int) >>> for i in xrange(3): ... idx = np.argmax(A) ... B[i]=idx; A[idx]=0 ... >>> B array([0, 2, 3])
from operator import itemgetter from heapq import nlargest result = nlargest(N, enumerate(your_list), itemgetter(1))
def max_indices(arr, k): Returns the indices of the k first largest elements of arr (in descending order in values) assert k <= arr.size, arr_ = arr.astype(float) max_idxs = [] for _ in range(k): max_element = np.max(arr_) if np.isinf(max_element): break else: idx = np.where(arr_ == max_element) max_idxs.append(idx) arr_[idx] = -np.inf return max_idxs
In [0]: A = np.array([[ 0.51845014, 0.72528114], [ 0.88421561, 0.18798661], [ 0.89832036, 0.19448609], [ 0.89832036, 0.19448609]]) In [1]: max_indices(A, 8) Out[1]: [(array([2, 3], dtype=int64), array([0, 0], dtype=int64)), (array([1], dtype=int64), array([0], dtype=int64)), (array([0], dtype=int64), array([1], dtype=int64)), (array([0], dtype=int64), array([0], dtype=int64)), (array([2, 3], dtype=int64), array([1, 1], dtype=int64)), (array([1], dtype=int64), array([1], dtype=int64))] In [2]: A[max_indices(A, 8)[0]][0] Out[2]: array([ 0.89832036])
M = np.random.random((3, 4)) print(M) print(M.max(axis=1), M.argmax(axis=1))
multi_max = [1,1,2,2,4,0,0,4] uniques, idx = np.unique(multi_max, return_inverse=True) print np.squeeze(np.argwhere(idx == np.argmax(uniques))) >> [4 7]
top_k_index_list = [ ] for i in range(k): top_k_index_list.append(np.argmax(my_array)) my_array[top_k_index_list[-1]] = -float(
d = {} d[i for i in range(1, 11)] = [x for x in range(1, 11)]
>>> d = {n: n**2 for n in range(5)} >>> print d {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
>>> d = {n: True for n in range(5)} >>> print d {0: True, 1: True, 2: True, 3: True, 4: True}
>>> dict.fromkeys(range(5), True) {0: True, 1: True, 2: True, 3: True, 4: True}
from collections import defaultdict d = defaultdict(True)
>>> class KeyDict(dict): ... def __missing__(self, key): ... ... return key ... >>> d = KeyDict() >>> d[1] 1 >>> d[2] 2 >>> d[3] 3 >>> print(d) {}
>>> {i:i for i in range(1, 11)} {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10}
keys = [ values = [1, 2, 3] d = dict(zip(keys, values))
i_s = range(1, 11) x_s = range(1, 11) d = dict([(i_s[index], x_s[index], ) for index in range(len(i_s))])
my_list = [ my_dict = {k:my_list.count(k) for k in my_list} print(my_dict)
import requests header = { url = az_base_url + az_subscription_id + r = requests.get(url, headers=header)
/usr/local/lib/python2.7/dist-packages/requests/packages/urllib3/util/ssl_.py:79: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. For more information, see https: InsecurePlatformWarning
class Foo: def __init__(self, item): self.item = item def __eq__(self, other): if isinstance(other, self.__class__): return self.__dict__ == other.__dict__ else: return False def __ne__(self, other): return not self.__eq__(other)
>>> a = Foo(1) >>> b = Foo(1) >>> a is b False >>> a == b False
>>> a = Foo(1) >>> b = Foo(1) >>> a is b False >>> a == b True
class Number: def __init__(self, number): self.number = number n1 = Number(1) n2 = Number(1) n1 == n2
def __eq__(self, other): if isinstance(other, Number): return self.number == other.number return False n1 == n2 n1 != n2
def __ne__(self, other): """Overrides the default implementation (unnecessary in Python 3)""" return not self.__eq__(other) n1 == n2 n1 != n2
class SubNumber(Number): pass n3 = SubNumber(1) n1 == n3 n3 == n1 n1 != n3 n3 != n1
def __eq__(self, other): if isinstance(other, Number): return self.number == other.number return NotImplemented def __ne__(self, other): """Overrides the default implementation (unnecessary in Python 3)""" x = self.__eq__(other) if x is not NotImplemented: return not x return NotImplemented
def __hash__(self): return hash(tuple(sorted(self.__dict__.items()))) len(set([n1, n2, n3]))
class Number: def __init__(self, number): self.number = number def __eq__(self, other): if isinstance(other, Number): return self.number == other.number return NotImplemented def __ne__(self, other): """Overrides the default implementation (unnecessary in Python 3)""" x = self.__eq__(other) if x is not NotImplemented: return not x return NotImplemented def __hash__(self): return hash(tuple(sorted(self.__dict__.items()))) class SubNumber(Number): pass n1 = Number(1) n2 = Number(1) n3 = SubNumber(1) n4 = SubNumber(4) assert n1 == n2 assert n2 == n1 assert not n1 != n2 assert not n2 != n1 assert n1 == n3 assert n3 == n1 assert not n1 != n3 assert not n3 != n1 assert not n1 == n4 assert not n4 == n1 assert n1 != n4 assert n4 != n1 assert len(set([n1, n2, n3, ])) == 1 assert len(set([n1, n2, n3, n4])) == 2
>>> class Foo: def __eq__(self, other): if isinstance(other, self.__class__): return self.__dict__ == other.__dict__ else: return False >>> class Bar(Foo):pass >>> b = Bar() >>> f = Foo() >>> f == b True >>> b == f False
def __eq__(self, other): if type(other) is type(self): return self.__dict__ == other.__dict__ return False
class CommonEqualityMixin(object): def __eq__(self, other): return (isinstance(other, self.__class__) and self.__dict__ == other.__dict__) def __ne__(self, other): return not self.__eq__(other) class Foo(CommonEqualityMixin): def __init__(self, item): self.item = item
@total_ordering class Student: def __eq__(self, other): return ((self.lastname.lower(), self.firstname.lower()) == (other.lastname.lower(), other.firstname.lower())) def __lt__(self, other): return ((self.lastname.lower(), self.firstname.lower()) < (other.lastname.lower(), other.firstname.lower()))
def __ne__(self, other): return not self.__eq__(other)
>>> a = [1,2,3] >>> b = [1,2,3] >>> a == b True <-- a and b have values which are equal >>> a is b False <-- a and b are not the same list object
import types class ComparesNicely(object): def __eq__(self, other): for key, value in self.__dict__.iteritems(): if (isinstance(value, types.FunctionType) or key.startswith("__")): continue if key not in other.__dict__: return False if other.__dict__[key] != value: return False return True
with open(fname, lines = [x.strip() for x in f.readlines()] for line in lines: tmp = line.strip().lower() if
mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) mysock.connect(( mysock.send(**b** while True: data = mysock.recv(512) if ( len(data) < 1 ) : break print (data); mysock.close()
def __init__(self): self.myCsv = csv.writer(open( self.myCsv.writerow([
def __init__(self): self.myCsv = csv.writer(open( self.myCsv.writerow([
with open(fname, lines = [x.strip() for x in f.readlines()]
for line in lines: line = line.decode() print(type(line)) if print(
try: thevariable except NameError: print "well, it WASN else: print "sure, it was defined."
class Whatever(object): def __getattr__(self, key): return None
daysago line_race rating rw wrating line_date 2007-03-31 62 11 56 1.000000 56.000000 2007-03-10 83 11 67 1.000000 67.000000 2007-02-10 111 9 66 1.000000 66.000000 2007-01-13 139 10 83 0.880678 73.096278 2006-12-23 160 10 88 0.793033 69.786942 2006-11-09 204 9 52 0.636655 33.106077 2006-10-22 222 8 66 0.581946 38.408408 2006-09-29 245 9 70 0.518825 36.317752 2006-09-16 258 11 68 0.486226 33.063381 2006-08-30 275 8 72 0.446667 32.160051 2006-02-11 475 5 65 0.164591 10.698423 2006-01-13 504 0 70 0.142409 9.968634 2006-01-02 515 0 64 0.134800 8.627219 2005-12-06 542 0 70 0.117803 8.246238 2005-11-29 549 0 70 0.113758 7.963072 2005-11-22 556 0 -1 0.109852 -0.109852 2005-11-01 577 0 -1 0.098919 -0.098919 2005-10-20 589 0 -1 0.093168 -0.093168 2005-09-27 612 0 -1 0.083063 -0.083063 2005-09-07 632 0 -1 0.075171 -0.075171 2005-06-12 719 0 69 0.048690 3.359623 2005-05-29 733 0 -1 0.045404 -0.045404 2005-05-02 760 0 -1 0.039679 -0.039679 2005-04-02 790 0 -1 0.034160 -0.034160 2005-03-13 810 0 -1 0.030915 -0.030915 2004-11-09 934 0 -1 0.016647 -0.016647
In [56]: df Out[56]: line_date daysago line_race rating raw wrating 0 2007-03-31 62 11 56 1.000 56.000 1 2007-03-10 83 11 67 1.000 67.000 2 2007-02-10 111 9 66 1.000 66.000 3 2007-01-13 139 10 83 0.881 73.096 4 2006-12-23 160 10 88 0.793 69.787 5 2006-11-09 204 9 52 0.637 33.106 6 2006-10-22 222 8 66 0.582 38.408 7 2006-09-29 245 9 70 0.519 36.318 8 2006-09-16 258 11 68 0.486 33.063 9 2006-08-30 275 8 72 0.447 32.160 10 2006-02-11 475 5 65 0.165 10.698 11 2006-01-13 504 0 70 0.142 9.969 12 2006-01-02 515 0 64 0.135 8.627 13 2005-12-06 542 0 70 0.118 8.246 14 2005-11-29 549 0 70 0.114 7.963 15 2005-11-22 556 0 -1 0.110 -0.110 16 2005-11-01 577 0 -1 0.099 -0.099 17 2005-10-20 589 0 -1 0.093 -0.093 18 2005-09-27 612 0 -1 0.083 -0.083 19 2005-09-07 632 0 -1 0.075 -0.075 20 2005-06-12 719 0 69 0.049 3.360 21 2005-05-29 733 0 -1 0.045 -0.045 22 2005-05-02 760 0 -1 0.040 -0.040 23 2005-04-02 790 0 -1 0.034 -0.034 24 2005-03-13 810 0 -1 0.031 -0.031 25 2004-11-09 934 0 -1 0.017 -0.017 In [57]: df[df.line_race != 0] Out[57]: line_date daysago line_race rating raw wrating 0 2007-03-31 62 11 56 1.000 56.000 1 2007-03-10 83 11 67 1.000 67.000 2 2007-02-10 111 9 66 1.000 66.000 3 2007-01-13 139 10 83 0.881 73.096 4 2006-12-23 160 10 88 0.793 69.787 5 2006-11-09 204 9 52 0.637 33.106 6 2006-10-22 222 8 66 0.582 38.408 7 2006-09-29 245 9 70 0.519 36.318 8 2006-09-16 258 11 68 0.486 33.063 9 2006-08-30 275 8 72 0.447 32.160 10 2006-02-11 475 5 65 0.165 10.698
class Count(): def __init__(self,mymin,mymax): self.mymin=mymin self.mymax=mymax obj1 = Count(1,10) print(obj1.mymin) print(obj1.mymax) print(obj1.mycurrent) --> AttributeError:
class Count: def __init__(self,mymin,mymax): self.mymin=mymin self.mymax=mymax def __getattr__(self, item): self.__dict__[item]=0 return 0 obj1 = Count(1,10) print(obj1.mymin) print(obj1.mymax) print(obj1.mycurrent1)
class Count: def __init__(self,mymin,mymax): self.mymin=mymin self.mymax=mymax self.current=None def __getattribute__(self, item): if item.startswith( raise AttributeError return object.__getattribute__(self,item) obj1 = Count(1,10) print(obj1.mymin) print(obj1.mymax) print(obj1.current)
class Count(object): def __init__(self,mymin,mymax): self.mymin=mymin self.mymax=mymax self.current=None def __getattr__(self, item): self.__dict__[item]=0 return 0 def __getattribute__(self, item): if item.startswith( raise AttributeError return object.__getattribute__(self,item) obj1 = Count(1,10) print(obj1.mymin) print(obj1.mymax) print(obj1.current)
class SomeObject(object): pass class SubObject(SomeObject): pass
class Foo(object): def __getattr__(self, attr): print "looking up", attr value = 42 self.__dict__[attr] = value return value f = Foo() print f.x f.x = 3 print f.x print (
import os import zipfile def zipdir(path, ziph): for root, dirs, files in os.walk(path): for file in files: ziph.write(os.path.join(root, file)) if __name__ == zipf = zipfile.ZipFile( zipdir( zipf.close()
import os import zipfile zf = zipfile.ZipFile("myzipfile.zip", "w") for dirname, subdirs, files in os.walk("mydirectory"): zf.write(dirname) for filename in files: zf.write(os.path.join(dirname, filename)) zf.close()
from shutil import make_archive make_archive( root_dir=None, base_dir=None)
import os import zipfile def make_zipfile(output_filename, source_dir): relroot = os.path.abspath(os.path.join(source_dir, os.pardir)) with zipfile.ZipFile(output_filename, "w", zipfile.ZIP_DEFLATED) as zip: for root, dirs, files in os.walk(source_dir): zip.write(root, os.path.relpath(root, relroot)) for file in files: filename = os.path.join(root, file) if os.path.isfile(filename): arcname = os.path.join(os.path.relpath(root, relroot), file) zip.write(filename, arcname)
import os import zipfile def addDirToZip(zipHandle, path, basePath=""): """ Adding directory given by \a path to opened zip file \a zipHandle @param basePath path that will be removed from \a path when adding to archive Examples: zipHandle = zipfile.ZipFile( addDirToZip(zipHandle, zipHandle.close() zipHandle = zipfile.ZipFile( addDirToZip(zipHandle, zipHandle.close() zipHandle = zipfile.ZipFile( addDirToZip(zipHandle, zipHandle.close() zipHandle = zipfile.ZipFile( addDirToZip(zipHandle, zipHandle.close() zipHandle = zipfile.ZipFile( addDirToZip(zipHandle, zipHandle.close() zipHandle = zipfile.ZipFile( addDirToZip(zipHandle, addDirToZip(zipHandle, zipHandle.close() """ basePath = basePath.rstrip("\\/") + "" basePath = basePath.rstrip("\\/") for root, dirs, files in os.walk(path): zipHandle.write(os.path.join(root, ".")) for file in files: filePath = os.path.join(root, file) inZipPath = filePath.replace(basePath, "", 1).lstrip("\\/") zipHandle.write(filePath, inZipPath)
from pathlib import Path import zipfile from datetime import datetime DATE_FORMAT = def date_str(): return def zip_name(path): cur_dir = Path(path).resolve() parent_dir = cur_dir.parents[0] zip_filename = p_zip = Path(zip_filename) n = 1 while p_zip.exists(): zip_filename = ( date_str(), n)) p_zip = Path(zip_filename) n += 1 return zip_filename def all_files(path): for child in Path(path).iterdir(): yield str(child) if child.is_dir(): for grand_child in all_files(str(child)): yield str(Path(grand_child)) def zip_dir(path): zip_filename = zip_name(path) zip_file = zipfile.ZipFile(zip_filename, print( for file in all_files(path): print( zip_file.write(file) zip_file.close() if __name__ == zip_dir( print(
def WriteDirectoryToZipFile( zipHandle, srcPath, zipLocalPath = "", zipOperation = zipfile.ZIP_DEFLATED ): basePath = os.path.split( srcPath )[ 0 ] for root, dirs, files in os.walk( srcPath ): p = os.path.join( zipLocalPath, root [ ( len( basePath ) + 1 ) : ] ) zipHandle.write( root, p, zipOperation ) for f in files: filePath = os.path.join( root, f ) fileInZipPath = os.path.join( p, f ) zipHandle.write( filePath, fileInZipPath, zipOperation )
import zipfile, os zipf = "compress.zip" def main(): directory = r"Filepath" toZip(directory) def toZip(directory): zippedHelp = zipfile.ZipFile(zipf, "w", compression=zipfile.ZIP_DEFLATED ) list = os.listdir(directory) for file_list in list: file_name = os.path.join(directory,file_list) if os.path.isfile(file_name): print file_name zippedHelp.write(file_name) else: addFolderToZip(zippedHelp,file_list,directory) print "---------------Directory Found-----------------------" zippedHelp.close() def addFolderToZip(zippedHelp,folder,directory): path=os.path.join(directory,folder) print path file_list=os.listdir(path) for file_name in file_list: file_path=os.path.join(path,file_name) if os.path.isfile(file_path): zippedHelp.write(file_path) elif os.path.isdir(file_name): print "------------------sub directory found--------------------" addFolderToZip(zippedHelp,file_name,path) if __name__=="__main__": main()
import os import zipfile def zipdir(path, ziph): for root, dirs, files in os.walk(path): if root.replace(path, prefix = else: prefix = root.replace(path, if (prefix[0] == prefix = prefix[1:] for filename in files: actual_file_path = root + zipped_file_path = prefix + filename zipf.write( actual_file_path, zipped_file_path) zipf = zipfile.ZipFile( zipdir( zipf.close()
from pathlib import Path from zipfile import ZIP_DEFLATED, ZipFile from os import PathLike from typing import Union def zip_dir(zip_name: str, source_dir: Union[str, PathLike]): src_path = Path(source_dir).expanduser().resolve(strict=True) with ZipFile(zip_name, for file in src_path.rglob( zf.write(file, file.relative_to(src_path.parent))
def zip_dir(filename: str, dir_to_zip: pathlib.Path): with zipfile.ZipFile(filename, for directory in dir_to_zip.glob( for file in directory.iterdir(): if not file.is_file(): continue zip_path = pathlib.Path(*file.parts[1:]) zipf.write(str(file), str(zip_path))
import os import zipfile def zip_dir(path_dir, path_file_zip= if not path_file_zip: path_file_zip = os.path.join( os.path.dirname(path_dir), os.path.basename(path_dir)+ with zipfile.ZipFile(path_file_zip, for root, dirs, files in os.walk(path_dir): for file_or_dir in files + dirs: zip_file.write( os.path.join(root, file_or_dir), os.path.relpath(os.path.join(root, file_or_dir), os.path.join(path_dir, os.path.pardir)))
import os,zipfile os.chdir( zf = zipfile.ZipFile( for dirnames,folders,files in os.walk( zf.write( for file in files: zf.write(os.path.join(
def zipDir( path, ziph ) : """ Inserts directory (path) into zipfile instance (ziph) """ for root, dirs, files in os.walk( path ) : for file in files : ziph.write( os.path.join( root, file ) , os.path.basename( os.path.normpath( path ) ) + "\\" + file ) def makeZip( pathToFolder ) : zipf = zipfile.ZipFile( pathToFolder + zipDir( pathToFolder, zipf ) zipf.close() print( "Zip file saved to: " + pathToFolder) makeZip( "c:\\path\\to\\folder\\to\\insert\\into\\zipfile" )
import os import zipfile def zipall(ob, path, rel=""): basename = os.path.basename(path) if os.path.isdir(path): if rel == "": rel = basename ob.write(path, os.path.join(rel)) for root, dirs, files in os.walk(path): for d in dirs: zipall(ob, os.path.join(root, d), os.path.join(rel, d)) for f in files: ob.write(os.path.join(root, f), os.path.join(rel, f)) break elif os.path.isfile(path): ob.write(path, os.path.join(rel, basename)) else: pass
. ├── dir │ ├── dir2 │ │ └── file2.txt │ ├── dir3 │ │ └── file3.txt │ └── file.txt ├── dir4 │ ├── dir5 │ └── file4.txt ├── listdir.zip ├── main.py ├── root.txt └── selective.zip
cwd = os.getcwd() files = [os.path.join(cwd, f) for f in [ with zipfile.ZipFile("selective.zip", "w" ) as myzip: for f in files: zipall(myzip, f)
with zipfile.ZipFile("listdir.zip", "w" ) as myzip: for f in os.listdir(): if f == "listdir.zip": continue zipall(myzip, f)
def CREATEZIPFILE(zipname, path): zipf = zipfile.ZipFile(zipname, zipf.setpassword(b"password") if os.path.isdir(path): for files in os.listdir(path): zipf.write(os.path.join(path, files), files) elif os.path.isfile(path): zipf.write(os.path.join(path), path) zipf.close()
def print_full(x): pd.set_option( print(x) pd.reset_option(
import pandas as pd from io import StringIO from tabulate import tabulate c = """Chromosome Start End chr1 3 6 chr1 5 7 chr1 8 9""" df = pd.read_table(StringIO(c), sep="\s+", header=0) print(tabulate(df, headers= +----+--------------+---------+-------+ | | Chromosome | Start | End | |----+--------------+---------+-------| | 0 | chr1 | 3 | 6 | | 1 | chr1 | 5 | 7 | | 2 | chr1 | 8 | 9 | +----+--------------+---------+-------+
pd.set_option( pd.set_option( pd.set_option( pd.set_option(
from IPython.core.display import HTML display(HTML(df.to_html()))
df= DataFrame(..) with pd.option_context( print(df)
def set_pandas_options() -> None: pd.options.display.max_columns = 1000 pd.options.display.max_rows = 1000 pd.options.display.max_colwidth = 199 pd.options.display.width = None set_pandas_options()
>> Index: 8 entries, count to max >> Data columns: >> x1 8 non-null values >> x2 8 non-null values >> x3 8 non-null values >> x4 8 non-null values >> x5 8 non-null values >> x6 8 non-null values >> x7 8 non-null values
import pandas as pd pd.set_option( pd.set_option( pd.set_option( pd.set_option(
In [3]: df.describe() Out[3]: <class Index: 8 entries, count to max Data columns: x1 8 non-null values x2 8 non-null values x3 8 non-null values x4 8 non-null values x5 8 non-null values x6 8 non-null values x7 8 non-null values dtypes: float64(7) In [4]: pd.set_printoptions(precision=2) In [5]: df.describe() Out[5]: x1 x2 x3 x4 x5 x6 x7 count 8.0 8.0 8.0 8.0 8.0 8.0 8.0 mean 69024.5 69025.5 69026.5 69027.5 69028.5 69029.5 69030.5 std 17.1 17.1 17.1 17.1 17.1 17.1 17.1 min 69000.0 69001.0 69002.0 69003.0 69004.0 69005.0 69006.0 25% 69012.2 69013.2 69014.2 69015.2 69016.2 69017.2 69018.2 50% 69024.5 69025.5 69026.5 69027.5 69028.5 69029.5 69030.5 75% 69036.8 69037.8 69038.8 69039.8 69040.8 69041.8 69042.8 max 69049.0 69050.0 69051.0 69052.0 69053.0 69054.0 69055.0
In [3]: df.describe() Out[3]: x1 x2 x3 x4 x5 \ count 8.000000 8.000000 8.000000 8.000000 8.000000 mean 59832.361578 27356.711336 49317.281222 51214.837838 51254.839690 std 22600.723536 26867.192716 28071.737509 21012.422793 33831.515761 min 31906.695474 1648.359160 56.378115 16278.322271 43.745574 25% 45264.625201 12799.540572 41429.628749 40374.273582 29789.643875 50% 56340.214856 18666.456293 51995.661512 54894.562656 47667.684422 75% 75587.003417 31375.610322 61069.190523 67811.893435 76014.884048 max 98136.474782 84544.484627 91743.983895 75154.587156 99012.695717 x6 x7 count 8.000000 8.000000 mean 41863.000717 33950.235126 std 38709.468281 29075.745673 min 3590.990740 1833.464154 25% 15145.759625 6879.523949 50% 22139.243042 33706.029946 75% 72038.983496 51449.893980 max 98601.190488 83309.051963
In [4]: pd.set_option( In [5]: df.describe() Out[5]: x1 x2 x3 x4 x5 x6 x7 count 8.0 8.0 8.0 8.0 8.0 8.0 8.0 mean 59832.4 27356.7 49317.3 51214.8 51254.8 41863.0 33950.2 std 22600.7 26867.2 28071.7 21012.4 33831.5 38709.5 29075.7 min 31906.7 1648.4 56.4 16278.3 43.7 3591.0 1833.5 25% 45264.6 12799.5 41429.6 40374.3 29789.6 15145.8 6879.5 50% 56340.2 18666.5 51995.7 54894.6 47667.7 22139.2 33706.0 75% 75587.0 31375.6 61069.2 67811.9 76014.9 72039.0 51449.9 max 98136.5 84544.5 91744.0 75154.6 99012.7 98601.2 83309.1
In [1]: import pandas as pd In [2]: pd.options.display.max_rows Out[2]: 15 In [3]: pd.options.display.max_rows = 999 In [4]: pd.options.display.max_rows Out[4]: 999
pd.set_option( pd.set_option( pd.set_option( pd.set_option( pd.set_option(
import pandas as pd pd.set_option( pd.set_option( SentenceA = "William likes Piano and Piano likes William" SentenceB = "Sara likes Guitar" SentenceC = "Mamoosh likes Piano" SentenceD = "William is a CS Student" SentenceE = "Sara is kind" SentenceF = "Mamoosh is kind" bowA = SentenceA.split(" ") bowB = SentenceB.split(" ") bowC = SentenceC.split(" ") bowD = SentenceD.split(" ") bowE = SentenceE.split(" ") bowF = SentenceF.split(" ") wordSet = set(bowA).union(set(bowB)).union(set(bowC)).union(set(bowD)).union(set(bowE)).union(set(bowF)) print("Set of all words is: ", wordSet) wordDictA = dict.fromkeys(wordSet, 0) wordDictB = dict.fromkeys(wordSet, 0) wordDictC = dict.fromkeys(wordSet, 0) wordDictD = dict.fromkeys(wordSet, 0) wordDictE = dict.fromkeys(wordSet, 0) wordDictF = dict.fromkeys(wordSet, 0) for word in bowA: wordDictA[word] += 1 for word in bowB: wordDictB[word] += 1 for word in bowC: wordDictC[word] += 1 for word in bowD: wordDictD[word] += 1 for word in bowE: wordDictE[word] += 1 for word in bowF: wordDictF[word] += 1 print("SentenceA TF: ", wordDictA) print("SentenceB TF: ", wordDictB) print("SentenceC TF: ", wordDictC) print("SentenceD TF: ", wordDictD) print("SentenceE TF: ", wordDictE) print("SentenceF TF: ", wordDictF) print(pd.DataFrame([wordDictA, wordDictB, wordDictB, wordDictC, wordDictD, wordDictE, wordDictF]))
CS Guitar Mamoosh Piano Sara Student William a and is kind likes 0 0 0 0 2 0 0 2 0 1 0 0 2 1 0 1 0 0 1 0 0 0 0 0 0 1 2 0 1 0 0 1 0 0 0 0 0 0 1 3 0 0 1 1 0 0 0 0 0 0 0 1 4 1 0 0 0 0 1 1 1 0 1 0 0 5 0 0 0 0 1 0 0 0 0 1 1 0 6 0 0 1 0 0 0 0 0 0 1 1 0
>>> 10/3 3 >>> >>> 10.0/3 3.3333333333333335 >>> float(10)/3 3.3333333333333335
$ python2.6 -Qold -c 0 $ python2.6 -Qnew -c 0.666666666667
$ python -m timeit 100000000 loops, best of 3: 0.0149 usec per loop $ python -m timeit 10000000 loops, best of 3: 0.0484 usec per loop $ python -m timeit 10000000 loops, best of 3: 0.043 usec per loop $ python -m timeit 100000000 loops, best of 3: 0.0144 usec per loop
import math >>> 1.0 / 2 0.5 >>> math.floor(1.0/2) 0.0 >>> 1.0 0.0 >>> 1/2 0 >>> 1 0
>>> from HTMLParser import HTMLParser >>> class TextParser(HTMLParser): ... def __init__(self): ... super(TextParser, self).__init__() ... self.all_data = [] ... >>> TextParser() (...) TypeError: must be type, not classobj
>>> class OldStyle: pass >>> instance = OldStyle() >>> issubclass(instance.__class__, object) False
>>> issubclass(OldStyle, object) False >>> issubclass(int, object) True
>>> type(OldStyle) classobj >>> isinstance(OldStyle, type) False >>> type(int) type
class TextParser(HTMLParser): def __init__(self): HTMLParser.__init__(self) self.all_data = []
>>> class oldstyle: ... def __init__(self): self.os = True >>> class myclass(oldstyle): ... def __init__(self): super(myclass, self).__init__() >>> myclass() TypeError: must be type, not classobj
>>> class newstyle(object): pass >>> type(newstyle) type
>>> class myclass(oldstyle, object): ... def __init__(self): super(myclass, self).__init__() >>> myclass().os True
class A: def foo(self): return "Hi there" class B(A): def foo(self, name): return A.foo(self) + name
>>> class TextParser(HTMLParser): ... def handle_starttag(self, tag, attrs): ... if tag == "b": ... self.all_data.append("bold") ... else: ... self.all_data.append("other") ... ... >>> p = TextParser() >>> p.all_data = [] >>> p.feed(text) >>> print p.all_data (...)
s = Session() s.add(Foo( print 1, s.query(Foo).all() s.commit() s2 = Session() s2.autoflush = False s2.add(Foo( print 2, s2.query(Foo).all() s2.flush() print 3, s2.query(Foo).all() s2.rollback() print 4, s2.query(Foo).all() Output: 1 [<Foo( 2 [<Foo( 3 [<Foo( 4 [<Foo(
from visual import * floor = box (pos=(0,0,0), length=4, height=0.5, width=4, color=color.blue) ball = sphere (pos=(0,4,0), radius=1, color=color.red) ball.velocity = vector(0,-1,0) dt = 0.01 while 1: rate (100) ball.pos = ball.pos + ball.velocity*dt if ball.y < ball.radius: ball.velocity.y = -ball.velocity.y else: ball.velocity.y = ball.velocity.y - 9.8*dt
>>> from turtle import * >>> setup() >>> title("turtle test") >>> clear() >>> >>> >>> down() >>> forward(50) >>> right(90) >>> forward(50) >>> right(90) >>> forward(50) >>> right(90) >>> forward(50) >>> >>> >>> clear() >>> for i in range(4): forward(50) right(90) >>> >>> >>> def square(length): down() for i in range(4): forward(length) right(90) >>> >>> >>> for i in range(50): up() left(90) forward(25) square(i) >>> >>> >>> >>> >>> >>> >>>
mylogger.critical("something failed") print "something failed"
import logging import sys root = logging.getLogger() root.setLevel(logging.DEBUG) handler = logging.StreamHandler(sys.stdout) handler.setLevel(logging.DEBUG) formatter = logging.Formatter( handler.setFormatter(formatter) root.addHandler(handler)
import logging import sys logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
import logging import auxiliary_module log = logging.getLogger( log.setLevel(logging.DEBUG) formatter = logging.Formatter( fh = logging.FileHandler( fh.setLevel(logging.DEBUG) fh.setFormatter(formatter) log.addHandler(fh) ch = logging.StreamHandler() ch.setLevel(logging.ERROR) ch.setFormatter(formatter) log.addHandler(ch) log.info( a = auxiliary_module.Auxiliary() log.info( log.info( a.do_something() log.info( log.info( auxiliary_module.some_function() log.info( for handler in log.handlers: handler.close() log.removeFilter(handler)
import logging import sys file_handler = logging.FileHandler(filename= stdout_handler = logging.StreamHandler(sys.stdout) handlers = [file_handler, stdout_handler] logging.basicConfig( level=logging.DEBUG, format= handlers=handlers ) logger = logging.getLogger(
import logging logging.basicConfig(filename="logfile.txt") stderrLogger=logging.StreamHandler() stderrLogger.setFormatter(logging.Formatter(logging.BASIC_FORMAT)) logging.getLogger().addHandler(stderrLogger)
import logging import logging.config import sys class _ExcludeErrorsFilter(logging.Filter): def filter(self, record): """Filters out log messages with log level ERROR (numeric value: 40) or higher.""" return record.levelno < 40 config = { } }, } }, }, }, } }, }, } logging.config.dictConfig(config)
import os, sys import Image size = 128, 128 for infile in sys.argv[1:]: outfile = os.path.splitext(infile)[0] + ".thumbnail" if infile != outfile: try: im = Image.open(infile) im.thumbnail(size, Image.ANTIALIAS) im.save(outfile, "JPEG") except IOError: print "cannot create thumbnail for
from PIL import Image basewidth = 300 img = Image.open( wpercent = (basewidth/float(img.size[0])) hsize = int((float(img.size[1])*float(wpercent))) img = img.resize((basewidth,hsize), Image.ANTIALIAS) img.save(
new_width = 680 new_height = new_width * height / width
new_height = 680 new_width = new_height * width / height
img = img.resize((new_width, new_height), Image.ANTIALIAS)
from PIL import Image img = Image.open( new_width = 200 new_height = 300 img = img.resize((new_width, new_height), Image.ANTIALIAS) img.save(
half = 0.5 out = im.resize( [int(half * s) for s in im.size] )
from PIL import Image from resizeimage import resizeimage def resize_file(in_file, out_file, size): with open(in_file) as fd: image = resizeimage.resize_thumbnail(Image.open(fd), size) image.save(out_file) image.close() resize_file(
def resize(img_path, max_px_size, output_folder): with Image.open(img_path) as img: width_0, height_0 = img.size out_f_name = os.path.split(img_path)[-1] out_f_path = os.path.join(output_folder, out_f_name) if max((width_0, height_0)) <= max_px_size: print( img.save(out_f_path) return if width_0 > height_0: wpercent = max_px_size / float(width_0) hsize = int(float(height_0) * float(wpercent)) img = img.resize((max_px_size, hsize), Image.ANTIALIAS) print( img.save(out_f_path) return if width_0 < height_0: hpercent = max_px_size / float(height_0) wsize = int(float(width_0) * float(hpercent)) img = img.resize((max_px_size, wsize), Image.ANTIALIAS) print( img.save(out_f_path) return
def imageResize(filepath): from PIL import Image file_dir=os.path.split(filepath) img = Image.open(filepath) if img.size[0] > img.size[1]: aspect = img.size[1]/120 new_size = (img.size[0]/aspect, 120) else: aspect = img.size[0]/120 new_size = (120, img.size[1]/aspect) img.resize(new_size).save(file_dir[0]+ img = Image.open(file_dir[0]+ if img.size[0] > img.size[1]: new_img = img.crop( ( (((img.size[0])-120)/2), 0, 120+(((img.size[0])-120)/2), 120 ) ) else: new_img = img.crop( ( 0, (((img.size[1])-120)/2), 120, 120+(((img.size[1])-120)/2) ) ) new_img.save(file_dir[0]+
from PIL import Image from resizeimage import resizeimage fd_img = open( img = Image.open(fd_img) img = resizeimage.resize_width(img, 200) img.save( fd_img.close()
from PIL import Image my_img = numpy.array(Image.fromarray(arr).resize((new_width, new_height), Image.ANTIALIAS)
def get_primes(n): numbers = set(range(n, 1, -1)) primes = [] while numbers: p = numbers.pop() primes.append(p) numbers.difference_update(set(range(p*2, n+1, p))) return primes >>> timeit.Timer(stmt= 1.1499958793645562
>>> sum(get_primes(2000000)) 142913828922L >>> 529 in get_primes(1000) False >>> 529 in get_primes(530) True
+---------------------+-------+ | Method | ms | +---------------------+-------+ | rwh_primes1 | 43.0 | | sieveOfAtkin | 46.4 | | rwh_primes | 57.4 | | sieve_wheel_30 | 63.0 | | rwh_primes2 | 67.8 | | sieveOfEratosthenes | 147.0 | | ambi_sieve_plain | 152.0 | | sundaram3 | 194.0 | +---------------------+-------+
+---------------------+-------+ | Method | ms | +---------------------+-------+ | rwh_primes2 | 68.1 | | rwh_primes1 | 93.7 | | rwh_primes | 94.6 | | sieve_wheel_30 | 97.4 | | sieveOfEratosthenes | 178.0 | | ambi_sieve_plain | 286.0 | | sieveOfAtkin | 314.0 | | sundaram3 | 416.0 | +---------------------+-------+
+---------------------+-------+ | Method | ms | +---------------------+-------+ | primesfrom2to | 15.9 | | primesfrom3to | 18.4 | | ambi_sieve | 29.3 | +---------------------+-------+
python -mtimeit -s"import primes" "primes.{method}(1000000)"
import psyco; psyco.full() from math import sqrt, ceil import numpy as np def rwh_primes(n): sieve = [True] * n for i in xrange(3,int(n**0.5)+1,2): if sieve[i]: sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1) return [2] + [i for i in xrange(3,n,2) if sieve[i]] def rwh_primes1(n): sieve = [True] * (n/2) for i in xrange(3,int(n**0.5)+1,2): if sieve[i/2]: sieve[i*i/2::i] = [False] * ((n-i*i-1)/(2*i)+1) return [2] + [2*i+1 for i in xrange(1,n/2) if sieve[i]] def rwh_primes2(n): correction = (n%6>1) n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6] sieve = [True] * (n/3) sieve[0] = False for i in xrange(int(n**0.5)/3+1): if sieve[i]: k=3*i+1|1 sieve[ ((k*k)/3) ::2*k]=[False]*((n/6-(k*k)/6-1)/k+1) sieve[(k*k+4*k-2*k*(i&1))/3::2*k]=[False]*((n/6-(k*k+4*k-2*k*(i&1))/6-1)/k+1) return [2,3] + [3*i+1|1 for i in xrange(1,n/3-correction) if sieve[i]] def sieve_wheel_30(N): Copyright 2009 by zerovolt.com This code is free for non-commercial purposes, in which case you can just leave this comment as a credit for my work. If you need this code for commercial purposes, please contact me by sending an email to: info [at] zerovolt [dot] com. __smallp = ( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997) wheel = (2, 3, 5) const = 30 if N < 2: return [] if N <= const: pos = 0 while __smallp[pos] <= N: pos += 1 return list(__smallp[:pos]) offsets = (7, 11, 13, 17, 19, 23, 29, 1) p = [2, 3, 5] dim = 2 + N tk1 = [True] * dim tk7 = [True] * dim tk11 = [True] * dim tk13 = [True] * dim tk17 = [True] * dim tk19 = [True] * dim tk23 = [True] * dim tk29 = [True] * dim tk1[0] = False d = {} for x in offsets: for y in offsets: res = (x*y) % const if res in offsets: d[(x, res)] = y tmptk = {1:tk1, 7:tk7, 11:tk11, 13:tk13, 17:tk17, 19:tk19, 23:tk23, 29:tk29} pos, prime, lastadded, stop = 0, 0, 0, int(ceil(sqrt(N))) def del_mult(tk, start, step): for k in xrange(start, len(tk), step): tk[k] = False cpos = const * pos while prime < stop: if tk7[pos]: prime = cpos + 7 p.append(prime) lastadded = 7 for off in offsets: tmp = d[(7, off)] start = (pos + prime) if off == 7 else (prime * (const * (pos + 1 if tmp < 7 else 0) + tmp) ) del_mult(tmptk[off], start, prime) if tk11[pos]: prime = cpos + 11 p.append(prime) lastadded = 11 for off in offsets: tmp = d[(11, off)] start = (pos + prime) if off == 11 else (prime * (const * (pos + 1 if tmp < 11 else 0) + tmp) ) del_mult(tmptk[off], start, prime) if tk13[pos]: prime = cpos + 13 p.append(prime) lastadded = 13 for off in offsets: tmp = d[(13, off)] start = (pos + prime) if off == 13 else (prime * (const * (pos + 1 if tmp < 13 else 0) + tmp) ) del_mult(tmptk[off], start, prime) if tk17[pos]: prime = cpos + 17 p.append(prime) lastadded = 17 for off in offsets: tmp = d[(17, off)] start = (pos + prime) if off == 17 else (prime * (const * (pos + 1 if tmp < 17 else 0) + tmp) ) del_mult(tmptk[off], start, prime) if tk19[pos]: prime = cpos + 19 p.append(prime) lastadded = 19 for off in offsets: tmp = d[(19, off)] start = (pos + prime) if off == 19 else (prime * (const * (pos + 1 if tmp < 19 else 0) + tmp) ) del_mult(tmptk[off], start, prime) if tk23[pos]: prime = cpos + 23 p.append(prime) lastadded = 23 for off in offsets: tmp = d[(23, off)] start = (pos + prime) if off == 23 else (prime * (const * (pos + 1 if tmp < 23 else 0) + tmp) ) del_mult(tmptk[off], start, prime) if tk29[pos]: prime = cpos + 29 p.append(prime) lastadded = 29 for off in offsets: tmp = d[(29, off)] start = (pos + prime) if off == 29 else (prime * (const * (pos + 1 if tmp < 29 else 0) + tmp) ) del_mult(tmptk[off], start, prime) pos += 1 cpos = const * pos if tk1[pos]: prime = cpos + 1 p.append(prime) lastadded = 1 for off in offsets: tmp = d[(1, off)] start = (pos + prime) if off == 1 else (prime * (const * pos + tmp) ) del_mult(tmptk[off], start, prime) if lastadded == 1: p.pop() while pos < len(tk1): cpos = const * pos if tk1[pos]: p.append(cpos + 1) if tk7[pos]: p.append(cpos + 7) if tk11[pos]: p.append(cpos + 11) if tk13[pos]: p.append(cpos + 13) if tk17[pos]: p.append(cpos + 17) if tk19[pos]: p.append(cpos + 19) if tk23[pos]: p.append(cpos + 23) if tk29[pos]: p.append(cpos + 29) pos += 1 pos = len(p) - 1 while p[pos] > N: pos -= 1 if pos < len(p) - 1: del p[pos+1:] return p def sieveOfEratosthenes(n): """sieveOfEratosthenes(n): return the list of the primes < n.""" if n <= 2: return [] sieve = range(3, n, 2) top = len(sieve) for si in sieve: if si: bottom = (si*si - 3) if bottom >= top: break sieve[bottom::si] = [0] * -((bottom - top) return [2] + [el for el in sieve if el] def sieveOfAtkin(end): """sieveOfAtkin(end): return a list of all the prime numbers <end using the Sieve of Atkin.""" assert end > 0 lng = ((end-1) sieve = [False] * (lng + 1) x_max, x2, xd = int(sqrt((end-1)/4.0)), 0, 4 for xd in xrange(4, 8*x_max + 2, 8): x2 += xd y_max = int(sqrt(end-x2)) n, n_diff = x2 + y_max*y_max, (y_max << 1) - 1 if not (n & 1): n -= n_diff n_diff -= 2 for d in xrange((n_diff - 1) << 1, -1, -8): m = n % 12 if m == 1 or m == 5: m = n >> 1 sieve[m] = not sieve[m] n -= d x_max, x2, xd = int(sqrt((end-1) / 3.0)), 0, 3 for xd in xrange(3, 6 * x_max + 2, 6): x2 += xd y_max = int(sqrt(end-x2)) n, n_diff = x2 + y_max*y_max, (y_max << 1) - 1 if not(n & 1): n -= n_diff n_diff -= 2 for d in xrange((n_diff - 1) << 1, -1, -8): if n % 12 == 7: m = n >> 1 sieve[m] = not sieve[m] n -= d x_max, y_min, x2, xd = int((2 + sqrt(4-8*(1-end)))/4), -1, 0, 3 for x in xrange(1, x_max + 1): x2 += xd xd += 6 if x2 >= end: y_min = (((int(ceil(sqrt(x2 - end))) - 1) << 1) - 2) << 1 n, n_diff = ((x*x + x) << 1) - 1, (((x-1) << 1) - 2) << 1 for d in xrange(n_diff, y_min, -8): if n % 12 == 11: m = n >> 1 sieve[m] = not sieve[m] n += d primes = [2, 3] if end <= 3: return primes[:max(0,end-2)] for n in xrange(5 >> 1, (int(sqrt(end))+1) >> 1): if sieve[n]: primes.append((n << 1) + 1) aux = (n << 1) + 1 aux *= aux for k in xrange(aux, end, 2 * aux): sieve[k >> 1] = False s = int(sqrt(end)) + 1 if s % 2 == 0: s += 1 primes.extend([i for i in xrange(s, end, 2) if sieve[i >> 1]]) return primes def ambi_sieve_plain(n): s = range(3, n, 2) for m in xrange(3, int(n**0.5)+1, 2): if s[(m-3)/2]: for t in xrange((m*m-3)/2,(n>>1)-1,m): s[t]=0 return [2]+[t for t in s if t>0] def sundaram3(max_n): numbers = range(3, max_n+1, 2) half = (max_n) initial = 4 for step in xrange(3, max_n+1, 2): for i in xrange(initial, half, step): numbers[i-1] = 0 initial += 2*(step+1) if initial > half: return [2] + filter(None, numbers) def ambi_sieve(n): s = np.arange(3, n, 2) for m in xrange(3, int(n ** 0.5)+1, 2): if s[(m-3)/2]: s[(m*m-3)/2::m]=0 return np.r_[2, s[s>0]] def primesfrom3to(n): assert n>=2 sieve = np.ones(n/2, dtype=np.bool) for i in xrange(3,int(n**0.5)+1,2): if sieve[i/2]: sieve[i*i/2::i] = False return np.r_[2, 2*np.nonzero(sieve)[0][1::]+1] def primesfrom2to(n): sieve = np.ones(n/3 + (n%6==2), dtype=np.bool) sieve[0] = False for i in xrange(int(n**0.5)/3+1): if sieve[i]: k=3*i+1|1 sieve[ ((k*k)/3) ::2*k] = False sieve[(k*k+4*k-2*k*(i&1))/3::2*k] = False return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)] if __name__== import itertools import sys def test(f1,f2,num): print( f1=f1.func_name, f2=f2.func_name)) if not all([a==b for a,b in itertools.izip_longest(f1(num),f2(num))]): sys.exit("Error: %s(%s) != %s(%s)"%(f1.func_name,num,f2.func_name,num)) n=1000000 test(sieveOfAtkin,sieveOfEratosthenes,n) test(sieveOfAtkin,ambi_sieve,n) test(sieveOfAtkin,ambi_sieve_plain,n) test(sieveOfAtkin,sundaram3,n) test(sieveOfAtkin,sieve_wheel_30,n) test(sieveOfAtkin,primesfrom3to,n) test(sieveOfAtkin,primesfrom2to,n) test(sieveOfAtkin,rwh_primes,n) test(sieveOfAtkin,rwh_primes1,n) test(sieveOfAtkin,rwh_primes2,n)
def primes(n): sieve = [True] * n for i in range(3,int(n**0.5)+1,2): if sieve[i]: sieve[i*i::2*i]=[False]*((n-i*i-1) return [2] + [i for i in range(3,n,2) if sieve[i]]
def primes1(n): sieve = [True] * (n for i in range(3,int(n**0.5)+1,2): if sieve[i sieve[i*i return [2] + [2*i+1 for i in range(1,n
import numpy def primesfrom3to(n): """ Returns a array of primes, 3 <= p < n """ sieve = numpy.ones(n for i in range(3,int(n**0.5)+1,2): if sieve[i sieve[i*i return 2*numpy.nonzero(sieve)[0][1::]+1
import numpy def primesfrom2to(n): sieve = numpy.ones(n for i in range(1,int(n**0.5) if sieve[i]: k=3*i+1|1 sieve[ k*k sieve[k*(k-2*(i&1)+4) return numpy.r_[2,3,((3*numpy.nonzero(sieve)[0][1:]+1)|1)]
def primes2(n): n, correction = n-n%6+6, 2-(n%6>1) sieve = [True] * (n for i in range(1,int(n**0.5) if sieve[i]: k=3*i+1|1 sieve[ k*k sieve[k*(k-2*(i&1)+4) return [2,3] + [3*i+1|1 for i in range(1,n
import itertools def erat2( ): D = { } yield 2 for q in itertools.islice(itertools.count(3), 0, None, 2): p = D.pop(q, None) if p is None: D[q*q] = q yield q else: x = p + q while x in D or not (x&1): x += p D[x] = p
def get_primes_erat(n): return list(itertools.takewhile(lambda p: p<n, erat2()))
$ python2.5 -mtimeit -s 10 loops, best of 3: 1.69 sec per loop $ python2.5 -mtimeit -s 10 loops, best of 3: 673 msec per loop
def sundaram3(max_n): numbers = range(3, max_n+1, 2) half = (max_n) initial = 4 for step in xrange(3, max_n+1, 2): for i in xrange(initial, half, step): numbers[i-1] = 0 initial += 2*(step+1) if initial > half: return [2] + filter(None, numbers)
C:\USERS>python -m timeit -n10 -s "import get_primes" "get_primes.get_primes_erat(1000000)" 10 loops, best of 3: 710 msec per loop C:\USERS>python -m timeit -n10 -s "import get_primes" "get_primes.daniel_sieve_2(1000000)" 10 loops, best of 3: 435 msec per loop C:\USERS>python -m timeit -n10 -s "import get_primes" "get_primes.sundaram3(1000000)" 10 loops, best of 3: 327 msec per loop
>>> sorted(get_primes(530)) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 527, 529] >>> 17*31 527 >>> 23*23 529
for pos,i in enumerate(primes): if i > N: print primes[:pos]
from sympy import sieve primes = list(sieve.primerange(1, 10**6))
import itertools izip = itertools.zip_longest chain = itertools.chain.from_iterable compress = itertools.compress def rwh_primes2_python3(n): zero = bytearray([False]) size = n sieve = bytearray([True]) * size sieve[0] = False for i in range(int(n**0.5) if sieve[i]: k=3*i+1|1 start = (k*k+4*k-2*k*(i&1)) sieve[(k*k) sieve[ start ::2*k]=zero*((size - start - 1) ans = [2,3] poss = chain(izip(*[range(i, n, 6) for i in (1,5)])) ans.extend(compress(poss, sieve)) return ans
>>> timeit.timeit( 0.0652179726976101 >>> timeit.timeit( 0.03267321276325674
>>> timeit.timeit( 6.394284538007014 >>> timeit.timeit( 3.833829450302801
import primesieve primes = primesieve.generate_primes(10**8)
from itertools import compress def rwh_primes1v1(n): sieve = bytearray([True]) * (n for i in range(3,int(n**0.5)+1,2): if sieve[i sieve[i*i return [2,*compress(range(3,n,2), sieve[1:])] def rwh_primes1v2(n): sieve = bytearray([True]) * (n for i in range(1,int(n**0.5) if sieve[i]: sieve[2*i*(i+1)::2*i+1] = bytearray((n return [2,*compress(range(3,n,2), sieve[1:])]
import sys import random def miller_rabin_pass(a, n): d = n - 1 s = 0 while d % 2 == 0: d >>= 1 s += 1 a_to_power = pow(a, d, n) if a_to_power == 1: return True for i in xrange(s-1): if a_to_power == n - 1: return True a_to_power = (a_to_power * a_to_power) % n return a_to_power == n - 1 def miller_rabin(n): for a in [2, 3, 37, 73]: if not miller_rabin_pass(a, n): return False return True n = int(sys.argv[1]) primes = [2] for p in range(3,n,2): if miller_rabin(p): primes.append(p) print len(primes)
$ python -mtimeit -s 10 loops, best of 3: 445 msec per loop $ cat sieve.py from math import sqrt def sieve(size): prime=[True]*size rng=xrange limit=int(sqrt(size)) for i in rng(3,limit+1,+2): if prime[i]: prime[i*i::+i]=[False]*len(prime[i*i::+i]) return [2]+[i for i in rng(3,size,+2) if prime[i]] if __name__== print sieve(100)
def daniel_sieve_2(maxNumber): allNumbers = range(3, maxNumber+1, 2) for mIndex, number in enumerate(xrange(3, maxNumber+1, 2)): if allNumbers[mIndex] == 0: continue for index in xrange(mIndex+number, (maxNumber-3)/2+1, number): allNumbers[index] = 0 return [2] + filter(lambda n: n!=0, allNumbers)
>>>mine = timeit.Timer("daniel_sieve_2(1000000)", ... "from sieves import daniel_sieve_2") >>>prev = timeit.Timer("get_primes_erat(1000000)", ... "from sieves import get_primes_erat") >>>print "Mine: {0:0.4f} ms".format(min(mine.repeat(3, 1))*1000) Mine: 428.9446 ms >>>print "Previous Best {0:0.4f} ms".format(min(prev.repeat(3, 1))*1000) Previous Best 621.3581 ms
python -m timeit -r10 -s"from sympy import sieve" "primes = list(sieve.primerange(1, 10**6))"
pypy -m timeit -r10 -s"from sympy import sieve" "primes = list(sieve.primerange(1, 10**6))"
import time def GetPrimes(n): Sieve = [1 for x in xrange(n)] Done = False w = 3 while not Done: for q in xrange (3, n, 2): Prod = w*q if Prod < n: Sieve[Prod] = 0 else: break if w > (n/2): Done = True w += 2 return Sieve start = time.clock() d = 10000000 Primes = GetPrimes(d) count = 1 for x in xrange (3, d, 2): if Primes[x]: count+=1 elapsed = (time.clock() - start) print "\nFound", count, "primes in", elapsed, "seconds!\n"
import time def GetPrimes2(n): Sieve = [1 for x in xrange(n)] for q in xrange (3, n, 2): k = q for y in xrange(k*3, n, k*2): Sieve[y] = 0 return Sieve start = time.clock() d = 10000000 Primes = GetPrimes2(d) count = 1 for x in xrange (3, d, 2): if Primes[x]: count+=1 elapsed = (time.clock() - start) print "\nFound", count, "primes in", elapsed, "seconds!\n"
import time def GetPrimes3(n): Sieve = [1 for x in xrange(n)] for q in xrange (3, n, 2): k = q for y in xrange(k*k, n, k << 1): Sieve[y] = 0 return Sieve start = time.clock() d = 10000000 Primes = GetPrimes3(d) count = 1 for x in xrange (3, d, 2): if Primes[x]: count+=1 elapsed = (time.clock() - start) print "\nFound", count, "primes in", elapsed, "seconds!\n"
def primeSieveSeq(MAX_Int): if MAX_Int > 5*10**8: import ctypes int16Array = ctypes.c_ushort * (MAX_Int >> 1) sieve = int16Array() else: sieve = (MAX_Int >> 1) * [False] if MAX_Int < 10**8: sieve[4::3] = [True]*((MAX_Int - 8)/6+1) sieve[12::5] = [True]*((MAX_Int - 24)/10+1) r = [2, 3, 5] n = 0 for i in xrange(int(MAX_Int**0.5)/30+1): n += 3 if not sieve[n]: n2 = (n << 1) + 1 r.append(n2) n2q = (n2**2) >> 1 sieve[n2q::n2] = [True]*(((MAX_Int >> 1) - n2q - 1) / n2 + 1) n += 2 if not sieve[n]: n2 = (n << 1) + 1 r.append(n2) n2q = (n2**2) >> 1 sieve[n2q::n2] = [True]*(((MAX_Int >> 1) - n2q - 1) / n2 + 1) n += 1 if not sieve[n]: n2 = (n << 1) + 1 r.append(n2) n2q = (n2**2) >> 1 sieve[n2q::n2] = [True]*(((MAX_Int >> 1) - n2q - 1) / n2 + 1) n += 2 if not sieve[n]: n2 = (n << 1) + 1 r.append(n2) n2q = (n2**2) >> 1 sieve[n2q::n2] = [True]*(((MAX_Int >> 1) - n2q - 1) / n2 + 1) n += 1 if not sieve[n]: n2 = (n << 1) + 1 r.append(n2) n2q = (n2**2) >> 1 sieve[n2q::n2] = [True]*(((MAX_Int >> 1) - n2q - 1) / n2 + 1) n += 2 if not sieve[n]: n2 = (n << 1) + 1 r.append(n2) n2q = (n2**2) >> 1 sieve[n2q::n2] = [True]*(((MAX_Int >> 1) - n2q - 1) / n2 + 1) n += 3 if not sieve[n]: n2 = (n << 1) + 1 r.append(n2) n2q = (n2**2) >> 1 sieve[n2q::n2] = [True]*(((MAX_Int >> 1) - n2q - 1) / n2 + 1) n += 1 if not sieve[n]: n2 = (n << 1) + 1 r.append(n2) n2q = (n2**2) >> 1 sieve[n2q::n2] = [True]*(((MAX_Int >> 1) - n2q - 1) / n2 + 1) if MAX_Int < 10**8: return [2, 3, 5]+[(p << 1) + 1 for p in [n for n in xrange(3, MAX_Int >> 1) if not sieve[n]]] n = n >> 1 try: for i in xrange((MAX_Int-2*n)/30 + 1): n += 3 if not sieve[n]: r.append((n << 1) + 1) n += 2 if not sieve[n]: r.append((n << 1) + 1) n += 1 if not sieve[n]: r.append((n << 1) + 1) n += 2 if not sieve[n]: r.append((n << 1) + 1) n += 1 if not sieve[n]: r.append((n << 1) + 1) n += 2 if not sieve[n]: r.append((n << 1) + 1) n += 3 if not sieve[n]: r.append((n << 1) + 1) n += 1 if not sieve[n]: r.append((n << 1) + 1) except: pass return r
import lib import timeit import sys import math import datetime import prettyplotlib as ppl import numpy as np import matplotlib.pyplot as plt from prettyplotlib import brewer2mpl primenumbers_gen = [ ] def human_format(num): magnitude = 0 while abs(num) >= 1000: magnitude += 1 num /= 1000.0 return if __name__== n = 10000000 nbcol = 5 nb_benchloop = 3 datetimeformat = config = primenumbers_gen = { } if len(sys.argv)>1: n = int(sys.argv[1]) step = int(math.ceil(n / float(nbcol))) nbs = np.array([i * step for i in range(1, int(nbcol) + 1)]) set2 = brewer2mpl.get_map( print datetime.datetime.now().strftime(datetimeformat) print("Compute prime number to %(n)s" % locals()) print("") results = dict() for pgen in primenumbers_gen: results[pgen] = dict() benchtimes = list() for n in nbs: t = timeit.Timer("lib.%(pgen)s(n)" % locals(), setup=config) execute_times = t.repeat(repeat=nb_benchloop,number=1) benchtime = np.mean(execute_times) benchtimes.append(benchtime) results[pgen] = { fig, ax = plt.subplots(1) plt.ylabel( plt.xlabel( i = 0 for pgen in primenumbers_gen: bench = results[pgen][ avgs = np.divide(bench,nbs) avg = np.average(bench, weights=nbs) A = np.vstack([nbs, np.ones(len(nbs))]).T a, b = np.linalg.lstsq(A, nbs*avgs)[0] i += 1 label="%(pgen)s avg" % locals() ppl.plot(nbs, a * nbs + b, label=label, lw=2, color=set2[i % 12]) print datetime.datetime.now().strftime(datetimeformat) ppl.legend(ax, loc= ax.get_xaxis().get_major_formatter().set_scientific(False) fig.canvas.draw() labels = [human_format(int(item.get_text())) for item in ax.get_xticklabels()] ax.set_xticklabels(labels) ax = plt.gca() plt.show()
def rwh_primes2(n): correction = (n%6>1) n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6] sieve = [True] * (n sieve[0] = False for i in range(int(n**0.5) if sieve[i]: k=3*i+1|1 sieve[ ((k*k) sieve[(k*k+4*k-2*k*(i&1)) return [2,3] + [3*i+1|1 for i in range(1,n
def erat3( ): from itertools import islice, count yield 2 D = {} for q in islice(count(3),0,None,2): if q in D: p = D[q] del D[q] x = q + p+p while x in D: x += p+p D[x] = p else: D[q*q] = q yield q
import itertools as it def erat2a( ): D = { } yield 2 for q in it.islice(it.count(3), 0, None, 2): p = D.pop(q, None) if p is None: D[q*q] = q yield q else: x = q + 2*p while x in D: x += 2*p D[x] = p
from bitarray import bitarray def primes_to(n): size = n sieve = bitarray(size) sieve.setall(1) limit = int(n**0.5) for i in range(1,limit): if sieve[i]: val = 2*i+1 sieve[(i+i*val)::val] = 0 return [2] + [2*i+1 for i, v in enumerate(sieve) if v and i > 0] python -m timeit -n10 -s "import euler" "euler.primes_to(1000000000)" 10 loops, best of 3: 46.5 sec per loop
from time import time def primes_sieve(limit): a = [True] * limit a[0] = a[1] = False for n in xrange(4, limit, 2): a[n] = False root_limit = int(limit**.5)+1 for i in xrange(3,root_limit): if a[i]: for n in xrange(i*i, limit, 2*i): a[n] = False return a LIMIT = 10**6 s=time() primes = primes_sieve(LIMIT) print time()-s
import numpy as np def ajs_primes3a(upto): mat = np.ones((upto), dtype=bool) mat[0] = False mat[1] = False mat[4::2] = False for idx in range(3, int(upto ** 0.5)+1, 2): mat[idx*2::idx] = False return np.where(mat == True)[0]
noprimes = [j for i in range(2, 8) for j in range(i*2, 50, i)] primes = [x for x in range(2, 50) if x not in noprimes]
primes = [1,3,5,7] for n in range(9,100000,2): for x in range(1,(len(primes)/2)): if n % primes[x] == 0: break else: primes.append(n) print primes
nums = xrange(2, n) for i in range(2, 10): nums = filter(lambda s: s==i or s%i, nums) print nums
source venv/bin/activate pip freeze > requirements.txt pip uninstall -r requirements.txt -y deactivate rm -r venv/
Uninstalling virtualenv-15.1.0: /usr/bin/virtualenv /usr/local/bin/virtualenv /usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info/DESCRIPTION.rst /usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info/INSTALLER /usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info/METADATA /usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info/RECORD /usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info/WHEEL /usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info/entry_points.txt /usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info/metadata.json /usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info/top_level.txt /usr/local/lib/python2.7/dist-packages/virtualenv.py /usr/local/lib/python2.7/dist-packages/virtualenv.pyc /usr/local/lib/python2.7/dist-packages/virtuakmr.ndrsh@gmail.comlenv_support/__init__.py /usr/local/lib/python2.7/dist-packages/virtualenv_support/__init__.pyc /usr/local/lib/python2.7/dist-packages/virtualenv_support/argparse-1.4.0-py2.py3-none-any.whl /usr/local/lib/python2.7/dist-packages/virtualenv_support/pip-9.0.1-py2.py3-none-any.whl /usr/local/lib/python2.7/dist-packages/virtualenv_support/setuptools-28.8.0-py2.py3-none-any.whl /usr/local/lib/python2.7/dist-packages/virtualenv_support/wheel-0.29.0-py2.py3-none-any.whl Proceed (y/n)? y Successfully uninstalled virtualenv-15.1.0 The directory --------------------------------
class Quitter(object): def __init__(self, name): self.name = name def __repr__(self): return def __call__(self, code=None): try: sys.stdin.close() except: pass raise SystemExit(code) __builtin__.quit = Quitter( __builtin__.exit = Quitter(
rpt <class MultiIndex: 47518 entries, ( Data columns: STK_ID 47518 non-null values STK_Name 47518 non-null values RPT_Date 47518 non-null values sales 47518 non-null values
<class MultiIndex: 25 entries, ( Data columns: STK_ID 25 non-null values STK_Name 25 non-null values RPT_Date 25 non-null values sales 25 non-null values
>>> rpt[rpt[ ... STK_ID ... ... ... ... ... ... ...
>>> rpt[rpt[ ... STK_ID ... ... ... ... ... ... ...
RPT_Date STK_ID STK_Name sales 0 1980-01-01 0 Arthur 0 1 1980-01-02 1 Beate 4 2 1980-01-03 2 Cecil 2 3 1980-01-04 3 Dana 8 4 1980-01-05 4 Eric 4 5 1980-01-06 5 Fidel 5 6 1980-01-07 6 George 4 7 1980-01-08 7 Hans 7 8 1980-01-09 8 Ingrid 7 9 1980-01-10 9 Jones 4
mask = df[ mask 0 False 1 False 2 True 3 False 4 True 5 False 6 True 7 False 8 False 9 False Name: STK_ID, dtype: bool df[mask] RPT_Date STK_ID STK_Name sales 2 1980-01-03 2 Cecil 2 4 1980-01-05 4 Eric 4 6 1980-01-07 6 George 4
df.set_index( RPT_Date STK_Name sales STK_ID 0 1980-01-01 Arthur 0 1 1980-01-02 Beate 4 2 1980-01-03 Cecil 2 3 1980-01-04 Dana 8 4 1980-01-05 Eric 4 5 1980-01-06 Fidel 5 6 1980-01-07 George 4 7 1980-01-08 Hans 7 8 1980-01-09 Ingrid 7 9 1980-01-10 Jones 4 df.loc[[4, 2, 6]] RPT_Date STK_Name sales STK_ID 4 1980-01-05 Eric 4 2 1980-01-03 Cecil 2 6 1980-01-07 George 4
stkid_df = pd.DataFrame({"STK_ID": [4,2,6]}) df.merge(stkid_df, on= STK_ID RPT_Date STK_Name sales 0 2 1980-01-03 Cecil 2 1 4 1980-01-05 Eric 4 2 6 1980-01-07 George 4
df = pd.DataFrame({ df = pd.DataFrame({ list_of_values = [3,6] result= df.query("A in @list_of_values") result A B 1 6 2 2 3 3
import six if isinstance(obj, six.string_types): print(
import sys PY3 = sys.version_info[0] == 3 if PY3: string_types = str else: string_types = basestring
def is_string(s): try: s += except: return False return True
def getfields(*fields, sep= field sequence. Accepts a string, a string with separators, or a sequence of strings if fields: try: fieldseq, = fields try: fieldseq = fieldseq.split(sep) except AttributeError: pass except ValueError: fieldseq = fields invalid_fields = [field for field in fieldseq if not validator(field)] if invalid_fields: raise ValueError( else: raise ValueError( try: yield from fieldseq except TypeError as e: raise ValueError(
from . import getfields def test_getfields_novalidation(): result = [ assert list(getfields( assert list(getfields( assert list(getfields( assert list(getfields([
def is_string(obj): try: obj + return True except TypeError: return False
>>> def f(x, y): ... print("Hello") ... if x: ... y += x ... print(x, y) ... return x+y ... >>> import dis >>> dis.dis(f) 2 0 LOAD_GLOBAL 0 (print) 2 LOAD_CONST 1 ( 4 CALL_FUNCTION 1 6 POP_TOP 3 8 LOAD_FAST 0 (x) 10 POP_JUMP_IF_FALSE 20 4 12 LOAD_FAST 1 (y) 14 LOAD_FAST 0 (x) 16 INPLACE_ADD 18 STORE_FAST 1 (y) 5 >> 20 LOAD_GLOBAL 0 (print) 22 LOAD_FAST 0 (x) 24 LOAD_FAST 1 (y) 26 CALL_FUNCTION 2 28 POP_TOP 6 30 LOAD_FAST 0 (x) 32 LOAD_FAST 1 (y) 34 BINARY_ADD 36 RETURN_VALUE
class SomeClass(object): def not_often_called(self) from datetime import datetime self.datetime = datetime.now()
from datetime import datetime class SomeClass(object): def not_often_called(self) self.datetime = datetime.now()
if [condition]: import foo as plugin_api else: import bar as plugin_api xx = plugin_api.Plugin() [...]
from pprint import pprint pprint(x) do_something_with_x(x)
import os try: kill = os.kill from signal import SIGTERM def terminate(process): kill(process.pid, SIGTERM) except (AttributeError, ImportError): try: from win32api import TerminateProcess def terminate(process): TerminateProcess(int(process._handle), -1) except ImportError: def terminate(process): raise NotImplementedError
0 foo: 14429.0924 µs 1 foo: 63.8962 µs 2 foo: 10.0136 µs 3 foo: 7.1526 µs 4 foo: 7.8678 µs 0 bar: 9.0599 µs 1 bar: 6.9141 µs 2 bar: 7.1526 µs 3 bar: 7.8678 µs 4 bar: 7.1526 µs
from __future__ import print_function from time import time def foo(): import collections import re import string import math import subprocess return def bar(): import collections import re import string import math import subprocess return t0 = time() for i in xrange(5): foo() t1 = time() print(" %2d foo: %12.4f \xC2\xB5s" % (i, (t1-t0)*1E6)) t0 = t1 for i in xrange(5): bar() t1 = time() print(" %2d bar: %12.4f \xC2\xB5s" % (i, (t1-t0)*1E6)) t0 = t1
from test import add, X, Y, Z def callme(): x=X y=Y z=Z ladd=add for i in range(100000000): ladd(i) x+y+z callme()
from test import add, X, Y, Z def callme(): for i in range(100000000): add(i) X+Y+Z callme()
/usr/bin/time -f "\t%E real,\t%U user,\t%S sys" python run.py 0:17.80 real, 17.77 user, 0.01 sys /tmp/test$ /usr/bin/time -f "\t%E real,\t%U user,\t%S sys" python runlocal.py 0:14.23 real, 14.22 user, 0.01 sys
>>> from operator import itemgetter >>> data = [( >>> sorted(data,key=itemgetter(1)) [(
>python -m timeit -s "from operator import itemgetter; data = [( 1000000 loops, best of 3: 1.22 usec per loop >python -m timeit -s "data = [( 1000000 loops, best of 3: 1.4 usec per loop
>>> from operator import itemgetter, attrgetter >>> sorted(student_tuples, key=itemgetter(2)) [( >>> sorted(student_objects, key=attrgetter( [(
foo = [(list of tuples)] foo.sort(key=lambda x:x[0])
import web import json from mimerender import mimerender render_xml = lambda message: render_json = lambda **args: json.dumps(args) render_html = lambda message: render_txt = lambda message: message urls = ( ) app = web.application(urls, globals()) class greet: @mimerender( default = html = render_html, xml = render_xml, json = render_json, txt = render_txt ) def GET(self, name): if not name: name = return { if __name__ == "__main__": app.run()
$ curl localhost:8080/x <html><body>Hello, x!</body></html> $ curl -H "Accept: application/html" localhost:8080/x <html><body>Hello, x!</body></html> $ curl -H "Accept: application/xml" localhost:8080/x <message>Hello, x!</message> $ curl -H "Accept: application/json" localhost:8080/x { $ curl -H "Accept: text/plain" localhost:8080/x Hello, x!
from flask import Flask app = Flask(__name__) @app.route("/") def hello(): return "Hello World!" if __name__ == "__main__": app.run()
def someUsefulThing( request, object_id ): return { a dictionary with results } def htmlView( request, object_id ): d = someUsefulThing( request, object_id ) render_to_response( def jsonView( request, object_id ): d = someUsefulThing( request, object_id ) data = serializers.serialize( response = HttpResponse( data, status=200, content_type= response[ return response
import cherrypy from cherrypy import expose class Converter: @expose def index(self): return "Hello World!" @expose def fahr_to_celc(self, degrees): temp = (float(degrees) - 32) * 5 / 9 return "%.01f" % temp @expose def celc_to_fahr(self, degrees): temp = float(degrees) * 9 / 5 + 32 return "%.01f" % temp cherrypy.quickstart(Converter())
from django.conf.urls.defaults import patterns, url from djangorestframework.resources import ModelResource from djangorestframework.views import ListOrCreateModelView, InstanceModelView from myapp.models import MyModel class MyResource(ModelResource): model = MyModel urlpatterns = patterns( url(r url(r )
import os, shutil folder = for the_file in os.listdir(folder): file_path = os.path.join(folder, the_file) try: if os.path.isfile(file_path): os.unlink(file_path) except Exception as e: print(e)
import os import glob files = glob.glob( for f in files: os.remove(f)
import os import shutil for root, dirs, files in os.walk( for f in files: os.unlink(os.path.join(root, f)) for d in dirs: shutil.rmtree(os.path.join(root, d))
folder_path = for file_object in os.listdir(folder_path): file_object_path = os.path.join(folder_path, file_object) if os.path.isfile(file_object_path): os.unlink(file_object_path) else: shutil.rmtree(file_object_path)
import os map( os.unlink, (os.path.join( mydir,f) for f in os.listdir(mydir)) ) list( map( os.unlink, (os.path.join( mydir,f) for f in os.listdir(mydir)) ) )
def rm(f): if os.path.isdir(f): return os.rmdir(f) if os.path.isfile(f): return os.unlink(f) raise TypeError, map( rm, (os.path.join( mydir,f) for f in os.listdir(mydir)) )
import os import stat import shutil def _remove_readonly(fn, path_, excinfo): if fn is os.rmdir: os.chmod(path_, stat.S_IWRITE) os.rmdir(path_) elif fn is os.remove: os.lchmod(path_, stat.S_IWRITE) os.remove(path_) def force_remove_file_or_symlink(path_): try: os.remove(path_) except OSError: os.lchmod(path_, stat.S_IWRITE) os.remove(path_) def is_regular_dir(path_): try: mode = os.lstat(path_).st_mode except os.error: mode = 0 return stat.S_ISDIR(mode) def clear_dir(path_): if is_regular_dir(path_): for name in os.listdir(path_): fullpath = os.path.join(path_, name) if is_regular_dir(fullpath): shutil.rmtree(fullpath, onerror=_remove_readonly) else: force_remove_file_or_symlink(fullpath) else: raise OSError("Cannot call clear_dir() on a symbolic link")
for filename in os.listdir(dirpath): filepath = os.path.join(dirpath, filename) try: shutil.rmtree(filepath) except OSError: os.remove(filepath)
import os import shutil contents = [os.path.join(target_dir, i) for i in os.listdir(target_dir)] [os.remove(i) if os.path.isfile(i) or os.path.islink(i) else shutil.rmtree(i) for i in contents]
import os import shutil with os.scandir(target_dir) as entries: for entry in entries: if entry.is_file() or entry.is_symlink(): os.remove(entry.path) elif entry.is_dir(): shutil.rmtree(entry.path)
import shutil import os shutil.rmtree(dirpath) os.mkdir(dirpath)
def emptydir(top): if(top == else: for root, dirs, files in os.walk(top, topdown=False): for name in files: os.remove(os.path.join(root, name)) for name in dirs: os.rmdir(os.path.join(root, name))
if os.path.isdir(folder_location): shutil.rmtree(folder_location) time.sleep(.5) os.makedirs(folder_location, 0o777)
import os def recursively_remove_files(f): if os.path.isfile(f): os.unlink(f) elif os.path.isdir(f): map(recursively_remove_files, [os.path.join(f,fi) for fi in os.listdir(f)]) recursively_remove_files(my_directory)
_ = [os.remove(os.path.join(save_dir,i)) for i in os.listdir(temp_dir)]
import os DIR = os.list( for i in range(len(DIR)): os.remove(
>>> import datetime >>> print unicode(datetime.datetime.now()) 2011-11-03 11:13:39.278026
>>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
>>> import datetime >>> now = datetime.datetime.now() >>> print unicode(now.replace(microsecond=0)) 2011-11-03 11:19:07
import datetime datetime.datetime.now().replace(microsecond=0).isoformat()
datetime.datetime.now().replace(microsecond=0).isoformat(
from datetime import datetime datetime.datetime.now().isoformat(
>>> import time >>> time.strftime("%Y-%m-%d %H:%M:%S")
>>> time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())
import datetime date_generated = datetime.datetime.now() date_generated.replace(microsecond=0).isoformat(
>>> t = datetime.datetime.now() >>> t datetime.datetime(2018, 11, 30, 17, 21, 26, 606191) >>> t = str(t).split( >>> t [ >>> t = t[0] >>> t >>>
import datetime now = datetime.datetime.now() now = now.replace(microsecond=0) print(now)
query = (model.Session.query(model.Entry) .join(model.ClassificationItem) .join(model.EnumerationValue) .filter_by(id=c.row.id) .order_by(model.Entry.amount) )
from sqlalchemy import desc someselect.order_by(desc(table1.mycol))
query = (model.Session.query(model.Entry) .join(model.ClassificationItem) .join(model.EnumerationValue) .filter_by(id=c.row.id) .order_by(model.Entry.amount.desc()) )
query = session.query( model.Entry ).join( model.ClassificationItem ).join( model.EnumerationValue ).filter_by( id=c.row.id ).order_by( model.Entry.amount.desc() ) )
lst1 = [1, 2, 3] lst2 = lst1 del lst1[:] print(lst2)
$ python -mtimeit "l=list(range(1000))" "b=l[:];del b[:]" 10000 loops, best of 3: 29.8 usec per loop $ python -mtimeit "l=list(range(1000))" "b=l[:];b[:] = []" 10000 loops, best of 3: 28.7 usec per loop $ python -V Python 2.5.2
index=len(list)-1 while index>=0: del list[index] index-=1
name = input("what is your name ?") what is your name ?harsha Traceback (most recent call last): File "<pyshell name = input("what is your name ?") File "<string>", line 1, in <module> NameError: name
>>> name = input("what is your name?") what is your name?"harsha" >>> print(name) harsha
name = raw_input("what is your name ?") what is your name ?harsha >>> name
name = eval(raw_input("what is your name?")) what is your name?harsha Traceback (most recent call last): File "<pyshell name = eval(raw_input("what is your name?")) File "<string>", line 1, in <module> NameError: name
try: try_this(whatever) except SomeException as exception: else: return something
something = some_default_value try: something = try_this(whatever) except SomeException as exception: finally: return something
try: something = try_this(whatever) return something except SomeException as exception:
recip = float( try: recip = 1 / f(x) except ZeroDivisionError: logging.info( else: logging.info(
try: try_this(whatever) except SomeException as the_exception: handle(the_exception) else: return something
no_error = None try: try_this(whatever) no_error = True except SomeException as the_exception: handle(the_exception) if no_error: return something
try: try_this(whatever) except SomeException as the_exception: handle_SomeException(the_exception) except Exception as the_exception: generic_handle(the_exception) else: return something() finally: return True
BaseException Exception ArithmeticError FloatingPointError OverflowError ZeroDivisionError AssertionError AttributeError BufferError EOFError ImportError ModuleNotFoundError LookupError IndexError KeyError MemoryError NameError UnboundLocalError OSError BlockingIOError ChildProcessError ConnectionError BrokenPipeError ConnectionAbortedError ConnectionRefusedError ConnectionResetError FileExistsError FileNotFoundError InterruptedError IsADirectoryError NotADirectoryError PermissionError ProcessLookupError TimeoutError ReferenceError RuntimeError NotImplementedError RecursionError StopAsyncIteration StopIteration SyntaxError IndentationError TabError SystemError TypeError ValueError UnicodeError UnicodeDecodeError UnicodeEncodeError UnicodeTranslateError Warning BytesWarning DeprecationWarning FutureWarning ImportWarning PendingDeprecationWarning ResourceWarning RuntimeWarning SyntaxWarning UnicodeWarning UserWarning GeneratorExit KeyboardInterrupt SystemExit
try: try_this(whatever) except SomeException as the_exception: handle(the_exception) raise
try: try_this(whatever) except SomeException as the_exception: handle(the_exception) raise DifferentException from the_exception
try: raw_value = int(input()) except ValueError: value = some_processed_value else: value = process_value(raw_value)
raw_value = input() if valid_number(raw_value): value = process_value(int(raw_value)) else: value = some_processed_value
In [10]: dict_ = {"a": 1} In [11]: try: ....: dict_["b"] ....: except KeyError: ....: pass ....: finally: ....: print "something" ....: something
In [14]: try: dict_["b"] except KeyError: pass else: print "something" ....:
try: y = 1 / x except ZeroDivisionError: pass else: return y
try: return 1 / x except ZeroDivisionError: return None
import contextlib with contextlib.suppress(ZeroDivisionError): return 1 / x
for i in range(3): try: y = 1 / i except ZeroDivisionError: print(f"\ti = {i}") print("\tError report: ZeroDivisionError") else: print(f"\ti = {i}") print(f"\tNo error report and y equals {y}") finally: print("Try block is run.")
i = 0 Error report: ZeroDivisionError Try block is run. i = 1 No error report and y equals 1.0 Try block is run. i = 2 No error report and y equals 0.5 Try block is run.
def div(a, b): try: a/b except ZeroDivisionError: print("Zero Division Error detected") else: print("No Zero Division Error") finally: print("Finally the division of %d/%d is done" % (a, b))
div(1, 1) No Zero Division Error Finally the division of 1/1 is done
div(1, 0) Zero Division Error detected Finally the division of 1/0 is done
try: x = blah() except: print "failed at blah()" else: print "just succeeded with blah"
try: x = blah() print "just succeeded with blah" except: print "failed at blah()"
import pandas as pd df=pd.read_csv( df.values array([[ 1. , 2. , 3. ], [ 4. , 5.5, 6. ]])
1.0, 2, 3 4, 5.5, 6 import numpy as np np.genfromtxt(
from numpy import genfromtxt genfromtxt(fname = dest_file, dtype = (<whatever options>))
import csv import numpy as np with open(dest_file, data_iter = csv.reader(dest_f, delimiter = delimiter, quotechar = data = [data for data in data_iter] data_array = np.asarray(data, dtype = <whatever options>)
$ for f in test_pandas.py test_numpy_csv.py ; do /usr/bin/time python $f; done 2.94user 0.41system 0:03.05elapsed 109%CPU (0avgtext+0avgdata 502068maxresident)k 0inputs+24outputs (0major+107147minor)pagefaults 0swaps 23.29user 0.72system 0:23.72elapsed 101%CPU (0avgtext+0avgdata 1680888maxresident)k 0inputs+0outputs (0major+416145minor)pagefaults 0swaps
du -h ~/me/notebook/train.csv 59M /home/hvn/me/notebook/train.csv
$ pip freeze | egrep -i numpy==1.13.3 pandas==0.20.2
import pandas as p import numpy as n closingValue = p.read_csv("<FILENAME>", usecols=[4], dtype=float) print(closingValue)
import pandas as pd data = pd.read_csv("dataset.csv") store = pd.HDFStore( store[ store.close()
import pandas as pd store = pd.HDFStore( data = store[ store.close() data = data.values
class test: def __init__(self): self.a = 10 def __call__(self): b = 20
class Foo: def __init__(self, a, b, c): x = Foo(1, 2, 3)
class Foo: def __call__(self, a, b, c): x = Foo() x(1, 2, 3)
In [1]: class A: ...: def __init__(self): ...: print "init" ...: ...: def __call__(self): ...: print "call" ...: ...: In [2]: a = A() init In [3]: a() call
class Stuff(object): def __init__(self, x, y, range): super(Stuff, self).__init__() self.x = x self.y = y self.range = range def __call__(self, x, y): self.x = x self.y = y print def __del__(self): del self.x del self.y del self.range >>> s = Stuff(1, 2, 3) >>> s.x 1 >>> s(7, 8) __call__ with (7,8) >>> s.x 7
>>> class A: ... def __init__(self): ... print "From init ... " ... >>> a = A() From init ... >>> a() Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: A instance has no __call__ method >>> >>> class B: ... def __init__(self): ... print "From init ... " ... def __call__(self): ... print "From call ... " ... >>> b = B() From init ... >>> b() From call ... >>>
class Recorder: def __init__(self): self._weights = [] for i in range(0, 2): self._weights.append(1) print self._weights[-1] print self._weights[-2] print "no. above is from __init__" def __call__(self, t): self._weights = [self._weights[-1], self._weights[-1] + self._weights[-2]] print self._weights[-1] print "no. above is from __call__" weight_recorder = Recorder() for i in range(0, 10): weight_recorder(i)
1 1 no. above is from __init__ 2 no. above is from __call__ 3 no. above is from __call__ 5 no. above is from __call__ 8 no. above is from __call__ 13 no. above is from __call__ 21 no. above is from __call__ 34 no. above is from __call__ 55 no. above is from __call__ 89 no. above is from __call__ 144 no. above is from __call__
class _Callable: def __init__(self, anycallable): self.__call__ = anycallable class Model: def get_instance(conn, table_name): get_instance = _Callable(get_instance) provs_fac = Model.get_instance(connection, "users")
class decorator_without_arguments(object): def __init__(self, f): print("Inside __init__()") self.f = f def __call__(self, *args): print("Inside __call__()") self.f(*args) print("After self.f( * args)") @decorator_without_arguments def sayHello(a1, a2, a3, a4): print( print("After decoration") print("Preparing to call sayHello()") sayHello("say", "hello", "argument", "list") print("After first sayHello() call") sayHello("a", "different", "set of", "arguments") print("After second sayHello() call")
>>> class Test: ... def __init__(self): ... return ... >>> Test() Traceback (most recent call last): File "<console>", line 1, in <module> TypeError: __init__() should return None, not >>> class Test2: ... def __call__(self): ... return ... >>> Test2()() >>> >>> Test2()() >>>
class test(object): def __init__(self, a, b, c): self.a = a self.b = b self.c = c def __call__(self, a, b, c): self.a = a self.b = b self.c = c instance1 = test(1, 2, 3) print(instance1.a) instance1(13,3,4) print(instance1.a)
public class Test { public static void main(String[] args) { Test.TestInnerClass testInnerClass = new Test(). new TestInnerClass(1, 2, 3); System.out.println(testInnerClass.a); testInnerClass = new Test().new TestInnerClass(13, 3, 4); System.out.println(testInnerClass.a); testInnerClass.a = 5; testInnerClass.b = 14; testInnerClass.c = 23; } class TestInnerClass { private int a, b,c; TestInnerClass(int a, int b, int c) { this.a = a; this.b = b; this.c = c; } } }
class my_class(): def __init__(self,a,b): self.a = a self.b = b print("Object was created, instance variables were initialized") obj = my_class(1,2) print(obj.a) print(obj.b)
class my_class(): def __init__(self, a,b): self.a=a self.b=b def __call__(self,a,b): Sum = a+b return Sum obj = my_class(1,2) Sum = obj(4,5) print(Sum)
factorial_memo = {} def factorial(k): if k < 2: return 1 if k not in factorial_memo: factorial_memo[k] = k * factorial(k-1) return factorial_memo[k]
class Memoize: def __init__(self, f): self.f = f self.memo = {} def __call__(self, *args): if not args in self.memo: self.memo[args] = self.f(*args) return self.memo[args]
def factorial(k): if k < 2: return 1 return k * factorial(k - 1) factorial = Memoize(factorial)
@Memoize def factorial(k): if k < 2: return 1 return k * factorial(k - 1)
def doSomeExpensiveCalculation(self, input): if input not in self.cache: <do expensive calculation> self.cache[input] = result return self.cache[input]
def fact(n): if not hasattr(fact, fact.mem = {1: 1} if not n in fact.mem: fact.mem[n] = n * fact(n - 1) return fact.mem[n]
def memoize(function): from functools import wraps memo = {} @wraps(function) def wrapper(*args): if args in memo: return memo[args] else: rv = function(*args) memo[args] = rv return rv return wrapper @memoize def fibonacci(n): if n < 2: return n return fibonacci(n - 1) + fibonacci(n - 2) fibonacci(25)
fibcache = {} def fib(num): if num in fibcache: return fibcache[num] else: fibcache[num] = num if num < 2 else fib(num-1) + fib(num-2) return fibcache[num]
def memoize(fn): """returns a memoized version of any function that can be called with the same list of arguments. Usage: foo = memoize(foo)""" def handle_item(x): if isinstance(x, dict): return make_tuple(sorted(x.items())) elif hasattr(x, return make_tuple(x) else: return x def make_tuple(L): return tuple(handle_item(x) for x in L) def foo(*args, **kwargs): items_cache = make_tuple(sorted(kwargs.items())) args_cache = make_tuple(args) if (args_cache, items_cache) not in foo.past_calls: foo.past_calls[(args_cache, items_cache)] = fn(*args,**kwargs) return foo.past_calls[(args_cache, items_cache)] foo.past_calls = {} foo.__name__ = return foo
if is_instance(x, set): return make_tuple(sorted(list(x)))
def factorial(n, _cache={1:1}): try: return _cache[n] except IndexError: _cache[n] = factorial(n-1)*n return _cache[n]
cache = {} def fib(n): if n <= 1: return n else: if n not in cache: cache[n] = fib(n-1) + fib(n-2) return cache[n]
import inspect import functools def memoize(fn): cache = fn.cache = {} @functools.wraps(fn) def memoizer(*args, **kwargs): kwargs.update(dict(zip(inspect.getargspec(fn).args, args))) key = tuple(kwargs.get(k, None) for k in inspect.getargspec(fn).args) if key not in cache: cache[key] = fn(**kwargs) return cache[key] return memoizer
integer ::= decinteger | bininteger | octinteger | hexinteger decinteger ::= nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")* bininteger ::= "0" ("b" | "B") (["_"] bindigit)+ octinteger ::= "0" ("o" | "O") (["_"] octdigit)+ hexinteger ::= "0" ("x" | "X") (["_"] hexdigit)+ nonzerodigit ::= "1"..."9" digit ::= "0"..."9" bindigit ::= "0" | "1" octdigit ::= "0"..."7" hexdigit ::= digit | "a"..."f" | "A"..."F"
7 2147483647 0o177 0b100110111 3 79228162514264337593543950336 0o377 0xdeadbeef 100_000_000_000 0b_1110_0101
from timeit import * stats = ["for i in xrange(1000): iter(s).next() ", "for i in xrange(1000): \n\tfor x in s: \n\t\tbreak", "for i in xrange(1000): s.add(s.pop()) ", "for i in xrange(1000): s.get() "] for stat in stats: t = Timer(stat, setup="s=set(range(100))") try: print "Time for %s:\t %f"%(stat, t.timeit(number=1000)) except: t.print_exc()
$ ./test_get.py Time for for i in xrange(1000): iter(s).next() : 0.433080 Time for for i in xrange(1000): for x in s: break: 0.148695 Time for for i in xrange(1000): s.add(s.pop()) : 0.317418 Time for for i in xrange(1000): s.get() : 0.146673
from timeit import Timer stats = [ "for i in range(1000): \n\tfor x in s: \n\t\tbreak", "for i in range(1000): next(iter(s))", "for i in range(1000): s.add(s.pop())", "for i in range(1000): list(s)[0]", "for i in range(1000): random.sample(s, 1)", ] for stat in stats: t = Timer(stat, setup="import random\ns=set(range(100))") try: print("Time for %s:\t %f"%(stat, t.timeit(number=1000))) except: t.print_exc()
$ ./test_get.py Time for for i in range(1000): for x in s: break: 0.249871 Time for for i in range(1000): next(iter(s)): 0.526266 Time for for i in range(1000): s.add(s.pop()): 0.658832 Time for for i in range(1000): list(s)[0]: 4.117106 Time for for i in range(1000): random.sample(s, 1): 21.851104
>>> import random >>> s = set([1,2,3]) >>> random.sample(s, 1) [2]
>>> lst = list(s) ... >>> e = random.sample(lst, 1)[0]
from random import sample def ForLoop(s): for e in s: break return e def IterNext(s): return next(iter(s)) def ListIndex(s): return list(s)[0] def PopAdd(s): e = s.pop() s.add(e) return e def RandomSample(s): return sample(s, 1) def SetUnpacking(s): e, *_ = s return e from simple_benchmark import benchmark b = benchmark([ForLoop, IterNext, ListIndex, PopAdd, RandomSample, SetUnpacking], {2**i: set(range(2**i)) for i in range(1, 20)}, argument_name= function_aliases={first: b.plot()
>>> from iteration_utilities import first >>> first({1,2,3,4}) 1
def anyitem(iterable): try: return iter(iterable).next() except StopIteration: return None
from timeit import * stats = ["for i in range(1000): next(iter(s))", "for i in range(1000): \n\tfor x in s: \n\t\tbreak", "for i in range(1000): s.add(s.pop())"] for stat in stats: t = Timer(stat, setup="s=set(range(100000))") try: print("Time for %s:\t %f"%(stat, t.timeit(number=1000))) except: t.print_exc()
Time for for i in range(1000): next(iter(s)): 0.205888 Time for for i in range(1000): for x in s: break: 0.083397 Time for for i in range(1000): s.add(s.pop()): 0.226570
from timeit import * stats = ["while s:\n\ta = next(iter(s))\n\ts.remove(a)", "while s:\n\tfor x in s: break\n\ts.remove(x)", "while s:\n\tx=s.pop()\n\ts.add(x)\n\ts.remove(x)"] for stat in stats: t = Timer(stat, setup="s=set(range(100000))") try: print("Time for %s:\t %f"%(stat, t.timeit(number=1000))) except: t.print_exc()
Time for while s: a = next(iter(s)) s.remove(a): 2.938494 Time for while s: for x in s: break s.remove(x): 2.728367 Time for while s: x=s.pop() s.add(x) s.remove(x): 0.030272
poor_man_set = {} poor_man_set[1] = None poor_man_set[2] = None poor_man_set[3] = None ...
keys = poor_man_set.keys() print "Some key = %s" % keys[0]
poor_man_set = {} poor_man_set[1] = None poor_man_set[2] = None poor_man_set[3] = None poor_man_set = poor_man_set.keys()
abort: error: error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol
def zero(): print "You typed zero.\n" def sqr(): print "n is a perfect square\n" def even(): print "n is an even number\n" def prime(): print "n is a prime number\n" options = {0 : zero, 1 : sqr, 4 : sqr, 9 : sqr, 2 : even, 3 : prime, 5 : prime, 7 : prime, }
def time_dec(func): def wrapper(*arg): t = time.clock() res = func(*arg) print func.func_name, time.clock()-t return res return wrapper @time_dec def myFunction(n): ...
import functools def synchronized(lock): def wrap(f): @functools.wraps(f) def newFunction(*args, **kw): lock.acquire() try: return f(*args, **kw) finally: lock.release() return newFunction return wrap
import functools def synchronized(lock): def wrap(f): @functools.wraps(f) def newFunction(*args, **kw): with lock: return f(*args, **kw) return newFunction return wrap
import threading lock = threading.Lock() @synchronized(lock) def do_something(): @synchronzied(lock) def do_something_else():
def myMethod(ID, name): if not (myIsType(ID, raise BlaBlaException() ...
@accepts(uint, utf8string) def myMethod(ID, name): ...
@inlineCallbacks def asyncf(): doStuff() yield someAsynchronousCall() doStuff() yield someAsynchronousCall() doStuff()
@parameters( (2, 4, 6), (5, 6, 11), ) def test_add(a, b, expected): assert a + b == expected
import functools def log(logger, level= def log_decorator(fn): @functools.wraps(fn) def wrapper(*a, **kwa): getattr(logger, level)(fn.__name__) return fn(*a, **kwa) return wrapper return log_decorator @log(logging.getLogger( def potentially_dangerous_function(times): for _ in xrange(times): rockets.get_rocket(NUCLEAR=True).fire()
def threadsafe_function(fn): lock = threading.Lock() def new(*args, **kwargs): lock.acquire() try: r = fn(*args, **kwargs) except Exception as e: raise e finally: lock.release() return r return new class X: var = 0 @threadsafe_function def inc_var(self): X.var += 1 return X.var
class HelloWorld: ... def secret(self): return "You shouldn @cherrypy.expose def index(self): return "Hello world!" cherrypy.quickstart(HelloWorld())
def fill_it(arg): if isinstance(arg, int): return "wan" + str(arg) else: try: if str(int(arg)) == arg: return "wan" + arg else: raise Exception("I dont know this " + arg) print "What arg?" except ValueError, e: return arg def fill_wanname(func): def wrapper(arg): filled = fill_it(arg) return func(filled) return wrapper @fill_wanname def get_iface_of(wanname): global __iface_config__ return __iface_config__[wanname][
def static_var(varname, value): Decorator to create a static variable for the specified function @param varname: static variable name @param value: initial value for the variable def decorate(func): setattr(func, varname, value) return func return decorate @static_var("count", 0) def mainCallCount(): mainCallCount.count += 1
def printProgressBar (iteration, total, prefix = """ Call in a loop to create terminal progress bar @params: iteration - Required : current iteration (Int) total - Required : total iterations (Int) prefix - Optional : prefix string (Str) suffix - Optional : suffix string (Str) decimals - Optional : positive number of decimals in percent complete (Int) length - Optional : character length of bar (Int) fill - Optional : bar fill character (Str) """ percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total))) filledLength = int(length * iteration bar = fill * filledLength + print( if iteration == total: print() from time import sleep items = list(range(0, 57)) l = len(items) printProgressBar(0, l, prefix = for i, item in enumerate(items): sleep(0.1) printProgressBar(i + 1, l, prefix = Progress: |█████████████████████████████████████████████-----| 90.0% Complete
import time import sys for i in range(100): time.sleep(1) sys.stdout.write("\r%d%%" % i) sys.stdout.flush()
>>> import time >>> from tqdm import tqdm >>> for i in tqdm(range(100)): ... time.sleep(1) ... |
import sys def progress(count, total, suffix= bar_len = 60 filled_len = int(round(bar_len * count / float(total))) percents = round(100.0 * count / float(total), 1) bar = sys.stdout.write( sys.stdout.flush()
import click with click.progressbar(range(1000000)) as bar: for i in bar: pass
import click, sys with click.progressbar(range(100000), file=sys.stderr, show_pos=True, width=70, bar_template= for i in bar: pass
(_(_)===================================D(_(_| 100000/100000 00:00:02
click.progressbar(iterable=None, length=None, label=None, show_eta=True, show_percent=None, show_pos=False, item_show_func=None, fill_char=
import sys def cli_progress_test(end_val, bar_length=20): for i in xrange(0, end_val): percent = float(i) / end_val hashes = spaces = sys.stdout.write("\rPercent: [{0}] {1}%".format(hashes + spaces, int(round(percent * 100)))) sys.stdout.flush()
from time import sleep from random import random from clint.textui import progress if __name__ == for i in progress.bar(range(100)): sleep(random() * 0.2) for i in progress.dots(range(100)): sleep(random() * 0.2)
import time,sys for i in range(100+1): time.sleep(0.1) sys.stdout.write(( sys.stdout.flush()
import sys class ProgressBar(object): DEFAULT_BAR_LENGTH = 65 DEFAULT_CHAR_ON = DEFAULT_CHAR_OFF = def __init__(self, end, start=0): self.end = end self.start = start self._barLength = self.__class__.DEFAULT_BAR_LENGTH self.setLevel(self.start) self._plotted = False def setLevel(self, level): self._level = level if level < self.start: self._level = self.start if level > self.end: self._level = self.end self._ratio = float(self._level - self.start) / float(self.end - self.start) self._levelChars = int(self._ratio * self._barLength) def plotProgress(self): sys.stdout.write("\r %3i%% [%s%s]" %( int(self._ratio * 100.0), self.__class__.DEFAULT_CHAR_ON * int(self._levelChars), self.__class__.DEFAULT_CHAR_OFF * int(self._barLength - self._levelChars), )) sys.stdout.flush() self._plotted = True def setAndPlot(self, level): oldChars = self._levelChars self.setLevel(level) if (not self._plotted) or (oldChars != self._levelChars): self.plotProgress() def __add__(self, other): assert type(other) in [float, int], "can only add a number" self.setAndPlot(self._level + other) return self def __sub__(self, other): return self.__add__(-other) def __iadd__(self, other): return self.__add__(other) def __isub__(self, other): return self.__add__(-other) def __del__(self): sys.stdout.write("\n") if __name__ == "__main__": import time count = 150 print "starting things:" pb = ProgressBar(count) for i in range(0, count): pb += 1 time.sleep(0.01) del pb print "done"
starting things: 100% [=================================================================] done
>>> import threading >>> for i in range(50+1): ... threading._sleep(0.5) ... print "\r%3d" % i, (
import time from tqdm import tqdm for i in tqdm(range(1000)): time.sleep(0.01)
47%|██████████████████▊ | 470/1000 [00:04<00:05, 98.61it/s]
import time, sys def update_progress(progress): barLength = 10 status = "" if isinstance(progress, int): progress = float(progress) if not isinstance(progress, float): progress = 0 status = "error: progress var must be float\r\n" if progress < 0: progress = 0 status = "Halt...\r\n" if progress >= 1: progress = 1 status = "Done...\r\n" block = int(round(barLength*progress)) text = "\rPercent: [{0}] {1}% {2}".format( " sys.stdout.write(text) sys.stdout.flush()
import urllib from tqdm import tqdm def my_hook(t): """ Wraps tqdm instance. Don the tqdm instance once you Example ------- >>> with tqdm(...) as t: ... reporthook = my_hook(t) ... urllib.urlretrieve(..., reporthook=reporthook) """ last_b = [0] def inner(b=1, bsize=1, tsize=None): """ b : int, optional Number of blocks just transferred [default: 1]. bsize : int, optional Size of each block (in tqdm units) [default: 1]. tsize : int, optional Total size (in tqdm units). If [default: None] remains unchanged. """ if tsize is not None: t.total = tsize t.update((b - last_b[0]) * bsize) last_b[0] = b return inner eg_link = with tqdm(unit= desc=eg_link.split( urllib.urlretrieve(eg_link, filename= reporthook=my_hook(t), data=None)
import time import progressbar for i in progressbar.progressbar(range(100)): time.sleep(0.02)
import sys def progresssbar(): for i in range(100): time.sleep(1) sys.stdout.write("%i\r" % i) progressbar()
import os import time def load(left_side, right_side, length, time): x = 0 y = "" print "\r" while x < length: space = length - len(y) space = " " * space z = left + y + space + right print "\r", z, y += "█" time.sleep(time) x += 1 cls()
print "loading something awesome" load("|", "|", 10, .01)
import sys import time max_length = 5 at_length = max_length empty = "-" used = "%" bar = empty * max_length for i in range(0, max_length): at_length -= 1 bar = used * i bar = bar+empty * at_length sys.stdout.write("[{}]\0\r".format(bar)) sys.stdout.flush() time.sleep(1) sys.stdout.write("\n") sys.stdout.flush()
import datetime, sys start = datetime.datetime.now() def print_progress_bar (iteration, total): process_duration_samples = [] average_samples = 5 end = datetime.datetime.now() process_duration = end - start if len(process_duration_samples) == 0: process_duration_samples = [process_duration] * average_samples process_duration_samples = process_duration_samples[1:average_samples-1] + [process_duration] average_process_duration = sum(process_duration_samples, datetime.timedelta()) / len(process_duration_samples) remaining_steps = total - iteration remaining_time_estimation = remaining_steps * average_process_duration bars_string = int(float(iteration) / float(total) * 20.) sys.stdout.write( "\r[%-20s] %d%% (%s/%s) Estimated time left: %s" % ( iteration, total, remaining_time_estimation ) ) sys.stdout.flush() if iteration + 1 == total: print for i in range(0,300): print_progress_bar(i, 300)
import sys def prg(prog, fillchar, emptchar): fillt = 0 emptt = 20 if prog < 100 and prog > 0: prog2 = prog/5 fillt = fillt + prog2 emptt = emptt - prog2 sys.stdout.write("\r[" + str(fillchar)*fillt + str(emptchar)*emptt + "]" + str(prog) + "%") sys.stdout.flush() elif prog >= 100: prog = 100 prog2 = prog/5 fillt = fillt + prog2 emptt = emptt - prog2 sys.stdout.write("\r[" + str(fillchar)*fillt + str(emptchar)*emptt + "]" + str(prog) + "%" + "\nDone!") sys.stdout.flush() elif prog < 0: prog = 0 prog2 = prog/5 fillt = fillt + prog2 emptt = emptt - prog2 sys.stdout.write("\r[" + str(fillchar)*fillt + str(emptchar)*emptt + "]" + str(prog) + "%" + "\nHalted!") sys.stdout.flush()
import time for i in range(100): time.sleep(1) s = "{}% Complete".format(i) print(s,end=len(s) *
def printProgressBar (iteration, total, prefix = percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total))) filledLength = int(length * iteration bar = fill * filledLength + print sys.stdout.flush() if iteration == total: print()
import time import progressbar widgets = [ ] bar = progressbar.ProgressBar(redirect_stdout=True, widgets=widgets) bar.start(100) for i in range(100): time.sleep(0.1) bar.update(i + 1, loss=i / 100., error=i) bar.finish()
bar = progressbar.ProgressBar() for i in bar(range(100)): time.sleep(0.02) bar.finish()
from tqdm import tqdm for i in tqdm(range(10000)): ...
def bar(total, current, length=10, prefix="", filler=" if len(border) != 2: print("parameter return None print(prefix + border[0] + (filler * int(current / total * length) + (space * (length - int(current / total * length)))) + border[1], suffix, "\r", end="") if total == current: if oncomp: print(prefix + border[0] + space * int(((length - len(oncomp)) / 2)) + oncomp + space * int(((length - len(oncomp)) / 2)) + border[1], suffix) if not oncomp: print(prefix + border[0] + (filler * int(current / total * length) + (space * (length - int(current / total * length)))) + border[1], suffix)
from time import sleep, time start_time = time() for i in range(10): pref = str((i+1) * 10) + "% " complete_text = "done in %s sec" % str(round(time() - start_time)) sleep(1) bar(10, i + 1, length=20, prefix=pref, oncomp=complete_text)
>>> l = [22, 13, 45, 50, 98, 69, 43, 44, 1] >>> [x+1 if x >= 45 else x+5 for x in l] [27, 18, 46, 51, 99, 70, 48, 49, 6]
l = [22, 13, 45, 50, 98, 69, 43, 44, 1] print [[x+5,x+1][x >= 45] for x in l]
map(lambda x: a if condition1 else b, filter(lambda x: condition2, list1))
for this many times: if conditional: do this thing else: do something else
[ expression if conditional else other thing for this many times ]
v = [22, 13, 45, 50, 98, 69, 43, 44, 1] [ (x+1 if x >=45 else x+5) for x in v ]
@app.route("/summary") def summary(): d = make_summary()
from flask import jsonify @app.route( def summary(): d = make_summary() return jsonify(d)
from flask import json @app.route( def summary(): data = make_summary() response = app.response_class( response=json.dumps(data), status=200, mimetype= ) return response
@app.route( def get_current_user(): return jsonify( username=g.user.username, email=g.user.email, id=g.user.id )
from flask import json @app.route( def summary(): data = make_summary() response = app.response_class( response=json.dumps(data), mimetype= ) return response
from flask import request, jsonify from werkzeug import secure_filename @app.route( def summary(): if request.method == csv = request.files[ return jsonify( summary=make_summary(csv), csv_name=secure_filename(csv.filename) ) return render_template(
def return_json(view): @functools.wraps(view) def wrapped_view(**values): return jsonify(view(**values)) return wrapped_view @app.route( @return_json def test(arg): if arg == return [1, 2, 3] elif arg == return { elif arg == return True return
@app.route( def get_records(): results = [ { "rec_create_date": "12 Jun 2016", "rec_dietary_info": "nothing", "rec_dob": "01 Apr 1988", "rec_first_name": "New", "rec_last_name": "Guy", }, { "rec_create_date": "1 Apr 2016", "rec_dietary_info": "Nut allergy", "rec_dob": "01 Feb 1988", "rec_first_name": "Old", "rec_last_name": "Guy", }, ] return jsonify(results=list)
@app.route("/json") def hello(): return json_response(your_dict, status_code=201)
import code, traceback, signal def debug(sig, frame): d={ d.update(frame.f_globals) d.update(frame.f_locals) i = code.InteractiveConsole(d) message = "Signal received : entering python shell.\nTraceback:\n" message += i.interact(message) def listen(): signal.signal(signal.SIGUSR1, debug)
import threading, sys, traceback def dumpstacks(signal, frame): id2name = dict([(th.ident, th.name) for th in threading.enumerate()]) code = [] for threadId, stack in sys._current_frames().items(): code.append("\n for filename, lineno, name, line in traceback.extract_stack(stack): code.append( if line: code.append(" %s" % (line.strip())) print "\n".join(code) import signal signal.signal(signal.SIGQUIT, dumpstacks)
$ sudo pip install pyrasite $ echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope $ sudo pyrasite 16262 dump_stacks.py
>>> import traceback >>> def x(): >>> print traceback.extract_stack() >>> x() [(
import signal import traceback signal.signal(signal.SIGUSR1, lambda sig, stack: traceback.print_stack(stack))
import faulthandler, signal faulthandler.register(signal.SIGUSR1)
import traceback import sys def dumpstacks(signal, frame): code = [] for threadId, stack in sys._current_frames().items(): code.append("\n for filename, lineno, name, line in traceback.extract_stack(stack): code.append( if line: code.append(" %s" % (line.strip())) print "\n".join(code) import signal signal.signal(signal.SIGQUIT, dumpstacks)
16000: /usr/bin/python2.6 /usr/lib/pkg.depotd --cfg svc:/application/pkg/serv [ /usr/lib/python2.6/vendor-packages/cherrypy/process/wspbus.py:282 (_wait) ] [ /usr/lib/python2.6/vendor-packages/cherrypy/process/wspbus.py:295 (wait) ] [ /usr/lib/python2.6/vendor-packages/cherrypy/process/wspbus.py:242 (block) ] [ /usr/lib/python2.6/vendor-packages/cherrypy/_init_.py:249 (quickstart) ] [ /usr/lib/pkg.depotd:890 (<module>) ] [ /usr/lib/python2.6/threading.py:256 (wait) ] [ /usr/lib/python2.6/Queue.py:177 (get) ] [ /usr/lib/python2.6/vendor-packages/pkg/server/depot.py:2142 (run) ] [ /usr/lib/python2.6/threading.py:477 (run) etc.
$ gdb -ex r --args python <programname>.py [arguments]
import sys, traceback, signal import threading import os def dumpstacks(signal, frame): id2name = dict((th.ident, th.name) for th in threading.enumerate()) for threadId, stack in sys._current_frames().items(): print(id2name[threadId]) traceback.print_stack(f=stack) signal.signal(signal.SIGQUIT, dumpstacks) os.killpg(os.getpgid(0), signal.SIGQUIT)
from pudb import set_interrupt_handler; set_interrupt_handler()
>>> import pdb >>> import my_function >>> def f(): ... pdb.set_trace() ... my_function() ...
>>> f() > <stdin>(3)f() (Pdb) s --Call-- > <stdin>(1)my_function() (Pdb)
import pdb, signal signal.signal(signal.SIGINT, lambda sig, frame: pdb.Pdb().set_trace(frame))
for i in range(10): print(i) if i == 9: print("Too big - I break; else: print("Completed successfully")
found_obj = None for obj in objects: if obj.key == search_key: found_obj = obj break else: print(
def find_obj(search_key): for obj in objects: if obj.key == search_key: return obj
matching_objs = [o for o in objects if o.key == search_key] if matching_objs: print( else: print(
for i in mylist: if i == theflag: break process(i) else: raise ValueError("List argument missing terminal flag.")
flagfound = False for i in mylist: if i == theflag: flagfound = True break process(i) if not flagfound: raise ValueError("List argument missing terminal flag.")
for a in range(3): print(a) if a==4: break else: print( print(
for: do stuff conditional break else not break: do more stuff
for x in range(0,3): print("x: {}".format(x)) if x == 2: try: raise AssertionError("ASSERTION ERROR: x is {}".format(x)) except: print(AssertionError("ASSERTION ERROR: x is {}".format(x))) break else: print("X loop complete without error")
for y in range(0,3): print("y: {}".format(y)) if y == 2: print("BREAK: y is {}\n----------".format(y)) break else: print("y_loop completed without break----------\n")
for z in range(0,3): print("z: {}".format(z)) if z == 4: print("BREAK: z is {}\n".format(y)) break if z == 4: raise AssertionError("ASSERTION ERROR: x is {}".format(x)) else: print("z_loop complete without break or error\n----------\n")
z: 0 z: 1 z: 2 z_loop complete without break or error ----------
try: do_something() except: print("Error happened.") else: print("Everything is find.")
for x in iterable: do_something(x) except break: pass else: print(
for x in xrange(1,5): if x == 5: print break else: print
>>> for n in range(2, 10): ... for x in range(2, n): ... if n % x == 0: ... print(n, ... break ... else: ... ... print(n, ... 2 is a prime number 3 is a prime number 4 equals 2 * 2 5 is a prime number 6 equals 2 * 3 7 is a prime number 8 equals 2 * 4 9 equals 3 * 3
>>> for num in range(2, 10): ... if num % 2 == 0: ... print("Found an even number", num) ... continue ... print("Found a number", num) Found an even number 2 Found a number 3 Found an even number 4 Found a number 5 Found an even number 6 Found a number 7 Found an even number 8 Found a number 9
import socket import time sock = socket.socket() timeout = time.time() + 15 while time.time() < timeout: if sock.connect_ex(( print( break print( else: raise TimeoutError()
item = None while sequence.hasnext(): item = sequence.next() do_something(item)
for x in range(4): if not broken(x) : break else: print("Everything broken... doom is upon us")
for x in range(6): if not broken(x) : break else: print("Everything broken... doom is upon us")
for x in range(6): if not broken(x) : continue else: print("Everything broken... doom is upon us")
for i in range(3): print(i) if i == 2: print("Too big - I break; else: print("Completed successfully")
for i in range(3): print(i) if i == 2: print("Too big - I break; if "for clause is completed": print("Completed successfully")
In [331]: for i in range(0): ...: print(i) ...: ...: if i == 9: ...: print("Too big - I ...: break ...: else: ...: print("Completed successfully") ...: Completed successfully
if "for clause is completed" or "not run at all": do else stuff
if "for clause is not partially run": do else stuff
if "for clause not encounter a break": do else stuff
[method_name for method_name in dir(object) if callable(getattr(object, method_name))]
$ python Python 2.7.6 (default, Jun 22 2015, 17:58:13) [GCC 4.8.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> a = "I am a string" >>> >>> type(a) <class >>> >>> dir(a) [
""" Demonstrates the usage of dir(), with better output. """ __author__ = "ivanleoncz" obj = "I am a string." count = 0 print "\nObject Data: %s" % obj print "Object Type: %s\n" % type(obj) for method in dir(obj): print "| {0: <20}".format(method), count += 1 if count == 4: count = 0 print
""" Demonstrates the usage of dir(), with better output. """ __author__ = "ivanleoncz" obj = "I am a string." count = 0 print("\nObject Data: ", obj) print("Object Type: ", type(obj),"\n") for method in dir(obj): print("| {:20}".format(method), end=" ") count += 1 if count == 4: count = 0 print("")
import inspect method_names = [attr for attr in dir(self) if inspect.ismethod(getattr(self, attr))]
import inspect methods = [member for member in [getattr(self, attr) for attr in dir(self)] if inspect.ismethod(member)]
user@note:~$ python3 Python 3.4.3 (default, Nov 17 2016, 01:08:31) [GCC 4.8.4] on linux Type "help", "copyright", "credits" or "license" for more information. >>> import readline >>> readline.parse_and_bind("tab: complete") >>> s = "Any object. Now it >>> s. s.__add__( s.__rmod__( s.istitle( s.__class__( s.__rmul__( s.isupper( s.__contains__( s.__setattr__( s.join( s.__delattr__( s.__sizeof__( s.ljust( s.__dir__( s.__str__( s.lower( s.__doc__ s.__subclasshook__( s.lstrip( s.__eq__( s.capitalize( s.maketrans( s.__format__( s.casefold( s.partition( s.__ge__( s.center( s.replace( s.__getattribute__( s.count( s.rfind( s.__getitem__( s.encode( s.rindex( s.__getnewargs__( s.endswith( s.rjust( s.__gt__( s.expandtabs( s.rpartition( s.__hash__( s.find( s.rsplit( s.__init__( s.format( s.rstrip( s.__iter__( s.format_map( s.split( s.__le__( s.index( s.splitlines( s.__len__( s.isalnum( s.startswith( s.__lt__( s.isalpha( s.strip( s.__mod__( s.isdecimal( s.swapcase( s.__mul__( s.isdigit( s.title( s.__ne__( s.isidentifier( s.translate( s.__new__( s.islower( s.upper( s.__reduce__( s.isnumeric( s.zfill( s.__reduce_ex__( s.isprintable( s.__repr__( s.isspace(
class MoreMethod(object): def some_method(self, x): return x def __getattr__(self, *args): return lambda x: x*2
>>> o = MoreMethod() >>> o.some_method(5) 5 >>> dir(o) [ >>> o.i_dont_care_of_the_name(5) 10
def getAttrs(object): return filter(lambda m: callable(getattr(object, m)), dir(object)) print getAttrs(
for method in dir(module) : if "keyword_of_methode" in method : print(method, end="\n")
from inspect import getmembers, isfunction from my_project import my_module functions_list = [o for o in getmembers(my_module) if isfunction(o[1])]
import types import yourmodule print([getattr(yourmodule, a) for a in dir(yourmodule) if isinstance(getattr(yourmodule, a), types.FunctionType)])
import ast import sys def top_level_functions(body): return (f for f in body if isinstance(f, ast.FunctionDef)) def parse_ast(filename): with open(filename, "rt") as file: return ast.parse(file.read(), filename=filename) if __name__ == "__main__": for filename in sys.argv[1:]: print(filename) tree = parse_ast(filename) for func in top_level_functions(tree.body): print(" %s" % func.name)
$ python list.py list.py list.py top_level_functions parse_ast
import inspect import <module_to_inspect> as module functions = inspect.getmembers(module, inspect.isfunction)
>>> import ast >>> ast.__all__ Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: module >>>
import re pattern = re.compile("def (.*)\(") for i, line in enumerate(open( for match in re.finditer(pattern, line): print
(C:\Program Files\Anaconda2) C:\Users\lenovo>ipython Python 2.7.12 |Anaconda 4.2.0 (64-bit)| (default, Jun 29 2016, 11:07:13) [MSC v.1500 64 bit (AMD64)] Type "copyright", "credits" or "license" for more information. IPython 5.1.0 -- An enhanced Interactive Python. ? -> Introduction and overview of IPython %quickref -> Quick reference. help -> Python object? -> Details about In [1]: import hashlib In [2]: hashlib. hashlib.algorithms hashlib.new hashlib.sha256 hashlib.algorithms_available hashlib.pbkdf2_hmac hashlib.sha384 hashlib.algorithms_guaranteed hashlib.sha1 hashlib.sha512 hashlib.md5 hashlib.sha224
result=[] for i in dir(unit8_conversion_methods): if type(getattr(your_module, i)).__name__ == "function": result.append(getattr(your_module, i))
sudo apt-get install -y python-dev libmysqlclient-dev && sudo pip install mysqlclient
brew install mysql-connector-c pip install MySQL-python
from ...connectors.mysqldb import ( MySQLDBExecutionContext, MySQLDBCompiler, MySQLDBIdentifierPreparer, MySQLDBConnector )
try: method_that_can_raise_an_exception(params) except Exception as e: print_to_textbox(complete_exception_description(e))
import traceback try: raise ValueError except ValueError: tb = traceback.format_exc() else: tb = "No error" finally: print tb
>>> import sys >>> import traceback >>> try: ... 5 / 0 ... except ZeroDivisionError, e: ... type_, value_, traceback_ = sys.exc_info() >>> traceback.format_tb(traceback_) [ >>> value_ ZeroDivisionError( >>> type_ <type >>> >>> 5 / 0 Traceback (most recent call last): File "<stdin>", line 1, in <module> ZeroDivisionError: integer division or modulo by zero
>>> ex = traceback.format_exception(type_, value_, traceback_) >>> ex [
def raise_error(): raise RuntimeError( def do_something_that_might_error(): raise_error()
import logging logging.basicConfig(level=logging.DEBUG) logger = logging.getLogger(__name__)
try: do_something_that_might_error() except Exception as error: logger.exception(error)
ERROR:__main__:something bad happened! Traceback (most recent call last): File "<stdin>", line 2, in <module> File "<stdin>", line 2, in do_something_that_might_error File "<stdin>", line 2, in raise_error RuntimeError: something bad happened!
>>> do_something_that_might_error() Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 2, in do_something_that_might_error File "<stdin>", line 2, in raise_error RuntimeError: something bad happened!
import traceback try: do_something_that_might_error() except Exception as error: just_the_string = traceback.format_exc() logger.debug(just_the_string)
DEBUG:__main__:Traceback (most recent call last): File "<stdin>", line 2, in <module> File "<stdin>", line 2, in do_something_that_might_error File "<stdin>", line 2, in raise_error RuntimeError: something bad happened!
import traceback try: method_that_can_raise_an_exception(params) except Exception as ex: print(
import traceback def exception_to_string(excp): stack = traceback.extract_stack()[:-3] + traceback.extract_tb(excp.__traceback__) pretty = traceback.format_list(stack) return
def foo(): try: something_invalid() except Exception as e: print(exception_to_string(e)) def bar(): return foo()
File "./test.py", line 57, in <module> bar() File "./test.py", line 55, in bar return foo() File "./test.py", line 50, in foo something_invalid() <class
import cgitb cgitb.enable(format= def func2(a, divisor): return a / divisor def func1(a, b): c = b - 5 return func2(a, c) func1(1, 5)
ZeroDivisionError Python 3.4.2: C:\tools\python\python.exe Tue Sep 22 15:29:33 2015 A problem occurred in a Python script. Here is the sequence of function calls leading up to the error, in the order they occurred. c:\TEMP\cgittest2.py in <module>() 7 def func1(a, b): 8 c = b - 5 9 return func2(a, c) 10 11 func1(1, 5) func1 = <function func1> c:\TEMP\cgittest2.py in func1(a=1, b=5) 7 def func1(a, b): 8 c = b - 5 9 return func2(a, c) 10 11 func1(1, 5) global func2 = <function func2> a = 1 c = 0 c:\TEMP\cgittest2.py in func2(a=1, divisor=0) 3 4 def func2(a, divisor): 5 return a / divisor 6 7 def func1(a, b): a = 1 divisor = 0 ZeroDivisionError: division by zero __cause__ = None __class__ = <class __context__ = None __delattr__ = <method-wrapper __dict__ = {} __dir__ = <built-in method __dir__ of ZeroDivisionError object> __doc__ = __eq__ = <method-wrapper __format__ = <built-in method __format__ of ZeroDivisionError object> __ge__ = <method-wrapper __getattribute__ = <method-wrapper __gt__ = <method-wrapper __hash__ = <method-wrapper __init__ = <method-wrapper __le__ = <method-wrapper __lt__ = <method-wrapper __ne__ = <method-wrapper __new__ = <built-in method __new__ of type object> __reduce__ = <built-in method __reduce__ of ZeroDivisionError object> __reduce_ex__ = <built-in method __reduce_ex__ of ZeroDivisionError object> __repr__ = <method-wrapper __setattr__ = <method-wrapper __setstate__ = <built-in method __setstate__ of ZeroDivisionError object> __sizeof__ = <built-in method __sizeof__ of ZeroDivisionError object> __str__ = <method-wrapper __subclasshook__ = <built-in method __subclasshook__ of type object> __suppress_context__ = False __traceback__ = <traceback object> args = ( with_traceback = <built-in method with_traceback of ZeroDivisionError object> The above is a description of an error in a Python program. Here is the original traceback: Traceback (most recent call last): File "cgittest2.py", line 11, in <module> func1(1, 5) File "cgittest2.py", line 9, in func1 return func2(a, c) File "cgittest2.py", line 5, in func2 return a / divisor ZeroDivisionError: division by zero
import sys, traceback try: ... except Exception, e: T, V, TB = sys.exc_info() print
import traceback class TracedExeptions(object): def __init__(self): pass def __enter__(self): pass def __exit__(self, etype, value, tb): if value : if not hasattr(value, value.traceString = "\n".join(traceback.format_exception(etype, value, tb)) return False return True
def log_err(ex): if hasattr(ex, print("ERROR:{}".format(ex.traceString)); else: print("ERROR:{}".format(ex));
$ sudo easy_install -U virtualenv $ cd ~ $ virtualenv . $ bin/pip ...
import time from threading import Thread class worker(Thread): def run(self): for x in xrange(0,11): print x time.sleep(1) class waiter(Thread): def run(self): for x in xrange(100,103): print x time.sleep(5) def run(): worker().start() waiter().start()
>>> thread_test.run() 0 100 >>> 1 2 3 4 5 101 6 7 8 9 10 102
import os PROJECT_DIR = os.path.dirname(__file__) ... STATIC_DOC_ROOT = os.path.join(PROJECT_DIR, "static") ... TEMPLATE_DIRS = ( os.path.join(PROJECT_DIR, "templates"), )
@render_to( def foo(request): bars = Bar.objects.all() if request.user.is_authenticated(): return HttpResponseRedirect("/some/url/") else: return { def foo(request): bars = Bar.objects.all() if request.user.is_authenticated(): return HttpResponseRedirect("/some/url/") else: return render_to_response( { context_instance=RequestContext(request))
from django import template template.add_to_builtins(
def myview(request, arg, arg2=None, template= response = dict() myuser = MyUser.objects.get(user=request.user) response[ ... return render_to_response(template, response, context_instance=RequestContext(request))
def my_context(request): try: return dict(my_user=MyUser.objects.get(user=request.user)) except ObjectNotFound: return dict(my_user=
from django.utils.translation import ugettext_lazy as _ class Post(models.Model): title = models.CharField(_( body = models.TextField(_( created = models.DateTimeField(auto_now_add=True)
import twitter from django.core.cache import cache from django.db.models.signals import post_save from django.conf import settings def posted_blog(sender, created=None, instance=None, **kwargs): if (created and instance is not None): tweet = t = twitter.PostUpdate(settings.TWITTER_USER, settings.TWITTER_PASSWD, tweet) cache.set(instance.cache_key, instance, 60*5) else: cache.delete(instance.cache_key) post_save.connect(posted_blog, sender=Post)
from IPython.Shell import IPShellEmbed; IPShellEmbed()()
python -m smtpd -n -c DebuggingServer localhost:1025
<a href="{% url project_team project.id %}">Team</a>
from django import http class RestView(object): methods = ( @classmethod def dispatch(cls, request, *args, **kwargs): resource = cls() if request.method.lower() not in (method.lower() for method in resource.methods): return http.HttpResponseNotAllowed(resource.methods) try: method = getattr(resource, request.method.lower()) except AttributeError: raise Exception("View method `%s` does not exist." % request.method.lower()) if not callable(method): raise Exception("View method `%s` is not callable." % request.method.lower()) return method(request, *args, **kwargs) def get(self, request, *args, **kwargs): return http.HttpResponse() def head(self, request, *args, **kwargs): response = self.get(request, *args, **kwargs) response.content = return response
from django.conf.urls.defaults import * from views import MyRestView urlpatterns = patterns( (r )
from django.views.generic import simple def article_detail(request, slug=None): article = get_object_or_404(Article, slug=slug) return simple.direct_to_template(request, template="articles/article_detail.html", extra_context={ )
{% url image-processor uid as img_src %} <img src="{% thumbnail img_src 100x100 %}"/>
<profile id=4> <email>joe@example.com</email> <first_name>Joe</first_name> <last_name>Example</last_name> <date_of_birth>1975-05-15</date_of_birth> </profile>
class Profile(xml_models.Model): user_id = xml_models.IntField(xpath= email = xml_models.CharField(xpath= first = xml_models.CharField(xpath= last = xml_models.CharField(xpath= birthday = xml_models.DateField(xpath= finders = { (user_id,): settings.API_URL + (email,): settings.API_URL + } profile = Profile.objects.get(user_id=4) print profile.email
>>> a = 5 >>> li = [1, 2, 3] >>> [a] + li [5, 1, 2, 3]
>>>var=7 >>>array = [1,2,3,4,5,6] >>>array.insert(0,var) >>>array [7, 1, 2, 3, 4, 5, 6]
In [1]: lst = [0]*1000 In [2]: timeit -n1000 lst.insert(0, 1) 1000 loops, best of 3: 794 ns per loop In [3]: from collections import deque In [4]: deq = deque([0]*1000) In [5]: timeit -n1000 deq.appendleft(1) 1000 loops, best of 3: 73 ns per loop
list1 = [ list2 = [ newlist=list2+list1 print(newlist)
l = ((pd.Series(<first element>)).append(pd.Series(<list of other elements>))).tolist()
>>> str = "h3110 23 cat 444.4 rabbit 11 2 dog" >>> [int(s) for s in str.split() if s.isdigit()] [23, 11, 2]
python -m timeit -s "str = 100 loops, best of 3: 2.84 msec per loop python -m timeit -s "import re" "str = 100 loops, best of 3: 5.66 msec per loop
import re ss = [("apple-12.34 ba33na fanc-14.23e-2yapple+45e5+67.56E+3", [ ( [ ( [ ( [ ( [ ( [ ( [ ( [ for s, r in ss: rr = re.findall("[-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?", s) if rr == r: print( else: print(
l = [] for t in s.split(): try: l.append(float(t)) except ValueError: pass
In [1]: int(filter(str.isdigit, Out[1]: 200 In [2]: int(filter(str.isdigit, Out[2]: 55 In [3]: int(filter(str.isdigit, Out[3]: 23
def get_first_nbr_from_str(input_str): :param input_str: strings that contains digit and words :return: the number extracted from the input_str demo: if not input_str and not isinstance(input_str, str): return 0 out_number = for ele in input_str: if (ele == out_number += ele elif out_number: break return float(out_number)
s = newstr = listOfNumbers = [float(i) for i in newstr.split()] print(listOfNumbers) [12.0, 3.14, 0.0, 1.6e-19, 334.0]
from itertools import groupby my_str = "hello 12 hi 89" l = [int(
import re def find_numbers(string, ints=True): numexp = re.compile(r numbers = numexp.findall(string) numbers = [x.replace( if ints is True: return [int(x.replace( else: return numbers
s = xy = ("X", "Y") num_char = (".", "+", "-") l = [] tokens = s.split() for token in tokens: if token.startswith(xy): num = "" for char in token: if char.isdigit() or (char in num_char): num = num + char try: l.append(float(num)) except ValueError: pass print(l)
lines = "hello 12 hi 89" import re output = [] line = lines.split() for word in line: match = re.search(r if match: output.append(float(match.group())) print (output)
def extract_nbr(input_str): if input_str is None or input_str == return 0 out_number = for ele in input_str: if ele.isdigit(): out_number += ele return float(out_number)
$ pip install yolk3k $ yolk -V django Django 1.3 Django 1.2.5 Django 1.2.4 Django 1.2.3 Django 1.2.2 Django 1.2.1 Django 1.2 Django 1.1.4 Django 1.1.3 Django 1.1.2 Django 1.0.4
root@node7:~ Downloading/unpacking web.py Using version 0.37 (newest of versions: 0.37, 0.36, 0.35, 0.34, 0.33, 0.33, 0.32, 0.31, 0.22, 0.2) Downloading web.py-0.37.tar.gz (90Kb): 90Kb downloaded Running setup.py egg_info for package web.py running egg_info creating pip-egg-info/web.py.egg-info
root@node7:~ Downloading/unpacking flask Using version 0.10.1 (newest of versions: 0.10.1, 0.10, 0.9, 0.8.1, 0.8, 0.7.2, 0.7.1, 0.7, 0.6.1, 0.6, 0.5.2, 0.5.1, 0.5, 0.4, 0.3.1, 0.3, 0.2, 0.1) Downloading Flask-0.10.1.tar.gz (544Kb): 544Kb downloaded
root@node7:~ root@node7:/tmp/tmp.c6H99cWD0g Downloading/unpacking flask Using version 0.10.1 (newest of versions: 0.10.1, 0.10, 0.9, 0.8.1, 0.8, 0.7.2, 0.7.1, 0.7, 0.6.1, 0.6, 0.5.2, 0.5.1, 0.5, 0.4, 0.3.1, 0.3, 0.2, 0.1) Downloading Flask-0.10.1.tar.gz (544Kb): 4.1Kb downloaded
root@node7:~ pip 1.0 from /usr/lib/python2.7/dist-packages (python 2.7)
import json import urllib2 from distutils.version import StrictVersion def versions(package_name): url = "https: data = json.load(urllib2.urlopen(urllib2.Request(url))) versions = data["releases"].keys() versions.sort(key=StrictVersion) return versions print "\n".join(versions("scikit-image"))
0.7.2 0.8.0 0.8.1 0.8.2 0.9.0 0.9.1 0.9.2 0.9.3 0.10.0 0.10.1
$ python test.py pip Versions of pip 0.8.2 0.8.1 0.8 0.7.2 0.7.1 0.7 0.6.3 0.6.2 0.6.1 0.6 0.5.1 0.5 0.4 0.3.1 0.3 0.2.1 0.2 dev
import posixpath import pkg_resources import sys from pip.download import url_to_path from pip.exceptions import DistributionNotFound from pip.index import PackageFinder, Link from pip.log import logger from pip.req import InstallRequirement from pip.util import Inf class MyPackageFinder(PackageFinder): def find_requirement(self, req, upgrade): url_name = req.url_name main_index_url = None if self.index_urls: main_index_url = Link(posixpath.join(self.index_urls[0], url_name)) page = self._get_page(main_index_url, req) if page is None: url_name = self._find_url_name(Link(self.index_urls[0]), url_name, req) or req.url_name all_index_urls = self.index_urls + self.mirror_urls def mkurl_pypi_url(url): loc = posixpath.join(url, url_name) if not loc.endswith( loc = loc + return loc if url_name is not None: locations = [ mkurl_pypi_url(url) for url in all_index_urls] + self.find_links else: locations = list(self.find_links) locations.extend(self.dependency_links) for version in req.absolute_versions: if url_name is not None and main_index_url is not None: locations = [ posixpath.join(main_index_url.url, version)] + locations file_locations, url_locations = self._sort_locations(locations) locations = [Link(url) for url in url_locations] logger.debug( for location in locations: logger.debug( found_versions = [] found_versions.extend( self._package_versions( [Link(url, page_versions = [] for page in self._get_pages(locations, req): logger.debug( logger.indent += 2 try: page_versions.extend(self._package_versions(page.links, req.name.lower())) finally: logger.indent -= 2 dependency_versions = list(self._package_versions( [Link(url) for url in self.dependency_links], req.name.lower())) if dependency_versions: logger.info( file_versions = list(self._package_versions( [Link(url) for url in file_locations], req.name.lower())) if not found_versions and not page_versions and not dependency_versions and not file_versions: logger.fatal( raise DistributionNotFound( if req.satisfied_by is not None: found_versions.append((req.satisfied_by.parsed_version, Inf, req.satisfied_by.version)) if file_versions: file_versions.sort(reverse=True) logger.info( found_versions = file_versions + found_versions all_versions = found_versions + page_versions + dependency_versions applicable_versions = [] for (parsed_version, link, version) in all_versions: if version not in req.req: logger.info("Ignoring link %s, version %s doesn % (link, version, continue applicable_versions.append((link, version)) applicable_versions = sorted(applicable_versions, key=lambda v: pkg_resources.parse_version(v[1]), reverse=True) existing_applicable = bool([link for link, version in applicable_versions if link is Inf]) if not upgrade and existing_applicable: if applicable_versions[0][1] is Inf: logger.info( % req.satisfied_by.version) else: logger.info( % (req.satisfied_by.version, applicable_versions[0][1])) return None if not applicable_versions: logger.fatal( % (req, raise DistributionNotFound( if applicable_versions[0][0] is Inf: logger.info( % (req.satisfied_by.version, return None if len(applicable_versions) > 1: logger.info( (applicable_versions[0][1], return applicable_versions if __name__ == req = InstallRequirement.from_line(sys.argv[1], None) finder = MyPackageFinder([], [ versions = finder.find_requirement(req, False) print for v in versions: print v[1]
set -e PACKAGE_JSON_URL="https: curl -s "$PACKAGE_JSON_URL" | jq -r
import json import requests from distutils.version import StrictVersion def versions(package_name): url = "https: data = requests.get(url).json() return sorted(list(data["releases"].keys()), key=StrictVersion, reverse=True) >>> print("\n".join(versions("gunicorn"))) 19.1.1 19.1.0 19.0.0 18.0 17.5 0.17.4 0.17.3 ...
$ pip install --no-deps Django==x.x.x Collecting Django==x.x.x. Could not find a version that satisfies the requirement Django==x.x.x. (from versions: 1.1.3, 1.1.4, 1.2, 1.2.1, 1.2.2, 1.2.3, 1.2.4, 1.2.5, 1.2.6, 1.2.7, 1.3, 1.3.1, 1.3.2, 1.3.3, 1.3.4, 1.3.5, 1.3.6, 1.3.7, 1.4, 1.4.1, 1.4.2, 1.4.3, 1.4.4, 1.4.5, 1.4.6, 1.4.7, 1.4.8, 1.4.9, 1.4.10, 1.4.11, 1.4.12, 1.4.13, 1.4.14, 1.4.15, 1.4.16, 1.4.17, 1.4.18, 1.4.19, 1.4.20, 1.5, 1.5.1, 1.5.2, 1.5.3, 1.5.4, 1.5.5, 1.5.6, 1.5.7, 1.5.8, 1.5.9, 1.5.10, 1.5.11, 1.5.12, 1.6, 1.6.1, 1.6.2, 1.6.3, 1.6.4, 1.6.5, 1.6.6, 1.6.7, 1.6.8, 1.6.9, 1.6.10, 1.6.11, 1.7, 1.7.1, 1.7.2, 1.7.3, 1.7.4, 1.7.5, 1.7.6, 1.7.7, 1.7.8, 1.8a1, 1.8b1, 1.8b2, 1.8rc1, 1.8, 1.8.1, 1.8.2) No matching distribution found for Django==x.x.x.
1.1.0rc1 1.1.0rc2 1.1.0 1.2.0rc1 1.2.0rc2 1.2.0rc3 1.2.0rc4 1.2.0 1.3.0rc1 1.3.0rc2 1.3.0rc3 1.3.0 1.3.1 1.3.2 1.3.3 1.4.0rc1 1.4.0rc2 1.4.0rc3 1.4.0 1.4.1 1.4.2 1.5.0rc1 1.5.0rc2 1.5.0rc3 1.5.0 1.5.1 1.5.2 1.6.0rc1 1.6.0 1.6.1 1.6.2 1.7.0rc1 1.7.0rc2 1.7.0 1.7.1 1.8.0rc1 1.8.0rc2 1.8.0 1.8.1 1.9.0rc1 1.9.0rc2 1.9.0rc3 1.9.0rc4 1.9.0 1.10.0rc1 1.10.0rc2 1.10.0
>>> import requests >>> from pkg_resources import parse_version >>> >>> def versions(name): ... url = "https: ... return sorted(requests.get(url).json()["releases"], key=parse_version) ... >>> print(*reversed(versions("Django")), sep="\n") 1.10.3 1.10.2 1.10.1 1.10 1.10rc1 1.10b1 1.10a1 ...
> pip3 show setuptools --- Metadata-Version: 2.0 Name: setuptools Version: 18.4 Summary: Easily download, build, install, upgrade, and uninstall Python packages Home-page: https: Author: Python Packaging Authority Author-email: distutils-sig@python.org License: PSF or ZPL Location: /usr/local/lib/python3.4/site-packages Requires:
from pip import index import requests finder = index.PackageFinder( [], [ session=requests.Session() ) results = finder.find_all_candidates("package_name") versions = [p.version for p in results]
import sys import logging try: from pip._internal import cmdoptions, main from pip._internal.commands import commands_dict from pip._internal.basecommand import RequirementCommand except ImportError: from pip import cmdoptions, main from pip.commands import commands_dict from pip.basecommand import RequirementCommand from pip._vendor.packaging.version import parse as parse_version logger = logging.getLogger( class ListPkgVersionsCommand(RequirementCommand): """ List all available versions for a given package from: - PyPI (and other indexes) using requirement specifiers. - VCS project urls. - Local project directories. - Local or remote source archives. """ name = "list-pkg-versions" usage = summary = def __init__(self, *args, **kw): super(ListPkgVersionsCommand, self).__init__(*args, **kw) cmd_opts = self.cmd_opts cmd_opts.add_option(cmdoptions.install_options()) cmd_opts.add_option(cmdoptions.global_options()) cmd_opts.add_option(cmdoptions.use_wheel()) cmd_opts.add_option(cmdoptions.no_use_wheel()) cmd_opts.add_option(cmdoptions.no_binary()) cmd_opts.add_option(cmdoptions.only_binary()) cmd_opts.add_option(cmdoptions.pre()) cmd_opts.add_option(cmdoptions.require_hashes()) index_opts = cmdoptions.make_option_group( cmdoptions.index_group, self.parser, ) self.parser.insert_option_group(0, index_opts) self.parser.insert_option_group(0, cmd_opts) def run(self, options, args): cmdoptions.resolve_wheel_no_use_binary(options) cmdoptions.check_install_build_global(options) with self._build_session(options) as session: finder = self._build_package_finder(options, session) for pkg in args: logger.info( sorted( set(str(c.version) for c in finder.find_all_candidates(pkg)), key=parse_version, ) ) ) commands_dict[ListPkgVersionsCommand.name] = ListPkgVersionsCommand if __name__ == sys.exit(main())
$ ./list-pkg-versions.py list-pkg-versions pika django pika: 0.5, 0.5.1, 0.5.2, 0.9.1a0, 0.9.2a0, 0.9.3, 0.9.4, 0.9.5, 0.9.6, 0.9.7, 0.9.8, 0.9.9, 0.9.10, 0.9.11, 0.9.12, 0.9.13, 0.9.14, 0.10.0b1, 0.10.0b2, 0.10.0, 0.11.0b1, 0.11.0, 0.11.1, 0.11.2, 0.12.0b2 django: 1.1.3, 1.1.4, 1.2, 1.2.1, 1.2.2, 1.2.3, 1.2.4, 1.2.5, 1.2.6, 1.2.7, 1.3, 1.3.1, 1.3.2, 1.3.3, 1.3.4, 1.3.5, 1.3.6, 1.3.7, 1.4, 1.4.1, 1.4.2, 1.4.3, 1.4.4, 1.4.5, 1.4.6, 1.4.7, 1.4.8, 1.4.9, 1.4.10, 1.4.11, 1.4.12, 1.4.13, 1.4.14, 1.4.15, 1.4.16, 1.4.17, 1.4.18, 1.4.19, 1.4.20, 1.4.21, 1.4.22, 1.5, 1.5.1, 1.5.2, 1.5.3, 1.5.4, 1.5.5, 1.5.6, 1.5.7, 1.5.8, 1.5.9, 1.5.10, 1.5.11, 1.5.12, 1.6, 1.6.1, 1.6.2, 1.6.3, 1.6.4, 1.6.5, 1.6.6, 1.6.7, 1.6.8, 1.6.9, 1.6.10, 1.6.11, 1.7, 1.7.1, 1.7.2, 1.7.3, 1.7.4, 1.7.5, 1.7.6, 1.7.7, 1.7.8, 1.7.9, 1.7.10, 1.7.11, 1.8a1, 1.8b1, 1.8b2, 1.8rc1, 1.8, 1.8.1, 1.8.2, 1.8.3, 1.8.4, 1.8.5, 1.8.6, 1.8.7, 1.8.8, 1.8.9, 1.8.10, 1.8.11, 1.8.12, 1.8.13, 1.8.14, 1.8.15, 1.8.16, 1.8.17, 1.8.18, 1.8.19, 1.9a1, 1.9b1, 1.9rc1, 1.9rc2, 1.9, 1.9.1, 1.9.2, 1.9.3, 1.9.4, 1.9.5, 1.9.6, 1.9.7, 1.9.8, 1.9.9, 1.9.10, 1.9.11, 1.9.12, 1.9.13, 1.10a1, 1.10b1, 1.10rc1, 1.10, 1.10.1, 1.10.2, 1.10.3, 1.10.4, 1.10.5, 1.10.6, 1.10.7, 1.10.8, 1.11a1, 1.11b1, 1.11rc1, 1.11, 1.11.1, 1.11.2, 1.11.3, 1.11.4, 1.11.5, 1.11.6, 1.11.7, 1.11.8, 1.11.9, 1.11.10, 1.11.11, 1.11.12, 2.0, 2.0.1, 2.0.2, 2.0.3, 2.0.4
import requests r = requests.get("https: print(r.json()[
matplotlib.pyplot.plot(x,y) matplotlib.pyplot.show()
import numpy as np import matplotlib.pyplot as plt x = [0,5,9,10,15] y = [0,1,2,3,4] plt.plot(x,y) plt.xticks(np.arange(min(x), max(x)+1, 1.0)) plt.show()
start, end = ax.get_xlim() ax.xaxis.set_ticks(np.arange(start, end, stepsize))
ax.xaxis.set_major_formatter(ticker.FormatStrFormatter(
import numpy as np import matplotlib.pyplot as plt import matplotlib.ticker as ticker x = [0,5,9,10,15] y = [0,1,2,3,4] fig, ax = plt.subplots() ax.plot(x,y) start, end = ax.get_xlim() ax.xaxis.set_ticks(np.arange(start, end, 0.712123)) ax.xaxis.set_major_formatter(ticker.FormatStrFormatter( plt.show()
import matplotlib.ticker as plticker loc = plticker.MultipleLocator(base=1.0) ax.xaxis.set_major_locator(loc)
import matplotlib.pyplot as plt import matplotlib.ticker as ticker x = [0,5,9,10,15] y = [0,1,2,3,4] tick_spacing = 1 fig, ax = plt.subplots(1,1) ax.plot(x,y) ax.xaxis.set_major_locator(ticker.MultipleLocator(tick_spacing)) plt.show()
for label in ax.get_xticklabels()[::2]: label.set_visible(False)
visible_labels = [lab for lab in ax.get_xticklabels() if lab.get_visible() is True and lab.get_text() != plt.setp(visible_labels[::2], visible=False)
import matplotlib.pyplot as pp import numpy as np def resadjust(ax, xres=None, yres=None): if xres: start, stop = ax.get_xlim() ticks = np.arange(start, stop + xres, xres) ax.set_xticks(ticks) if yres: start, stop = ax.get_ylim() ticks = np.arange(start, stop + yres, yres) ax.set_yticks(ticks)
import matplotlib.pyplot as plt x = [0,1,2,3,4,5] y = [10,20,15,18,7,19] xlabels = [
xlabelsnew = [] for i in xlabels: if i not in [ i = xlabelsnew.append(i) else: xlabelsnew.append(i)
plt.plot(x,y) plt.xticks(range(0,len(x)),xlabels,rotation=45) plt.show()
plt.plot(x,y) plt.xticks(range(0,len(x)),xlabelsnew,rotation=45) plt.show()
xmarks=[i for i in range(1,length+1,1)] plt.xticks(xmarks)
def computeTicks (x, step = 5): import math as Math xMax, xMin = Math.ceil(max(x)), Math.floor(min(x)) dMax, dMin = xMax + abs((xMax % step) - step) + (step if (xMax % step != 0) else 0), xMin - abs((xMin % step)) return range(dMin, dMax, step)
series = [-2, 18, 24, 29, 43] print(list(computeTicks(series))) [-5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45] series = [-30, -14, -10, -9, -3, 0] print(list(computeTicks(series))) [-30, -25, -20, -15, -10, -5, 0] series = [19, 23, 24, 27] print(list(computeTicks(series))) [15, 20, 25, 30] series = [1.8, 12.0, 21.2] print(list(computeTicks(series))) [0, 5, 10, 15, 20, 25] series = [118.3, 293.2, 768.1] print(list(computeTicks(series, step = 100))) [100, 200, 300, 400, 500, 600, 700, 800]
import matplotlib.pyplot as plt x = [0,5,9,10,15] y = [0,1,2,3,4] plt.plot(x,y) plt.xticks(computeTicks(x)) plt.show()
In [2]: df = pd.DataFrame(np.random.randn(1000,1000)) In [3]: df[df > 0.9] = pd.np.nan In [4]: %timeit df.isnull().any().any() 100 loops, best of 3: 14.7 ms per loop In [5]: %timeit df.isnull().values.sum() 100 loops, best of 3: 2.15 ms per loop In [6]: %timeit df.isnull().sum().sum() 100 loops, best of 3: 18 ms per loop In [7]: %timeit df.isnull().values.any() 1000 loops, best of 3: 948 µs per loop
import pandas as pd import numpy as np df = pd.DataFrame(np.random.randn(10,6)) df.iloc[1:3,1] = np.nan df.iloc[5,3] = np.nan df.iloc[7:9,5] = np.nan
0 1 2 3 4 5 0 0.520113 0.884000 1.260966 -0.236597 0.312972 -0.196281 1 -0.837552 NaN 0.143017 0.862355 0.346550 0.842952 2 -0.452595 NaN -0.420790 0.456215 1.203459 0.527425 3 0.317503 -0.917042 1.780938 -1.584102 0.432745 0.389797 4 -0.722852 1.704820 -0.113821 -1.466458 0.083002 0.011722 5 -0.622851 -0.251935 -1.498837 NaN 1.098323 0.273814 6 0.329585 0.075312 -0.690209 -3.807924 0.489317 -0.841368 7 -1.123433 -1.187496 1.868894 -2.046456 -0.949718 NaN 8 1.133880 -0.110447 0.050385 -1.158387 0.188222 NaN 9 -0.513741 1.196259 0.704537 0.982395 -0.585040 -1.693810
0 1 2 3 4 5 0 False False False False False False 1 False True False False False False 2 False True False False False False 3 False False False False False False 4 False False False False False False 5 False False False True False False 6 False False False False False False 7 False False False False False True 8 False False False False False True 9 False False False False False False
0 False 1 True 2 False 3 True 4 False 5 True dtype: bool
df.isnull().sum() 0 0 1 2 2 0 3 1 4 0 5 2 dtype: int64
<class Int64Index: 3276314 entries, 0 to 3276313 Data columns (total 10 columns): n_matches 3276314 non-null int64 avg_pic_distance 3276314 non-null float64
testdf = pd.DataFrame({ >>> testdf2 Monthly Tenure Yearly 0 10 1 10.0 1 20 2 40.0 2 30 3 NaN 3 40 4 NaN 4 50 5 250.0 nan_rows = testdf2[testdf2[ >>> nan_rows Monthly Tenure Yearly 2 30 3 NaN 3 40 4 NaN >>> index = list(nan_rows.index) >>> index [2, 3] >>> for i in index: testdf2[ >>> testdf2 Monthly Tenure Yearly 0 10 1 10.0 1 20 2 40.0 2 30 3 90.0 3 40 4 160.0 4 50 5 250.0
df = pd.DataFrame({ df A B 0 1.0 NaN 1 2.0 4.0 2 NaN 5.0
for col in df: print df[col].value_counts(dropna=False)
df.apply(axis=0, func=lambda x : any(pd.isnull(x)))
cmd_create_db = Col1 INTEGER, Col2 INTEGER, Col3 TEXT)
>>> cmd_create_db = ... .DS_StoreCol1 INTEGER, ... .DS_StoreCol2 INTEGER, ... .DS_StoreCol3 TEXT) >>> cmd_create_db
import operator s = sorted(s, key = operator.itemgetter(1, 2))
a = [( b = sorted(sorted(a, key = lambda x : x[0]), key = lambda x : x[1], reverse = True) print(b) [(
def attr_sort(self, attrs=[ return lambda k: [ getattr(k, attr) for attr in attrs ]
self.SortListA = [ self.SortListB = [ records = .... records.sort(key=self.attr_sort(attrs=self.SortListA)) more_records = .... more_records.sort(key=self.attr_sort(attrs=self.SortListB))
my_sortLambdaLst = [lambda x,y:cmp(x[0], y[0]), lambda x,y:cmp(x[1], y[1])] def multi_attribute_sort(x,y): r = 0 for l in my_sortLambdaLst: r = l(x,y) if r!=0: return r return r Lst = [(4, 2.0), (4, 0.01), (4, 0.9), (4, 0.999),(4, 0.2), (1, 2.0), (1, 0.01), (1, 0.9), (1, 0.999), (1, 0.2) ] Lst.sort(lambda x,y:multi_attribute_sort(x,y)) for rec in Lst: print str(rec)
class probe: def __init__(self, group, score): self.group = group self.score = score self.rank =-1 def set_rank(self, r): self.rank = r def __str__(self): return def RankLst(inLst, group_lambda= lambda x:x.group, sortLambdaLst = [lambda x,y:cmp(x.group, y.group), lambda x,y:cmp(x.score, y.score)], SetRank_Lambda = lambda x, rank:x.set_rank(rank)): def multi_attribute_sort(x,y): r = 0 for l in sortLambdaLst: r = l(x,y) if r!=0: return r return r inLst.sort(lambda x,y:multi_attribute_sort(x,y)) rank = 0 last_group = group_lambda(inLst[0]) for i in range(len(inLst)): rec = inLst[i] group = group_lambda(rec) if last_group == group: rank+=1 else: rank=1 last_group = group SetRank_Lambda(inLst[i], rank) Lst = [probe(4, 2.0), probe(4, 0.01), probe(4, 0.9), probe(4, 0.999), probe(4, 0.2), probe(1, 2.0), probe(1, 0.01), probe(1, 0.9), probe(1, 0.999), probe(1, 0.2) ] RankLst(Lst, group_lambda= lambda x:x.group, sortLambdaLst = [lambda x,y:cmp(x.group, y.group), lambda x,y:cmp(x.score, y.score)], SetRank_Lambda = lambda x, rank:x.set_rank(rank)) print for r in Lst: print r
for i in range(9): newBoard = currentBoard.newBoardWithMove([i / 3, i % 3], player) if newBoard: temp = minMax(newBoard, depth + 1, not isMinLevel) values.append(temp) if isMinLevel: return min(values) else: return max(values)
index_min = min(xrange(len(values)), key=values.__getitem__)
import operator min_index, min_value = min(enumerate(values), key=operator.itemgetter(1)) max_index, max_value = max(enumerate(values), key=operator.itemgetter(1))
values = [3,4,5] (m,i) = max((v,i) for i,v in enumerate(values)) print (m,i)
list=[1.1412, 4.3453, 5.8709, 0.1314] list.index(min(list))
import numpy import operator import perfplot def min_enumerate(a): return min(enumerate(a), key=lambda x: x[1])[0] def min_enumerate_itemgetter(a): min_index, min_value = min(enumerate(a), key=operator.itemgetter(1)) return min_index def getitem(a): return min(range(len(a)), key=a.__getitem__) def np_argmin(a): return numpy.argmin(a) perfplot.show( setup=lambda n: numpy.random.rand(n).tolist(), kernels=[ min_enumerate, min_enumerate_itemgetter, getitem, np_argmin, ], n_range=[2**k for k in range(15)], logx=True, logy=True, )
idx = n.where((x>3)&(x<60))[0] idx array([2, 3, 4, 5]) x[idx] array([ 4, 7, 4, 56])
minval = min(mylist) ind = [i for i, v in enumerate(mylist) if v == minval]
theList = [1, 5, 10] maxIndex, maxValue = max(enumerate(theList), key=lambda v: v[1])
max_index = max( range( len(my_list) ), key = lambda index : my_list[ index ] )
max_val = max(list) index_max = list.index(max_val)
my_indexed_list = zip(my_list, range(len(my_list))) min_value, min_index = min(my_indexed_list) max_value, max_index = max(my_indexed_list)
element, index = min(list(zip(a, range(len(a))))) min(list(zip(a, range(len(a))))) (7, 2) timeit min(list(zip(a, range(len(a))))) 1.36 µs ± 107 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
index, element = min(list(enumerate(a)), key=lambda x:x[1]) min(list(enumerate(a)), key=lambda x:x[1]) (2, 7) timeit min(list(enumerate(a)), key=lambda x:x[1]) 1.45 µs ± 78.1 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
values.reverse() (values.index(min(values)) + len(values) - 1) % len(values) values.reverse()
indices = [] i = -1 for _ in range(values.count(min(values))): i = values[i + 1:].index(min(values)) + i + 1 indices.append(i)
min_value = min(values) indexes_with_min_value = [i for i in range(0,len(values)) if values[i] == min_value]
stuff = [2, 4, 8, 15, 11] index = stuff.index(max(stuff))
import operator x = [2, 5, 7, 4, 8, 2, 6, 1, 7, 1, 8, 3, 4, 9, 3, 6, 5, 0, 9, 0] min = False max = True min_val_index = sorted( list(zip(x, range(len(x)))), key = operator.itemgetter(0), reverse = min ) max_val_index = sorted( list(zip(x, range(len(x)))), key = operator.itemgetter(0), reverse = max ) min_val_index[0] >(0, 17) max_val_index[0] >(9, 13) import ittertools max_val = max_val_index[0][0] maxes = [n for n in itertools.takewhile(lambda x: x[0] == max_val, max_val_index)]
import sys reload(sys) sys.setdefaultencoding( print u"åäö"
import sys for line in sys.stdin: line = line.decode( line = line.upper() line = line.encode( sys.stdout.write(line)
import sys import codecs sys.stdout = codecs.getwriter(
if __name__ == if (sys.stdout.encoding is None): print >> sys.stderr, "please set python env PYTHONIOENCODING=UTF-8, example: export PYTHONIOENCODING=UTF-8, when write to stdout." exit(1)
import sys, codecs class EncodedOut: def __init__(self, enc): self.enc = enc self.stdout = sys.stdout def __enter__(self): if sys.stdout.encoding is None: w = codecs.getwriter(self.enc) sys.stdout = w(sys.stdout) def __exit__(self, exc_ty, exc_val, tb): sys.stdout = self.stdout
def __fix_io_encoding(last_resort_default= import sys if [x for x in (sys.stdin,sys.stdout,sys.stderr) if x.encoding is None] : import os defEnc = None if defEnc is None : try: import locale defEnc = locale.getpreferredencoding() except: pass if defEnc is None : try: defEnc = sys.getfilesystemencoding() except: pass if defEnc is None : try: defEnc = sys.stdin.encoding except: pass if defEnc is None : defEnc = last_resort_default os.environ[ os.execvpe(sys.argv[0],sys.argv,os.environ) __fix_io_encoding() ; del __fix_io_encoding
$ cat a.py print "åäö" $ python a.py åäö $ python a.py | tee out åäö
import codecs import builtins def print_utf8(text, **kwargs): print(str(text).encode( def print_utf8(fn): def print_fn(*args, **kwargs): return fn(str(*args).encode( return print_fn builtins.print = print_utf8(print)
In [116]: frame = DataFrame(np.random.randn(4, 3), columns=list( In [117]: frame Out[117]: b d e Utah -0.029638 1.081563 1.280300 Ohio 0.647747 0.831136 -1.549481 Texas 0.513416 -0.884417 0.195343 Oregon -0.485454 -0.477388 -0.309548 In [118]: f = lambda x: x.max() - x.min() In [119]: frame.apply(f) Out[119]: b 1.133201 d 1.965980 e 2.829781 dtype: float64
In [120]: format = lambda x: In [121]: frame.applymap(format) Out[121]: b d e Utah -0.03 1.08 1.28 Ohio 0.65 0.83 -1.55 Texas 0.51 -0.88 0.20 Oregon -0.49 -0.48 -0.31
In [122]: frame[ Out[122]: Utah 1.28 Ohio -1.55 Texas 0.20 Oregon -0.31 Name: e, dtype: object
In [40]: p=pd.Series([1,2,3]) In [41]: p Out[31]: 0 1 1 2 2 3 dtype: int64 In [42]: p.apply(lambda x: pd.Series([x, x])) Out[42]: 0 1 0 1 1 1 2 2 2 3 3 In [43]: p.map(lambda x: pd.Series([x, x])) Out[43]: 0 0 1 1 1 dtype: int64 1 0 2 1 2 dtype: int64 2 0 3 1 3 dtype: int64 dtype: object
In [39]: p=pd.Series([1,0,3,4,2]) In [40]: p.map(p) Out[40]: 0 0 1 1 2 4 3 2 4 3 dtype: int64
frame.apply(np.sqrt) Out[102]: b d e Utah NaN 1.435159 NaN Ohio 1.098164 0.510594 0.729748 Texas NaN 0.456436 0.697337 Oregon 0.359079 NaN NaN frame.applymap(np.sqrt) Out[103]: b d e Utah NaN 1.435159 NaN Ohio 1.098164 0.510594 0.729748 Texas NaN 0.456436 0.697337 Oregon 0.359079 NaN NaN
def f(x): if x < 0: x = 0 elif x > 100000: x = 100000 return x df.applymap(f) df.describe()
majority = lambda x : x > 17 df2[ def times10(x): if type(x) is int: x *= 10 return x df2.applymap(times10)
a = [1,2,3,2,1,5,6,5,5,5] import collections print [item for item, count in collections.Counter(a).items() if count > 1]
seen = set() uniq = [] for x in a: if x not in seen: uniq.append(x) seen.add(x)
seen = set() uniq = [x for x in a if x not in seen and not seen.add(x)]
seen = {} dupes = [] for x in a: if x not in seen: seen[x] = 1 else: if seen[x] == 1: dupes.append(x) seen[x] += 1
a = [ [1], [2], [3], [1], [5], [3] ] no_dupes = [x for n, x in enumerate(a) if x not in a[:n]] print no_dupes dupes = [x for n, x in enumerate(a) if x in a[:n]] print dupes
>>> l = [1,2,3,4,4,5,5,6,1] >>> set([x for x in l if l.count(x) > 1]) set([1, 4, 5])
def list_duplicates(seq): seen = set() seen_add = seen.add seen_twice = set( x for x in seq if x in seen or seen_add(x) ) return list( seen_twice ) a = [1,2,3,2,1,5,6,5,5,5] list_duplicates(a)
import collections def thg435(l): return [x for x, y in collections.Counter(l).items() if y > 1] def moooeeeep(l): seen = set() seen_add = seen.add seen_twice = set( x for x in l if x in seen or seen_add(x) ) return list( seen_twice ) def RiteshKumar(l): return list(set([x for x in l if l.count(x) > 1])) def JohnLaRooy(L): seen = set() seen2 = set() seen_add = seen.add seen2_add = seen2.add for item in L: if item in seen: seen2_add(item) else: seen_add(item) return list(seen2) l = [1,2,3,2,1,5,6,5,5,5]*100
$ python -mtimeit -s 10000 loops, best of 3: 74.6 usec per loop $ python -mtimeit -s 10000 loops, best of 3: 91.3 usec per loop $ python -mtimeit -s 1000 loops, best of 3: 266 usec per loop $ python -mtimeit -s 100 loops, best of 3: 8.35 msec per loop
$ pypy -mtimeit -s 100000 loops, best of 3: 17.8 usec per loop $ pypy -mtimeit -s 10000 loops, best of 3: 23 usec per loop $ pypy -mtimeit -s 10000 loops, best of 3: 39.3 usec per loop
$ pypy -mtimeit -s 1000 loops, best of 3: 495 usec per loop $ pypy -mtimeit -s 1000 loops, best of 3: 499 usec per loop $ pypy -mtimeit -s 1000 loops, best of 3: 1.68 msec per loop
>>> print list(getDupes_9([1,2,3,2,1,5,6,5,5,5])) [1, 2, 5]
def getDupes(c): a, b = itertools.tee(sorted(c)) next(b, None) r = None for k, g in itertools.izip(a, b): if k != g: continue if k != r: yield k r = k
import itertools import time import random def getDupes_1(c): for i in xrange(0, len(c)): if c[i] in c[:i]: yield c[i] def getDupes_2(c): s = set() for i in c: l = len(s) s.add(i) if len(s) == l: yield i def getDupes_3(c): d = {} for i in c: if i in d: if d[i]: yield i d[i] = False else: d[i] = True def getDupes_4(c): s,r = set(),set() for i in c: if i not in s: s.add(i) elif i not in r: r.add(i) yield i def getDupes_5(c): c = sorted(c) r = None for i in xrange(1, len(c)): if c[i] == c[i - 1]: if c[i] != r: yield c[i] r = c[i] def getDupes_6(c): def multiple(x): try: x.next() x.next() return True except: return False for k, g in itertools.ifilter(lambda x: multiple(x[1]), itertools.groupby(sorted(c))): yield k def getDupes_7(c): c = sorted(c) r = None for k, g in zip(c[:-1],c[1:]): if k == g: if k != r: yield k r = k def getDupes_8(c): c = sorted(c) r = None for k, g in itertools.izip(c[:-1],c[1:]): if k == g: if k != r: yield k r = k def getDupes_9(c): a, b = itertools.tee(sorted(c)) next(b, None) r = None for k, g in itertools.izip(a, b): if k != g: continue if k != r: yield k r = k def getDupes_a(l): seen = set() seen_add = seen.add for x in l: if x in seen or seen_add(x): yield x def getDupes_b(x): x = sorted(x) def _matches(): for k,g in itertools.izip(x[:-1],x[1:]): if k == g: yield k for k, n in itertools.groupby(_matches()): yield k def getDupes_c(a): import pandas as pd vc = pd.Series(a).value_counts() i = vc[vc > 1].index for _ in i: yield _ def hasDupes(fn,c): try: if fn(c).next(): return True except StopIteration: pass return False def getDupes(fn,c): return list(fn(c)) STABLE = True if STABLE: print else: print for location in (50,250000,500000,750000,999999): for test in (getDupes_2, getDupes_3, getDupes_4, getDupes_5, getDupes_6, getDupes_8, getDupes_9, getDupes_a, getDupes_b, getDupes_c): print deltas = [] for FIRST in (True,False): for i in xrange(0, 5): c = range(0,1000000) if STABLE: c[0] = location else: c.append(location) random.shuffle(c) start = time.time() if FIRST: print else: print deltas.append(time.time()-start) print print print
Finding FIRST then ALL duplicates, single dupe of "nth" placed element in 1m element array Test set len change : 500000 - . . . . . -- 0.264 . . . . . -- 0.402 Test in dict : 500000 - . . . . . -- 0.163 . . . . . -- 0.250 Test in set : 500000 - . . . . . -- 0.163 . . . . . -- 0.249 Test sort/adjacent : 500000 - . . . . . -- 0.159 . . . . . -- 0.229 Test sort/groupby : 500000 - . . . . . -- 0.860 . . . . . -- 1.286 Test sort/izip : 500000 - . . . . . -- 0.165 . . . . . -- 0.229 Test sort/tee/izip : 500000 - . . . . . -- 0.145 . . . . . -- 0.206 * Test moooeeeep : 500000 - . . . . . -- 0.149 . . . . . -- 0.232 Test iter*/sorted : 500000 - . . . . . -- 0.160 . . . . . -- 0.221 Test pandas : 500000 - . . . . . -- 0.493 . . . . . -- 0.499
Finding FIRST then ALL duplicates, single dupe of "n" included in randomised 1m element array Test set len change : 500000 - . . . . . -- 0.321 . . . . . -- 0.473 Test in dict : 500000 - . . . . . -- 0.285 . . . . . -- 0.360 Test in set : 500000 - . . . . . -- 0.309 . . . . . -- 0.365 Test sort/adjacent : 500000 - . . . . . -- 0.756 . . . . . -- 0.823 Test sort/groupby : 500000 - . . . . . -- 1.459 . . . . . -- 1.896 Test sort/izip : 500000 - . . . . . -- 0.786 . . . . . -- 0.845 Test sort/tee/izip : 500000 - . . . . . -- 0.743 . . . . . -- 0.804 Test moooeeeep : 500000 - . . . . . -- 0.234 . . . . . -- 0.311 * Test iter*/sorted : 500000 - . . . . . -- 0.776 . . . . . -- 0.840 Test pandas : 500000 - . . . . . -- 0.539 . . . . . -- 0.540
>>> from iteration_utilities import duplicates >>> list(duplicates([1,1,2,1,2,3,4,2])) [1, 1, 2, 2]
>>> from iteration_utilities import unique_everseen >>> list(unique_everseen(duplicates([1,1,2,1,2,3,4,2]))) [1, 2]
>>> list(duplicates([[1], [2], [1], [3], [1]])) [[1], [1]] >>> list(unique_everseen(duplicates([[1], [2], [1], [3], [1]]))) [[1]]
from iteration_utilities import duplicates, unique_everseen from collections import Counter import pandas as pd import itertools def georg_counter(it): return [item for item, count in Counter(it).items() if count > 1] def georg_set(it): seen = set() uniq = [] for x in it: if x not in seen: uniq.append(x) seen.add(x) def georg_set2(it): seen = set() return [x for x in it if x not in seen and not seen.add(x)] def georg_set3(it): seen = {} dupes = [] for x in it: if x not in seen: seen[x] = 1 else: if seen[x] == 1: dupes.append(x) seen[x] += 1 def RiteshKumar_count(l): return set([x for x in l if l.count(x) > 1]) def moooeeeep(seq): seen = set() seen_add = seen.add seen_twice = set( x for x in seq if x in seen or seen_add(x) ) return list( seen_twice ) def F1Rumors_implementation(c): a, b = itertools.tee(sorted(c)) next(b, None) r = None for k, g in zip(a, b): if k != g: continue if k != r: yield k r = k def F1Rumors(c): return list(F1Rumors_implementation(c)) def Edward(a): d = {} for elem in a: if elem in d: d[elem] += 1 else: d[elem] = 1 return [x for x, y in d.items() if y > 1] def wordsmith(a): return pd.Series(a)[pd.Series(a).duplicated()].values def NikhilPrabhu(li): li = li.copy() for x in set(li): li.remove(x) return list(set(li)) def firelynx(a): vc = pd.Series(a).value_counts() return vc[vc > 1].index.tolist() def HenryDev(myList): newList = set() for i in myList: if myList.count(i) >= 2: newList.add(i) return list(newList) def yota(number_lst): seen_set = set() duplicate_set = set(x for x in number_lst if x in seen_set or seen_set.add(x)) return seen_set - duplicate_set def IgorVishnevskiy(l): s=set(l) d=[] for x in l: if x in s: s.remove(x) else: d.append(x) return d def it_duplicates(l): return list(duplicates(l)) def it_unique_duplicates(l): return list(unique_everseen(duplicates(l)))
from simple_benchmark import benchmark import random funcs = [ georg_counter, georg_set, georg_set2, georg_set3, RiteshKumar_count, moooeeeep, F1Rumors, Edward, wordsmith, NikhilPrabhu, firelynx, HenryDev, yota, IgorVishnevskiy, it_duplicates, it_unique_duplicates ] args = {2**i: [random.randint(0, 2**(i-1)) for _ in range(2**i)] for i in range(2, 12)} b = benchmark(funcs, args, b.plot()
funcs = [ georg_counter, georg_set, georg_set2, georg_set3, moooeeeep, F1Rumors, Edward, wordsmith, firelynx, yota, IgorVishnevskiy, it_duplicates, it_unique_duplicates ] args = {2**i: [random.randint(0, 2**(i-1)) for _ in range(2**i)] for i in range(2, 20)} b = benchmark(funcs, args, b.plot()
Python 2.5.4 (r254:67916, May 31 2010, 15:03:39) [GCC 4.1.2 20080704 (Red Hat 4.1.2-46)] on linux2 a = [1,2,3,2,1,5,6,5,5,5] import collections print [x for x, y in collections.Counter(a).items() if y > 1] Type "help", "copyright", "credits" or "license" for more information. File "", line 1, in AttributeError: >>>
a = [1,2,3,2,1,5,6,5,5,5] d = {} for elem in a: if elem in d: d[elem] += 1 else: d[elem] = 1 print [x for x, y in d.items() if y > 1]
>>> import pandas as pd >>> a = [1, 2, 1, 3, 3, 3, 0] >>> pd.Series(a)[pd.Series(a).duplicated()].values array([1, 3, 3])
myList = [2 ,4 , 6, 8, 4, 6, 12]; newList = set() for i in myList: if myList.count(i) >= 2: newList.add(i) print(list(newList))
a=[1,2,3,3,3] dup=[] for each in a: if each not in dup: dup.append(each) print(dup)
a=[1,2,3,3,3] uniques=[] dups=[] for each in a: if each not in uniques: uniques.append(each) else: dups.append(each) print("Unique values are below:") print(uniques) print("Duplicate values are below:") print(dups)
import pandas as pd a = [1,2,3,3,3,4,5,6,6,7] vc = pd.Series(a).value_counts() vc[vc > 1].index.tolist()
number_lst = [1, 1, 2, 3, 5, ...] seen_set = set() duplicate_set = set(x for x in number_lst if x in seen_set or seen_set.add(x)) unique_set = seen_set - duplicate_set
l=[1,2,3,5,4,1,3,1] s=set(l) d=[] for x in l: if x in s: s.remove(x) else: d.append(x) d [1,3,1]
testList = [ testListDict = {} for item in testList: try: testListDict[item] += 1 except: testListDict[item] = 1 print testListDict
from itertools import groupby myList = [2, 4, 6, 8, 4, 6, 12] for x, y in groupby(sorted(myList)): if len(list(y)) > 1: print x
list2 = [1, 2, 3, 4, 1, 2, 3] lset = set() [(lset.add(item), list2.append(item)) for item in list2 if item not in lset] print list(lset)
set([i for i in list if sum([1 for a in list if a == i]) > 1])
def get_duplicates(sorted_list): duplicates = [] last = sorted_list[0] for x in sorted_list[1:]: if x == last: duplicates.append(x) last = x return set(duplicates)
def gen_dupes(array): unique = {} for value in array: if value in unique and unique[value]: unique[value] = False yield value else: unique[value] = True array = [1, 2, 2, 3, 4, 1, 5, 2, 6, 6] print(list(gen_dupes(array)))
def gen_dupes(array): unique = {} for value in array: is_list = False if type(value) is list: value = tuple(value) is_list = True if value in unique and unique[value]: unique[value] = False if is_list: value = list(value) yield value else: unique[value] = True array = [1, 2, 2, [1, 2], 3, 4, [1, 2], 5, 2, 6, 6] print(list(gen_dupes(array)))
def removeduplicates(a): seen = set() for i in a: if i not in seen: seen.add(i) return seen print(removeduplicates([1,1,2,2]))
def dups_count_dict(l): d = {} for item in l: if item not in d: d[item] = 0 d[item] += 1 result_d = {key: val for key, val in d.iteritems() if val > 1} return result_d.keys()
dups_count: 13.368s dups_count_dict: 0.014s dups_count_counter: 0.024s
import numpy as np from time import time from collections import Counter class TimerCounter(object): def __init__(self): self._time_sum = 0 def start(self): self.time = time() def stop(self): self._time_sum += time() - self.time def get_time_sum(self): return self._time_sum def dups_count(l): return set([x for x in l if l.count(x) > 1]) def dups_count_dict(l): d = {} for item in l: if item not in d: d[item] = 0 d[item] += 1 result_d = {key: val for key, val in d.iteritems() if val > 1} return result_d.keys() def dups_counter(l): counter = Counter(l) result_d = {key: val for key, val in counter.iteritems() if val > 1} return result_d.keys() def gen_array(): np.random.seed(17) return list(np.random.randint(0, 5000, 10000)) def assert_equal_results(*results): primary_result = results[0] other_results = results[1:] for other_result in other_results: assert set(primary_result) == set(other_result) and len(primary_result) == len(other_result) if __name__ == dups_count_time = TimerCounter() dups_count_dict_time = TimerCounter() dups_count_counter = TimerCounter() l = gen_array() for i in range(3): dups_count_time.start() result1 = dups_count(l) dups_count_time.stop() dups_count_dict_time.start() result2 = dups_count_dict(l) dups_count_dict_time.stop() dups_count_counter.start() result3 = dups_counter(l) dups_count_counter.stop() assert_equal_results(result1, result2, result3) print print print
def dupList(oldlist): if type(oldlist)==type((2,2)): oldlist=[x for x in oldlist] newList=[] newList=newList+oldlist oldlist=oldlist forbidden=[] checkPoint=0 for i in range(len(oldlist)): if i in forbidden: continue else: for j in range(len(oldlist)): if j in forbidden: continue else: if i!=j: if oldlist[j]==oldlist[i]: forbidden.append(j) del newList[j-checkPoint] checkPoint=checkPoint+1 return newList
>>>a = [1,2,3,3,3,4,5,6,6,7] >>>dupList(a) [1, 2, 3, 4, 5, 6, 7]
from toolz import frequencies, valfilter a = [1,2,2,3,4,5,4] >>> list(valfilter(lambda count: count > 1, frequencies(a)).keys()) [2,4]
duplicates=dict(set((x,target.count(x)) for x in filter(lambda rec : target.count(rec)>1,target)))
duplicates=filter(lambda rec : target.count(rec)>1,target)
tuple = (1, "foo", "bar") def myfun(number, str1, str2): return (number * 2, str1 + str2, str2 + str1) myfun(expand(tuple))
from toolz import * from operator import add, eq apply_tuple = curry(apply_tuple) thread_last( [(1,2), (3,4)], (map, apply_tuple(add)), list, (eq, [3, 7]) )
def run_argtup(func, argvalues): argnames = get_func_argnames(func) if len(argnames) != len(argvalues): raise ValueError("Length of args doens for argn, argv in zip(argnames, argvalues): exec( return eval(
def grandKids(generation, kidsFunc, val): layer = [val] for i in xrange(generation): layer = itertools.chain.from_iterable(itertools.imap(kidsFunc, layer)) return layer
grandKids generation kidsFunc val = iterate (concatMap kidsFunc) [val] !! generation
try: from StringIO import StringIO except ImportError: from io import StringIO
import numpy as np from StringIO import StringIO data = "1, abc , 2\n 3, xxx, 4" print type(data) print """ [[ [ """ print print """ [[ 1. nan 2.] [ 3. nan 4.]] """
import numpy as np from io import StringIO import io data = "1, abc , 2\n 3, xxx, 4" """ 1, abc , 2 3, xxx, 4 """ print( print(np.genfromtxt(io.BytesIO(data.encode()), delimiter=",", dtype="|S3", autostrip=True)) """ [[b [b """ print( print(np.genfromtxt(io.BytesIO(data.encode()), delimiter=",", autostrip=True)) """ [[ 1. nan 2.] [ 3. nan 4.]] """
import six import numpy x = "1 3\n 4.5 8" numpy.genfromtxt(six.StringIO(x))
import io data =io.BytesIO(b"1, 2, 3\n4, 5, 6") import numpy numpy.genfromtxt(data, delimiter=",")
import io import numpy x = "1 3\n 4.5 8" numpy.genfromtxt(io.BytesIO(x.encode()))
import sys, os print( pathname = os.path.dirname(sys.argv[0]) print( print(
In [1]: import numpy as np In [2]: a = np.array([[1,2],[3,4]])
In: a = np.array([[1,2,3],[4,5,6]]) In: a.shape Out: (2, 3) In: a.shape[0] Out: 2 In: a.shape[1] Out: 3
var = np.array([[1,2,3,4,5,6], [1,2,3,4,5,6]]) var.ndim var.shape
var = np.array([[1,2,3,4,5,6], [1,2,3,4,5,6]]).reshape(3,4) var.ndim var.shape
>>> import json >>> json_string = json.dumps("ברי צקלה") >>> print json_string "\u05d1\u05e8\u05d9 \u05e6\u05e7\u05dc\u05d4"
>>> output = json_string.decode( "\u05d1\u05e8\u05d9 \u05e6\u05e7\u05dc\u05d4"
>>> >>> s= json.dumps( "ברי צקלה", ensure_ascii=False) >>> print json.loads(s) ברי צקלה >>> >>> d={ 1: "ברי צקלה", 2: u"ברי צקלה" } >>> print d {1: 2: u >>> s = json.dumps( d, ensure_ascii=False, encoding= >>> print json.loads(s)[ ברי צקלה >>> print json.loads(s)[ ××¨× ×¦×§××
>>> json_string = json.dumps(u"ברי צקלה", ensure_ascii=False).encode( >>> json_string >>> print json_string "ברי צקלה"
with io.open( json.dump(u"ברי צקלה", json_file, ensure_ascii=False)
with io.open( data = json.dumps(u"ברי צקלה", ensure_ascii=False) json_file.write(unicode(data))
>>> d={ 1: "ברי צקלה", 2: u"ברי צקלה" } >>> d {1: >>> s=json.dumps(d, ensure_ascii=False, encoding= >>> s u >>> json.loads(s)[ u >>> json.loads(s)[ u >>> print json.loads(s)[ ברי צקלה >>> print json.loads(s)[ ברי צקלה
>>> s = u >>> print s ××¨× ×¦×§×× >>> print s.encode( ברי צקלה
import codecs import json with codecs.open( json.dump({"message":"xin chào việt nam"}, f, ensure_ascii=False)
import codecs import json print(json.dumps({"message":"xin chào việt nam"}, ensure_ascii=False))
>>> d = {1: "ברי צקלה", 2: u"ברי צקלה"} >>> json_str = json.dumps(d).decode( >>> print json_str {"1": "ברי צקלה", "2": "ברי צקלה"}
d = {u with io.open( data = json.dumps(d, ensure_ascii=False).decode( try: json_file.write(data) except TypeError: json_file.write(data.decode( UnicodeEncodeError:
with io.open( data = json.dumps(d, ensure_ascii=False, encoding= json_file.write(unicode(data)) cat filename {"keyword": "bad credit çredit cards"}
r""" @update: 2017-01-09 14:44:39 @explain: str, unicode, bytes in python2to3 """ from __future__ import print_function import json a = {"b": u"中文"} print( print( print( a = {"b": u"中文"} print( print( print( b = a[ print( print( print( c = b.decode( print( print( """ { u u u { b b b b """
def jsonWrite(p, pyobj, ensure_ascii=False, encoding=SYSTEM_ENCODING, **kwargs): with codecs.open(p, json.dump(pyobj, fileobj, ensure_ascii=ensure_ascii,encoding=encoding, **kwargs)
locale.setlocale(locale.LC_ALL, SYSTEM_ENCODING = locale.getlocale()[1]
with codecs.open( fp.write(json.dumps(res, ensure_ascii=False))
name = {"last_name": u"王"} json.dumps(name, ensure_ascii=False)
itm Date Amount 67 420 2012-09-30 00:00:00 65211 68 421 2012-09-09 00:00:00 29424 69 421 2012-09-16 00:00:00 29877 70 421 2012-09-23 00:00:00 30990 71 421 2012-09-30 00:00:00 61303 72 485 2012-09-09 00:00:00 71781 73 485 2012-09-16 00:00:00 NaN 74 485 2012-09-23 00:00:00 11072 75 485 2012-09-30 00:00:00 113702 76 489 2012-09-09 00:00:00 64731 77 489 2012-09-16 00:00:00 NaN
In [7]: df Out[7]: 0 1 0 NaN NaN 1 -0.494375 0.570994 2 NaN NaN 3 1.876360 -0.229738 4 NaN NaN In [8]: df.fillna(0) Out[8]: 0 1 0 0.000000 0.000000 1 -0.494375 0.570994 2 0.000000 0.000000 3 1.876360 -0.229738 4 0.000000 0.000000
In [12]: df[1].fillna(0, inplace=True) Out[12]: 0 0.000000 1 0.570994 2 0.000000 3 -0.229738 4 0.000000 Name: 1 In [13]: df Out[13]: 0 1 0 NaN 0.000000 1 -0.494375 0.570994 2 NaN 0.000000 3 1.876360 -0.229738 4 NaN 0.000000
idx = pd.IndexSlice df.loc[idx[:,mask_1],idx[mask_2,:]].fillna(value=0,inplace=True)
df.update(df.loc[idx[:,mask_1],idx[[mask_2],:]].fillna(value=0))
import pandas df = pandas.read_csv( df = df.fillna(0)
import pandas as pd import numpy as np df[ df = df.replace(np.nan, 0) df.replace(np.nan, 0, inplace=True)
class MyClass(object): def meth_a(self): pass def meth_b(self): print "I
try: self.version = "Expat %d.%d.%d" % expat.version_info except AttributeError: pass
class _BaseSubmittingController(_BaseController): def submit(self, tasks): pass def retrieve(self, deferred_results): pass
for x, error in MDNewton(mp, f, (1,-2), verbose=0, norm=lambda x: norm(x, inf)): pass
def time_step(agents): for agent in agents: update_agent(agent)
def some_silly_transform(n): if n % 2 == 0: n /= 2 flag = True elif n < 0: n = -n flag = True else: pass
class TestFunctions(unittest.TestCase): def test_some_feature(self): pass def test_some_other_feature(self): pass
if (something == true): pass while (some condition is true): pass
void main() { int age = 12; if( age < 18 ) { printf("You are not adult, so you can } else if( age >= 18 && age < 60) { } else { printf("You are too old to do anything , sorry "); } }
age = 12 if age < 18: print "You are not adult, so you can elif age >= 18 and age < 60: else: print "You are too old to do anything , sorry "
age = 12 if age < 18: print "You are not adult, so you can elif age >= 18 and age < 60: pass else: print "You are too old to do anything , sorry "
>>> a = [ >>> data = [] >>> type(a) <class >>> type(a[1]) <class >>> type(a[0]) <class
a = [ data = [] for i in range(0, len(a)): if a[i].isalpha(): pass else: data.append(a[i]) print(data) [
for letter in if letter == pass print print print "Good bye!"
Current Letter : P Current Letter : y Current Letter : t This is pass block Current Letter : h Current Letter : o Current Letter : n Good bye!
For i in range (1,100): If i%2==0: Pass Else: Print(i)
if hi == hi: print "hi" elif hi (does not equal) bye: print "no hi"
answer = if answer == print "hi" elif answer != print "no hi"
if not (1) == (1): print "the world is ending" elif (1+1) != (2): print "the world is ending" else: print "you are good for another day"
if hi == hi: print "hi" elif hi != bye: print "no hi"
File "PIL/Image.py", line 375, in _getdecoder raise IOError("decoder %s not available" % decoder_name) IOError: decoder jpeg not available
sudo apt-get install libjpeg-dev sudo apt-get install libjpeg8-dev pip install --no-cache-dir -I pillow
sudo ln -s /usr/lib/x86_64-linux-gnu/libjpeg.so /usr/lib sudo ln -s /usr/lib/x86_64-linux-gnu/libfreetype.so /usr/lib sudo ln -s /usr/lib/x86_64-linux-gnu/libz.so /usr/lib
sudo ln -s /usr/lib/i386-linux-gnu/libjpeg.so /usr/lib/ sudo ln -s /usr/lib/i386-linux-gnu/libfreetype.so.6 /usr/lib/ sudo ln -s /usr/lib/i386-linux-gnu/libz.so /usr/lib/
pip install PIL --allow-external PIL --allow-unverified PIL
ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future pip install PIL --allow-external PIL --allow-unverified PIL
pip uninstall PIL apt-get install libjpeg-dev apt-get install libfreetype6-dev apt-get install zlib1g-dev apt-get install libpng12-dev pip install PIL --upgrade
sudo yum install --assumeyes libjpeg-devel sudo pip-python install --upgrade PIL
PIL SETUP SUMMARY -------------------------------------------------------------------- version Pillow 2.8.2 platform linux 3.4.3 (default, May 25 2015, 15:44:26) [GCC 4.8.2] -------------------------------------------------------------------- *** TKINTER support not available --- JPEG support available *** OPENJPEG (JPEG2000) support not available --- ZLIB (PNG/ZIP) support available --- LIBTIFF support available --- FREETYPE2 support available *** LITTLECMS2 support not available *** WEBP support not available *** WEBPMUX support not available --------------------------------------------------------------------
apt-get install libjpeg-dev apt-get install libfreetype6-dev apt-get install zlib1g-dev apt-get install libpng12-dev
raise IOError("decoder %s not available" % decoder_name) OSError: decoder jpeg not available
f = open("myfile", "rb") try: byte = f.read(1) while byte != "": byte = f.read(1) finally: f.close()
with open("myfile", "rb") as f: byte = f.read(1) while byte != "": byte = f.read(1)
with open("myfile", "rb") as f: byte = f.read(1) while byte != b"": byte = f.read(1)
with open("myfile", "rb") as f: byte = f.read(1) while byte: byte = f.read(1)
def bytes_from_file(filename, chunksize=8192): with open(filename, "rb") as f: while True: chunk = f.read(chunksize) if chunk: for b in chunk: yield b else: break for b in bytes_from_file( do_stuff_with(b)
bytes_read = open("filename", "rb").read() for b in bytes_read: process_byte(b)
file = open("filename", "rb") try: bytes_read = file.read(CHUNKSIZE) while bytes_read: for b in bytes_read: process_byte(b) bytes_read = file.read(CHUNKSIZE) finally: file.close()
with open(filename, for byte in iter(lambda: file.read(1), b
import sys from functools import partial from collections import deque chunksize = int(sys.argv[1]) if len(sys.argv) > 1 else (1 << 15) deque(iter(partial(sys.stdin.detach().read, chunksize), b
$ dd if=/dev/zero bs=1M count=1000 | python3 blackhole.py
from mmap import ACCESS_READ, mmap with open(filename, for byte in s:
with open("myfile", "rb") as f: while True: byte = f.read(1) if not byte: break do_stuff_with(ord(byte))
from functools import partial with open(filename, for byte in iter(partial(file.read, 1), b
def bytes_from_file(filename): with open(filename, "rb") as f: while True: byte = f.read(1) if not byte: break yield(ord(byte)) for b in bytes_from_file( do_stuff_with(b)
import pathlib for byte in pathlib.Path(path).read_bytes(): print(byte)
with open(path, for byte in file.read(): print(byte)
with open(path, callable = lambda: file.read(1024) sentinel = bytes() for chunk in iter(callable, sentinel): for byte in chunk: print(byte)
from pathlib import Path from functools import partial from io import DEFAULT_BUFFER_SIZE def file_byte_iterator(path): path = Path(path) with path.open( reader = partial(file.read1, DEFAULT_BUFFER_SIZE) file_iterator = iter(reader, bytes()) for chunk in file_iterator: for byte in chunk: yield byte
import random import pathlib path = pathobj = pathlib.Path(path) pathobj.write_bytes( bytes(random.randint(0, 255) for _ in range(2**20)))
>>> l = list(file_byte_iterator(path)) >>> len(l) 1048576
>>> l[-100:] [208, 5, 156, 186, 58, 107, 24, 12, 75, 15, 1, 252, 216, 183, 235, 6, 136, 50, 222, 218, 7, 65, 234, 129, 240, 195, 165, 215, 245, 201, 222, 95, 87, 71, 232, 235, 36, 224, 190, 185, 12, 40, 131, 54, 79, 93, 210, 6, 154, 184, 82, 222, 80, 141, 117, 110, 254, 82, 29, 166, 91, 42, 232, 72, 231, 235, 33, 180, 238, 29, 61, 250, 38, 86, 120, 38, 49, 141, 17, 190, 191, 107, 95, 223, 222, 162, 116, 153, 232, 85, 100, 97, 41, 61, 219, 233, 237, 55, 246, 181] >>> l[:100] [28, 172, 79, 126, 36, 99, 103, 191, 146, 225, 24, 48, 113, 187, 48, 185, 31, 142, 216, 187, 27, 146, 215, 61, 111, 218, 171, 4, 160, 250, 110, 51, 128, 106, 3, 10, 116, 123, 128, 31, 73, 152, 58, 49, 184, 223, 17, 176, 166, 195, 6, 35, 206, 206, 39, 231, 89, 249, 21, 112, 168, 4, 88, 169, 215, 132, 255, 168, 129, 127, 60, 252, 244, 160, 80, 155, 246, 147, 234, 227, 157, 137, 101, 84, 115, 103, 77, 44, 84, 134, 140, 77, 224, 176, 242, 254, 171, 115, 193, 29]
with open(path, for chunk in file: for byte in chunk: yield byte
with open("filename", "rb") as binary_file: data = binary_file.read() print(data)
from array import array with open( path, data = array( for byte in data: v = byte c = chr(byte)
c.InteractiveShellApp.extensions = [ c.InteractiveShellApp.exec_lines = [
import inspect def recursively_reload_all_submodules(module, loaded=None): for name in dir(module): member = getattr(module, name) if inspect.ismodule(member) and member not in loaded: recursively_reload_all_submodules(member, loaded) loaded.add(module) reload(module) import mymodule recursively_reload_all_submodules(mymodule, set())
from IPython import get_ipython ipython = get_ipython() ipython.magic("pylab") ipython.magic("load_ext autoreload") ipython.magic("autoreload 2")
$ cat << EOF > ~/.ipython/profile_default/startup/50-autoreload.ipy %load_ext autoreload %autoreload 2 EOF
from IPython.lib.deepreload import reload %load_ext autoreload %autoreload 2
{"keys": ["ctrl+shift+c"], "command": "exec", "args": {"kill": true} }
{ "cmd": ["C:\\python27\\python.exe", "-u", "$file"], "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.python" }
{ "path": "/usr/local/bin", "cmd": ["python3", "-u", "$file"], "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.python" }
startupinfo = None if os.name == "nt": startupinfo = subprocess.STARTUPINFO()
for k, v in proc_env.iteritems(): proc_env[k] = os.path.expandvars(v).encode(sys.getfilesystemencoding())
try: for k, v in proc_env.iteritems(): proc_env[k] = os.path.expandvars(v).encode(sys.getfilesystemencoding()) except: print
{ "cmd": ["/usr/local/bin/python", "-u", "$file"], "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.python", }
{ "cmd": ["path_to_the_python.exe","-u", "$file"], "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.python" }
from selenium import webdriver browser = webdriver.Firefox()
Exception ignored in: <bound method Service.__del__ of <selenium.webdriver.firefox.service.Service object at 0x00000249C0DA1080>> Traceback (most recent call last): File "C:\Python\Python35\lib\site-packages\selenium\webdriver\common\service.py", line 163, in __del__ self.stop() File "C:\Python\Python35\lib\site-packages\selenium\webdriver\common\service.py", line 135, in stop if self.process is None: AttributeError: Exception ignored in: <bound method Service.__del__ of <selenium.webdriver.firefox.service.Service object at 0x00000249C0E08128>> Traceback (most recent call last): File "C:\Python\Python35\lib\site-packages\selenium\webdriver\common\service.py", line 163, in __del__ self.stop() File "C:\Python\Python35\lib\site-packages\selenium\webdriver\common\service.py", line 135, in stop if self.process is None: AttributeError: Traceback (most recent call last): File "C:\Python\Python35\lib\site-packages\selenium\webdriver\common\service.py", line 64, in start stdout=self.log_file, stderr=self.log_file) File "C:\Python\Python35\lib\subprocess.py", line 947, in __init__ restore_signals, start_new_session) File "C:\Python\Python35\lib\subprocess.py", line 1224, in _execute_child startupinfo) FileNotFoundError: [WinError 2] The system cannot find the file specified During handling of the above exception, another exception occurred: Traceback (most recent call last): File "<pyshell browser = webdriver.Firefox() File "C:\Python\Python35\lib\site-packages\selenium\webdriver\firefox\webdriver.py", line 135, in __init__ self.service.start() File "C:\Python\Python35\lib\site-packages\selenium\webdriver\common\service.py", line 71, in start os.path.basename(self.path), self.start_error_message) selenium.common.exceptions.WebDriverException: Message:
export PATH=$PATH:/path/to/directory/of/executable/downloaded/in/previous/step
from selenium import webdriver browser = webdriver.Firefox()
from selenium import webdriver from selenium.webdriver.firefox.firefox_binary import FirefoxBinary binary = FirefoxBinary( browser = webdriver.Firefox(firefox_binary=binary)
firefox_capabilities = DesiredCapabilities.FIREFOX firefox_capabilities[ firefox_capabilities[ browser = webdriver.Firefox(capabilities=firefox_capabilities)
from selenium import webdriver driver = webdriver.Firefox(executable_path=r driver.get(
PATH="/Users/<your-name>/Downloads/geckodriver:$PATH" export PATH
import os; os.environ["PATH"] += os.pathsep + r from selenium import webdriver; browser = webdriver.Firefox(); browser.get( assert
from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapabilities firefox_capabilities = DesiredCapabilities.FIREFOX firefox_capabilities[ firefox_capabilities[ firefox_capabilities[ firefox_capabilities[ ffProfilePath = profile = webdriver.FirefoxProfile(profile_directory=ffProfilePath) geckoPath = browser = webdriver.Firefox(firefox_profile=profile, capabilities=firefox_capabilities, executable_path=geckoPath) browser.get(
Drivers ======= Selenium requires a driver to interface with the chosen browser. Firefox, for example, requires `geckodriver <https: Failure to observe this step will give you an error `selenium.common.exceptions.WebDriverException: Message:
def download(url): firefox_capabilities = DesiredCapabilities.FIREFOX firefox_capabilities[ browser = webdriver.Firefox(capabilities=firefox_capabilities, executable_path=r browser.get(url) return browser.page_source
def __init__(self, firefox_profile=None, firefox_binary=None, timeout=30, capabilities=None, proxy=None, executable_path="/PATH/gecko/geckodriver", firefox_options=None, log_path="/PATH/geckodriver.log"):
try: do_evil() except: exc_type, exc_value, tb = sys.exc_info() if something(exc_value): raise
try: do_evil() except: exc_type, exc_value, tb = sys.exc_info() del tb if something(exc_value): raise
class A(object): def set_a(self, a): self.a=a a=A() a.set_a(3) if hasattr(a, "a"): print("Hallo")
import sys if sys.version_info < (3,): print("Python 2 not supported")
import sys if sys.version_info < (3,): print("Python 2 not supported") del sys
def f(a, b, c=3): return def g(**kwargs): if del kwargs[ return f(**kwargs)
def g(a, b, c=None): kwargs = { if c is not None: kwargs[ return f(**kwargs)
import ROOT as R input_file = R.TFile( tree = input_file.Get( tree.Draw( R.gPad.Close() R.hy tree.Draw( R.hy del R.hy R.hy
def expires(): epoch = datetime.datetime(1970, 1, 1) seconds_in_a_day = 60 * 60 * 24 five_minutes = datetime.timedelta(seconds=5*60) five_minutes_from_now = datetime.datetime.now() + five_minutes since_epoch = five_minutes_from_now - epoch return since_epoch.days * seconds_in_a_day + since_epoch.seconds
future = datetime.datetime.utcnow() + datetime.timedelta(minutes=5) return calendar.timegm(future.timetuple())
import datetime current_time = datetime.datetime.now(datetime.timezone.utc) unix_timestamp = current_time.timestamp() unix_timestamp_plus_5_min = unix_timestamp + (5 * 60)
import time def expires(): return int(time.time()+300)
import time import datetime n = datetime.datetime.now() unix_time = time.mktime(n.timetuple())
def expires(): future = datetime.datetime.now() + datetime.timedelta(seconds=5*60) return int(future.strftime("%s"))
future = datetime.datetime.utcnow() + datetime.timedelta(minutes=5) return (future - datetime.datetime(1970, 1, 1)).total_seconds()
def in_unix(input): start = datetime.datetime(year=1970,month=1,day=1) diff = input - start return diff.total_seconds()
import datetime import pytz UNIX_EPOCH = datetime.datetime(1970, 1, 1, 0, 0, tzinfo = pytz.utc) def EPOCH(utc_datetime): delta = utc_datetime - UNIX_EPOCH seconds = delta.total_seconds() ms = seconds * 1000 return ms
def datetime_timestamp(datetime): Equivalent to datetime.timestamp() for pre-3.3 try: return datetime.timestamp() except AttributeError: utc_datetime = datetime.astimezone(utc) return timegm(utc_datetime.timetuple()) + utc_datetime.microsecond / 1e6
def expiration_time(): import datetime,calendar timestamp = calendar.timegm(datetime.datetime.now().timetuple()) returnValue = datetime.timedelta(minutes=5).total_seconds() + timestamp return returnValue
test = "have it break." selectiveEscape = "Print percent % in sentence and not %s" % test print(selectiveEscape)
selectiveEscape = "Use percent % in sentence and not %s" % test TypeError: %d format: a number is required, not str
>>> test = "have it break." >>> selectiveEscape = "Print percent %% in sentence and not %s" % test >>> print selectiveEscape Print percent % in sentence and not have it break.
selectiveEscape = "Print percent %% in sentence and not %s" % (test, )
selectiveEscape = "Print percent %s in sentence and not %s" % (
import matplotlib.pyplot as plt fig,ax = plt.subplots(4,1) float_number = 4.17 ax[0].set_title( ax[1].set_title( ax[2].set_title( ax[3].set_title(
import matplotlib.pyplot as plt import matplotlib font = { matplotlib.rc( matplotlib.rcParams[ matplotlib.rcParams[ fig,ax = plt.subplots(4,1) float_number = 4.17 ax[1].set_title( ax[2].set_title( ax[3].set_title(
Starting new HTTP connection (1): example.com http:
import logging logging.getLogger("requests").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.WARNING)
import requests import logging for key in logging.Logger.manager.loggerDict: print(key) logging.getLogger(
import logging urllib3_logger = logging.getLogger( urllib3_logger.setLevel(logging.CRITICAL)
import requests import logging import httplib httplib.HTTPConnection.debuglevel = 1 logging.basicConfig() logging.getLogger().setLevel(logging.DEBUG) requests_log = logging.getLogger("requests.packages.urllib3") requests_log.setLevel(logging.DEBUG) requests_log.propagate = True requests.get(
[logger_urllib3] level = WARNING handlers = qualname = requests.packages.urllib3.connectionpool
PYTHONWARNINGS="ignore:Unverified HTTPS request" ./do-insecure-request.py
name = "Spongebob Squarepants" puts "Who lives in a Pineapple under the sea? \n
name = "Spongebob Squarepants" print(f"Who lives in a Pineapple under the sea? {name}.")
name = "Spongebob Squarepants" print("Who lives in a Pineapple under the sea? %(name)s." % locals())
name = "Spongebob Squarepants" print("Who lives in a Pineapple under the sea? {name!s}.".format(**locals()))
tmpl = string.Template("Who lives in a Pineapple under the sea? $name.") print(tmpl.substitute(name="Spongebob Squarepants"))
"my {0} string: {1}".format("cool", "Hello there!")
name = "Spongebob Squarepants" print "Who lives in a Pineapple under the sea? \n
name = "SpongeBob Squarepants" print "Who lives in a Pineapple under the sea? %s" % name
name = "Spongebob Squarepants" print "Who lives in a Pineapple under the sea? \n{name}.".format(name=name)
import inspect def s(template, **kwargs): "Usage: s(string, **locals())" if not kwargs: frame = inspect.currentframe() try: kwargs = frame.f_back.f_locals finally: del frame if not kwargs: kwargs = globals() return template.format(**kwargs)
import string def try_interp(): d = 1 f = 1.1 s = "s" print string.Template("d: $d f: $f s: $s").substitute(**locals()) try_interp()
import inspect lines = inspect.getsource(foo) print(lines)
>>> import dis >>> def foo(arg1,arg2): ... ... a = arg1 + arg2 ... return a ... >>> dis.dis(foo) 3 0 LOAD_FAST 0 (arg1) 3 LOAD_FAST 1 (arg2) 6 BINARY_ADD 7 STORE_FAST 2 (a) 4 10 LOAD_FAST 2 (a) 13 RETURN_VALUE
In [19]: foo?? Signature: foo(arg1, arg2) Source: def foo(arg1,arg2): a = arg1 + arg2 return a File: ~/Desktop/<ipython-input-18-3174e3126506> Type: function
>>> from dill.source import getsource >>> >>> def add(x,y): ... return x+y ... >>> squared = lambda x:x**2 >>> >>> print getsource(add) def add(x,y): return x+y >>> print getsource(squared) squared = lambda x:x**2 >>> >>> class Foo(object): ... def bar(self, x): ... return x*x+x ... >>> f = Foo() >>> >>> print getsource(f.bar) def bar(self, x): return x*x+x >>>
>>> def foo(a): ... x = 2 ... return x + a >>> import inspect >>> inspect.getsource(foo) u print inspect.getsource(foo) def foo(a): x = 2 return x + a
import inspect def get_my_code(): x = "abcd" return x print(inspect.getsource(get_my_code))
import inspect print( "".join(inspect.getsourcelines(foo)[0]))
import inspect def main(): x, f = 3, lambda a: a + 1 print(inspect.getsource(f)) if __name__ == "__main__": main()
import sys filename = sys.argv[1] source = open(filename, compile(source, filename,
doCheckPythonSyntax(){ doLog "DEBUG START doCheckPythonSyntax" test -z "$sleep_interval" || sleep "$sleep_interval" cd $product_version_dir/sfw/python while read -r f ; do \ py_name_ext=$(basename $f) py_name=${py_name_ext%.*} doLog "python3 -c \"import $py_name\"" python3 -c "import $py_name" test $! -ne 0 && sleep 5 done < <(find "$product_version_dir/sfw/python" -type f -name "*.py") doLog "DEBUG STOP doCheckPythonSyntax" }
print "something", 1/0, "other" print("something", 1/0, "other")
import sys temp = sys.stdout sys.stdout = open( print("testing123") print("another line") sys.stdout.close() sys.stdout = temp print("back to normal")
def myfunc(outfile=None): if outfile is None: out = sys.stdout else: out = open(outfile, try: out.write(mytext + finally: if outfile is not None: out.close()
Note carriage return-> "\rMy Status Message: %s" % progress
import sys def printstars(count): if count >= 1: i = 1 while (i <= count): x=0 while(x<i): sys.stdout.write( x = x+1 print( i=i+1 printstars(5)
import time, sys Iterations = 555 for k in range(Iterations+1): percentage = k / Iterations time_msg = "\rRunning Progress at {0:.2%} ".format(percentage) sys.stdout.write(time_msg) sys.stdout.flush() time.sleep(0.01)
import itertools stuff = [1, 2, 3] for L in range(0, len(stuff)+1): for subset in itertools.combinations(stuff, L): print(subset)
from itertools import chain, combinations def all_subsets(ss): return chain(*map(lambda x: combinations(ss, x), range(0, len(ss)+1))) for subset in all_subsets(stuff): print(subset)
from itertools import compress, product def combinations(items): return ( set(compress(items,mask)) for mask in product(*[[0,1]]*len(items)) )
items=abc * mask= | V 000 -> 001 -> c 010 -> b 011 -> bc 100 -> a 101 -> a c 110 -> ab 111 -> abc
>>> list(combinations(range(4))) [set(), {3}, {2}, {2, 3}, {1}, {1, 3}, {1, 2}, {1, 2, 3}, {0}, {0, 3}, {0, 2}, {0, 2, 3}, {0, 1}, {0, 1, 3}, {0, 1, 2}, {0, 1, 2, 3}] >>> list(combinations( [set(), {
from itertools import chain, combinations def powerset(iterable): "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) stuff = [1, 2, 3] for i, combo in enumerate(powerset(stuff), 1): print(
>>> import copy >>> def combinations(target,data): ... for i in range(len(data)): ... new_target = copy.copy(target) ... new_data = copy.copy(data) ... new_target.append(data[i]) ... new_data = data[i+1:] ... print new_target ... combinations(new_target, ... new_data) ... ... >>> target = [] >>> data = [ >>> >>> combinations(target,data) [ [ [ [ [ [ [ [ [ [ [ [ [ [ [
iterable = range(10) for s in xrange(len(iterable)+1): for comb in itertools.combinations(iterable, s): yield comb
from itertools import combinations input = [ output = sum([map(list, combinations(input, i)) for i in range(len(input) + 1)], [])
import itertools a = [1,2,3,4] for i in xrange(0,len(a)+1): print list(itertools.combinations(a,i))
[()] [(1,), (2,), (3,), (4,)] [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)] [(1, 2, 3, 4)]
def powerSet(items): N = len(items) for i in range(2**N): combo = [] for j in range(N): if (i >> j) % 2 == 1: combo.append(items[j]) yield combo
for i in powerSet([1,2,3,4]): print (i, ", ", end="")
def combs(x): return [c for i in range(len(x)+1) for c in combinations(x,i)]
>>> combs([1,2,3,4]) [(), (1,), (2,), (3,), (4,), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (1, 2, 3, 4)]
def combs(xs, i=0): if i==len(xs): yield () return for c in combs(xs,i+1): yield c yield c+(xs[i],)
>>> list( combs(range(5)) ) [(), (0,), (1,), (1, 0), (2,), (2, 0), (2, 1), (2, 1, 0), (3,), (3, 0), (3, 1), (3, 1, 0), (3, 2), (3, 2, 0), (3, 2, 1), (3, 2, 1, 0), (4,), (4, 0), (4, 1), (4, 1, 0), (4, 2), (4, 2, 0), (4, 2, 1), (4, 2, 1, 0), (4, 3), (4, 3, 0), (4, 3, 1), (4, 3, 1, 0), (4, 3, 2), (4, 3, 2, 0), (4, 3, 2, 1), (4, 3, 2, 1, 0)] >>> list(sorted( combs(range(5)), key=len)) [(), (0,), (1,), (2,), (3,), (4,), (1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2), (4, 0), (4, 1), (4, 2), (4, 3), (2, 1, 0), (3, 1, 0), (3, 2, 0), (3, 2, 1), (4, 1, 0), (4, 2, 0), (4, 2, 1), (4, 3, 0), (4, 3, 1), (4, 3, 2), (3, 2, 1, 0), (4, 2, 1, 0), (4, 3, 1, 0), (4, 3, 2, 0), (4, 3, 2, 1), (4, 3, 2, 1, 0)] >>> len(set(combs(range(5)))) 32
from itertools import permutations perm = permutations([1, 2, 3], 2) for i in list(perm): print (i)
from itertools import combinations comb = combinations([1, 2, 3], 2) for i in list(comb): print (i)
# # # def getCombos(listIn = [ listCombos = [ [ [] ] ] listSimple = [] for item in listIn: listCombos.append([]) for index in xrange(len(listCombos)-1, 0, -1): for listPrev in listCombos[index-1]: listCur = listPrev[:] listCur.append(item) listCombos[index].append(listCur) itemCombo = for item in listCur: itemCombo += item listSimple.append(itemCombo) return [listSimple, listCombos]
lambda l: [(a, b) for i, a in enumerate(l) for b in l[i+1:]]
lambda l: [(a, b, c) for i, a in enumerate(l) for ii, b in enumerate(l[i+1:]) for c in l[i+ii+2:]]
import itertools combs_3 = lambda l: [ (a, b, c) for i, a in enumerate(l) for ii, b in enumerate(l[i+1:]) for c in l[i+ii+2:] ] data = ((1, 2), 5, "a", None) print("A:", list(itertools.combinations(data, 3))) print("B:", combs_3(data))
def combine(inp): return combine_helper(inp, [], []) def combine_helper(inp, temp, ans): for i in range(len(inp)): current = inp[i] remaining = inp[i + 1:] temp.append(current) ans.append(tuple(temp)) combine_helper(remaining, temp, ans) temp.pop() return ans print(combine([
import itertools col_names = ["aa","bb", "cc", "dd"] all_combinations = itertools.chain(*[itertools.combinations(col_names,i+1) for i,_ in enumerate(col_names)]) print(list(all_combinations))
def selfCombine( list2Combine, length ): listCombined = str( [ + if length > 1: listCombined += str( [ .replace( " .replace( "[ .replace( " listCombined = listCombined = eval( listCombined ) return listCombined list2Combine = [ listCombined = selfCombine( list2Combine, 2 )
def get_combinations(list_of_things): list_of_combinations = [list(combinations_of_a_certain_size) for possible_size_of_combinations in range(1, len(list_of_things)) for combinations_of_a_certain_size in itertools.combinations(list_of_things, possible_size_of_combinations)] return list_of_combinations
def combinations(lst, depth, start=0, items=[]): if depth <= 0: return [items] out = [] for i in range(start, len(lst)): out += combinations(lst, depth - 1, i + 1, items + [lst[i]]) return out
def combinations(lst, depth, start=0, prepend=[]): if depth <= 0: yield prepend else: for i in range(start, len(lst)): for c in combinations(lst, depth - 1, i + 1, prepend + [lst[i]]): yield c
print([c for c in combinations([1, 2, 3, 4], 3)]) prepend = [c for c in combinations([], -1)][0] prepend.append(None) print([c for c in combinations([1, 2, 3, 4], 3)])
def comb(s, res): if not s: return res.add(s) for i in range(0, len(s)): t = s[0:i] + s[i + 1:] comb(t, res) res = set() comb( print(res)
def combinations(arr, carry): for i in range(len(arr)): yield carry + arr[i] yield from combinations(arr[i + 1:], carry + arr[i])
def combinations(iterable, r): pool = tuple(iterable) n = len(pool) if r > n: return indices = range(r) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) x = [2, 3, 4, 5, 1, 6, 4, 7, 8, 3, 9] for i in combinations(x, 2): print i
stuff = [1, 2, 3, 4] def reverse(bla, y): for subset in itertools.combinations(bla, len(bla)-y): print list(subset) if y != len(bla): y += 1 reverse(bla, y) reverse(stuff, 1)
def checkEqual1(iterator): iterator = iter(iterator) try: first = next(iterator) except StopIteration: return True return all(first == rest for rest in iterator)
def checkEqual2(iterator): return len(set(iterator)) <= 1
s1 = [1] * 5000 s2 = [1] * 4999 + [2] s3 = [2] + [1]*4999 s4 = [set([9])] * 5000 s5 = [set([9])] * 4999 + [set([10])] s6 = [set([10])] + [set([9])] * 4999 s7 = [1,1] s8 = [1,2] s9 = []
| checkEqual1 | checkEqual2 | checkEqual3 | checkEqualIvo | checkEqual6502 | |-----|-------------|-------------|--------------|---------------|----------------| | s1 | 1.19 msec | 348 usec | 183 usec | 51.6 usec | 121 usec | | s2 | 1.17 msec | 376 usec | 185 usec | 50.9 usec | 118 usec | | s3 | 4.17 usec | 348 usec | 120 usec | 264 usec | 61.3 usec | | | | | | | | | s4 | 1.73 msec | | 182 usec | 50.5 usec | 121 usec | | s5 | 1.71 msec | | 181 usec | 50.6 usec | 125 usec | | s6 | 4.29 usec | | 122 usec | 423 usec | 61.1 usec | | | | | | | | | s7 | 3.1 usec | 1.4 usec | 1.24 usec | 0.932 usec | 1.92 usec | | s8 | 4.07 usec | 1.54 usec | 1.28 usec | 0.997 usec | 1.79 usec | | s9 | 5.91 usec | 1.25 usec | 0.749 usec | 0.407 usec | 0.386 usec |
def checkEqualIvo(lst): return not lst or lst.count(lst[0]) == len(lst) def checkEqual6502(lst): return not lst or [lst[0]]*len(lst) == lst
>>> timeit.timeit( 1.4383411407470703 >>> timeit.timeit( 1.4765670299530029 >>> timeit.timeit( 0.26274609565734863 >>> timeit.timeit( 0.25654196739196777
def all_equal(iterable): "Returns True if all the elements are equal to each other" g = groupby(iterable) return next(g, True) and not next(g, False)
def constantList(x): return x and [x[0]]*len(x) == x
>>> a = [ >>> b = [ >>> len(set(a))==1 False >>> len(set(b))==1 True
all(element==input_list[0] for element in input_list)
>>> a = [1, 2, 3, 4, 5] >>> b = [1, 1, 1, 1, 1] >>> all(number==a[0] for number in a) False >>> all(number==b[0] for number in b) True
result = mylist and all(mylist[0] == elem for elem in mylist)
def all_identical(seq): if not seq: return False first = seq[0] return all(first == elem for elem in seq)
>>> falseList = [1,2,3,4] >>> trueList = [1, 1, 1] >>> >>> def testList(list): ... for item in list[1:]: ... if item != list[0]: ... return False ... return True ... >>> testList(falseList) False >>> testList(trueList) True
def compare_lists(list1, list2): if len(list1) != len(list2): return False for item in list1: if item not in list2: return False return True a_list_1 = [ a_list_2 = [ b_list_1 = [ b_list_2 = [ c_list_1 = [ c_list_2 = [ print compare_lists(a_list_1, a_list_2) print compare_lists(b_list_1, b_list_2) print compare_lists(c_list_1, c_list_2)
not any((x[i] != x[i+1] for i in range(0, len(x)-1)))
reduce(lambda x, y: (x[1]==y, y), [2, 2, 2], (True, 2))
list1 = [1,1,1] len(set(list1)) >1 list1 = [1,2,3] len(set(list1) >3
>>> a = [1, 2, 3, 4, 5, 6] >>> z = [(a[x], a[x+1]) for x in range(0, len(a)-1)] >>> z [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] >>> z = [(a[x] == a[x+1]) for x in range(0, len(a)-1)] >>> z [False, False, False, False, False] >>> if False in z : Print "All elements are not equal"
def allTheSame(i): j = itertools.groupby(i) for k in j: break for k in j: return False return True
lst = [1,1,1,1,1,1,1,1,1] print all(map(lambda x: x == lst[0], lst[1:]))
reduce(and_, (x==yourList[0] for x in yourList), True)
lambda lst: reduce(lambda a,b:(b,b==a[0] and a[1]), lst, (lst[0], True))[1]
all(itertools.imap(lambda i:yourlist[i]==yourlist[i+1], xrange(len(yourlist)-1)))
def checkEqual(lst): if len(lst)==2 : return lst[0]==lst[1] else: return lst[0]==lst[1] and checkEqual(lst[1:])
import numpy as np def allthesame(l): return np.all(np.diff(l)==0)
import numpy as np def allthesame(l): return np.unique(l).shape[0]<=1
>>> datetime.time(11, 34, 59) + 3 TypeError: unsupported operand type(s) for +: >>> datetime.time(11, 34, 59) + datetime.timedelta(0, 3) TypeError: unsupported operand type(s) for +: >>> datetime.time(11, 34, 59) + datetime.time(0, 0, 3) TypeError: unsupported operand type(s) for +:
def add_secs_to_time(timeval, secs_to_add): secs = timeval.hour * 3600 + timeval.minute * 60 + timeval.second secs += secs_to_add return datetime.time(secs
import datetime a = datetime.datetime(100,1,1,11,34,59) b = a + datetime.timedelta(0,3) print a.time() print b.time()
import datetime def addSecs(tm, secs): fulldate = datetime.datetime(100, 1, 1, tm.hour, tm.minute, tm.second) fulldate = fulldate + datetime.timedelta(seconds=secs) return fulldate.time() a = datetime.datetime.now().time() b = addSecs(a, 300) print a print b
sometime = get_some_time() later = (datetime.combine(date.today(), sometime) + timedelta(seconds=3)).time()
>>> b = a + datetime.timedelta(seconds=3000) >>> b datetime.datetime(1, 1, 1, 12, 24, 59)
def add_secs_to_time(timeval, secs_to_add): dummy_date = datetime.date(1, 1, 1) full_datetime = datetime.datetime.combine(dummy_date, timeval) added_datetime = full_datetime + datetime.timedelta(seconds=secs_to_add) return added_datetime.time()
(datetime.datetime.combine(datetime.date(1, 1, 1), timeval) + datetime.timedelta(seconds=secs_to_add)).time()
>>> import datetime >>> import nptime >>> nptime.nptime(11, 34, 59) + datetime.timedelta(0, 3) nptime(11, 35, 2)
>>> from datetime import datetime, timedelta >>> t = datetime.now() + timedelta(seconds=3000) >>> print(t) datetime.datetime(2018, 1, 17, 21, 47, 13, 90244)
sometime = arrow.now() abitlater = sometime.shift(seconds=3)
try: do_something() except Exception: sys.exc_clear()
from contextlib import suppress with suppress(Exception):
def xyz(): -------- -------- def abc(): -------- --------
import my_example.py a = my_example.xyz() b = my_example.abc()
import os os.chdir("**Put here the directory where you have the file with your function**") from file import function os.chdir("**Put here the directory where you were working**")
import sys sys.path.append("**Put here the directory where you have the file with your function**") from file import function
def Add(a,b): return a+b def subtract(a,b): return a-b
line.replace("^.*interfaceOpDataFile.*$/i", "interfaceOpDataFile %s" % (fileIn))
import re line = re.sub( r"(?i)^.*interfaceOpDataFile.*$", "interfaceOpDataFile %s" % fileIn, line )
import re regex = re.compile(r"^.*interfaceOpDataFile.*$", re.IGNORECASE) for line in some_file: line = regex.sub("interfaceOpDataFile %s" % fileIn, line)
import re s = "Example String" replaced = re.sub( print replaced
import sys import re f = sys.argv[1] find = sys.argv[2] replace = sys.argv[3] with open (f, "r") as myfile: s=myfile.read() ret = re.sub(find,replace, s) print ret
re.sub(r"(?i)interfaceOpDataFile", "interfaceOpDataFile %s" % filein, line)
In [26]: df.ix[2] Out[26]: A 1.027680 B 1.514210 C -1.466963 D -0.162339 Name: 2000-01-03 00:00:00 In [27]: df[2:3] Out[27]: A B C D 2000-01-03 1.02768 1.51421 -1.466963 -0.162339
In [1]: df = pd.DataFrame(np.random.rand(5,2),index=range(0,10,2),columns=list( In [2]: df Out[2]: A B 0 1.068932 -0.794307 2 -0.470056 1.192211 4 -0.284561 0.756029 6 1.037563 -0.267820 8 -0.538478 -0.800654 In [5]: df.iloc[[2]] Out[5]: A B 4 -0.284561 0.756029 In [6]: df.loc[[2]] Out[6]: A B 2 -0.470056 1.192211
print df._slice(slice(0, 2)) print df._slice(slice(0, 2), 0) print df._slice(slice(0, 2), 1)
for ad in range(1,dataframe_c.size): print(dataframe_c.values[ad])
import ftplib import urllib2 import os import logging logger = logging.getLogger( hdlr = logging.FileHandler( formatter = logging.Formatter( hdlr.setFormatter(formatter) logger.addHandler(hdlr) logger.setLevel(logging.INFO) FTPADDR = "some ftp address" def upload_to_ftp(con, filepath): try: f = open(filepath, con.storbinary( f.close() logger.info( except, e: logger.error(
try: with open(filepath, con.storbinary( logger.info( except Exception, e: logger.error(
try: with open(filepath, con.storbinary( logger.info( except Exception as e: logger.error(
try: do_something() except BaseException as e: logger.error(
import logging logger = logging.Logger( def catchEverythingInLog(): try: ... do something ... except Exception as e: logger.error(e, exc_info=True) ... exception handling ...
import sys, traceback def catchEverything(): try: ... some operation(s) ... except: exc_type, exc_value, exc_traceback = sys.exc_info() ... exception handling ...
try: do_something() except BaseException, e: logger.error(
import sys import traceback try: ans = 1/0 except BaseException as ex: ex_type, ex_value, ex_traceback = sys.exc_info() trace_back = traceback.extract_tb(ex_traceback) stack_trace = list() for trace in trace_back: stack_trace.append("File : %s , Line : %d, Func.Name : %s, Message : %s" % (trace[0], trace[1], trace[2], trace[3])) print("Exception type : %s " % ex_type.__name__) print("Exception message : %s" %ex_value) print("Stack trace : %s" %stack_trace)
Exception type : ZeroDivisionError Exception message : division by zero Stack trace : [
try ... except Exception as e: logger.error(f"Failed to upload to ftp: {e}")
. ├── bin │ └── /the usual stuff/ ├── include │ └── /the usual stuff/ ├── lib │ └── python2.7 │ └── /the usual stuff/ ├── local │ └── /the usual stuff/ └── README.md 27 directories, 280 files
>>> import mymodule >>> mymodule.myfunc() Hello! >>> from mymodule import myfunc >>> myfunc() Hello! >>> from mymodule import * >>> myfunc() Hello!
>>> import mypackage >>> from mypackage import mymodule >>> mymodule.myfunc() Hello! >>> import mypackage.mymodule >>> mypackage.mymodule.myfunc() Hello! >>> from mypackage import mymodule >>> mymodule.myfunc() Hello! >>> from mypackage.mymodule import myfunc >>> myfunc() Hello! >>> from mypackage.mymodule import * >>> myfunc() Hello!
. └── hellostackoverflow/ ├── __init__.py └── hellostackoverflow.py
. ├── setup.py └── hellostackoverflow/ ├── __init__.py └── hellostackoverflow.py
from setuptools import setup setup( name= version= description= license= packages=[ author= author_email= keywords=[ url= )
. ├── LICENCE.txt ├── README.rst ├── setup.py └── hellostackoverflow/ ├── __init__.py └── hellostackoverflow.py
. ├── dist/ ├── hellostackoverflow.egg-info/ ├── LICENCE.txt ├── README.rst ├── setup.py └── hellostackoverflow/ ├── __init__.py └── hellostackoverflow.py
Python 3.5.2 (default, Sep 14 2017, 22:51:06) [GCC 5.4.0 20160609] on linux Type "help", "copyright", "credits" or "license" for more information. >>> from hellostackoverflow import hellostackoverflow >>> hellostackoverflow.greeting()
>>> import hello >>> hello.say("hi") hi >>> from hello import say >>> say("test") test
def manyArgs(*arg): print "I was called with", len(arg), "arguments:", arg >>> manyArgs(1) I was called with 1 arguments: (1,) >>> manyArgs(1, 2,3) I was called with 3 arguments: (1, 2, 3)
def myfunc(**kwargs): for k,v in kwargs.iteritems(): print "%s = %s" % (k, v) myfunc(abc=123, efh=456)
def myfunc2(*args, **kwargs): for a in args: print a for k,v in kwargs.iteritems(): print "%s = %s" % (k, v) myfunc2(1, 2, 3, banan=123)
def manyArgs1(args): print args.a, args.b def manyArgs2(args): print args.c class Args: pass args = Args() args.a = 1 args.b = 2 args.c = 3 manyArgs1(args) manyArgs2(args)
myfuns = [manyArgs1, manyArgs2] for fun in myfuns: fun(args)
def myfunc(**kwargs): for k,v in kwargs.items(): print("%s = %s" % (k, v)) myfunc(abc=123, efh=456)
def myfunc2(*args, **kwargs): for a in args: print(a) for k,v in kwargs.items(): print("%s = %s" % (k, v)) myfunc2(1, 2, 3, banan=123)
def f(dic): if print dic[ pass else: print if print dic[ pass else: print if print dic[ pass else: print print pass f({}) f({ f({ ____________
@execute_complete_reservation(True) def test_booking_gta_object(self): self.test_select_gta_object()
def execute_complete_reservation(test_case,insurance_mode): def inner_function(self,*args,**kwargs): self.test_create_qsf_query() test_case(self,*args,**kwargs) self.test_select_room_option() if insurance_mode: self.test_accept_insurance_crosseling() else: self.test_decline_insurance_crosseling() self.test_configure_pax_details() self.test_configure_payer_details return inner_function
def decorator(argument): def real_decorator(function): def wrapper(*args, **kwargs): funny_stuff() something_with_argument(argument) result = function(*args, **kwargs) more_funny_stuff() return result return wrapper return real_decorator
@decorator_with_args(arg) def foo(*args, **kwargs): pass
from functools import partial def _pseudo_decor(fun, argument): def ret_fun(*args, **kwargs): print ("decorator arg is %s" % str(argument)) return fun(*args, **kwargs) return ret_fun real_decorator = partial(_pseudo_decor, argument=arg) @real_decorator def foo(*args, **kwargs): pass
>>> print(foo) <function _pseudo_decor.<locals>.ret_fun at 0x10666a2f0>
from functools import partial, wraps def _pseudo_decor(fun, argument): @wraps(fun) def ret_fun(*args, **kwargs): print ("decorator arg is %s" % str(argument)) return fun(*args, **kwargs) return ret_fun real_decorator = partial(_pseudo_decor, argument=arg) @real_decorator def bar(*args, **kwargs): pass >>> print(bar) <function __main__.bar(*args, **kwargs)>
def parametrized(dec): def layer(*args, **kwargs): def repl(f): return dec(f, *args, **kwargs) return repl return layer
def double(f): def aux(*xs, **kws): return 2 * f(*xs, **kws) return aux @double def function(a): return 10 + a print function(3)
@parametrized def multiply(f, n): def aux(*xs, **kws): return n * f(*xs, **kws) return aux @multiply(2) def function(a): return 10 + a print function(3) @multiply(3) def function_again(a): return 10 + a print function(3) print function_again(3)
import itertools as it @parametrized def types(f, *types): def rep(*args): for a, t, n in zip(args, types, it.count()): if type(a) is not t: raise TypeError( (n, t, type(a)) ) return f(*args) return rep @types(str, int) def string_multiply(text, times): return text * times print(string_multiply( print(string_multiply(3, 3))
from functools import wraps def decorator(argument): def real_decorator(function): @wraps(function) def wrapper(*args, **kwargs): funny_stuff() something_with_argument(argument) retval = function(*args, **kwargs) more_funny_stuff() return retval return wrapper return real_decorator
class MyDec(object): def __init__(self,flag): self.flag = flag def __call__(self, original_func): decorator_self = self def wrappee( *args, **kwargs): print original_func(*args,**kwargs) print return wrappee @MyDec( def bar(a,b,c): print bar(
in decorator before wrapee with flag foo de fa fa in bar x y z in decorator after wrapee with flag foo de fa fa
def finished_message(function, message="Finished!"): def wrapper(*args, **kwargs): output = function(*args,**kwargs) print(message) return output return wrapper @finished_message def func(): pass my_finished_message = lambda f: finished_message(f, "All Done!") @my_finished_message def my_func(): pass if __name__ == func() my_func()
def decoratorize(FUN, **kw): def foo(*args, **kws): return FUN(*args, **kws, **kw) return foo
@decoratorize(FUN, arg1 = , arg2 = , ...) def bar(...): ...
def decorator(argument): def real_decorator(function): def wrapper(*args): for arg in args: assert type(arg)==int,f result = function(*args) result = result*argument return result return wrapper return real_decorator
@decorator(2) def adder(*args): sum=0 for i in args: sum+=i return sum
--------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-143-242a8feb1cc4> in <module> ----> 1 adder( <ipython-input-140-d3420c248ebd> in wrapper(*args) 3 def wrapper(*args): 4 for arg in args: ----> 5 assert type(arg)==int,f 6 result = function(*args) 7 result = result*argument AssertionError: hi is not an interger
>>> range(9,-1,-1) [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] >>> range(-2, 6, 2) [-2, 0, 2, 4]
$ python -m timeit "[9-i for i in range(10)]" 1000000 loops, best of 3: 1.54 usec per loop
$ python -m timeit "range(10)[::-1]" 1000000 loops, best of 3: 0.743 usec per loop
$ python -m timeit "reversed(range(10))" 1000000 loops, best of 3: 0.538 usec per loop
$ python -m timeit "range(9,-1,-1)" 1000000 loops, best of 3: 0.401 usec per loop
$ python -m timeit "reversed(range(1000000000))" 1000000 loops, best of 3: 0.598 usec per loop $ python -m timeit "range(1000000000)[::-1]" 1000000 loops, best of 3: 0.945 usec per loop
>>> range(10-1, -1, -1) [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] >>> range(10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> reversed(range(10)) <listreverseiterator object at 0x10e14e090> >>> list(reversed(range(10))) [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
for number in range ( 10 , 0 , -1 ) : print ( number )
def reverse(text): result = [] for index in range(len(text)-1,-1,-1): c = text[index] result.append(c) return print reverse("python!")
[9-i for i in range(10)] [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
import networkx as nx import matplotlib import matplotlib.pyplot import matplotlib.pyplot as plt G=nx.Graph() G.add_node(1) G.add_nodes_from([2,3,4,5,6,7,8,9,10]) nx.draw(G) plt.savefig("/var/www/node.png") Traceback (most recent call last): File "graph.py", line 13, in <module> nx.draw(G) File "/usr/lib/pymodules/python2.5/networkx/drawing/nx_pylab.py", line 124, in draw cf=pylab.gcf() File "/usr/lib/pymodules/python2.5/matplotlib/pyplot.py", line 276, in gcf return figure() File "/usr/lib/pymodules/python2.5/matplotlib/pyplot.py", line 254, in figure **kwargs) File "/usr/lib/pymodules/python2.5/matplotlib/backends/backend_tkagg.py", line 90, in new_figure_manager window = Tk.Tk() File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 1650, in __init__ self.tk = _tkinter.create(screenName, baseName, className, interactive, wantobjects, useTk, sync, use) _tkinter.TclError: no display name and no $DISPLAY environment variable
import networkx as nx import matplotlib import matplotlib.pyplot import matplotlib.pyplot as plt matplotlib.use( G=nx.Graph() G.add_node(1) G.add_nodes_from([2,3,4,5,6,7,8,9,10]) nx.draw(G) plt.savefig("/var/www/node.png")
/usr/lib/pymodules/python2.5/matplotlib/__init__.py:835: UserWarning: This call to matplotlib.use() has no effect because the the backend has already been chosen; matplotlib.use() must be called *before* pylab, matplotlib.pyplot, or matplotlib.backends is imported for the first time. if warn: warnings.warn(_use_error_msg) Traceback (most recent call last): File "graph.py", line 15, in <module> nx.draw(G) File "/usr/lib/python2.5/site-packages/networkx-1.2.dev-py2.5.egg/networkx/drawing/nx_pylab.py", line 124, in draw cf=pylab.gcf() File "/usr/lib/pymodules/python2.5/matplotlib/pyplot.py", line 276, in gcf return figure() File "/usr/lib/pymodules/python2.5/matplotlib/pyplot.py", line 254, in figure **kwargs) File "/usr/lib/pymodules/python2.5/matplotlib/backends/backend_tkagg.py", line 90, in new_figure_manager window = Tk.Tk() File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 1650, in __init__ self.tk = _tkinter.create(screenName, baseName, className, interactive, wantobjects, useTk, sync, use) _tkinter.TclError: no display name and no $DISPLAY environment variable
import networkx as nx import matplotlib import matplotlib.pyplot import matplotlib.pyplot as plt matplotlib.use( G=nx.Graph() G.add_node(1) G.add_nodes_from([2,3,4,5,6,7,8,9,10]) nx.draw(G) plt.savefig("/var/www/node.png")
/usr/lib/pymodules/python2.5/matplotlib/__init__.py:835: UserWarning: This call to matplotlib.use() has no effect because the the backend has already been chosen; matplotlib.use() must be called *before* pylab, matplotlib.pyplot, or matplotlib.backends is imported for the first time. if warn: warnings.warn(_use_error_msg) Traceback (most recent call last): File "graph.py", line 15, in <module> nx.draw(G) File "/usr/lib/python2.5/site-packages/networkx-1.2.dev-py2.5.egg/networkx/drawing/nx_pylab.py", line 124, in draw cf=pylab.gcf() File "/usr/lib/pymodules/python2.5/matplotlib/pyplot.py", line 276, in gcf return figure() File "/usr/lib/pymodules/python2.5/matplotlib/pyplot.py", line 254, in figure **kwargs) File "/usr/lib/pymodules/python2.5/matplotlib/backends/backend_tkagg.py", line 90, in new_figure_manager window = Tk.Tk() File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 1650, in __init__ self.tk = _tkinter.create(screenName, baseName, className, interactive, wantobjects, useTk, sync, use) _tkinter.TclError: no display name and no $DISPLAY environment variable
>>> import matplotlib>>> matplotlib.matplotlib_fname()
export MPLBACKEND="agg" python <program_using_matplotlib.py>
import matplotlib.pyplot as plt. plt.switch_backend(
import os import matplotlib as mpl if os.environ.get( print( mpl.use( import matplotlib.pyplot as plt
user@debian:~$ xauth list debian/unix:10 MIT-MAGIC-COOKIE-1 ae921efd0026c6fc9d62a8963acdcca0 root@debian:~ root@debian:~
import matplotlib as mpl mpl.use( from matplotlib.backends.backend_pdf import PdfPages
def multi_page(filename, figs=None, dpi=200): pp = PdfPages(filename) if figs is None: figs = [mpl.pyplot.figure(n) for n in mpl.pyplot.get_fignums()] for fig in figs: fig.savefig(pp, format= pp.close()
{ "glossary": { "title": "example glossary", "GlossDiv": { "title": "S", "GlossList": { "GlossEntry": { "ID": "SGML", "SortAs": "SGML", "GlossTerm": "Standard Generalized Markup Language", "Acronym": "SGML", "Abbrev": "ISO 8879:1986", "GlossDef": { "para": "A meta-markup language, used to create markup languages such as DocBook.", "GlossSeeAlso": ["GML", "XML"] }, "GlossSee": "markup" } } } } }
import json m = { n = json.dumps(m) o = json.loads(n) print o[
import simplejson as json json.loads(obj) or cjson.decode(obj)
>>> x = "{ >>> y = eval(x) >>> print x { >>> print y { >>> print type(x), type(y) <type >>> print y[ 1 <type >>> print y[ 1 <type >>> print y[ 1 <type
def long_running_func(p): c_func_no_gil(p) p = multiprocessing.Pool(4) xs = p.map(long_running_func, range(100))
executor = ThreadPoolExecutor(max_workers=10) a = executor.submit(my_function)
import multiprocessing def worker(lnk): .... def start_process(): ..... .... if(PROCESS): pool = multiprocessing.Pool(processes=POOL_SIZE, initializer=start_process) else: pool = multiprocessing.pool.ThreadPool(processes=POOL_SIZE, initializer=start_process) pool.map(worker, inputs) ....
from Queue import Queue from threading import Thread class Worker(Thread): def __init__(self, tasks): Thread.__init__(self) self.tasks = tasks self.daemon = True self.start() def run(self): while True: func, args, kargs = self.tasks.get() try: func(*args, **kargs) except Exception, e: print e finally: self.tasks.task_done() class ThreadPool: def __init__(self, num_threads): self.tasks = Queue(num_threads) for _ in range(num_threads): Worker(self.tasks) def add_task(self, func, *args, **kargs): self.tasks.put((func, args, kargs)) def wait_completion(self): self.tasks.join() if __name__ == from random import randrange from time import sleep delays = [randrange(1, 10) for i in range(100)] def wait_delay(d): print sleep(d) pool = ThreadPool(20) for i, d in enumerate(delays): pool.add_task(wait_delay, d) pool.wait_completion()
from multiprocessing.dummy import Pool as ThreadPool
pool = ThreadPool(threads) results = pool.map(service, tasks) pool.close() pool.join() return results
from threading import Thread from Queue import Queue def worker(): while True: item = q.get() do_work(item) q.task_done() q = Queue() for i in range(num_worker_threads): t = Thread(target=worker) t.daemon = True t.start() for item in source(): q.put(item) q.join()
from queue import Queue, Empty import threading from threading import Thread class Worker(Thread): _TIMEOUT = 2 def __init__(self, tasks, th_num): Thread.__init__(self) self.tasks = tasks self.daemon, self.th_num = True, th_num self.done = threading.Event() self.start() def run(self): while not self.done.is_set(): try: func, args, kwargs = self.tasks.get(block=True, timeout=self._TIMEOUT) try: func(*args, **kwargs) except Exception as e: print(e) finally: self.tasks.task_done() except Empty as e: pass return def signal_exit(self): self.done.set() class ThreadPool: def __init__(self, num_threads, tasks=[]): self.tasks = Queue(num_threads) self.workers = [] self.done = False self._init_workers(num_threads) for task in tasks: self.tasks.put(task) def _init_workers(self, num_threads): for i in range(num_threads): self.workers.append(Worker(self.tasks, i)) def add_task(self, func, *args, **kwargs): self.tasks.put((func, args, kwargs)) def _close_all_threads(self): for workr in self.workers: workr.signal_exit() self.workers = [] def wait_completion(self): self.tasks.join() def __del__(self): self._close_all_threads() def create_task(func, *args, **kwargs): return (func, args, kwargs)
from random import randrange from time import sleep delays = [randrange(1, 10) for i in range(30)] def wait_delay(d): print( sleep(d) pool = ThreadPool(20) for i, d in enumerate(delays): pool.add_task(wait_delay, d) pool.wait_completion()
from __future__ import with_statement with open("out.txt","wt"), open("in.txt") as file_out, file_in: for line in file_in: file_out.write(line)
with A() as a, B() as b, C() as c: doSomething(a,b,c)
import contextlib with contextlib.nested(open("out.txt","wt"), open("in.txt")) as (file_out, file_in): ...
from __future__ import with_statement with open("out.txt","wt") as file_out: with open("in.txt") as file_in: for line in file_in: file_out.write(line)
with A() as a, \ B() as b, \ C() as c: doSomething(a,b,c)
with (A() as a, B() as b, C() as c): doSomething(a,b,c)
with ExitStack() as stack: files = [stack.enter_context(open(fname)) for fname in filenames]
from contextlib import ExitStack class X: num = 1 def __init__(self): self.num = X.num X.num += 1 def __repr__(self): cls = type(self) return def __enter__(self): print( return self.num def __exit__(self, exc_type, exc_value, traceback): print( return True xs = [X() for _ in range(3)] with ExitStack() as stack: print(stack._exit_callbacks) nums = [stack.enter_context(x) for x in xs] print(stack._exit_callbacks) print(stack._exit_callbacks) print(nums)
deque([]) enter X1 enter X2 enter X3 deque([<function ExitStack._push_cm_exit.<locals>._exit_wrapper at 0x7f5c95f86158>, <function ExitStack._push_cm_exit.<locals>._exit_wrapper at 0x7f5c95f861e0>, <function ExitStack._push_cm_exit.<locals>._exit_wrapper at 0x7f5c95f86268>]) exit X3 exit X2 exit X1 deque([]) [1, 2, 3]
>>> s = list("Hello zorld") >>> s [ >>> s[6] = >>> s [ >>> "".join(s)
s = "abcdefg" b_s = bytearray(s) b_s[1] = "Z" s = str(b_s) print s aZcdefg
oldStr = newStr = for i in oldStr: if newStr += chr(ord(i)-32) else: newStr += i print(newStr)
word = "Heloo World!" word = word.replace(word[3], "l", 1) print word
[ {"name": "Tom", "age": 10}, {"name": "Mark", "age": 5}, {"name": "Pam", "age": 7} ]
>>> dicts = [ ... { "name": "Tom", "age": 10 }, ... { "name": "Mark", "age": 5 }, ... { "name": "Pam", "age": 7 }, ... { "name": "Dick", "age": 12 } ... ] >>> next(item for item in dicts if item["name"] == "Pam") {
>>> dicts = [ { "name": "Tom", "age": 10 }, { "name": "Mark", "age": 5 }, { "name": "Pam", "age": 7 }, { "name": "Dick", "age": 12 } ] >>> next(item for item in dicts if item["name"] == "Pam") {
>>> next((item for item in dicts if item["name"] == "Pam"), False) { >>> next((item for item in dicts if item["name"] == "Sam"), False) False >>>
def search(name, people): return [element for element in people if element[
people = [ { { { ] def search(name): for p in people: if p[ return p search("Pam")
from random import randint from timeit import timeit list_dicts = [] for _ in range(1000): dict_tmp = {} for i in range(10): dict_tmp[f"key{i}"] = randint(0,50) list_dicts.append( dict_tmp ) def a(): for dict_ in list_dicts: if dict_["key3"] == 20: pass def b(): for dict_ in (x for x in list_dicts if x["key3"] == 20): pass def c(): for dict_ in [x for x in list_dicts if x["key3"] == 20]: pass def d(): for dict_ in filter(lambda x: x[ pass
next((item for item in dicts if item.get("name") and item["name"] == "Pam"), None)
import pandas as pd listOfDicts = [ {"name": "Tom", "age": 10}, {"name": "Mark", "age": 5}, {"name": "Pam", "age": 7} ] df = pd.DataFrame(listOfDicts) df2 = df[ (df[ df2 = df[ (df.name ==
setup_large = [dicts.extend(({ "name": "Tom", "age": 10 },{ "name": "Mark", "age": 5 },\ { "name": "Pam", "age": 7 },{ "name": "Dick", "age": 12 })) for _ in range(25000)];\ from operator import itemgetter;import pandas as pd;\ df = pd.DataFrame(dicts);' setup_small = dicts.extend(({ "name": "Tom", "age": 10 },{ "name": "Mark", "age": 5 },\ { "name": "Pam", "age": 7 },{ "name": "Dick", "age": 12 }));\ from operator import itemgetter;import pandas as pd;\ df = pd.DataFrame(dicts);' method1 = method2 = import timeit t = timeit.Timer(method1, setup_small) print( t = timeit.Timer(method2, setup_small) print( t = timeit.Timer(method1, setup_large) print( t = timeit.Timer(method2, setup_large) print(
def search_dictionaries(key, value, list_of_dictionaries): return [element for element in list_of_dictionaries if element[key] == value]
names = [{ resultlist = [d for d in names if d.get( first_result = resultlist[0]
def get_records(key, store=dict()): assert key is not None return [d for d in store if d[
dicts=[ {"name": "Tom", "age": 10}, {"name": "Mark", "age": 5}, {"name": "Pam", "age": 7} ] from collections import defaultdict dicts_by_name=defaultdict(list) for d in dicts: dicts_by_name[d[ print dicts_by_name[
import time list_of_dicts = list() for i in range(100000): list_of_dicts.append({ dict_of_dicts = dict() for i in range(100000): dict_of_dicts[i] = { lod_ts = time.time() for elem in list_of_dicts: if elem[ break lod_tf = time.time() lod_td = lod_tf - lod_ts f_ts = time.time() x = filter(lambda k: k[ f_tf = time.time() f_td = f_tf- f_ts dod_ts = time.time() x = dict_of_dicts[99999] dod_tf = time.time() dod_td = dod_tf - dod_ts print print print
List of Dictionries took: 0.0099310874939 Using filter took: 0.0121960639954 Dict of Dicts took: 4.05311584473e-06
def find_dict_in_list(dicts, default=None, **kwargs): rval = default for d in dicts: is_found = False for k, v in kwargs.items(): if d.get(k, None) == v: is_found = True else: is_found = False break if is_found: rval = d break return rval if __name__ == dicts = [] keys = start = 0 for _ in range(4): dct = {k: v for k, v in zip(keys, range(start, start+4))} dicts.append(dct) start += 4 for x in range(len(dicts)): spam = x*4 assert find_dict_in_list(dicts, spam=spam) == dicts[x] for x in range(len(dicts)): spam = x*4 assert find_dict_in_list(dicts, spam=spam, shrubbery=spam+2) == dicts[x] for x in range(len(dicts)): spam = x*4 assert find_dict_in_list(dicts, spam=spam, shrubbery=spam+1) is None for x in range(len(dicts)): spam = x+100 assert find_dict_in_list(dicts, spam=spam) is None
lst = [{"name": "Tom", "age": 10}, {"name": "Mark", "age": 5}, {"name": "Pam", "age": 7}] search = raw_input("What name: ") print [ lst[i] for i in range(len(lst)) if(lst[i]["name"]==search) ][0] >>> {
string = for i in range(11): string +=`i` print string
>>> string = "string" >>> [string+`i` for i in range(11)]
string = for i in range(11): string +=str(i) print string
>>> string = "string" >>> [string+str(i) for i in range(11)]
def sequence_generator(limit): inc = 0 while inc < limit: yield inc += 1 a_generator = (s for s in sequence_generator(10)) a_list = [s for s in sequence_generator(10)] a_string =
myoldlist_1=[[ No_ofposition=[] mynewlist_2=[] for i in xrange(0,4,1): mynewlist_2.append([x.replace( if len(mynewlist_2[i])>0: No_ofposition.append(i) mynewlist_2 No_ofposition
def my_func1(): print "Hello World" return None def my_func2(): print "Hello World" return def my_func3(): print "Hello World"
def get_mother(person): if is_human(person): return person.mother else: return None
def find_prisoner_with_knife(prisoners): for prisoner in prisoners: if "knife" in prisoner.items: prisoner.move_to_inquisition() return raise_alert()
def set_mother(person, mother): if is_human(person): person.mother = mother
import dis def f1(): print "Hello World" return None def f2(): print "Hello World" return def f3(): print "Hello World" dis.dis(f1) 4 0 LOAD_CONST 1 ( 3 PRINT_ITEM 4 PRINT_NEWLINE 5 5 LOAD_CONST 0 (None) 8 RETURN_VALUE dis.dis(f2) 9 0 LOAD_CONST 1 ( 3 PRINT_ITEM 4 PRINT_NEWLINE 10 5 LOAD_CONST 0 (None) 8 RETURN_VALUE dis.dis(f3) 14 0 LOAD_CONST 1 ( 3 PRINT_ITEM 4 PRINT_NEWLINE 5 LOAD_CONST 0 (None) 8 RETURN_VALUE
img = urllib2.urlopen(settings.STATICMAP_URL.format(**data)) with open(path, f.write(img.read())
r = requests.get(settings.STATICMAP_URL.format(**data)) if r.status_code == 200: img = r.raw.read() with open(path, f.write(img)
import requests import shutil r = requests.get(settings.STATICMAP_URL.format(**data), stream=True) if r.status_code == 200: with open(path, r.raw.decode_content = True shutil.copyfileobj(r.raw, f)
r = requests.get(settings.STATICMAP_URL.format(**data), stream=True) if r.status_code == 200: with open(path, for chunk in r: f.write(chunk)
r = requests.get(settings.STATICMAP_URL.format(**data), stream=True) if r.status_code == 200: with open(path, for chunk in r.iter_content(1024): f.write(chunk)
import shutil import requests url = response = requests.get(url, stream=True) with open( shutil.copyfileobj(response.raw, out_file) del response
import requests url = "http: response = requests.get(url) if response.status_code == 200: with open("/Users/apple/Desktop/sample.jpg", f.write(response.content)
import requests from PIL import Image from StringIO import StringIO r = requests.get( i = Image.open(StringIO(r.content))
import requests from StringIO import StringIO from PIL import Image import profile def testRequest(): image_name = url = r = requests.get(url, stream=True) with open(image_name, for chunk in r.iter_content(): f.write(chunk) def testRequest2(): image_name = url = r = requests.get(url) i = Image.open(StringIO(r.content)) i.save(image_name) if __name__ == profile.run( profile.run( profile.run(
343080 function calls (343068 primitive calls) in 2.580 seconds
3129 function calls (3105 primitive calls) in 0.024 seconds
>>> import wget >>> url = >>> filename = wget.download(url) 100% [................................................] 3841532 / 3841532> >> filename
>>> out_filepath = <output_filepath> >>> filename = wget.download(url, out=out_filepath)
import requests url = "http: filename = url.split("/")[-1] r = requests.get(url, timeout=0.5) if r.status_code == 200: with open(filename, f.write(r.content)
import io import requests r = requests.get( r.raise_for_status() with io.BytesIO(r.content) as f: with Image.open(f) as img: img.show()
import requests r = requests.get( r.raise_for_status() r.raw.decode_content = True with PIL.Image.open(r.raw) as img: img.show() r.close()
import requests from StringIO import StringIO from PIL import Image def createFilename(url, name, folder): dotSplit = url.split( if name == None: slashSplit = dotSplit[-2].split( name = slashSplit[-1] ext = dotSplit[-1] file = return file def getImage(url, name=None, folder= file = createFilename(url, name, folder) with open(file, r = requests.get(url, stream=True) for block in r.iter_content(1024): if not block: break f.write(block) def getImageFast(url, name=None, folder= file = createFilename(url, name, folder) r = requests.get(url) i = Image.open(StringIO(r.content)) i.save(file) if __name__ == getImage( getImageFast(
from PIL import Image import requests img = Image.open(requests.get(url, stream = True).raw) img.save(
import requests import shutil r = requests.get(settings.STATICMAP_URL.format(**data), stream=True) if r.status_code == 200: with open(path, r.raw.decode_content = True shutil.copyfileobj(r.raw, f)
Downloading/unpacking elasticutils==0.7.dev (from -r requirements.txt (line 20)) Could not find a version that satisfies the requirement elasticutils==0.7.dev (from -r requirements.txt (line 20)) (from versions: ) No distributions matching the version for elasticutils==0.7.dev (from -r requirements.txt (line 20))
package-one==1.9.4 package-two==3.7.1 package-three==1.0.1 ...
[-e] git+git: [-e] git+https: [-e] git+ssh: -e git+git@git.myproject.org:SomeProject
pip uninstall brabeion pip install -r requirements.txt
cool.app.run( host=cool.app.config.get("HOST", "localhost"), port=cool.app.config.get("PORT", 9000) )
import sys if "C:\\My_Python_Lib" not in sys.path: sys.path.append("C:\\My_Python_Lib")
%PY_HOME%\Lib;%PY_HOME%\DLLs;%PY_HOME%\Lib\lib-tk;C:\another-library
import sys sys.path.append("path/to/Modules") print sys.path
a = [1, 2, 3, 4, 5] b = [9, 8, 7, 6, 5] returnMatches(a, b)
>>> a = [1, 2, 3, 4, 5] >>> b = [9, 8, 7, 6, 5] >>> set(a) & set(b) {5}
import time def speed_test(func): def wrapper(*args, **kwargs): t1 = time.time() for x in xrange(5000): results = func(*args, **kwargs) t2 = time.time() print return results return wrapper @speed_test def compare_bitwise(x, y): set_x = frozenset(x) set_y = frozenset(y) return set_x & set_y @speed_test def compare_listcomp(x, y): return [i for i, j in zip(x, y) if i == j] @speed_test def compare_intersect(x, y): return frozenset(x).intersection(y) a = [1, 2, 3, 4, 5] b = [9, 8, 7, 6, 5] compare_bitwise(a, b) compare_listcomp(a, b) compare_intersect(a, b) import random a = random.sample(xrange(100000), 10000) b = random.sample(xrange(100000), 10000) compare_bitwise(a, b) compare_listcomp(a, b) compare_intersect(a, b)
compare_bitwise took 10.145 ms compare_listcomp took 11.157 ms compare_intersect took 7.461 ms compare_bitwise took 11203.709 ms compare_listcomp took 17361.736 ms compare_intersect took 6833.768 ms
>>> a = [1, 2, 3, 4, 5] >>> b = [9, 8, 7, 6, 5] >>> set(a) & set(b) set([5])
>>> s = [ >>> f = [ >>> ss= set(s) >>> fs =set(f) >>> print ss.intersection(fs) **set([ >>> print ss.union(fs) **set([ >>> print ss.union(fs) - ss.intersection(fs) **set([
new_list = [] for element in a: if element in b: new_list.append(element)
>>> set([1, 2, 3, 4, 5]).intersection(set([9, 8, 7, 6, 5])) set([5])
>>> common_elements=[] >>> for i in list(itertools.product(a,b)): ... if i[0] == i[1]: ... common_elements.append(i[0])
def returnMatches(a,b): return list(set(a) & set(b))
a = [1, 3, 4, 5, 9, 6, 7, 8] b = [1, 7, 0, 9] same_values = set(a) & set(b) print same_values
a = [1, 2, 3, 4, 5] b = [9, 8, 7, 6, 5] lista =set(a) listb =set(b) print listb.intersection(lista) returnMatches = set([ print " ".join(str(return) for return in returnMatches ) 5
>>> a = [1, 2, 3, 4, 5] >>> b = [9, 8, 7, 6, 5] >>> set(b) == set(a) & set(b) and set(a) == set(a) & set(b) False >>> a = [3,1,2] >>> b = [1,2,3] >>> set(b) == set(a) & set(b) and set(a) == set(a) & set(b) True
import numpy as np def getMatches(a, b): matches = [] unique_a = np.unique(a) unique_b = np.unique(b) for a in unique_a: for b in unique_b: if a == b: matches.append(a) return matches print(getMatches([1, 2, 3, 4, 5], [9, 8, 7, 6, 5, 9])) print(getMatches([1, 2, 3], [3, 4, 5, 1]))
>>> a = [1, 2, 3, 4, 5] >>> b = [9, 8, 7, 6, 5] >>> set(a).__and__(set(b)) set([5])
>>> set([1, 2, 3, 4, 5]).__and__(set([9, 8, 7, 6, 5])) set([5]) >>>
you can | for set union and & for set intersection. for example: set1={1,2,3} set2={3,4,5} print(set1&set2) output=3 set1={1,2,3} set2={3,4,5} print(set1|set2) output=1,2,3,4,5 curly braces in the answer.
group1 = [1, 2, 3, 4, 5] group2 = [9, 8, 7, 6, 5] for k in group1: for v in group2: if k == v: print(k)
@app.route( @app.route( def data(): query_string=?????? return render_template("data.html")
from flask import request @app.route( def data(): user = request.args.get(
from flask import request @app.route( def adhoc_test(): return request.query_string
from my_script import get_url_params @app.route( def get_url_params_index(): return Response(get_url_params())
from flask import request def get_url_params(): firstName = request.args.get( return firstName
from flask import request @app.route( @app.route( def data(): query_string = request.query_string return render_template("data.html")
import os try: user_paths = os.environ[ except KeyError: user_paths = []
$ export PYTHONPATH=$HOME/Documents/DjangoTutorial/mysite
>>> os.environ[ >>> True >>> sys.path [ >>> sys.path.insert(0,os.environ[ >>> sys.path [ >>>
>>> globals()[ <module >>> locals()[ <module >>> globals()[ Traceback (most recent call last): File "<stdin>", line 1, in <module> KeyError: >>>
>>> path Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name >>>
>>> del locals()[ >>> os Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name >>> os.path Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name >>>
>>> globals()[ <module >>> locals()[ <module >>> globals()[ Traceback (most recent call last): File "<stdin>", line 1, in <module> KeyError: >>>
>>> path <module >>> os.path Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name >>>
>>> del locals()[ >>> path Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name >>>
>>> from os import path as HELL_BOY >>> locals()[ <module >>> globals()[ <module >>>
>>> globals()[ Traceback (most recent call last): File "<stdin>", line 1, in <module> KeyError: >>>
from package.subpackage.subsubpackage import module
from package1.subpackage import module from package2.subpackage import module
import package1.package2.package import package1.package2.module
from package1.package2 import package from package1.package2 import module
a = big_package_name.subpackage.even_longer_subpackage_name.function
class Volume(models.Model): id = models.AutoField(primary_key=True) journal_id = models.ForeignKey(Journals, db_column= volume_number = models.CharField( comments = models.TextField(
class MyModel(models.Model): field1 = models.CharField(max_length=50) field2 = models.CharField(max_length=50) class Meta: unique_together = (
class Volume(models.Model): id = models.AutoField(primary_key=True) journal_id = models.ForeignKey(Journals, db_column= volume_number = models.CharField( comments = models.TextField( class Meta: unique_together = (
>>> from datetime import datetime, timedelta >>> past = datetime.now() - timedelta(days=1) >>> present = datetime.now() >>> past < present True >>> datetime(3000, 1, 1) < present False >>> present - datetime(2000, 4, 4) datetime.timedelta(4242, 75703, 762105)
$ python -c "import os; print(os.environ[ /usr/bin/python
kuvivek@HOSTNAME ~ $ which python /usr/bin/python kuvivek@HOSTNAME ~ $ whereis python python: /usr/bin/python /usr/bin/python3.4 /usr/lib/python2.7 /usr/lib/python3.4 /usr/include/python2.7 /usr/include/python3.4m /usr/share/man/man1/python.1.gz kuvivek@HOSTNAME ~ $ which python3 /usr/bin/python3 kuvivek@HOSTNAME ~ $ command -v python /usr/bin/python kuvivek@HOSTNAME ~ $ type python python is hashed (/usr/bin/python)
>>> >>> import os >>> os.popen( >>> >>> os.popen( >>> >>> os.popen( >>> >>>
import numpy as np a=np.mat( b=np.mat( print(a) print(b) print(a*b)
import numpy as np a=np.array([[4, 3], [2, 1]]) b=np.array([[1, 2], [3, 4]]) print(a@b)
c=np.array([[4, 3], [2, 1]]) d=np.array([[1, 2], [3, 4]]) print(c*d)
>>> m = np.mat([[1,2],[2,3]]) >>> m matrix([[1, 2], [2, 3]]) >>> mm = m.mean(1) >>> mm matrix([[ 1.5], [ 2.5]]) >>> mm.shape (2, 1) >>> m - mm matrix([[-0.5, 0.5], [-0.5, 0.5]])
>>> a = np.array([[1,2],[2,3]]) >>> a array([[1, 2], [2, 3]]) >>> am = a.mean(1) >>> am.shape (2,) >>> am array([ 1.5, 2.5]) >>> a - am array([[-0.5, -0.5], [ 0.5, 0.5]]) >>> a - am[:, np.newaxis] array([[-0.5, 0.5], [-0.5, 0.5]])
A = numpy.ones((1, 3)) B = numpy.ones((3, 3)) A @ B
averages = [(x + y) / 2.0 for (x, y) in zip(my_list[:-1], my_list[1:])]
>>> a = range(10) >>> sum(a) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: >>> del sum >>> sum(a) 45
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] sm = sum(a[0:len(a)]) print(sm) print sm
>>> new_seq = [(2*k-1)/2. for k in nat_seq[1:]] >>> print new_seq [1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5]
l =[1,2,3,4,5] sum=0 for element in l: sum+=element print sum
def ave(x,y): return (x + y) / 2.0 map(ave, a[:-1], a[1:])
>>> a = range(10) >>> map(ave, a[:-1], a[1:]) [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5]
>>> import itertools >>> itertools.imap(ave, a, a[1:]) <itertools.imap object at 0x1005c3990> >>> list(_) [0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5]
import numpy as np x = [1,2,3,4,5] [(np.mean((x[i],x[i+1]))) for i in range(len(x)-1)]
from __future__ import division def averages( lst ): it = iter(lst) first = next(it) for item in it: yield (first+item)/2 first = item print list(averages(range(1,11)))
import itertools def pairwise(iterable): "s -> (s0,s1), (s1,s2), (s2, s3), ..." a, b = itertools.tee(iterable) next(b, None) return itertools.izip(a, b) def pair_averages(seq): return ( (a+b)/2 for a, b in pairwise(seq) )
a = [1,2,3,4,5,6,7,8,9,10] b = map(lambda x, y: (x+y)/2.0, fib[:-1], fib[1:]) print b
i = 0 while i < len(a)-1: result = (a[i]+a[i+1])/2 print result i +=1
def sum(a): total = 0 index = 0 while index < len(a): total = total + a[index] index = index + 1 return total
new_list = [(old_list[i] + old_list[i+1])/2 for i in range(len(old_list-1))]
from itertools import tee, izip def average(iterable): "s -> (s0,s1)/2.0, (s1,s2)/2.0, ..." a, b = tee(iterable) next(b, None) return ((x+y)/2.0 for x, y in izip(a, b))
>>>list(average([1,2,3,4,5])) [1.5, 2.5, 3.5, 4.5] >>>list(average([1,20,31,45,56,0,0])) [10.5, 25.5, 38.0, 50.5, 28.0, 0.0] >>>list(average(average([1,2,3,4,5]))) [2.0, 3.0, 4.0]
mylist=[1,2,3,4] total=0 def add(mylist): for i in mylist: total+=i return total result=add(mylist) print("sum = ",result)
n = int(input("Enter the length of array: ")) list1 = [] for i in range(n): list1.append(int(input("Enter numbers: "))) print("User inputs are", list1) list2 = [] for j in range(0, n-1): list2.append((list1[j]+list1[j+1])/2) print("result = ", list2)
numList = [1,2,3,4,5,6,7] target = 10 from itertools import permutations good_permutations = [] for p in permutations(numList, 3): if sum(p) == target: good_permutations.append(p) print(good_permutations)
[(1, 2, 7), (1, 3, 6), (1, 4, 5), (1, 5, 4), (1, 6, 3), (1, 7, 2), (2, 1, 7), (2, 3, 5), (2, 5, 3), (2, 7, 1), (3, 1, 6), (3, 2, 5), (3, 5, 2), (3, 6, 1), (4, 1, 5), (4, 5, 1), (5, 1, 4), (5, 2, 3), (5, 3, 2), (5, 4, 1), (6, 1, 3), (6, 3, 1), (7, 1, 2), (7, 2, 1)]
>>> import timeit >>> timeit.timeit("562949953420000.7 < 562949953421000") 0.5387085462592742
>>> timeit.timeit("562949953420000.7 < 562949953422000") 0.1481498428446173 >>> timeit.timeit("562949953423001.8 < 562949953421000") 0.1459577925548956
>>> import math >>> math.frexp(562949953420000.7) (0.9999999999976706, 49) >>> (562949953421000).bit_length() 49
~ $ ptipython Python 3.5.1 |Anaconda 4.0.0 (64-bit)| (default, Dec 7 2015, 11:16:01) Type "copyright", "credits" or "license" for more information. IPython 4.1.2 -- An enhanced Interactive Python. ? -> Introduction and overview of IPython %quickref -> Quick reference. help -> Python object? -> Details about In [1]: import gmpy2 In [2]: from gmpy2 import mpfr In [3]: from gmpy2 import mpz In [4]: gmpy2.get_context().precision=200 In [5]: i1=562949953421000 In [6]: i2=562949953422000 In [7]: f=562949953420000.7 In [8]: i11=mpz( In [9]: i12=mpz( In [10]: f1=mpfr( In [11]: f<i1 Out[11]: True In [12]: f<i2 Out[12]: True In [13]: f1<i11 Out[13]: True In [14]: f1<i12 Out[14]: True In [15]: %timeit f<i1 The slowest run took 10.15 times longer than the fastest. This could mean that an intermediate result is being cached. 1000000 loops, best of 3: 441 ns per loop In [16]: %timeit f<i2 The slowest run took 12.55 times longer than the fastest. This could mean that an intermediate result is being cached. 10000000 loops, best of 3: 152 ns per loop In [17]: %timeit f1<i11 The slowest run took 32.04 times longer than the fastest. This could mean that an intermediate result is being cached. 1000000 loops, best of 3: 269 ns per loop In [18]: %timeit f1<i12 The slowest run took 36.81 times longer than the fastest. This could mean that an intermediate result is being cached. 1000000 loops, best of 3: 231 ns per loop In [19]: %timeit f<i11 The slowest run took 78.26 times longer than the fastest. This could mean that an intermediate result is being cached. 10000000 loops, best of 3: 156 ns per loop In [20]: %timeit f<i12 The slowest run took 21.24 times longer than the fastest. This could mean that an intermediate result is being cached. 10000000 loops, best of 3: 194 ns per loop In [21]: %timeit f1<i1 The slowest run took 37.61 times longer than the fastest. This could mean that an intermediate result is being cached. 1000000 loops, best of 3: 275 ns per loop In [22]: %timeit f1<i2 The slowest run took 39.03 times longer than the fastest. This could mean that an intermediate result is being cached. 1000000 loops, best of 3: 259 ns per loop
>>> line = >>> n = 2 >>> [line[i:i+n] for i in range(0, len(line), n)] [
def split_by_n( seq, n ): while seq: yield seq[:n] seq = seq[n:] print list(split_by_n("1234567890",2))
>>> from textwrap import wrap >>> s = >>> wrap(s, 2) [
>>> help(wrap) Help on function wrap in module textwrap: wrap(text, width=70, **kwargs) Wrap a single paragraph of text, returning a list of wrapped lines. Reformat the single paragraph in more than default, tabs in all other whitespace characters (including newline) are converted to space. See TextWrapper class for available keyword args to customize wrapping behaviour.
split_string = lambda x, n: [x[i:i+n] for i in range(0, len(x), n)] s = split_string(s,2) [
>>> from more_itertools import sliced >>> list(sliced( [
def grouper(iterable, n, fillvalue=None): "Collect data into fixed-length chunks or blocks" args = [iter(iterable)] * n return izip_longest(fillvalue=fillvalue, *args)
def split_every(n, s): return [ s[i:i+n] for i in xrange(0, len(s), n) ] print split_every(2, "1234567890")
s= print([s[idx:idx+2] for idx,val in enumerate(s) if idx%2 == 0])
>>> from functools import reduce >>> from operator import add >>> from itertools import izip >>> x = iter( >>> [reduce(add, tup) for tup in izip(x, x)] [ >>> x = iter( >>> [reduce(add, tup) for tup in izip(x, x, x)] [
from itertools import islice def split_every(n, iterable): i = iter(iterable) piece = list(islice(i, n)) while piece: yield piece piece = list(islice(i, n)) s = print list(split_every(2, list(s)))
n = 2 line = "this is a line split into n characters" line = [line[i * n:i * n+n] for i,blah in enumerate(line[::n])]
def split_string(n, st): lst = [""] for i in str(st): l = len(lst) - 1 if len(lst[l]) < n: lst[l] += i else: lst += [i] return lst print(split_string(3, "test_string."))
def split(s, n): new_list = [] for i in range(0, len(s), n): new_list.append(s[i:i+n]) return new_list print(split(
def split(s, chunk_size): a = zip(*[s[i::chunk_size] for i in range(chunk_size)]) return [ print(split( print(split( print(split(
s = "1234567890" ["".join(c) for c in mit.grouper(2, s)] ["".join(c) for c in mit.chunked(s, 2)] ["".join(c) for c in mit.windowed(s, 2, step=2)] ["".join(c) for c in mit.split_after(s, lambda x: int(x) % 2 == 0)]
def split_every_n(S, n): return [S[i*n:(i+1)*n] for i in range(len(S) / n)]
def split(s, n): if len(s) < n: return [] else: return [s[:n]] + split(s[n:], n) print(split(
def split(s, n): if len(s) < n: return [] elif len(s) == n: return [s] else: return split(s[:n], n) + split(s[n:], n)
def fieldsplit(data=None, fieldsize=()): tmpl=[]; for pp in fieldsize: if(pp>0): tmpl.append(line[:pp]); line=line[pp:]; else: tmpl.append(line); break; return tuple(tmpl);
timestamp = [ "2010-04-20 10:07:30", "2010-04-20 10:07:38", "2010-04-20 10:07:52", "2010-04-20 10:08:22", "2010-04-20 10:08:22", "2010-04-20 10:09:46", "2010-04-20 10:10:37", "2010-04-20 10:10:58", "2010-04-20 10:11:50", "2010-04-20 10:12:13", "2010-04-20 10:12:13", "2010-04-20 10:25:38" ]
def foo(x): return time.strptime(x, timestamp.sort(key=foo, reverse=True)
import csv with open( data = list(csv.reader(f)) import collections counter = collections.defaultdict(int) for row in data: counter[row[10]] += 1 with open( writer = csv.writer(outfile) for row in data: if counter[row[10]] >= 504: writer.writerow(row)
with open( writer = csv.writer(outfile) with open( writer = csv.writer(outfile)
>>> import csv >>> spamWriter = csv.writer(open( >>> spamWriter.writerow([ >>> spamWriter.writerow([
with codecs.open( csv_file, mode= csv_out_file = csv.DictWriter(out_csv)
def writePhoneSpecsToCSV(): rowData=["field1", "field2"] with open( writer = csv.writer(csv_file) writer.writerow(rowData)
$ sudo pip3 install python3-tk Traceback (most recent call last): File "/usr/bin/pip3", line 9, in <module> load_entry_point( File "/usr/lib/python3/dist-packages/pkg_resources.py", line 356, in load_entry_point return get_distribution(dist).load_entry_point(group, name) File "/usr/lib/python3/dist-packages/pkg_resources.py", line 2476, in load_entry_point return ep.load() File "/usr/lib/python3/dist-packages/pkg_resources.py", line 2190, in load [ File "/usr/lib/python3/dist-packages/pip/__init__.py", line 61, in <module> from pip.vcs import git, mercurial, subversion, bazaar File "/usr/lib/python3/dist-packages/pip/vcs/mercurial.py", line 9, in <module> from pip.download import path_to_url File "/usr/lib/python3/dist-packages/pip/download.py", line 25, in <module> from requests.compat import IncompleteRead ImportError: cannot import name
$ sudo apt-get purge python-requests [now requests and pip gets deinstalled] $ sudo apt-get install python-requests python-pip
sudo apt-get purge python-virtualenv sudo pip install pip -U
sudo pip uninstall requests sudo pip uninstall urllib3 sudo yum remove python-urllib3 sudo yum remove python-requests
sudo yum install python-urllib3 sudo yum install python-requests
import datetime epoch = datetime.datetime.utcfromtimestamp(0) def unix_time_millis(dt): return (dt - epoch).total_seconds() * 1000.0
>>> import datetime >>> >>> int(datetime.datetime.now().strftime("%s")) * 1000 1312908481000
>>> import datetime, time >>> >>> time.mktime(datetime.datetime.now().timetuple()) * 1000 1312908681000.0
import datetime import delorean dt = datetime.datetime.utcnow() delorean.Delorean(dt, timezone="UTC").epoch
from datetime import datetime from time import mktime dt = datetime.now() sec_since_epoch = mktime(dt.timetuple()) + dt.microsecond/1000000.0 millis_since_epoch = sec_since_epoch * 1000
from datetime import datetime from calendar import timegm def unix_time(dttm=None): if dttm is None: dttm = datetime.utcnow() return timegm(dttm.utctimetuple()) print "Unix time now: %d" % unix_time() print "Unix timestamp from an existing dttm: %d" % unix_time(datetime(2014, 12, 30, 12, 0))
>>> import datetime >>> import time >>> import calendar >>> >>> now = datetime.datetime.now() >>> now datetime.datetime(2013, 3, 19, 13, 0, 9, 351812) >>> >>> tt = datetime.datetime.timetuple(now) >>> tt time.struct_time(tm_year=2013, tm_mon=3, tm_mday=19, tm_hour=13, tm_min=0, tm_sec=9, tm_wday=1, tm_yday=78, tm_isdst=-1) >>> >>> sec_epoch_utc = calendar.timegm(tt) * 1000 >>> sec_epoch_utc 1363698009 >>> >>> sec_epoch_loc = time.mktime(tt) * 1000 >>> sec_epoch_loc 1363678209.0
def to_unix_time(timestamp): epoch = datetime.datetime.utcfromtimestamp(0) my_time = datetime.datetime.strptime(timestamp, "%Y/%m/%d %H:%M:%S.%f") delta = my_time - epoch return delta.total_seconds() * 1000.0
import pandas def to_millis(dt): return int(pandas.to_datetime(dt).value / 1000000)
def getDateToEpoch(myDateTime): res = (datetime.datetime(myDateTime.year,myDateTime.month,myDateTime.day,myDateTime.hour,myDateTime.minute,myDateTime.second) - datetime.datetime(1970,1,1)).total_seconds() return res
import time seconds_since_epoch = time.mktime(your_datetime.timetuple()) * 1000
private static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc); public static long GetCurrentUnixTimestampMillis() { DateTime localDateTime, univDateTime; localDateTime = DateTime.Now; univDateTime = localDateTime.ToUniversalTime(); return (long)(univDateTime - UnixEpoch).TotalMilliseconds; }
import sys import os file_name = os.path.basename(sys.argv[0])
import inspect print (inspect.getfile(inspect.currentframe()))
import pylab import matplotlib.pyplot as plt a = [pow(10, i) for i in range(10)] fig = plt.figure() ax = fig.add_subplot(2, 1, 1) line, = ax.plot(a, color= pylab.show()
import pylab import matplotlib.pyplot as plt a = [pow(10, i) for i in range(10)] fig = plt.figure() ax = fig.add_subplot(2, 1, 1) line, = ax.plot(a, color= ax.set_yscale( pylab.show()
from matplotlib import pyplot a = [ pow(10,i) for i in range(10) ] pyplot.subplot(2,1,1) pyplot.plot(a, color= pyplot.yscale( pyplot.show()
from pylab import * import matplotlib.pyplot as pyplot a = [ pow(10,i) for i in range(10) ] fig = pyplot.figure() ax = fig.add_subplot(2,1,1) line, = ax.semilogy(a, color= show()
keep = set(generic_drugs_mapping[drug] for drug in drug_input)
for ...whatever...: onemorevalue = ...whatever... keep.add(onemorevalue)
>>> my_set = {1} >>> my_set = my_set | {2} >>> my_set {1, 2}
>>> my_set = {1} >>> my_set |= {2} >>> my_set {1, 2}
>>> help(string) .... DATA ascii_letters = ascii_lowercase = ascii_uppercase = digits = hexdigits = octdigits = printable = punctuation = whitespace =
import string string.ascii_lowercase string.ascii_uppercase
def letter_range(start, stop="{", step=1): for ord_ in range(ord(start.lower()), ord(stop.lower()), step): yield chr(ord_)
list(letter_range("a", "f")) list(letter_range("a", "f", step=2))
def strip_end(text, suffix): if not text.endswith(suffix): return text return text[:len(text)-len(suffix)]
url = "www.example.com" new_url = url[:url.rfind(".")]
text if not text.endswith(suffix) or len(suffix) == 0 else text[:-len(suffix)]
import os url = name,ext = os.path.splitext(url) print (name, ext) ext = name = url[:-len(ext)] print (name, ext)
import re def rm_suffix(url = return(re.sub(suffix+
def rm_dotcom(url = return(url[:-4] if url.endswith(
>>> import re >>> re.match(r"(.*)\.com", "hello.com").group(1)
def remove_file_type(infile): import re return(re.sub( remove_file_type(
class UnableToStripEnd(Exception): @staticmethod def get_exception(text, suffix): return UnableToStripEnd("Could not find suffix ({0}) on text: {1}." .format(suffix, text)) def strip_end(text, suffix): if not text.endswith(suffix): raise UnableToStripEnd.get_exception(text, suffix) return text[:len(text)-len(suffix)]
In [18]: %timeit df.set_value( 100000 loops, best of 3: 2.9 µs per loop In [20]: %timeit df[ 100000 loops, best of 3: 6.31 µs per loop In [81]: %timeit df.at[ 100000 loops, best of 3: 9.2 µs per loop
df.loc[df[<some_column_name>] == <condition>, [<another_column_name>]] = <value_to_add>
for index, row in result.iterrows(): if np.isnan(row[ result.at[index,
""" Created on Wed Nov 21 16:38:46 2018 @author: gebbissimo """ import pandas as pd import numpy as np import time NUM_ROWS = 100000 NUM_COLS = 1000 data = np.random.rand(NUM_ROWS,NUM_COLS) df = pd.DataFrame(data) NUM_ROWS_NEW = 100 data_tot = np.random.rand(NUM_ROWS + NUM_ROWS_NEW,NUM_COLS) df_tot = pd.DataFrame(data_tot) DATA_NEW = np.random.rand(1,NUM_COLS) def create_and_append(df): for i in range(NUM_ROWS_NEW): df_new = pd.DataFrame(DATA_NEW) df = df.append(df_new) return df def create_and_concat(df): for i in range(NUM_ROWS_NEW): df_new = pd.DataFrame(DATA_NEW) df = pd.concat((df, df_new)) return df def store_as_list(df): lst = [[] for i in range(NUM_ROWS_NEW)] for i in range(NUM_ROWS_NEW): for j in range(NUM_COLS): lst[i].append(DATA_NEW[0,j]) df_new = pd.DataFrame(lst) df_tot = df.append(df_new) return df_tot def store_as_dict(df): dct = {} for j in range(NUM_COLS): dct[j] = [] for i in range(NUM_ROWS_NEW): dct[j].append(DATA_NEW[0,j]) df_new = pd.DataFrame(dct) df_tot = df.append(df_new) return df_tot def fill_using_at(df): for i in range(NUM_ROWS_NEW): for j in range(NUM_COLS): df.at[NUM_ROWS+i,j] = DATA_NEW[0,j] return df def fill_using_set(df): for i in range(NUM_ROWS_NEW): for j in range(NUM_COLS): df.set_value(NUM_ROWS+i,j,DATA_NEW[0,j]) return df t0 = time.time() create_and_append(df) t1 = time.time() print( t0 = time.time() create_and_concat(df) t1 = time.time() print( t0 = time.time() store_as_list(df) t1 = time.time() print( t0 = time.time() store_as_dict(df) t1 = time.time() print( t0 = time.time() fill_using_at(df_tot) t1 = time.time() print( t0 = time.time() fill_using_set(df_tot) t1 = time.time() print(
src_df = pd.read_sql_query(src_sql,src_connection) for index1, row1 in src_df.iterrows(): for index, row in vertical_df.iterrows(): src_df.set_value(index=index1,col=u if (row1[u src_df.set_value(index=index1,col=u
day_count = (end_date - start_date).days + 1 for single_date in [d for d in (start_date + timedelta(n) for n in range(day_count)) if d <= end_date]: print strftime("%Y-%m-%d", single_date.timetuple())
2009-05-30 2009-05-31 2009-06-01 2009-06-02 2009-06-03 2009-06-04 2009-06-05 2009-06-06 2009-06-07 2009-06-08 2009-06-09
for single_date in (start_date + timedelta(n) for n in range(day_count)): print ...
from datetime import timedelta, date def daterange(start_date, end_date): for n in range(int ((end_date - start_date).days)): yield start_date + timedelta(n) start_date = date(2013, 1, 1) end_date = date(2015, 6, 2) for single_date in daterange(start_date, end_date): print single_date.strftime("%Y-%m-%d")
d = start_date delta = datetime.timedelta(days=1) while d <= end_date: print d.strftime("%Y-%m-%d") d += delta
from datetime import date from dateutil.rrule import rrule, DAILY a = date(2009, 5, 30) b = date(2009, 6, 9) for dt in rrule(DAILY, dtstart=a, until=b): print dt.strftime("%Y-%m-%d")
import pandas as pd daterange = pd.date_range(start_date, end_date)
for single_date in daterange: print (single_date.strftime("%Y-%m-%d"))
import datetime def daterange(start, stop, step=datetime.timedelta(days=1), inclusive=False): if step.days > 0: while start < stop: yield start start = start + step elif step.days < 0: while start > stop: yield start start = start + step if inclusive and start == stop: yield start for date in daterange(start_date, end_date, inclusive=True): print strftime("%Y-%m-%d", date.timetuple())
import datetime as dt start_date = dt.datetime(2012, 12,1) end_date = dt.datetime(2012, 12,5) total_days = (end_date - start_date).days + 1 for day_number in range(total_days): current_date = (start_date + dt.timedelta(days = day_number)).date() print current_date
import datetime def daterange(start, end, step=datetime.timedelta(1)): curr = start while curr < end: yield curr curr += step
import numpy as np from datetime import datetime, timedelta d0 = datetime(2009, 1,1) d1 = datetime(2010, 1,1) dt = timedelta(days = 1) dates = np.arange(d0, d1, dt).astype(datetime)
import datetime for i in range(0, 100): print((datetime.date.today() + datetime.timedelta(i)).isoformat())
2016-06-29 2016-06-30 2016-07-01 2016-07-02 2016-07-03 2016-07-04
import datetime def daterange(start, stop, step_days=1): current = start step = datetime.timedelta(step_days) if step_days > 0: while current < stop: yield current current += step elif step_days < 0: while current > stop: yield current current += step else: raise ValueError("daterange() step_days argument must not be zero") if __name__ == "__main__": from pprint import pprint as pp lo = datetime.date(2008, 12, 27) hi = datetime.date(2009, 1, 5) pp(list(daterange(lo, hi))) pp(list(daterange(hi, lo, -1))) pp(list(daterange(lo, hi, 7))) pp(list(daterange(hi, lo, -7))) assert not list(daterange(lo, hi, -1)) assert not list(daterange(hi, lo)) assert not list(daterange(lo, hi, -7)) assert not list(daterange(hi, lo, 7))
import calendar from datetime import datetime, timedelta def days_in_month(dt): return calendar.monthrange(dt.year, dt.month)[1] def monthly_range(dt_start, dt_end): forward = dt_end >= dt_start finish = False dt = dt_start while not finish: yield dt.date() if forward: days = days_in_month(dt) dt = dt + timedelta(days=days) finish = dt > dt_end else: _tmp_dt = dt.replace(day=1) - timedelta(days=1) dt = (_tmp_dt.replace(day=dt.day)) finish = dt < dt_end
date_start = datetime(2016, 6, 1) date_end = datetime(2017, 1, 1) for p in monthly_range(date_start, date_end): print(p)
2016-06-01 2016-07-01 2016-08-01 2016-09-01 2016-10-01 2016-11-01 2016-12-01 2017-01-01
date_start = datetime(2017, 1, 1) date_end = datetime(2016, 6, 1) for p in monthly_range(date_start, date_end): print(p)
2017-01-01 2016-12-01 2016-11-01 2016-10-01 2016-09-01 2016-08-01 2016-07-01 2016-06-01
for i in range(16): print datetime.date.today() + datetime.timedelta(days=i)
from datetime import datetime, timedelta def walk_days(start_date, end_date): if start_date <= end_date: print(start_date.strftime("%Y-%m-%d")) next_date = start_date + timedelta(days=1) walk_days(next_date, end_date) start_date = datetime(2009, 5, 30) end_date = datetime(2009, 6, 9) walk_days(start_date, end_date)
2009-05-30 2009-05-31 2009-06-01 2009-06-02 2009-06-03 2009-06-04 2009-06-05 2009-06-06 2009-06-07 2009-06-08 2009-06-09
> pip install DateTimeRange from datetimerange import DateTimeRange def dateRange(start, end, step): rangeList = [] time_range = DateTimeRange(start, end) for value in time_range.range(datetime.timedelta(days=step)): rangeList.append(value.strftime( return rangeList dateRange("2018-09-07", "2018-12-25", 7) Out[92]: [
for d in map( lambda x: startDate+datetime.timedelta(days=x), xrange( (stopDate-startDate).days ) ):
for d in map( lambda x: startTime+x*stepTime, xrange( (stopTime-startTime).total_seconds() / stepTime.total_seconds() ) ):
def total_seconds( td ): return float(td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6
import datetime from datetime import timedelta DATE_FORMAT = def daterange(start, end): def convert(date): try: date = datetime.datetime.strptime(date, DATE_FORMAT) return date.date() except TypeError: return date def get_date(n): return datetime.datetime.strftime(convert(start) + timedelta(days=n), DATE_FORMAT) days = (convert(end) - convert(start)).days if days <= 0: raise ValueError( for n in range(0, days): yield get_date(n) start = end = print list(daterange(start, end)) start_ = datetime.date.today() end = print list(daterange(start, end))
def count_timedelta(delta, step, seconds_in_interval): return int(delta.total_seconds() / (seconds_in_interval * step)) def range_dt(start, end, step=1, interval= intervals = functools.partial(count_timedelta, (end - start), step) if interval == for i in range(intervals(3600 * 24 * 7)): yield start + datetime.timedelta(weeks=i) * step elif interval == for i in range(intervals(3600 * 24)): yield start + datetime.timedelta(days=i) * step elif interval == for i in range(intervals(3600)): yield start + datetime.timedelta(hours=i) * step elif interval == for i in range(intervals(60)): yield start + datetime.timedelta(minutes=i) * step elif interval == for i in range(intervals(1)): yield start + datetime.timedelta(seconds=i) * step elif interval == for i in range(intervals(1 / 1000)): yield start + datetime.timedelta(milliseconds=i) * step elif interval == for i in range(intervals(1e-6)): yield start + datetime.timedelta(microseconds=i) * step else: raise AttributeError("Interval must be
def date_range(start, stop, step=1, inclusive=False): day_count = (stop - start).days if inclusive: day_count += 1 if step > 0: range_args = (0, day_count, step) elif step < 0: range_args = (day_count - 1, -1, step) else: raise ValueError("date_range(): step arg must be non-zero") for i in range(*range_args): yield start + timedelta(days=i)
if type(x) == type(str()): do_something_with_a_string(x) elif type(x) == type(dict()): do_somethting_with_a_dict(x) else: raise ValueError
def value_list(x): cases = {str: lambda t: [t], dict: lambda t: list(set(t.values()))} try: return cases[type(x)](x) except KeyError: return None
def value_list(x): if isinstance(x, dict): return list(set(x.values())) elif isinstance(x, basestring): return [x] else: return None
class D(dict): pass d = D() print("type(d) is dict", type(d) is dict) print("isinstance (d, dict)", isinstance(d, dict))
>>> s = "hallo" >>> type(s) is str True >>> s = {} >>> type(s) is dict True
>>> class a_dict(dict): ... pass ... >>> type(a_dict()) == type(dict()) False >>> isinstance(a_dict(), dict) True >>>
In [53]: s= In [54]: u=u In [55]: d={} In [56]: for each in s,u,d: if hasattr(each, print list(set(each.values())) elif hasattr(each, print [each] else: print "error" ....: ....: [ [u []
if isinstance(x, str): do_something_with_a_string(x) elif isinstance(x, dict): do_somethting_with_a_dict(x) else: raise ValueError
try: one, two = tupleOrValue except TypeError: one = tupleOrValue two = None
{type(str()): do_something_with_a_string, type(dict()): do_something_with_a_dict}.get(type(x), errorhandler)()
{str: do_something_with_a_string, dict: do_something_with_a_dict}.get(type(x), errorhandler)()
from inspect import getmro if (type([]) in getmro(obj.__class__)): elif (type{}) in getmro(obj.__class__)):
def unique_values(some_dict): return list(set(some_dict.values()))
sInvalidPath=AlwaysSuppliesAnInvalidPath() self.assertRaises(PathIsNotAValidOne, MyObject, sInvalidPath)
sValidPath=AlwaysSuppliesAValidPath() self.assertNotRaises(PathIsNotAValidOne, MyObject, sValidPath)
def run_test(self): try: myFunc() except ExceptionType: self.fail("myFunc() raised ExceptionType unexpectedly!")
sValidPath=AlwaysSuppliesAValidPath() MyObject(sValidPath)
try: a = Application("abcdef", "") except pySourceAidExceptions.PathIsNotAValidOne: pass except: self.assertTrue(False)
import traceback from unittest.case import _AssertRaisesContext class _AssertNotRaisesContext(_AssertRaisesContext): def __exit__(self, exc_type, exc_value, tb): if exc_type is not None: self.exception = exc_value.with_traceback(None) try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) if self.obj_name: self._raiseFailure("{} raised by {}".format(exc_name, self.obj_name)) else: self._raiseFailure("{} raised".format(exc_name)) else: traceback.clear_frames(tb) return True
class MyTestCase(unittest.TestCase): def assertNotRaises(self, expected_exception, *args, **kwargs): context = _AssertNotRaisesContext(expected_exception, self) try: return context.handle( finally: context = None
with self.assertRaises(pySourceAidExceptions.PathIsNotAValidOne): application = Application("abcdef", "")
def assertMayRaise(self, exception, expr): if exception is None: try: expr() except: info = sys.exc_info() self.fail( else: self.assertRaises(exception, expr) unittest.TestCase.assertMayRaise = assertMayRaise
for i,(a,b) in enumerate(itertools.product([x,y,z], [x,y,z])): self.assertMayRaise(None if i%4 else ValueError, lambda: op(a, b))
dataframe["period"] = dataframe["Year"].map(str) + dataframe["quarter"]
Year quarter period 0 2014 q1 2014q1 1 2015 q2 2015q2
In [250]: df Out[250]: Year quarter 0 2014 q1 1 2015 q2 In [251]: df = pd.concat([df] * 10**5) In [252]: df.shape Out[252]: (200000, 2)
In [107]: %timeit df[ 10 loops, best of 3: 131 ms per loop In [106]: %timeit df[ 10 loops, best of 3: 161 ms per loop In [108]: %timeit df.Year.str.cat(df.quarter) 10 loops, best of 3: 189 ms per loop In [109]: %timeit df.loc[:, [ 1 loop, best of 3: 567 ms per loop In [110]: %timeit df[[ 1 loop, best of 3: 584 ms per loop In [111]: %timeit df[[ 1 loop, best of 3: 24.7 s per loop
In [113]: %timeit df[ 10 loops, best of 3: 53.3 ms per loop In [114]: %timeit df[ 10 loops, best of 3: 65.5 ms per loop In [115]: %timeit df.Year.str.cat(df.quarter) 10 loops, best of 3: 79.9 ms per loop In [116]: %timeit df.loc[:, [ 1 loop, best of 3: 230 ms per loop In [117]: %timeit df[[ 1 loop, best of 3: 230 ms per loop In [118]: %timeit df[[ 1 loop, best of 3: 9.38 s per loop
>>> import pandas as pd >>> df = pd.DataFrame([["2014", "q1"], ... ["2015", "q3"]], ... columns=( >>> print(df) Year Quarter 0 2014 q1 1 2015 q3 >>> df[ >>> print(df) Year Quarter Period 0 2014 q1 2014q1 1 2015 q3 2015q3
>>> import pandas as pd >>> df = pd.DataFrame([[2014, 1], ... [2015, 3]], ... columns=( >>> print(df) Year Quarter 0 2014 1 1 2015 3 >>> df[ >>> print(df) Year Quarter Period 0 2014 1 2014q1 1 2015 3 2015q3
>>> df = pd.DataFrame( ... [[ ... [ ... columns=[ ... ) >>> df[ >>> print(df) Country State City AllTogether 0 USA Nevada Las Vegas USA - Nevada - Las Vegas 1 Brazil Pernambuco Recife Brazil - Pernambuco - Recife
import pandas as pd df = pd.DataFrame({ print df df[ print df Quarter Year 0 q1 2014 1 q2 2015 Quarter Year YearQuarter 0 q1 2014 2014q1 1 q2 2015 2015q2
import pandas as pd df = pd.DataFrame({ print df.dtypes print df df[ print df Quarter int64 Year object dtype: object Quarter Year 0 1 2014 1 2 2015 Quarter Year YearQuarter 0 1 2014 2014q1 1 2 2015 2015q2
import pandas as pd df = pd.DataFrame({ In [131]: %timeit df["Year"].map(str) 10000 loops, best of 3: 132 us per loop In [132]: %timeit df["Year"].astype(str) 10000 loops, best of 3: 82.2 us per loop
In [1]: import pandas as pd In [2]: df = pd.DataFrame([[0, ...: [1, ...: [2, ...: columns=[ In [3]: def str_join(df, sep, *cols): ...: from functools import reduce ...: return reduce(lambda x, y: x.astype(str).str.cat(y.astype(str), sep=sep), ...: [df[col] for col in cols]) ...: In [4]: df[ In [5]: df Out[5]: c0 c1 c2 c3 cat 0 0 the quick brown 0-the-quick-brown 1 1 fox jumps over 1-fox-jumps-over 2 2 the lazy dog 2-the-lazy-dog
def concat_df_str1(df): """ run time: 1.3416s """ return pd.Series([
import numpy as np import pandas as pd from time import time def concat_df_str1(df): """ run time: 1.3416s """ return pd.Series([ def concat_df_str2(df): return df.astype(str).sum(axis=1) def concat_df_str3(df): df = df.astype(str) return df[0] + df[1] + df[2] + df[3] + df[4] + \ df[5] + df[6] + df[7] + df[8] + df[9] def concat_df_str4(df): return df.astype(str).apply(lambda x: def main(): df = pd.DataFrame(np.zeros(1000000).reshape(100000, 10)) df = df.astype(int) time1 = time() df_en = concat_df_str4(df) print( print(df_en.head(10)) if __name__ == main()
df >>> Quarter Year 0 q1 2000 1 q2 2000 2 q3 2000 3 q4 2000
df >>> Quarter Year Period 0 q1 2000 2000 q1 1 q2 2000 2000 q2 2 q3 2000 2000 q3 3 q4 2000 2000 q4
dataframe["period"] = ([ zip(dataframe["Year"].map(str),dataframe["quarter"])])
import pandas as pd data = ID,Host,Protocol,Port 1,10.0.0.10,tcp,445 1,10.0.0.10,tcp,445 1,10.0.0.10,tcp,445 1,10.0.0.10,tcp,445 1,10.0.0.10,tcp,445 1,10.0.0.10,tcp,445 1,10.0.0.10,tcp,445 1,10.0.0.10,tcp,49707 1,10.0.0.10,tcp,49672 1,10.0.0.10,tcp,49670 df = pd.read_csv(pd.compat.StringIO(data)) df = pd.concat([df]*10000) %timeit df[ %timeit [ %timeit [ 10 loops, best of 3: 39.7 ms per loop 10 loops, best of 3: 35.9 ms per loop 10 loops, best of 3: 162 ms per loop
%timeit df[ 71.1 ms ± 3.76 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) %timeit df[ 565 ms ± 22.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
def madd(x): for i, arr in enumerate(x): if type(arr.item(0)) is not str: x[i] = x[i].astype(str) return reduce(np.core.defchararray.add, x)
data = list(zip([2000]*4, [ df = pd.DataFrame(data=data, columns=[ df[ df Year quarter period 0 2000 q1 2000q1 1 2000 q2 2000q2 2 2000 q3 2000q3 3 2000 q4 2000q4
dataframe["period"] = dataframe["Year"].astype(str).add(dataframe["quarter"])
dataframe["period"] = dataframe["Year"].astype(str).add(
df= (pd.DataFrame({ assign(period=lambda x: x.Year+x.quarter ))
>>> a = 100 >>> b = True >>> print a if b File "<stdin>", line 1 print a if b ^ SyntaxError: invalid syntax
expression_if_true if condition else expression_if_false
>>> b = True >>> a = 1 if b else None >>> a 1 >>> b = False >>> a = 1 if b else None >>> a >>>
a = 100 b = True print a if b else "", print "see no new line"
from __future__ import print_function a = False b = 100 print(b if a else "", end = "")
print (1==2 and "only if condition true" or "in case condition is false")
>>> print "%d item%s found." % (count, (count>1 and 1 item found. >>> count = 2 >>> print "%d item%s found." % (count, (count>1 and 2 items found.
import os class Monkey(object): def __init__(self): self._cached_stamp = 0 self.filename = def ook(self): stamp = os.stat(self.filename).st_mtime if stamp != self._cached_stamp: self._cached_stamp = stamp
from PyQt4 import QtCore @QtCore.pyqtSlot(str) def directory_changed(path): print( @QtCore.pyqtSlot(str) def file_changed(path): print( fs_watcher = QtCore.QFileSystemWatcher([ fs_watcher.connect(fs_watcher, QtCore.SIGNAL( fs_watcher.connect(fs_watcher, QtCore.SIGNAL(
import time import fcntl import os import signal FNAME = "/HOME/TOTO/FILETOWATCH" def handler(signum, frame): print "File %s modified" % (FNAME,) signal.signal(signal.SIGIO, handler) fd = os.open(FNAME, os.O_RDONLY) fcntl.fcntl(fd, fcntl.F_SETSIG, 0) fcntl.fcntl(fd, fcntl.F_NOTIFY, fcntl.DN_MODIFY | fcntl.DN_CREATE | fcntl.DN_MULTISHOT) while True: time.sleep(10000)
import os import win32file import win32con path_to_watch = "." file_to_watch = "test.txt" def ProcessNewData( newData ): print "Text added: %s"%newData ACTIONS = { 1 : "Created", 2 : "Deleted", 3 : "Updated", 4 : "Renamed from something", 5 : "Renamed to something" } FILE_LIST_DIRECTORY = 0x0001 hDir = win32file.CreateFile ( path_to_watch, FILE_LIST_DIRECTORY, win32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE, None, win32con.OPEN_EXISTING, win32con.FILE_FLAG_BACKUP_SEMANTICS, None ) a = open(file_to_watch, "r") a.read() while 1: results = win32file.ReadDirectoryChangesW ( hDir, 1024, False, win32con.FILE_NOTIFY_CHANGE_LAST_WRITE, None, None ) for action, file in results: full_filename = os.path.join (path_to_watch, file) if file == file_to_watch: newText = a.read() if newText != "": ProcessNewData( newText )
watchmedo shell-command \ --patterns="*.sql" \ --recursive \ --command= .
import time while 1: where = file.tell() line = file.readline() if not line: time.sleep(1) file.seek(where) else: print line,
import time f = open(r while True: line = f.readline() if not line: time.sleep(1) print else: print
import os, sys, time def files_to_timestamp(path): files = [os.path.join(path, f) for f in os.listdir(path)] return dict ([(f, os.path.getmtime(f)) for f in files]) if __name__ == "__main__": path_to_watch = sys.argv[1] print "Watching ", path_to_watch before = files_to_timestamp(path_to_watch) while 1: time.sleep (2) after = files_to_timestamp(path_to_watch) added = [f for f in after.keys() if not f in before.keys()] removed = [f for f in before.keys() if not f in after.keys()] modified = [] for f in before.keys(): if not f in removed: if os.path.getmtime(f) != before.get(f): modified.append(f) if added: print "Added: ", ", ".join(added) if removed: print "Removed: ", ", ".join(removed) if modified: print "Modified ", ", ".join(modified) before = after
import os import sys import time class Watcher(object): running = True refresh_delay_secs = 1 def __init__(self, watch_file, call_func_on_change=None, *args, **kwargs): self._cached_stamp = 0 self.filename = watch_file self.call_func_on_change = call_func_on_change self.args = args self.kwargs = kwargs def look(self): stamp = os.stat(self.filename).st_mtime if stamp != self._cached_stamp: self._cached_stamp = stamp print( if self.call_func_on_change is not None: self.call_func_on_change(*self.args, **self.kwargs) def watch(self): while self.running: try: time.sleep(self.refresh_delay_secs) self.look() except KeyboardInterrupt: print( break except FileNotFoundError: pass except: print( def custom_action(text): print(text) watch_file = watcher = Watcher(watch_file, custom_action, text= watcher.watch()
file_size_stored = os.stat( while True: try: file_size_current = os.stat( if file_size_stored != file_size_current: restart_program() except: pass
def restart_program(): python = sys.executable os.execl(python, python, * sys.argv)
ACTIONS = { 1 : "Created", 2 : "Deleted", 3 : "Updated", 4 : "Renamed from something", 5 : "Renamed to something" } FILE_LIST_DIRECTORY = 0x0001 class myThread (threading.Thread): def __init__(self, threadID, fileName, directory, origin): threading.Thread.__init__(self) self.threadID = threadID self.fileName = fileName self.daemon = True self.dir = directory self.originalFile = origin def run(self): startMonitor(self.fileName, self.dir, self.originalFile) def startMonitor(fileMonitoring,dirPath,originalFile): hDir = win32file.CreateFile ( dirPath, FILE_LIST_DIRECTORY, win32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE, None, win32con.OPEN_EXISTING, win32con.FILE_FLAG_BACKUP_SEMANTICS, None ) while 1: results = win32file.ReadDirectoryChangesW ( hDir, 1024, False, win32con.FILE_NOTIFY_CHANGE_LAST_WRITE, None, None ) for action, file_M in results: full_filename = os.path.join (dirPath, file_M) if len(full_filename) == len(fileMonitoring) and action == 3: ...
from PyQt5.QtCore import QFileSystemWatcher, QSettings, QThread from ui_main_window import Ui_MainWindow class MainWindow(QMainWindow, Ui_MainWindow): def __init__(self, parent=None): QMainWindow.__init__(self, parent) Ui_MainWindow.__init__(self) self._fileWatcher = QFileSystemWatcher() self._fileWatcher.fileChanged.connect(self.fileChanged) def fileChanged(self, filepath): QThread.msleep(300) with open(filepath) as file: lastLine = list(file)[-1] destPath = self._filemap[filepath][ with open(destPath, out_file.writelines([lastLine])
from pygtail import Pygtail while True: for line in Pygtail("some.log"): sys.stdout.write(line)
try: f = open(filePath) except IOError: print "No such file: %s" % filePath raw_input("Press Enter to close window") try: lines = f.readlines() while True: line = f.readline() try: if not line: time.sleep(1) else: functionThatAnalisesTheLine(line) except Exception, e: raw_input("Press Enter to close window") raise e finally: f.close()
from pathlib import Path contents = Path(file_path).read_text()
from pathlib2 import Path contents = Path(file_path).read_text()
def read_text(self, encoding=None, errors=None): with self.open(mode= return f.read()
import requests def DownloadFile(url) local_filename = url.split( r = requests.get(url) f = open(local_filename, for chunk in r.iter_content(chunk_size=512 * 1024): if chunk: f.write(chunk) f.close() return
def download_file(url): local_filename = url.split( r = requests.get(url, stream=True) with open(local_filename, for chunk in r.iter_content(chunk_size=1024): if chunk: f.write(chunk) return local_filename
import requests import shutil def download_file(url): local_filename = url.split( r = requests.get(url, stream=True) with open(local_filename, shutil.copyfileobj(r.raw, f) return local_filename
def DownloadFile(url): local_filename = url.split( r = requests.get(url) with open(local_filename, for chunk in r.iter_content(chunk_size=1024): if chunk: f.write(chunk) return
with open(local_filename, for chunk in r.iter_content(chunk_size=1024): if chunk: f.write(chunk) f.flush() os.fsync(f.fileno())
from urllib.request import urlretrieve url = dst = urlretrieve(url, dst)
from urllib.request import urlopen from shutil import copyfileobj from tempfile import NamedTemporaryFile url = with urlopen(url) as fsrc, NamedTemporaryFile(delete=False) as fdst: copyfileobj(fsrc, fdst)
>>> datetime.datetime.strptime( datetime.date(2010, 5, 24)
datetime.datetime.strptime("2015-02-24T13:00:00-08:00", "%Y-%B-%dT%H:%M:%S-%H:%M").date()
Traceback (most recent call last): File "<stdin>", line 1, in <module> File "/usr/local/lib/python2.7/_strptime.py", line 308, in _strptime format_regex = _TimeRE_cache.compile(format) File "/usr/local/lib/python2.7/_strptime.py", line 265, in compile return re_compile(self.pattern(format), IGNORECASE) File "/usr/local/lib/python2.7/re.py", line 194, in compile return _compile(pattern, flags) File "/usr/local/lib/python2.7/re.py", line 251, in _compile raise error, v sre_constants.error: redefinition of group name
<-24T13:00:00-08:00", "%Y-%B-%dT%HH:%MM:%SS-%HH:%MM").date()
>>> from dateutil.parser import parse >>> from datetime import datetime >>> parse("2015-02-24T13:00:00-08:00") datetime.datetime(2015, 2, 24, 13, 0, tzinfo=tzoffset(None, -28800))
from dateutil import parser dt = parser.parse("Jun 1 2005 1:33PM") print(dt.year, dt.month, dt.day,dt.hour, dt.minute, dt.second) >2005 6 1 13 33 0
import arrow import datetime a = arrow.get( print(isinstance(a, datetime.date))
from datetime import datetime cus_date = datetime.strptime("24052010", "%d%m%Y").date()
import time tring= var = int(time.mktime(time.strptime(tring, print var
proc = subprocess.Popen( cmd, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, shell=True)
from subprocess import STDOUT, check_output output = check_output(cmd, stderr=STDOUT, timeout=seconds)
import subprocess, threading class Command(object): def __init__(self, cmd): self.cmd = cmd self.process = None def run(self, timeout): def target(): print self.process = subprocess.Popen(self.cmd, shell=True) self.process.communicate() print thread = threading.Thread(target=target) thread.start() thread.join(timeout) if thread.is_alive(): print self.process.terminate() thread.join() print self.process.returncode command = Command("echo command.run(timeout=3) command.run(timeout=1)
Thread started Process started Process finished Thread finished 0 Thread started Process started Terminating process Thread finished -15
import shlex from subprocess import Popen, PIPE from threading import Timer def run(cmd, timeout_sec): proc = Popen(shlex.split(cmd), stdout=PIPE, stderr=PIPE) timer = Timer(timeout_sec, proc.kill) try: timer.start() stdout, stderr = proc.communicate() finally: timer.cancel() run("sleep 1", 5) run("sleep 5", 1)
import signal ... class Alarm(Exception): pass def alarm_handler(signum, frame): raise Alarm signal.signal(signal.SIGALRM, alarm_handler) signal.alarm(5*60) try: stdoutdata, stderrdata = proc.communicate() signal.alarm(0) except Alarm: print "Oops, taking too long!"
from os import kill from signal import alarm, signal, SIGALRM, SIGKILL from subprocess import PIPE, Popen def run(args, cwd = None, shell = False, kill_tree = True, timeout = -1, env = None): Run a command with a timeout after which it will be forcibly killed. class Alarm(Exception): pass def alarm_handler(signum, frame): raise Alarm p = Popen(args, shell = shell, cwd = cwd, stdout = PIPE, stderr = PIPE, env = env) if timeout != -1: signal(SIGALRM, alarm_handler) alarm(timeout) try: stdout, stderr = p.communicate() if timeout != -1: alarm(0) except Alarm: pids = [p.pid] if kill_tree: pids.extend(get_process_children(p.pid)) for pid in pids: try: kill(pid, SIGKILL) except OSError: pass return -9, return p.returncode, stdout, stderr def get_process_children(pid): p = Popen( stdout = PIPE, stderr = PIPE) stdout, stderr = p.communicate() return [int(p) for p in stdout.split()] if __name__ == print run( print run(
def kill_proc(proc, timeout): timeout["value"] = True proc.kill() def run(cmd, timeout_sec): proc = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE) timeout = {"value": False} timer = Timer(timeout_sec, kill_proc, [proc, timeout]) timer.start() stdout, stderr = proc.communicate() timer.cancel() return proc.returncode, stdout.decode("utf-8"), stderr.decode("utf-8"), timeout["value"]
outFile = tempfile.SpooledTemporaryFile() errFile = tempfile.SpooledTemporaryFile() proc = subprocess.Popen(args, stderr=errFile, stdout=outFile, universal_newlines=False) wait_remaining_sec = timeout while proc.poll() is None and wait_remaining_sec > 0: time.sleep(1) wait_remaining_sec -= 1 if wait_remaining_sec <= 0: killProc(proc.pid) raise ProcessIncompleteError(proc, timeout) outFile.seek(0); errFile.seek(0); out = outFile.read() err = errFile.read() outFile.close() errFile.close()
import subprocess subprocess.call("command", timeout=20, shell=True)
try: subprocess.call("command", timeout=20, shell=True) except subprocess.TimeoutExpired:
import subprocess from threading import Thread, Event def kill_on_timeout(done, timeout, proc): if not done.wait(timeout): proc.kill() def exec_command(command, timeout): done = Event() proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) watcher = Thread(target=kill_on_timeout, args=(done, timeout, proc)) watcher.daemon = True watcher.start() data, stderr = proc.communicate() done.set() return data, stderr, proc.returncode
In [2]: exec_command([ Out[2]: ( In [3]: exec_command([ Out[3]: (
from easyprocess import Proc stdout=Proc( print stdout
import subprocess32 try: output = subprocess32.check_output(command, shell=True, timeout=3) except subprocess32.TimeoutExpired as e: print e
Run the command described by args. Wait for command to complete, then return a CompletedProcess instance.
class Command(threading.Thread): def __init__(self, cmd, outFile, errFile, timeout): threading.Thread.__init__(self) self.cmd = cmd self.process = None self.outFile = outFile self.errFile = errFile self.timed_out = False self.timeout = timeout def run(self): self.process = subprocess.Popen(self.cmd, stdout = self.outFile, \ stderr = self.errFile) while (self.process.poll() is None and self.timeout > 0): time.sleep(1) self.timeout -= 1 if not self.timeout > 0: self.process.terminate() self.timed_out = True else: self.timed_out = False
outFile = tempfile.SpooledTemporaryFile() errFile = tempfile.SpooledTemporaryFile() executor = command.Command(c, outFile, errFile, timeout) executor.daemon = True executor.start() executor.join() if executor.timed_out: out = else: outFile.seek(0) errFile.seek(0) out = outFile.read() err = errFile.read() outFile.close() errFile.close()
class Popen(subprocess.Popen): def communicate(self, input=None, timeout=None): if timeout is None: return subprocess.Popen.communicate(self, input) if self.stdin: self.stdin.flush() if not input: self.stdin.close() read_set, write_set = [], [] stdout = stderr = None if self.stdin and input: write_set.append(self.stdin) if self.stdout: read_set.append(self.stdout) stdout = [] if self.stderr: read_set.append(self.stderr) stderr = [] input_offset = 0 deadline = time.time() + timeout while read_set or write_set: try: rlist, wlist, xlist = select.select(read_set, write_set, [], max(0, deadline - time.time())) except select.error as ex: if ex.args[0] == errno.EINTR: continue raise if not (rlist or wlist): break if self.stdin in wlist: chunk = input[input_offset:input_offset + subprocess._PIPE_BUF] try: bytes_written = os.write(self.stdin.fileno(), chunk) except OSError as ex: if ex.errno == errno.EPIPE: self.stdin.close() write_set.remove(self.stdin) else: raise else: input_offset += bytes_written if input_offset >= len(input): self.stdin.close() write_set.remove(self.stdin) for fn, tgt in ( (self.stdout, stdout), (self.stderr, stderr), ): if fn in rlist: data = os.read(fn.fileno(), 1024) if data == fn.close() read_set.remove(fn) tgt.append(data) if stdout is not None: stdout = if stderr is not None: stderr = return (stdout, stderr)
import subprocess from datetime import datetime from select import select def call_with_timeout(cmd, timeout): started = datetime.now() sp = subprocess.Popen(cmd, stdout=subprocess.PIPE) while True: p = select([sp.stdout], [], [], timeout) if p[0]: p[0][0].read() ret = sp.poll() if ret is not None: return ret if (datetime.now()-started).total_seconds() > timeout: sp.kill() return None
cmd = "timeout 20 "+ cmd subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE) (output, err) = p.communicate()
from logging import error from subprocess import Popen from threading import Event from threading import Thread class ExpirablePopen(Popen): def __init__(self, *args, **kwargs): self.timeout = kwargs.pop( self.timer = None self.done = Event() Popen.__init__(self, *args, **kwargs) def __tkill(self): timeout = self.timeout if not self.done.wait(timeout): error( self.kill() def expirable(func): def wrapper(self, *args, **kwargs): if self.timeout == 0: return func(self, *args, **kwargs) if self.timer is None: self.timer = thr = Thread(target=self.__tkill) thr.daemon = True thr.start() result = func(self, *args, **kwargs) self.done.set() return result return wrapper wait = expirable(Popen.wait) communicate = expirable(Popen.communicate) if __name__ == from subprocess import PIPE print ExpirablePopen(
import os import sys import signal import subprocess from multiprocessing import Pool cores_for_parallelization = 4 timeout_time = 15 def main(): jobs = [...YOUR_JOB_LIST...] with Pool(cores_for_parallelization) as p: p.map(run_parallel_jobs, jobs) def run_parallel_jobs(args): initial_terminal_command = function_to_start = final_list = [initial_terminal_command, function_to_start] final_list.extend(args) subp = subprocess.Popen(final_list) pid = subp.pid try: returncode = subp.wait(timeout=timeout_time) except subprocess.TimeoutExpired: if sys.platform == os.kill(pid, signal.SIGTERM) elif sys.platform == subp.terminate() if __name__ == main()
pipe = subprocess.Popen( timeout = 10 results = pipe.waitOrTerminate(timeout)
def kill_proc_tree(pid, including_parent=True): parent = psutil.Process(pid) children = parent.children(recursive=True) for child in children: child.kill() psutil.wait_procs(children, timeout=5) if including_parent: parent.kill() parent.wait(5) def run_with_timeout(cmd, current_dir, cmd_parms, timeout): def target(): process = subprocess.Popen(cmd, cwd=current_dir, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE) if (cmd_parms == ""): out, err = process.communicate() else: out, err = process.communicate(cmd_parms) errcode = process.returncode thread = Thread(target=target) thread.start() thread.join(timeout) if thread.is_alive(): me = os.getpid() kill_proc_tree(me, including_parent=False) thread.join()
from gevent.subprocess import Popen, PIPE, STDOUT def call_sys(cmd, timeout): p= Popen(cmd, shell=True, stdout=PIPE) output, _ = p.communicate(timeout=timeout) assert p.returncode == 0, p. returncode return output call_sys( sleep 5 echo done exit 1
import time import subprocess def run_command(cmd, timeout=0): start_time = time.time() df = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) while timeout and df.poll() == None: if time.time()-start_time >= timeout: df.kill() return -1, "" output = return df.returncode, output
import subprocess, optparse, os, sys, re, datetime, threading, time, glob, shutil, xml.dom.minidom, traceback class OutputManager: def __init__(self, filename, mode, console, logonly): self.con = console self.logtoconsole = True self.logtofile = False if filename: try: self.f = open(filename, mode) self.logtofile = True if logonly == True: self.logtoconsole = False except IOError: print (sys.exc_value) print ("Switching to console only output...\n") self.logtofile = False self.logtoconsole = True def write(self, data): if self.logtoconsole == True: self.con.write(data) if self.logtofile == True: self.f.write(data) sys.stdout.flush() def getTimeString(): return time.strftime("%Y-%m-%d", time.gmtime()) def runCommand(command): Execute a command in new thread and return the stdout and stderr content of it. try: Output = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True).communicate()[0] except Exception as e: print ("runCommand failed :%s" % (command)) print (str(e)) sys.stdout.flush() return None return Output def GetOs(): Os = "" if sys.platform.startswith( Os = "win" elif sys.platform.startswith( Os = "linux" elif sys.platform.startswith( Os = "mac" return Os def check_output(*popenargs, **kwargs): try: if raise ValueError( startTime = datetime.datetime.now() timeoutValue=3600 cmd = popenargs[0] if sys.platform.startswith( process = subprocess.Popen( cmd, stdout=subprocess.PIPE, shell=True) elif sys.platform.startswith( process = subprocess.Popen( cmd , stdout=subprocess.PIPE, shell=True ) elif sys.platform.startswith( process = subprocess.Popen( cmd , stdout=subprocess.PIPE, shell=True ) stdoutdata, stderrdata = process.communicate( timeout = timeoutValue ) retcode = process.poll() OutputHandle = None try: if retcode >= 1: OutputHandle = OutputManager( OutputHandle.write( cmd ) print (stdoutdata) print (stderrdata) sys.stdout.flush() except Exception as e: print (str(e)) except subprocess.TimeoutExpired: Os = GetOs() if Os == killCmd = "taskkill /FI \"IMAGENAME eq {0}\" /T /F" elif Os == killCmd = "pkill {0)" elif Os == killCmd = "killall -KILL {0}" runCommand(killCmd.format("java")) runCommand(killCmd.format("YouApp")) OutputHandle = None try: OutputHandle = OutputManager( OutputHandle.write( cmd ) except Exception as e: print (str(e)) except Exception as e: for frame in traceback.extract_tb(sys.exc_info()[2]): fname,lineno,fn,text = frame print "Error in %s on line %d" % (fname, lineno)
from subprocess import Popen, PIPE import datetime import time popen = Popen(["/bin/sleep", "10"]); pid = popen.pid sttime = time.time(); waittime = 3 print "Start time %s"%(sttime) while True: popen.poll(); time.sleep(1) rcode = popen.returncode now = time.time(); if [ rcode is None ] and [ now > (sttime + waittime) ] : print "Killing it now" popen.kill()
>>> OrderedDict(zip( OrderedDict([( >>> oldkey, newkey = >>> OrderedDict((newkey if k == oldkey else k, v) for k, v in _.viewitems()) OrderedDict([(
if newkey!=oldkey: dictionary[newkey] = dictionary[oldkey] del dictionary[oldkey]
def rename(self,key,new_key): ind = self._keys.index(key) self._keys[ind] = new_key self[new_key] = self[key] self._keys.pop(-1)
dic = OrderedDict((("a",1),("b",2),("c",3))) print dic dic.rename("a","foo") dic.rename("b","bar") dic["d"] = 5 dic.rename("d","spam") for k,v in dic.items(): print k,v
def rename(old_dict,old_name,new_name): new_dict = {} for key,value in zip(old_dict.keys(),old_dict.values()): new_key = key if key != old_name else new_name new_dict[new_key] = old_dict[key] return new_dict
print "a in" import sys print "b imported: %s" % ("b" in sys.modules, ) import b print "a out"
$ python a.py a in b imported: False b in a in b imported: True a out b out a out
$ python a.py a in b imported: False b in a in b imported: True a out Traceback (most recent call last): File "a.py", line 4, in <module> import b File "/home/shlomme/tmp/x/b.py", line 2, in <module> import a File "/home/shlomme/tmp/x/a.py", line 7, in <module> print b.x AttributeError:
from images.serializers import SimplifiedImageSerializer class SimplifiedProfileSerializer(serializers.Serializer): name = serializers.CharField() class ProfileSerializer(SimplifiedProfileSerializer): recent_images = SimplifiedImageSerializer(many=True)
from profiles.serializers import SimplifiedProfileSerializer class SimplifiedImageSerializer(serializers.Serializer): title = serializers.CharField() class ImageSerializer(SimplifiedImageSerializer): profile = SimplifiedProfileSerializer()
try: from images.serializers import SimplifiedImageSerializer except ImportError: import sys SimplifiedImageSerializer = sys.modules[__package__ +
Traceback (most recent call last): File "m.py", line 1, in <module> import foo File "/home/xolve/foo.py", line 1, in <module> import bar File "/home/xolve/bar.py", line 1, in <module> from foo import gX ImportError: cannot import name gX
def load_module(name): names = name.split(".") path = None for name in names: f, path, info = imp.find_module(name, path) path = [path] return imp.load_module(name, f, path[0], info) constants = load_module("app.constants")
import b y = 2 def main(): print ("a out") print (b.x) if __name__ == "__main__": main ()
print import b print print import a print if __name__ == print print
print "b in, __name__ = {}".format(__name__) x = 3 print import a y = 5 print "b out"
import b b in, __name__ = b b imports a a in, __name__ = a a imports b b has x True b has y False a out b out a in globals() False import a a in globals() True imports done b has y True, a is b.a True
def MandrillEmailOrderSerializer(): from sastaticketpk.apps.flights.api.v1.serializers import MandrillEmailOrderSerializer return MandrillEmailOrderSerializer email_data = MandrillEmailOrderSerializer()(order.booking).data
class A(object): def __init__(self, name): self.name = name CLASS = A("me") import b go = B(6) go.dostuff
class B(object): def __init__(self, number): self.number = number def dostuff(self): from a import CLASS print "Hello " + CLASS.name + ", " + str(number) + " is an interesting number."
>>> x = [1, 2, 3, 4, 2, 2, 3] >>> def remove_values_from_list(the_list, val): while val in the_list: the_list.remove(val) >>> remove_values_from_list(x, 2) >>> x [1, 3, 4, 3]
>>> x = [1,2,3,2,2,2,3,4] >>> filter(lambda a: a != 2, x) [1, 3, 3, 4]
>>> x = [1,2,3,2,2,2,3,4] >>> list(filter((2).__ne__, x)) [1, 3, 3, 4]
>>> x = [1,2,3,2,2,2,3,4] >>> list(filter(lambda a: a != 2, x)) [1, 3, 3, 4]
def remove_values_from_list(the_list, val): return [value for value in the_list if value != val] x = [1, 2, 3, 4, 2, 2, 3] x = remove_values_from_list(x, 2) print x
>>> x = [1, 2, 3, 4, 2, 2, 3] >>> x[:] = (value for value in x if value != 2) >>> x [1, 3, 4, 3]
>>> x = [1, 2, 3, 4, 2, 2, 3] >>> while 2 in x: x.remove(2) >>> x [1, 3, 4, 3]
>>> import random, timeit >>> a = list(range(5)) * 1000 >>> random.shuffle(a) >>> b = a >>> print(b is a) True >>> b = [x for x in b if x != 0] >>> print(b is a) False >>> b.count(0) 0 >>> a.count(0) 1000 >>> b = a >>> b = filter(lambda a: a != 2, x) >>> print(b is a) False
>>> def removeall_inplace(x, l): ... for _ in xrange(l.count(x)): ... l.remove(x) ... >>> removeall_inplace(0, b) >>> b is a True >>> a.count(0) 0
>>> def removeall_replace(x, l): .... t = [y for y in l if y != x] .... del l[:] .... l.extend(t)
x = [1, 2, 3, 4, 2, 2, 3] def remove_values_from_list(the_list, val): for i in range(the_list.count(val)): the_list.remove(val) remove_values_from_list(x, 2) print(x)
test = [1, 1, 2, 3] newlist = list(set(test)) print newlist [1, 2, 3]
category_ids.sort() ones_last_index = category_ids.count( del category_ids[0:ones_last_index]
In [10]: a.shape Out[10]: (1000000,) In [13]: len(lst) Out[13]: 1000000 In [18]: %timeit a[a != 2] 100 loops, best of 3: 2.94 ms per loop In [19]: %timeit [x for x in lst if x != 2] 10 loops, best of 3: 79.7 ms per loop
import numpy as np a = np.random.randint(0, 1000, 10**6) In [10]: a.shape Out[10]: (1000000,) In [12]: lst = a.tolist() In [13]: len(lst) Out[13]: 1000000
In [14]: a[a != 2].shape Out[14]: (998949,) In [15]: len([x for x in lst if x != 2]) Out[15]: 998949
>>> x=[1,2,3,4,5,6,7,8] >>> x [1, 2, 3, 4, 5, 6, 7, 8] >>> x = [val for val in x if val not in [2,3,4]] >>> x [1, 5, 6, 7, 8]
lists = [6.9,7,8.9,3,5,4.9,1,2.9,7,9,12.9,10.9,11,7] def remove_values_from_list(): for list in lists: if(list!=7): print(list) remove_values_from_list()
lists = [6.9,7,8.9,3,5,4.9,1,2.9,7,9,12.9,10.9,11,7] def remove_values_from_list(remove): for list in lists: if(list!=remove): print(list) remove_values_from_list(7)
ls = [2, 2, 3, 4, 5, 6, 7, 8, 2, 3, 4, 6, 2] ls = list(filter(lambda x: x != 2, ls)) ls = [x for x in ls if x != 2]
a = [1, 2, 2, 3, 1] to_remove = 1 a = [i for i in a if i != to_remove] print(a)
def remove_all(A, v): k = 0 n = len(A) for i in range(n): if A[i] != v: A[k] = A[i] k += 1 A = A[:k]
import time s_time = time.time() print a = range(100000000) del a[:] print s_time = time.time() print a = range(100000000) a = [] print
import matplotlib.pyplot as plt import random prefix = 6.18 rx = [prefix+(0.001*random.random()) for i in arange(100)] ry = [prefix+(0.001*random.random()) for i in arange(100)] plt.plot(rx,ry, frame1 = plt.gca() for xlabel_i in frame1.axes.get_xticklabels(): xlabel_i.set_visible(False) xlabel_i.set_fontsize(0.0) for xlabel_i in frame1.axes.get_yticklabels(): xlabel_i.set_fontsize(0.0) xlabel_i.set_visible(False) for tick in frame1.axes.get_xticklines(): tick.set_visible(False) for tick in frame1.axes.get_yticklines(): tick.set_visible(False) plt.show()
frame1.axes.get_xaxis().set_visible(False) frame1.axes.get_yaxis().set_visible(False)
frame1.axes.get_xaxis().set_ticks([]) frame1.axes.get_yaxis().set_ticks([])
frame1 = plt.gca() frame1.axes.xaxis.set_ticklabels([]) frame1.axes.yaxis.set_ticklabels([])
a = [ str = "a123" if a in str: print "some of the strings found in str" else: print "no strings found in str"
matches = [] for x in a: if x in str and x not in matches: matches.append(x)
a = [ str = "a123" found_a_string = False for item in a: if item in str: found_a_string = True if found_a_string: print "found a match" else: print "no match found"
a = [ str = "a123" a_match = [True for match in a if match in str] if True in a_match: print "some of the strings found in str" else: print "no strings found in str"
from aho_corasick import aho_corasick print(aho_corasick(string, ["keyword1", "keyword2"]))
if any(your_required in yourinput for your_required in original_word ):
original_word = [ yourinput = str(input()).lower() if all(requested_word in yourinput for requested_word in original_word): print("yes")
flog = open( flogLines = flog.readlines() strlist = [ res = False for line in flogLines: for fstr in strlist: if line.find(fstr) != -1: print( res = True if res: print( else: print(
def check_string(string, substring_list): for substring in substring_list: if substring in string: return True return False
data = "firstName and favoriteFood" mandatory_fields = [ for field in mandatory_fields: if field not in data: print("Error, missing req field {0}".format(field)); if ( print("Error, missing a req field"); missing_fields = [x for x in mandatory_fields if x not in data] if (len(missing_fields)>0): print("Error, missing fields {0}".format(", ".join(missing_fields)));
a = [ str = "a123" list(filter(lambda x: x in str, a))
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8) RESET_SEQ = "\033[0m" COLOR_SEQ = "\033[1;%dm" BOLD_SEQ = "\033[1m" def formatter_message(message, use_color = True): if use_color: message = message.replace("$RESET", RESET_SEQ).replace("$BOLD", BOLD_SEQ) else: message = message.replace("$RESET", "").replace("$BOLD", "") return message COLORS = { } class ColoredFormatter(logging.Formatter): def __init__(self, msg, use_color = True): logging.Formatter.__init__(self, msg) self.use_color = use_color def format(self, record): levelname = record.levelname if self.use_color and levelname in COLORS: levelname_color = COLOR_SEQ % (30 + COLORS[levelname]) + levelname + RESET_SEQ record.levelname = levelname_color return logging.Formatter.format(self, record)
class ColoredLogger(logging.Logger): FORMAT = "[$BOLD%(name)-20s$RESET][%(levelname)-18s] %(message)s ($BOLD%(filename)s$RESET:%(lineno)d)" COLOR_FORMAT = formatter_message(FORMAT, True) def __init__(self, name): logging.Logger.__init__(self, name, logging.DEBUG) color_formatter = ColoredFormatter(self.COLOR_FORMAT) console = logging.StreamHandler() console.setFormatter(color_formatter) self.addHandler(console) return logging.setLoggerClass(ColoredLogger)
$ python > import coloredlogs, logging > coloredlogs.install() > logging.info("It works!") 2014-07-30 21:21:26 peter-macbook root[7471] INFO It works!
import logging import Colorer logging.warn("a warning") logging.error("some error") logging.info("some info")
import logging def add_coloring_to_emit_windows(fn): def _out_handle(self): import ctypes return ctypes.windll.kernel32.GetStdHandle(self.STD_OUTPUT_HANDLE) out_handle = property(_out_handle) def _set_color(self, code): import ctypes self.STD_OUTPUT_HANDLE = -11 hdl = ctypes.windll.kernel32.GetStdHandle(self.STD_OUTPUT_HANDLE) ctypes.windll.kernel32.SetConsoleTextAttribute(hdl, code) setattr(logging.StreamHandler, def new(*args): FOREGROUND_BLUE = 0x0001 FOREGROUND_GREEN = 0x0002 FOREGROUND_RED = 0x0004 FOREGROUND_INTENSITY = 0x0008 FOREGROUND_WHITE = FOREGROUND_BLUE|FOREGROUND_GREEN |FOREGROUND_RED STD_INPUT_HANDLE = -10 STD_OUTPUT_HANDLE = -11 STD_ERROR_HANDLE = -12 FOREGROUND_BLACK = 0x0000 FOREGROUND_BLUE = 0x0001 FOREGROUND_GREEN = 0x0002 FOREGROUND_CYAN = 0x0003 FOREGROUND_RED = 0x0004 FOREGROUND_MAGENTA = 0x0005 FOREGROUND_YELLOW = 0x0006 FOREGROUND_GREY = 0x0007 FOREGROUND_INTENSITY = 0x0008 BACKGROUND_BLACK = 0x0000 BACKGROUND_BLUE = 0x0010 BACKGROUND_GREEN = 0x0020 BACKGROUND_CYAN = 0x0030 BACKGROUND_RED = 0x0040 BACKGROUND_MAGENTA = 0x0050 BACKGROUND_YELLOW = 0x0060 BACKGROUND_GREY = 0x0070 BACKGROUND_INTENSITY = 0x0080 levelno = args[1].levelno if(levelno>=50): color = BACKGROUND_YELLOW | FOREGROUND_RED | FOREGROUND_INTENSITY | BACKGROUND_INTENSITY elif(levelno>=40): color = FOREGROUND_RED | FOREGROUND_INTENSITY elif(levelno>=30): color = FOREGROUND_YELLOW | FOREGROUND_INTENSITY elif(levelno>=20): color = FOREGROUND_GREEN elif(levelno>=10): color = FOREGROUND_MAGENTA else: color = FOREGROUND_WHITE args[0]._set_color(color) ret = fn(*args) args[0]._set_color( FOREGROUND_WHITE ) return ret return new def add_coloring_to_emit_ansi(fn): def new(*args): levelno = args[1].levelno if(levelno>=50): color = elif(levelno>=40): color = elif(levelno>=30): color = elif(levelno>=20): color = elif(levelno>=10): color = else: color = args[1].msg = color + args[1].msg + return fn(*args) return new import platform if platform.system()== logging.StreamHandler.emit = add_coloring_to_emit_windows(logging.StreamHandler.emit) else: logging.StreamHandler.emit = add_coloring_to_emit_ansi(logging.StreamHandler.emit)
logging.addLevelName( logging.WARNING, "\033[1;31m%s\033[1;0m" % logging.getLevelName(logging.WARNING)) logging.addLevelName( logging.ERROR, "\033[1;41m%s\033[1;0m" % logging.getLevelName(logging.ERROR))
import logging LOG_LEVEL = logging.DEBUG LOGFORMAT = " %(log_color)s%(levelname)-8s%(reset)s | %(log_color)s%(message)s%(reset)s" from colorlog import ColoredFormatter logging.root.setLevel(LOG_LEVEL) formatter = ColoredFormatter(LOGFORMAT) stream = logging.StreamHandler() stream.setLevel(LOG_LEVEL) stream.setFormatter(formatter) log = logging.getLogger( log.setLevel(LOG_LEVEL) log.addHandler(stream) log.debug("A quirky message only developers care about") log.info("Curious users might want to know this") log.warn("Something is wrong and any user should be informed") log.error("Serious stuff, this is red for a reason") log.critical("OH NO everything is on fire")
import logging BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8) COLORS = { } RESET_SEQ = "\033[0m" COLOR_SEQ = "\033[1;%dm" BOLD_SEQ = "\033[1m" class ColorFormatter(logging.Formatter): def __init__(self, *args, **kwargs): logging.Formatter.__init__(self, *args, **kwargs) def format(self, record): levelname = record.levelname color = COLOR_SEQ % (30 + COLORS[levelname]) message = logging.Formatter.format(self, record) message = message.replace("$RESET", RESET_SEQ)\ .replace("$BOLD", BOLD_SEQ)\ .replace("$COLOR", color) for k,v in COLORS.items(): message = message.replace("$" + k, COLOR_SEQ % (v+30))\ .replace("$BG" + k, COLOR_SEQ % (v+40))\ .replace("$BG-" + k, COLOR_SEQ % (v+40)) return message + RESET_SEQ logging.ColorFormatter = ColorFormatter
[formatter_colorFormatter] class=logging.ColorFormatter format= $COLOR%(levelname)s $RESET %(asctime)s $BOLD$COLOR%(name)s$RESET %(message)s
import logging import os import sys try: import colorlog except ImportError: pass def setup_logging(): root = logging.getLogger() root.setLevel(logging.DEBUG) format = date_format = if cformat = f = colorlog.ColoredFormatter(cformat, date_format, log_colors = { else: f = logging.Formatter(format, date_format) ch = logging.StreamHandler() ch.setFormatter(f) root.addHandler(ch) setup_logging() log = logging.getLogger(__name__)
log.debug ( log.info ( log.warn ( log.error ( log.critical(
import copy import logging class ColoredConsoleHandler(logging.StreamHandler): def emit(self, record): myrecord = copy.copy(record) levelno = myrecord.levelno if(levelno >= 50): color = elif(levelno >= 40): color = elif(levelno >= 30): color = elif(levelno >= 20): color = elif(levelno >= 10): color = else: color = myrecord.msg = color + str(myrecord.msg) + logging.StreamHandler.emit(self, myrecord)
class ColorFormatter(logging.Formatter): FORMAT = ("[$BOLD%(name)-20s$RESET][%(levelname)-18s] " "%(message)s " "($BOLD%(filename)s$RESET:%(lineno)d)") BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8) RESET_SEQ = "\033[0m" COLOR_SEQ = "\033[1;%dm" BOLD_SEQ = "\033[1m" COLORS = { } def formatter_msg(self, msg, use_color = True): if use_color: msg = msg.replace("$RESET", self.RESET_SEQ).replace("$BOLD", self.BOLD_SEQ) else: msg = msg.replace("$RESET", "").replace("$BOLD", "") return msg def __init__(self, use_color=True): msg = self.formatter_msg(self.FORMAT, use_color) logging.Formatter.__init__(self, msg) self.use_color = use_color def format(self, record): levelname = record.levelname if self.use_color and levelname in self.COLORS: fore_color = 30 + self.COLORS[levelname] levelname_color = self.COLOR_SEQ % fore_color + levelname + self.RESET_SEQ record.levelname = levelname_color return logging.Formatter.format(self, record)
handler.setFormatter(ColorFormatter()) logger.addHandler(handler)
import logging NO_COLOR = "\33[m" RED, GREEN, ORANGE, BLUE, PURPLE, LBLUE, GREY = \ map("\33[%dm".__mod__, range(31, 38)) logging.basicConfig(format="%(message)s", level=logging.DEBUG) logger = logging.getLogger(__name__) def add_color(logger_method, color): def wrapper(message, *args, **kwargs): return logger_method( color+message+NO_COLOR, *args, **kwargs ) return wrapper for level, color in zip(( "info", "warn", "error", "debug"), ( GREEN, ORANGE, RED, BLUE )): setattr(logger, level, add_color(getattr(logger, level), color)) logger.error("Launching %s." % __file__)
def add_color(logger_method, _color): def wrapper(message, *args, **kwargs): color = kwargs.pop("color", _color) if isinstance(color, int): color = "\33[%dm" % color return logger_method( color+message+NO_COLOR, *args, **kwargs ) return wrapper logger.error("Launching %s." % __file__) logger.error("Launching %s." % __file__, color=34) logger.error("Launching %s." % __file__, color=GREY)
import logging import sys colors = { logging.basicConfig(stream=sys.stdout, level=logging.DEBUG) def str_color(color, data): return colors[color] + str(data) + colors[ params = { logging.info(
pip install colout myprocess | colout REGEX_WITH_GROUPS color1,color2...
from copy import copy from logging import Formatter MAPPING = { } PREFIX = SUFFIX = class ColoredFormatter(Formatter): def __init__(self, patern): Formatter.__init__(self, patern) def format(self, record): colored_record = copy(record) levelname = colored_record.levelname seq = MAPPING.get(levelname, 37) colored_levelname = ( .format(PREFIX, seq, levelname, SUFFIX) colored_record.levelname = colored_levelname return Formatter.format(self, colored_record)
import logging from colored_log import ColoredFormatter log = logging.getLogger("main") ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) cf = ColoredFormatter("[%(name)s][%(levelname)s] %(message)s (%(filename)s:%(lineno)d)") ch.setFormatter(cf) log.addHandler(ch) fh = logging.FileHandler( fh.setLevel(logging.DEBUG) ff = logging.Formatter( fh.setFormatter(ff) log.addHandler(fh) log.setLevel(logging.DEBUG) log.debug("app has started") log.info("Logging to log.warning("This is my last warning, take heed") log.error("This is an error") log.critical("He import sub_module
import logging log = logging.getLogger( log.debug("Hello from the sub module")
2017-09-29 00:32:23,434 - main - DEBUG - app has started 2017-09-29 00:32:23,434 - main - INFO - Logging to 2017-09-29 00:32:23,435 - main - WARNING - This is my last warning, take heed 2017-09-29 00:32:23,435 - main - ERROR - This is an error 2017-09-29 00:32:23,435 - main - CRITICAL - He 2017-09-29 00:32:23,435 - main.sub_module - ERROR - Hello from the sub module
class ColouredFormatter(logging.Formatter): RESET = RED = YELLOW = BRGREEN = def format(self, record, colour=False): message = super().format(record) if not colour: return message level_no = record.levelno if level_no >= logging.CRITICAL: colour = self.RED elif level_no >= logging.ERROR: colour = self.RED elif level_no >= logging.WARNING: colour = self.YELLOW elif level_no >= logging.INFO: colour = self.RESET elif level_no >= logging.DEBUG: colour = self.BRGREEN else: colour = self.RESET message = colour + message + self.RESET return message class ColouredHandler(logging.StreamHandler): def __init__(self, stream=sys.stdout): super().__init__(stream) def format(self, record, colour=False): if not isinstance(self.formatter, ColouredFormatter): self.formatter = ColouredFormatter() return self.formatter.format(record, colour) def emit(self, record): stream = self.stream try: msg = self.format(record, stream.isatty()) stream.write(msg) stream.write(self.terminator) self.flush() except Exception: self.handleError(record) h = ColouredHandler() h.formatter = ColouredFormatter( logging.basicConfig(level=logging.DEBUG, handlers=[h])
class ColouredFormatter(logging.Formatter): def __init__(self, msg): logging.Formatter.__init__(self, msg) self._init_colour = _get_colour() def close(self): _set_colour(self._init_colour) def format(self, record): _set_colour( LOG_LEVEL_COLOUR[record.levelno] ) return logging.Formatter.format(self, record) def init(): rootLogger = logging.getLogger() hdlr = logging.StreamHandler() fmt = ColouredFormatter( hdlr.setFormatter(fmt) rootLogger.addHandler(hdlr)
import coloured_log import logging coloured_log.init() logging.info("info") logging.debug("debug") coloured_log.close()
class ColoredFormatter(logging.Formatter): def format(self, record): if record.levelno == logging.WARNING: record.msg = elif record.levelno == logging.ERROR: record.msg = return logging.Formatter.format(self, record)
logger = logging.getLogger( handler = logging.StreamHandler() log_format = time_format = formatter = ColoredFormatter(log_format, datefmt=time_format) handler.setFormatter(formatter) logger.addHandler(handler) logger.warn( logger.error(
[17:01:36]:WARNING:this should be yellow [17:01:37]:ERROR :this should be red
class ColoredFormatter(logging.Formatter): BLACK = RED = GREEN = BROWN = BLUE = PURPLE = CYAN = GREY = DARK_GREY = LIGHT_RED = LIGHT_GREEN = YELLOW = LIGHT_BLUE = LIGHT_PURPLE = LIGHT_CYAN = WHITE = RESET = "\033[0m" def __init__(self, *args, **kwargs): self._colors = {logging.DEBUG: self.DARK_GREY, logging.INFO: self.RESET, logging.WARNING: self.BROWN, logging.ERROR: self.RED, logging.CRITICAL: self.LIGHT_RED} super(ColoredFormatter, self).__init__(*args, **kwargs) def format(self, record): record.msg = self._colors[record.levelno] + record.msg + self.RESET return logging.Formatter.format(self, record) def setLevelColor(self, logging_level, escaped_ansi_code): self._colors[logging_level] = escaped_ansi_code
class ColorizingStreamHandler(logging.StreamHandler): BLACK = RED = GREEN = BROWN = BLUE = PURPLE = CYAN = GREY = DARK_GREY = LIGHT_RED = LIGHT_GREEN = YELLOW = LIGHT_BLUE = LIGHT_PURPLE = LIGHT_CYAN = WHITE = RESET = "\033[0m" def __init__(self, *args, **kwargs): self._colors = {logging.DEBUG: self.DARK_GREY, logging.INFO: self.RESET, logging.WARNING: self.BROWN, logging.ERROR: self.RED, logging.CRITICAL: self.LIGHT_RED} super(ColorizingStreamHandler, self).__init__(*args, **kwargs) @property def is_tty(self): isatty = getattr(self.stream, return isatty and isatty() def emit(self, record): try: message = self.format(record) stream = self.stream if not self.is_tty: stream.write(message) else: message = self._colors[record.levelno] + message + self.RESET stream.write(message) stream.write(getattr(self, self.flush() except (KeyboardInterrupt, SystemExit): raise except: self.handleError(record) def setLevelColor(self, logging_level, escaped_ansi_code): self._colors[logging_level] = escaped_ansi_code
class TerminalColour: MAGENTA = BLUE = GREEN = YELLOW = RED = GREY = WHITE = UNDERLINE =
logging.addLevelName(logging.INFO, "{}{}{}".format(TerminalColour.WHITE, logging.getLevelName(logging.INFO), TerminalColour.GREY)) logging.addLevelName(logging.WARNING, "{}{}{}".format(TerminalColour.YELLOW, logging.getLevelName(logging.WARNING), TerminalColour.GREY)) logging.addLevelName(logging.ERROR, "{}{}{}".format(TerminalColour.RED, logging.getLevelName(logging.ERROR), TerminalColour.GREY)) logging.addLevelName(logging.CRITICAL, "{}{}{}".format(TerminalColour.MAGENTA, logging.getLevelName(logging.CRITICAL), .GREY))
def config_log(log_level): def set_color(level, code): level_fmt = "\033[1;" + str(code) + "m%s\033[1;0m" logging.addLevelName( level, level_fmt % logging.getLevelName(level) ) std_stream = sys.stdout isatty = getattr(std_stream, if isatty and isatty(): levels = [logging.DEBUG, logging.CRITICAL, logging.WARNING, logging.ERROR] for idx, level in enumerate(levels): set_color(level, 30 + idx ) set_color(logging.DEBUG, 0) logging.basicConfig(stream=std_stream, level=log_level)
options, arguments = p.parse_args() log_level = logging.DEBUG if options.verbose else logging.WARNING config_log(log_level)
import logging logging.basicConfig(filename="f.log" filemode= format = "%(logger_name)s %(color)s %(message)s %(endColor)s") class Logger(object): __GREEN = "\033[92m" __RED = __ENDC = def __init__(self, name): self.logger = logging.getLogger(name) self.extra={ def info(self, msg): self.extra[ self.logger.info(msg, extra=self.extra) def error(self, msg): self.extra[ self.logger.error(msg, extra=self.extra)
def reader(): for i in range(4): yield def reader_wrapper(g): for v in g: yield v wrap = reader_wrapper(reader()) for i in wrap: print(i) << 0 << 1 << 2 << 3
def writer_wrapper(coro): pass w = writer() wrap = writer_wrapper(w) wrap.send(None) for i in range(4): wrap.send(i) >> 0 >> 1 >> 2 >> 3
def writer_wrapper(coro): coro.send(None) while True: try: x = (yield) coro.send(x) except StopIteration: pass
class SpamException(Exception): pass def writer(): while True: try: w = (yield) except SpamException: print( else: print(
w = writer() wrap = writer_wrapper(w) wrap.send(None) for i in [0, 1, 2, if i == wrap.throw(SpamException) else: wrap.send(i) >> 0 >> 1 >> 2 *** >> 4 >> 0 >> 1 >> 2 Traceback (most recent call last): ... redacted ... File ... in writer_wrapper x = (yield) __main__.SpamException
def writer_wrapper(coro): coro.send(None) while True: try: try: x = (yield) except Exception as e: coro.throw(e) else: coro.send(x) except StopIteration: pass
def traverse_tree(node): if not node.children: yield node for child in node.children: yield from traverse_tree(child)
def get_list_values(lst): for item in lst: yield int(item) for item in lst: yield str(item) for item in lst: yield float(item)
def get_list_values(lst): for sub in [get_list_values_as_int, get_list_values_as_str, get_list_values_as_float]: yield from sub(lst)
def flatten(sequence): """flatten a multi level list or something >>> list(flatten([1, [2], 3])) [1, 2, 3] >>> list(flatten([1, [2], [3, [4]]])) [1, 2, 3, 4] """ for element in sequence: if hasattr(element, yield from flatten(element) else: yield element print(list(flatten([1, [2], [3, [4]]])))
def chain(*iters): for it in iters: for item in it: yield item def chain(*iters): for it in iters: yield from it
>>> print simplejson.dumps(ss) >>> print >> file( >>> simplejson.load(open( u
>>>import io >>>f = io.open("test", mode="r", encoding="utf-8")
>>>import codecs >>>f = codecs.open("test", "r", "utf-8")
open(file, mode= encoding=None, errors=None, newline=None, closefd=True, opener=None)
import codecs import commands file_location = "jumper.sub" file_encoding = commands.getoutput( file_stream = codecs.open(file_location, file_output = codecs.open(file_location+"b", for l in file_stream: file_output.write(l) file_stream.close() file_output.close()
import codecs f = codecs.open( for line in f: print(line)
0000000: 4361 7069 745c 7863 335c 7861 316e Capit\xc3\xa1n
import io text = u encoding = with io.open( fout.write(text) with io.open( text2 = fin.read() assert text == text2
>>> s = file("f1").read() >>> print unicode(s, "Latin-1") CapitÃ¡n
import codecs import functools open = functools.partial(codecs.open, encoding=
Traceback (most recent call last): File "ical.py", line 92, in parse print "{}".format(e[attr]) UnicodeEncodeError:
df= gi ptt_loc 0 384444683 593 1 384444684 594 2 384444686 596
df= index1 gi ptt_loc 0 0 384444683 593 1 1 384444684 594 2 2 384444686 596
>>> df val tick tag obs 2016-02-26 C 2 0.0139 2016-02-27 A 2 0.5577 2016-02-28 C 6 0.0303
>>> df.reset_index(level=[ tick obs val tag C 2016-02-26 2 0.0139 A 2016-02-27 2 0.5577 C 2016-02-28 6 0.0303
index = pd.MultiIndex.from_product([[ [ names=[ df = pd.DataFrame(index=index, data=np.random.randint(0, 10, (6,4)), columns=list(
df.assign(State=df.index.get_level_values( df.assign(**df.index.to_frame())
print(df) gi ptt_loc 0 384444683 593 4 384444684 594 9 384444686 596 print(df.reset_index()) index gi ptt_loc 0 0 384444683 593 1 4 384444684 594 2 9 384444686 596 print(df.reset_index().set_index( index gi ptt_loc index 0 0 384444683 593 4 4 384444684 594 9 9 384444686 596
df2 = df.reset_index().set_index( df2.index.name = None print(df2) index gi ptt_loc 0 0 384444683 593 4 4 384444684 594 9 9 384444686 596
python -m pip install --upgrade pip pip install "package-name"
sudo apt-get install python-psycopg2 python-mysqldb
sudo apt-get install python-setuptools python-dev build-essential
sudo apt install python-pip python-bluez libbluetooth-dev libboost-python-dev libboost-thread-dev libglib2.0-dev bluez bluez-hcidump
>>> a={"1":"one","2":"two"} >>> a.has_key("1") True
>>> timeit.timeit(" 0.04869917374131205 >>> timeit.timeit(" 0.06144205736110564
>>> timeit.timeit(" 0.04866674801541748 >>> timeit.timeit(" 0.06565782838087131 >>> timeit.timeit(" 0.08975995576448526 >>> timeit.timeit(" 0.12992391047427532
min(Timer("x == x", setup="x = min(Timer("x == y", setup="x =
TARGET(COMPARE_OP) { PyObject *right = POP(); PyObject *left = TOP(); PyObject *res = cmp_outcome(oparg, left, right); Py_DECREF(left); Py_DECREF(right); SET_TOP(res); if (res == NULL) goto error; PREDICT(POP_JUMP_IF_FALSE); PREDICT(POP_JUMP_IF_TRUE); DISPATCH(); }
static PyObject * cmp_outcome(int op, PyObject *v, PyObject *w) { int res = 0; switch (op) { case PyCmp_IS: ... case PyCmp_IS_NOT: ... case PyCmp_IN: res = PySequence_Contains(w, v); if (res < 0) return NULL; break; case PyCmp_NOT_IN: ... case PyCmp_EXC_MATCH: ... default: return PyObject_RichCompare(v, w, op); } v = res ? Py_True : Py_False; Py_INCREF(v); return v; }
int PySequence_Contains(PyObject *seq, PyObject *ob) { Py_ssize_t result; PySequenceMethods *sqm = seq->ob_type->tp_as_sequence; if (sqm != NULL && sqm->sq_contains != NULL) return (*sqm->sq_contains)(seq, ob); result = _PySequence_IterSearch(seq, ob, PY_ITERSEARCH_CONTAINS); return Py_SAFE_DOWNCAST(result, Py_ssize_t, int); }
static PySequenceMethods tuple_as_sequence = { ... (objobjproc)tuplecontains, }; PyTypeObject PyTuple_Type = { ... &tuple_as_sequence, ... };
static int tuplecontains(PyTupleObject *a, PyObject *el) { Py_ssize_t i; int cmp; for (i = 0, cmp = 0 ; cmp == 0 && i < Py_SIZE(a); ++i) cmp = PyObject_RichCompareBool(el, PyTuple_GET_ITEM(a, i), Py_EQ); return cmp; }
int PyObject_RichCompareBool(PyObject *v, PyObject *w, int op) { PyObject *res; int ok; if (v == w) { if (op == Py_EQ) return 1; else if (op == Py_NE) return 0; } ... }
PyObject * PyObject_RichCompare(PyObject *v, PyObject *w, int op) { PyObject *res; assert(Py_LT <= op && op <= Py_GE); if (v == NULL || w == NULL) { ... } if (Py_EnterRecursiveCall(" in comparison")) return NULL; res = do_richcompare(v, w, op); Py_LeaveRecursiveCall(); return res; }
static PyObject * do_richcompare(PyObject *v, PyObject *w, int op) { richcmpfunc f; PyObject *res; int checked_reverse_op = 0; if (v->ob_type != w->ob_type && ...) { ... } if ((f = v->ob_type->tp_richcompare) != NULL) { res = (*f)(v, w, op); if (res != Py_NotImplemented) return res; ... } ... }
PyTypeObject PyUnicode_Type = { ... PyUnicode_RichCompare, ... };
PyObject * PyUnicode_RichCompare(PyObject *left, PyObject *right, int op) { int result; PyObject *v; if (!PyUnicode_Check(left) || !PyUnicode_Check(right)) Py_RETURN_NOTIMPLEMENTED; if (PyUnicode_READY(left) == -1 || PyUnicode_READY(right) == -1) return NULL; if (left == right) { switch (op) { case Py_EQ: case Py_LE: case Py_GE: v = Py_True; break; case Py_NE: case Py_LT: case Py_GT: v = Py_False; break; default: ... } } else if (...) { ... } else { ...} Py_INCREF(v); return v; }
if (!PyUnicode_Check(left) || !PyUnicode_Check(right)) if (PyUnicode_READY(left) == -1 || PyUnicode_READY(right) == -1)
POP() TOP() # # case PyCmp_IN: # sqm != NULL sqm->sq_contains != NULL # *sqm->sq_contains # # cmp == 0 i < Py_SIZE(a) # v == w # op == Py_EQ # ++i cmp == 0 # # res < 0 res ? Py_True : Py_False # Py_INCREF(v) # # Py_DECREF(left) Py_DECREF(right) # SET_TOP(res) # res == NULL # DISPATCH() #
POP() TOP() # # default: # Py_LT <= op op <= Py_GE # v == NULL # w == NULL # Py_EnterRecursiveCall(...) # v->ob_type != w->ob_type f = v->ob_type->tp_richcompare f != NULL # # !PyUnicode_Check(left) !PyUnicode_Check(right)) # PyUnicode_READY(left) == -1 # PyUnicode_READY(right) == -1 # left == right case Py_EQ: Py_INCREF(v); # # res != Py_NotImplemented # # Py_LeaveRecursiveCall() # Py_DECREF(left) Py_DECREF(right) # SET_TOP(res) # res == NULL # DISPATCH() #
>>> n = float( >>> n in (n, ) True >>> n == n False >>> n is n True
In [18]: %timeit 10000000 loops, best of 3: 65.2 ns per loop In [19]: %timeit 10000000 loops, best of 3: 68 ns per loop In [20]: %timeit 10000000 loops, best of 3: 73.4 ns per loop In [21]: %timeit 10000000 loops, best of 3: 56.2 ns per loop
In [48]: a = 1 In [49]: b = 2 In [50]: %timeit a is a or a == a 10000000 loops, best of 3: 95.1 ns per loop In [51]: %timeit a in (a, ) 10000000 loops, best of 3: 140 ns per loop In [52]: %timeit a is b or a == b 10000000 loops, best of 3: 177 ns per loop In [53]: %timeit a in (b, ) 10000000 loops, best of 3: 169 ns per loop
>>> import timeit >>> setup = import random random.seed( s = [random.random() for i in range(1000)] timsort = list.sort >>> print min(timeit.Timer( 0.334147930145
In [1]: def f(x): ...: return x*x ...: In [2]: %timeit for x in range(100): f(x) 100000 loops, best of 3: 20.3 us per loop
>>> def f(x): ... return x * x ... >>> import timeit >>> timeit.repeat("for x in range(100): f(x)", "from __main__ import f", number=100000) [2.0640320777893066, 2.0876040458679199, 2.0520210266113281]
%~> python -m timeit "1 + 2" 10000000 loops, best of 3: 0.0468 usec per loop
%~> python -m timeit -s "x = range(10000)" "sum(x)" 1000 loops, best of 3: 543 usec per loop
%~> python -m timeit -s "x = range(10000)" -s "y = range(100)" "sum(x)" "min(y)" 1000 loops, best of 3: 554 usec per loop
SETUP=" ... " echo Minmod arr1 python -m timeit -s "$SETUP" "Minmod(arr1)" echo pure_minmod arr1 python -m timeit -s "$SETUP" "pure_minmod(arr1)" echo better_minmod arr1 python -m timeit -s "$SETUP" "better_minmod(arr1)" ... etc
def function(...): ... timeit.Timer(function).timeit(number=NUMBER)
min(timeit.Timer(function).repeat(repeat=REPEATS, number=NUMBER))
from functools import partial def to_time(items): ... test_items = [1, 2, 3] * 100 times = timeit.Timer(partial(to_time, test_items)).repeat(3, 1000) time_taken = min(times) / 1000
timeit.timeit("...", setup="from __main__ import ...", number=NUMBER)
>>> python -m timeit -s "x = 0" "x += 1" 10000000 loops, best of 3: 0.0476 usec per loop
>>> python -m timeit -s "x = 0" "" 100000000 loops, best of 3: 0.014 usec per loop
>>> python -m timeit -s "x = 0" "x" 100000000 loops, best of 3: 0.0166 usec per loop
>>> python -m timeit -s "x = [0]*100000" "while x: x.pop()" 10000000 loops, best of 3: 0.0436 usec per loop
>>> python -m timeit "x = [0]*100000" "while x: x.pop()" 100 loops, best of 3: 9.79 msec per loop
>>> python -m timeit "x = [0]*100000" 1000 loops, best of 3: 261 usec per loop
import timeit start_time = timeit.default_timer() func1() print(timeit.default_timer() - start_time) start_time = timeit.default_timer() func2() print(timeit.default_timer() - start_time)
def gen_prime(x): multiples = [] results = [] for i in range(2, x+1): if i not in multiples: results.append(i) for j in range(i*i, x+1, i): multiples.append(j) return results import timeit start_time = timeit.default_timer() gen_prime(3000) print(timeit.default_timer() - start_time)
import timeit def foo(): print("here is my code to time...") timeit.timeit(stmt=foo, number=1234567)
import timeit print(timeit.timeit(""" limit = 10000 prime_list = [i for i in range(2, limit+1)] for prime in prime_list: for elem in range(prime*2, max(prime_list)+1, prime): if elem in prime_list: prime_list.remove(elem)""" , number=10))
from timeit import default_timer as timer import sys def timefunc(func, *args, **kwargs): """Time a function. args: iterations=3 Usage example: timeit(myfunc, 1, b=2) """ try: iterations = kwargs.pop( except KeyError: iterations = 3 elapsed = sys.maxsize for _ in range(iterations): start = timer() result = func(*args, **kwargs) elapsed = min(timer() - start, elapsed) print(( return result
>>> import timeit >>> def naive_func(x): ... a = 0 ... for i in range(a): ... a += i ... return a >>> def wrapper(func, *args, **kwargs): ... def wrapper(): ... return func(*args, **kwargs) ... return wrapper >>> wrapped = wrapper(naive_func, 1_000) >>> timeit.timeit(wrapped, number=1_000_000) 0.4458435332577161
!/usr/local/bin/python3 import timeit def fibonacci(n): if(n == 0): result = 0 elif(n == 1): result = 1 else: result = fibonacci(n-1) + fibonacci(n-2) return result if __name__ == import timeit t1 = timeit.Timer("fibonacci(13)", "from __main__ import fibonacci") print("fibonacci ran:",t1.timeit(number=1000), "milliseconds")
Date,Open,High,Low,Close,Volume,Adj Close 2011-10-19,27.37,27.47,27.01,27.13,42880000,27.13 2011-10-18,26.94,27.40,26.80,27.31,52487900,27.31 2011-10-17,27.11,27.42,26.85,26.98,39433400,26.98 2011-10-14,27.31,27.50,27.02,27.27,50947700,27.27 ....
from pandas import * df = read_csv( for i, row in enumerate(df.values): date = df.index[i] open, high, low, close, adjclose = row
pct_change = [] for row in close: pct_change.append(...)
def my_algo(ndarray[object] dates, ndarray[float64_t] open, ndarray[float64_t] low, ndarray[float64_t] high, ndarray[float64_t] close, ndarray[float64_t] volume): cdef: Py_ssize_t i, n float64_t foo n = len(dates) for i from 0 <= i < n: foo = close[i] - open[i]
t = pd.DataFrame({ B = [] C = [] A = time.time() for i,r in t.iterrows(): C.append((r[ B.append(time.time()-A) C = [] A = time.time() for ir in t.itertuples(): C.append((ir[1], ir[2])) B.append(time.time()-A) C = [] A = time.time() for r in zip(t[ C.append((r[0], r[1])) B.append(time.time()-A) print B
[0.5639059543609619, 0.017839908599853516, 0.005645036697387695]
df[b] = df[a].apply(lambda col: do stuff with col here)
>>> for index in df.index: ... print ("df[" + str(index) + "][
>>> for index, row in df.iterrows(): ... print ("df[" + str(index) + "][
>>> for row in df.itertuples(): ... print ("df[" + str(row.Index) + "][
>>> df = pd.DataFrame({ index=[ >>> df col1 col2 a 1 0.1 b 2 0.2 >>> for row in df.itertuples(): ... print(row.col1, row.col2) ... 1, 0.1 2, 0.2
index = df.index.values column_of_interest1 = df.column_name1.values ... column_of_interestk = df.column_namek.values for i in range(df.shape[0]): index_value = index[i] ... column_value_k = column_of_interest_k[i]
tf.nn.softmax(logits, name=None) tf.nn.softmax_cross_entropy_with_logits(logits, labels, name=None)
a = tf.constant(np.array([[.1, .3, .5, .9]])) print s.run(tf.nn.softmax(a)) [[ 0.16838508 0.205666 0.25120102 0.37474789]]
y_hat_softmax = tf.nn.softmax(y_hat) total_loss = tf.reduce_mean(-tf.reduce_sum(y_true * tf.log(y_hat_softmax), [1]))
total_loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(y_hat, y_true))
import tensorflow as tf import numpy as np sess = tf.Session() y_hat = tf.convert_to_tensor(np.array([[0.5, 1.5, 0.1],[2.2, 1.3, 1.7]])) sess.run(y_hat)
y_hat_softmax = tf.nn.softmax(y_hat) sess.run(y_hat_softmax)
Pr(Class 1) Pr(Class 2) Pr(Class 3) ,-------------------------------------- Training instance 1 | 0.227863 | 0.61939586 | 0.15274114 Training instance 2 | 0.49674623 | 0.20196195 | 0.30129182
y_true = tf.convert_to_tensor(np.array([[0.0, 1.0, 0.0],[0.0, 0.0, 1.0]])) sess.run(y_true)
loss_per_instance_1 = -tf.reduce_sum(y_true * tf.log(y_hat_softmax), reduction_indices=[1]) sess.run(loss_per_instance_1)
total_loss_1 = tf.reduce_mean(-tf.reduce_sum(y_true * tf.log(y_hat_softmax), reduction_indices=[1])) sess.run(total_loss_1)
loss_per_instance_2 = tf.nn.softmax_cross_entropy_with_logits(y_hat, y_true) sess.run(loss_per_instance_2) total_loss_2 = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(y_hat, y_true)) sess.run(total_loss_2)
string = "test test test test" print string.find( print string.rfind( print string.find_all(
>>> help(str.find) Help on method_descriptor: find(...) S.find(sub [,start [,end]]) -> int
def find_all(a_str, sub): start = 0 while True: start = a_str.find(sub, start) if start == -1: return yield start start += len(sub) list(find_all(
>>> string = "test test test test" >>> [i for i in range(len(string)) if string.startswith( [0, 5, 10, 15]
>>> import re >>> aString = >>> print [(a.start(), a.end()) for a in list(re.finditer( [(2, 4), (5, 7), (38, 40), (42, 44)]
In [1]: aString="ababa" In [2]: print [(a.start(), a.end()) for a in list(re.finditer( Output: [(0, 3)]
def locations_of_substring(string, substring): substring_length = len(substring) def recurse(locations_found, start): location = string.find(substring, start) if location != -1: return recurse(locations_found + [location], location+substring_length) else: return locations_found return recurse([], 0) print(locations_of_substring(
def findall(p, s): the pattern p in the string s. i = s.find(p) while i != -1: yield i i = s.find(p, i+1)
string = "dooobiedoobiedoobie" match = reduce(lambda count, char: count + 1 if char == match else count, string, 0)
string = "test test test test" match = "test" len(string.split(match)) - 1
def find_all(a_string, sub): result = [] k = 0 while k < len(a_string): k = a_string.find(sub, k) if k == -1: return result else: result.append(k) k += 1 return result
numberString = "onetwothreefourfivesixseveneightninefiveten" testString = "five" marker = 0 while marker < len(numberString): try: print(numberString.index("five",marker)) marker = numberString.index("five", marker) + 1 except ValueError: print("String not found") marker = len(numberString)
def find_all(string,substring): length = len(substring) c=0 indexes = [] while c < len(string): if string[c:c+length] == substring: indexes.append(c) c=c+1 return indexes
class newstr(str): def find_all(string,substring): length = len(substring) c=0 indexes = [] while c < len(string): if string[c:c+length] == substring: indexes.append(c) c=c+1 return indexes
>>> string = "test test test test" >>> for index,value in enumerate(string): if string[index:index+(len("test"))] == "test": print index 0 5 10 15
import re text = find_the_word = re.finditer( for match in find_the_word: print( format(match.start(), match.end(), match.group()))
from flashtext import KeywordProcessor words = [ txt = kwp = KeywordProcessor() kwp.add_keywords_from_list(words) result = kwp.extract_keywords(txt, span_info=True)
mystring = find_all = lambda c,s: [x for x in range(c.find(s), len(c)) if c[x] == s] find_all(mystring, [4, 7, 20, 26] >>>
def get_substring_indices(text, s): result = [i for i in range(len(text)) if text.startswith(s, i)] return result if __name__ == text = "How much wood would a wood chuck chuck if a wood chuck could chuck wood?" s = print get_substring_indices(text, s)
>>> def fun(i): ... print "executed" ... return i ...
>>> fun(1) executed 1 >>> 1 or fun(1) 1 >>> 1 and fun(1) executed 1 >>> 0 and fun(1) 0
>>> any(fun(i) for i in [1, 2, 3, 4]) executed True >>> any(fun(i) for i in [0, 2, 3, 4]) executed executed True >>> any(fun(i) for i in [0, 0, 3, 4]) executed executed executed True
>>> all(fun(i) for i in [0, 0, 3, 4]) executed False >>> all(fun(i) for i in [1, 0, 3, 4]) executed executed False
>>> 5 > 6 > fun(3) False >>> 5 < 6 > fun(3) executed True >>> 4 <= 6 > fun(7) executed False >>> 5 < fun(6) < 3 executed False >>> 5 < fun(6) and fun(6) < 3 executed executed False
In [171]: name = raw_input( Enter Name: In [172]: name Out[172]:
>>>False and 3/0 False >>>True and 3/0 ZeroDivisionError: integer division or modulo by zero
>>>True or 3/0 True >>>False or 3/0 ZeroDivisionError: integer division or modulo by zero
from argparse import ArgumentParser parser = ArgumentParser(description= parser.add_argument( help="Some option, where\n" " a = alpha\n" " b = beta\n" " g = gamma\n" " d = delta\n" " e = epsilon") parser.parse_args()
from argparse import RawTextHelpFormatter parser = ArgumentParser(description=
import argparse class SmartFormatter(argparse.HelpFormatter): def _split_lines(self, text, width): if text.startswith( return text[2:].splitlines() return argparse.HelpFormatter._split_lines(self, text, width)
from argparse import ArgumentParser parser = ArgumentParser(description= parser.add_argument( help="R|Some option, where\n" " a = alpha\n" " b = beta\n" " g = gamma\n" " d = delta\n" " e = epsilon") parser.parse_args()
import argparse, textwrap parser = argparse.ArgumentParser(description= usage= formatter_class=argparse.RawTextHelpFormatter) parser.add_argument( help= textwrap.dedent( First line Second line More lines ...
usage: use "python your_python_program.py --help" for more information Prepare input file optional arguments: -h, --help show this help message and exit --argument ARGUMENT First line Second line More lines ...
parser = ArgumentParser(description= , usage= formatter_class=RawTextHelpFormatter) options = parser.parse_args()
import textwrap as _textwrap class MultilineFormatter(argparse.HelpFormatter): def _fill_text(self, text, width, indent): text = self._whitespace_matcher.sub( paragraphs = text.split( multiline_text = for paragraph in paragraphs: formatted_paragraph = _textwrap.fill(paragraph, width, initial_indent=indent, subsequent_indent=indent) + multiline_text = multiline_text + formatted_paragraph return multiline_text
def _fill_text(self, text, width, indent): text = self._whitespace_matcher.sub( return _textwrap.fill(text, width, initial_indent=indent, subsequent_indent=indent)
parser = ArgumentParser(description= , usage= formatter_class=MultilineFormatter) options = parser.parse_args()
import argparse from argparse import RawDescriptionHelpFormatter class SmartDescriptionFormatter(argparse.RawDescriptionHelpFormatter): def _fill_text(self, text, width, indent): if text.startswith( paragraphs = text[2:].splitlines() rebroken = [argparse._textwrap.wrap(tpar, width) for tpar in paragraphs] rebrokenstr = [] for tlinearr in rebroken: if (len(tlinearr) == 0): rebrokenstr.append("") else: for tlinepiece in tlinearr: rebrokenstr.append(tlinepiece) return return argparse.RawDescriptionHelpFormatter._fill_text(self, text, width, indent) parser = argparse.ArgumentParser(formatter_class=SmartDescriptionFormatter, description="""R|Blahbla bla blah blahh/blahbla (bla blah-blabla) a blahblah bl a blaha-blah .blah blah Blah blah bla blahblah, bla blahblah blah blah bl blblah bl blahb; blah bl blah bl bl a blah, bla blahb bl: blah blahblah blah bl blah blahblah""") options = parser.parse_args()
def askForNumber (): while True: try: return int(input( except ValueError: pass
BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- ModuleNotFoundError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError | +-- UnboundLocalError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- ReferenceError +-- RuntimeError | +-- NotImplementedError | +-- RecursionError +-- SyntaxError | +-- IndentationError | +-- TabError +-- SystemError +-- TypeError +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- ResourceWarning
try: foo = operation_that_includes_int(foo) except ValueError as e: if fatal_condition(): logging.info(e) raise else: foo = 0
fruits = [ found = False try: for i in range(len(fruit)): if fruits[i] == found = true except: pass if found: print "Found an apple" else: print "No apples in list"
try: except BaseException as e: if isinstance(e, Error1): elif isinstance(e, Error2): ... else: raise
soup = BeautifulSoup(sdata) mydivs = soup.findAll( for div in mydivs: if (div["class"]=="stylelistrow"): print div
File "./beautifulcoding.py", line 130, in getlanguage if (div["class"]=="stylelistrow"): File "/usr/local/lib/python2.6/dist-packages/BeautifulSoup.py", line 599, in __getitem__ return self._getAttrMap()[key] KeyError:
mydivs = soup.findAll("div", {"class": "stylelistrow"})
soup.find_all("div", class_="stylelistrowone stylelistrowtwo")
soup.find_all("html_element", class_="your_class_name")
soup = BeautifulSoup(sdata) for each_div in soup.findAll( print each_div
<div class="stylelistrow"> <div class="stylelistrow button"> <div class="button stylelistrow">
soup = BeautifulSoup(sdata) class_list = ["stylelistrow"] mydivs = soup.find_all(
soup = BeautifulSoup(sdata) mydivs = soup.findAll( for div in mydivs: if "class" in div: if (div["class"]=="stylelistrow"): print div
for hit in soup.findAll(name= print hit.contents[1][
for div in mydivs: try: clazz = div["class"] except KeyError: clazz = "" if (clazz == "stylelistrow"): print div
import matplotlib.pyplot as plt plt.figure(1, figsize = (8.5,11)) plt.suptitle( ax = [] aPlot = plt.subplot(321, axisbg = ax.append(aPlot) plt.plot(paramValues,plotDataPrice[0], color = marker = plt.xticks(paramValues) plt.ylabel( plt.xlabel( plt.grid(True) plt.ylim((25,250))
axes = plt.gca() axes.set_xlim([xmin,xmax]) axes.set_ylim([ymin,ymax])
from matplotlib import pyplot as plt plt.axis([0, 10, 0, 20])
import numpy as np fig, axes = plt.subplot() axes.plot(data[:,0], data[:,1]) xlim = axes.get_xlim() factor = 0.1 new_xlim = (xlim[0] + xlim[1])/2 + np.array((-0.5, 0.5)) * (xlim[1] - xlim[0]) * (1 + factor) axes.set_xlim(new_xlim)
import sys import StringIO codeOut = StringIO.StringIO() codeErr = StringIO.StringIO() code = """ def f(x): x = x + 1 return x print """ sys.stdout = codeOut sys.stderr = codeErr exec code sys.stdout = sys.__stdout__ sys.stderr = sys.__stderr__ print f(4) s = codeErr.getvalue() print "error:\n%s\n" % s s = codeOut.getvalue() print "output:\n%s" % s codeOut.close() codeErr.close()
public_variable = 10 private_variable = 2 def public_function(): return "public information" def private_function(): return "super sensitive information" safe_list = [ safe_dict = dict([ (k, locals().get(k, None)) for k in safe_list ]) safe_dict[ >>> eval("public_variable+2", {"__builtins__" : None }, safe_dict) 12 >>> eval("private_variable+2", {"__builtins__" : None }, safe_dict) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1, in <module> NameError: name >>> exec("print \" >>> exec("print \" Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1, in <module> NameError: name
import imp def get_customer_module(customerName= lm = None try: module_name = customerName+"_"+name; m = imp.find_module(module_name, [ lm = imp.load_module(module_name, m[0], m[1], m[2]) except: return lm m = get_customer_module(customerName, "filter") if m is not None: m.apply_address_filter(myobj)
import datetime print (datetime.date.today() + datetime.timedelta(6*365/12)).isoformat()
from datetime import date from dateutil.relativedelta import relativedelta six_months = date.today() + relativedelta(months=+6)
$ date(2010,12,31)+relativedelta(months=+1) datetime.date(2011, 1, 31) $ date(2010,12,31)+relativedelta(months=+2) datetime.date(2011, 2, 28)
(day, month, year) = (day, (month+6)%12, year+(month+6)/12)
from datetime import timedelta from dateutil.relativedelta import relativedelta end_date = start_date + relativedelta(months=delta_period) + timedelta(days=-delta_period)
import mx.DateTime as dt dt.now()+dt.RelativeDateTime(months=6) dt.now()+dt.RelativeDateTime(days=30*6)
def AddMonths(d,x): newmonth = ((( d.month - 1) + x ) % 12 ) + 1 newyear = d.year + ((( d.month - 1) + x ) / 12 ) return datetime.date( newyear, newmonth, d.day)
>>> import datetime >>> AddMonths(datetime.datetime(2010,8,25),1) datetime.date(2010, 9, 25) >>> AddMonths(datetime.datetime(2010,8,25),4) datetime.date(2010, 12, 25) >>> AddMonths(datetime.datetime(2010,8,25),5) datetime.date(2011, 1, 25) >>> AddMonths(datetime.datetime(2010,8,25),13) datetime.date(2011, 9, 25) >>> AddMonths(datetime.datetime(2010,8,25),24) datetime.date(2012, 8, 25) >>> AddMonths(datetime.datetime(2010,8,25),-1) datetime.date(2010, 7, 25) >>> AddMonths(datetime.datetime(2010,8,25),0) datetime.date(2010, 8, 25) >>> AddMonths(datetime.datetime(2010,8,25),-12) datetime.date(2009, 8, 25) >>> AddMonths(datetime.datetime(2010,8,25),-8) datetime.date(2009, 12, 25) >>> AddMonths(datetime.datetime(2010,8,25),-7) datetime.date(2010, 1, 25)>>>
import calendar date = datetime.date.today() datetime.timedelta(days=calendar.monthrange(date.year,date.month)[1])
>>> import datetime >>> from dateutil.relativedelta import relativedelta >>> today = datetime.datetime.today() >>> month_count = 0 >>> while month_count < 12: ... day = today - relativedelta(months=month_count) ... print day ... month_count += 1 ... 2010-07-07 10:51:45.187968 2010-06-07 10:51:45.187968 2010-05-07 10:51:45.187968 2010-04-07 10:51:45.187968 2010-03-07 10:51:45.187968 2010-02-07 10:51:45.187968 2010-01-07 10:51:45.187968 2009-12-07 10:51:45.187968 2009-11-07 10:51:45.187968 2009-10-07 10:51:45.187968 2009-09-07 10:51:45.187968 2009-08-07 10:51:45.187968
from datetime import datetime, timedelta from dateutil.relativedelta import * date = datetime.now() print(date) date = date + relativedelta(months=+6) print(date)
import datetime def in_the_future(months=1): year, month, day = datetime.date.today().timetuple()[:3] new_month = month + months return datetime.date(year + (new_month / 12), new_month % 12, day)
import datetime import calendar def add_months(date, months): months_count = date.month + months year = date.year + int(months_count / 12) month = (months_count % 12) if month == 0: month = 12 day = date.day last_day_of_month = calendar.monthrange(year, month)[1] if day > last_day_of_month: day = last_day_of_month new_date = datetime.date(year, month, day) return new_date
>>>date = datetime.date(2018, 11, 30) >>>print(date, add_months(date, 3)) (datetime.date(2018, 11, 30), datetime.date(2019, 2, 28)) >>>print(date, add_months(date, 14)) (datetime.date(2018, 12, 31), datetime.date(2020, 2, 29))
def add_months(start_date, months): import calendar year = start_date.year + (months / 12) month = start_date.month + (months % 12) day = start_date.day if month > 12: month = month % 12 year = year + 1 days_next = calendar.monthrange(year, month)[1] if day > days_next: day = days_next return start_date.replace(year, month, day)
>>>from PyQt4.QtCore import QDate >>>dt = QDate(2009,12,31) >>>required = dt.addMonths(6) >>>required PyQt4.QtCore.QDate(2010, 6, 30) >>>required.toPyDate() datetime.date(2010, 6, 30)
def AddMonths(d,x): days_of_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] newmonth = ((( d.month() - 1) + x ) % 12 ) + 1 newyear = d.year() + ((( d.month() - 1) + x ) if d.day() > days_of_month[newmonth-1]: newday = days_of_month[newmonth-1] else: newday = d.day() return DateTime( newyear, newmonth, newday)
import time def add_month(start_time, months): ret = time.strptime(start_time, t = list(ret) t[1] += months if t[1] > 12: t[0] += 1 + int(months / 12) t[1] %= 12 return int(time.mktime(tuple(t)))
import datetime today = datetime.date.today() six_months_from_today = datetime.date(today.year + (today.month + 6)/12, (today.month + 6) % 12, today.day)
day = datetime.date(2015, 3, 10) print day >>> 2015-03-10 print (day + datetime.timedelta(6*365/12)) >>> 2015-09-08
import calendar from datetime import datetime moths2add = 6 now = datetime.now() current_year = now.year current_month = now.month days = sum( [calendar.monthrange(current_year, elem)[1] for elem in range(current_month, current_month + moths)] ) print now + days
def addMonth(d,months=1): year, month, day = d.timetuple()[:3] new_month = month + months return datetime.date(year + ((new_month-1) / 12), (new_month-1) % 12 +1, day)
def add_months(d, months): return d.replace(year=d.year+months
def add_months(d, months): for i in range(4): day = d.day - i try: return d.replace(day=day).replace(year=d.year+int(months) except: pass raise Exception("should not happen")
import time, calendar from datetime import date import parsedatetime as pdt def print_todays_date(): todays_day_of_week = calendar.day_name[date.today().weekday()] print "today time.strftime( def convert_date(natural_language_date): cal = pdt.Calendar() (struct_time_date, success) = cal.parse(natural_language_date) if success: formal_date = time.strftime( else: formal_date = print print_todays_date() convert_date(
$ ./parsedatetime_simple.py today 6 months -> 2015-11-13 $
def add_months(date, months, endOfMonthBehaviour= assert endOfMonthBehaviour in [ year = date.year + (date.month + months - 1) / 12 month = (date.month + months - 1) % 12 + 1 day = date.day last = monthrange(year, month)[1] if day > last: if endOfMonthBehaviour == endOfMonthBehaviour == endOfMonthBehaviour == day = last elif endOfMonthBehaviour == endOfMonthBehaviour == endOfMonthBehaviour == month += 1 day = 1 return datetime.date(year, month, day) >>> from calendar import monthrange >>> import datetime >>> add_months(datetime.datetime(2016, 1, 31), 1) datetime.date(2016, 3, 1) >>> add_months(datetime.datetime(2016, 1, 31), -2) datetime.date(2015, 12, 1) >>> add_months(datetime.datetime(2016, 1, 31), -2, datetime.date(2015, 11, 30)
date=datetime.datetime(year=date.year+int((date.month+6)/12), month=(date.month+6)%13 + (1 if (date.month + months>12) else 0), day=date.day)
import datetime month_dt = 4 today = datetime.date.today() y,m = today.year, today.month m += month_dt-1 year_dt = m new_month = m%12 new_date = datetime.date(y+year_dt, new_month+1, 1)
def replace_month_year(date1, year2, month2): try: date2 = date1.replace(month = month2, year = year2) except: date2 = datetime.date(year2, month2 + 1, 1) - datetime.timedelta(days=1) return date2
new_year = my_date.year + (my_date.month + 6) / 12 new_month = (my_date.month + 6) % 12 new_date = replace_month_year(my_date, new_year, new_month)
import datetime today = datetime.date.today() def addMonths(dt, months = 0): new_month = months + dt.month year_inc = 0 if new_month>12: year_inc +=1 new_month -=12 return dt.replace(month = new_month, year = dt.year+year_inc) newdate = addMonths(today, 6)
import datetime Created on 2011-03-09 @author: tonydiep def add_business_months(start_date, months_to_add): """ Add months in the way business people think of months. Jan 31, 2011 + 1 month = Feb 28, 2011 to business people Method: Add the number of months, roll back the date until it becomes a valid date """ years_change = months_to_add / 12 if (start_date.month + (months_to_add % 12) > 12 ): years_change = years_change + 1 new_year = start_date.year + years_change work = months_to_add % 12 if 0 == work: new_month = start_date.month else: new_month = (start_date.month + (work % 12)) % 12 if 0 == new_month: new_month = 12 new_day = start_date.day if(new_day in [31, 30, 29, 28]): new_day = 31 new_date = None while (None == new_date and 27 < new_day): try: new_date = start_date.replace(year=new_year, month=new_month, day=new_day) except: new_day = new_day - 1 return new_date if __name__ == dates = [datetime.date(2011, 1, 31), datetime.date(2011, 2, 28), datetime.date(2011, 3, 28), datetime.date(2011, 4, 28), datetime.date(2011, 5, 28), datetime.date(2011, 6, 28), datetime.date(2011, 7, 28), datetime.date(2011, 8, 28), datetime.date(2011, 9, 28), datetime.date(2011, 10, 28), datetime.date(2011, 11, 28), datetime.date(2011, 12, 28), ] months = range(1, 24) for start_date in dates: for m in months: end_date = add_business_months(start_date, m) print("%s\t%s\t%s" %(start_date, end_date, m))
├── simulate.py ├── src │ ├── networkAlgorithm.py │ ├── ...
import sys import os.path sys.path.insert(0, "./src") from networkAlgorithm import *
├── MyDirectory │ └── simulate.py ├── src │ ├── networkAlgorithm.py │ ├── ...
$ pip install psycopg2 Downloading/unpacking psycopg2 Downloading psycopg2-2.5.2.tar.gz (685kB): 685kB downloaded Running setup.py (path:/private/var/folders/0z/ljjwsjmn4v9_zwm81vhxj69m0000gn/T/pip_build_tino/psycopg2/setup.py) egg_info for package psycopg2 Installing collected packages: psycopg2 Running setup.py install for psycopg2 building cc -fno-strict-aliasing -fno-common -dynamic -arch x86_64 -arch i386 -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -mno-fused-madd -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -fwrapv -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE -arch x86_64 -arch i386 -pipe -DPSYCOPG_DEFAULT_PYDATETIME=1 -DPSYCOPG_VERSION="2.5.2 (dt dec pq3 ext)" -DPG_VERSION_HEX=0x090303 -DPSYCOPG_EXTENSIONS=1 -DPSYCOPG_NEW_BOOLEAN=1 -DHAVE_PQFREEMEM=1 -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -I. -I/usr/local/Cellar/postgresql/9.3.3/include -I/usr/local/Cellar/postgresql/9.3.3/include/server -c psycopg/psycopgmodule.c -o build/temp.macosx-10.9-intel-2.7/psycopg/psycopgmodule.o clang: error: unknown argument: clang: note: this will be a hard error (cannot be downgraded to a warning) in the future error: command Complete output from command /usr/bin/python -c "import setuptools, tokenize;__file__= running install running build running build_py creating build creating build/lib.macosx-10.9-intel-2.7 creating build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/__init__.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/_json.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/_range.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/errorcodes.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/extensions.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/extras.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/pool.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/psycopg1.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 copying lib/tz.py -> build/lib.macosx-10.9-intel-2.7/psycopg2 creating build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/__init__.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/dbapi20.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/dbapi20_tpc.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_async.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_bug_gc.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_bugX000.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_cancel.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_connection.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_copy.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_cursor.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_dates.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_extras_dictcursor.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_green.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_lobject.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_module.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_notify.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_psycopg2_dbapi20.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_quote.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_transaction.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_types_basic.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_types_extras.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/test_with.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/testconfig.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests copying tests/testutils.py -> build/lib.macosx-10.9-intel-2.7/psycopg2/tests running build_ext building creating build/temp.macosx-10.9-intel-2.7 creating build/temp.macosx-10.9-intel-2.7/psycopg cc -fno-strict-aliasing -fno-common -dynamic -arch x86_64 -arch i386 -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -mno-fused-madd -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -fwrapv -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE -arch x86_64 -arch i386 -pipe -DPSYCOPG_DEFAULT_PYDATETIME=1 -DPSYCOPG_VERSION="2.5.2 (dt dec pq3 ext)" -DPG_VERSION_HEX=0x090303 -DPSYCOPG_EXTENSIONS=1 -DPSYCOPG_NEW_BOOLEAN=1 -DHAVE_PQFREEMEM=1 -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -I. -I/usr/local/Cellar/postgresql/9.3.3/include -I/usr/local/Cellar/postgresql/9.3.3/include/server -c psycopg/psycopgmodule.c -o build/temp.macosx-10.9-intel-2.7/psycopg/psycopgmodule.o clang: error: unknown argument: clang: note: this will be a hard error (cannot be downgraded to a warning) in the future error: command ---------------------------------------- Cleaning up... Command /usr/bin/python -c "import setuptools, tokenize;__file__=
export CFLAGS=-Qunused-arguments export CPPFLAGS=-Qunused-arguments
-I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -fno-strict-aliasing -fno-common -dynamic -arch x86_64 -arch i386 -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -mno-fused-madd -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -fwrapv -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE
ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future pip install psycopg2
cd /System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/ sudo rm _sysconfigdata.pyo _sysconfigdata.pyc
sudo ARCHFLAGS="-arch x86_64" CFLAGS=-Wunused-command-line-argument-hard-error-in-future pip install psycopg2
$ python Python 2.7.5 (default, Aug 25 2013, 00:04:04) [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
mkvirtualenv --no-site-packages -p/Library/Frameworks/Python.framework/Versions/2.7/bin/python {virtual_env_name}
yum install libffi-devel yum install gcc yum install openssl-devel pip install paramiko
import re from datetime import datetime StartDate = "10/10/11" Date = datetime.strptime(StartDate, "%m/%d/%y")
date_1 = datetime.datetime.strptime(start_date, "%m/%d/%y") end_date = date_1 + datetime.timedelta(days=10)
import pandas as pd startdate = "10/10/2011" enddate = pd.to_datetime(startdate) + pd.DateOffset(days=5)
from datetime import datetime from dateutil.relativedelta import relativedelta print date_after_month = datetime.now()+ relativedelta(days=5) print
import datetime def get_date(dateFormat="%d-%m-%Y", addDays=0): timeNow = datetime.datetime.now() if (addDays!=0): anotherTime = timeNow + datetime.timedelta(days=addDays) else: anotherTime = timeNow return anotherTime.strftime(dateFormat)
addDays = 3 output_format = output = get_date(output_format, addDays) print output
from datetime import datetime from datetime import timedelta date_now_more_5_days = (datetime.now() + timedelta(days=5) ).strftime(
from datetime import datetime as DateTime, timedelta as TimeDelta
date_1 = DateTime.today() end_date = date_1 + TimeDelta(days=10)
d = dict(p1=1, p2=2) def f2(p1,p2): print p1, p2 f2(d)
d = dict(p1=1, p2=2) def f2(p1,p2): print p1, p2 f2(**d)
In[8]: mydict = { In[9]: mytest(a=3, **mydict) TypeError: mytest() got multiple values for keyword argument
In[10]: mydict = { In[11]: mytest(**mydict) TypeError: mytest() got an unexpected keyword argument
d = { def f(dictionary): for key in dictionary: print key f(d)
def foo(a, b, c, **args): print "a = %s" % (a,) print "b = %s" % (b,) print "c = %s" % (c,) print args foo(a="testa", d="excess", c="testc", b="testb", k="another_excess")
def foo(a, b, c, *args): print "a = %s" % (a,) print "b = %s" % (b,) print "c = %s" % (c,) print args foo("testa", "testb", "testc", "excess", "another_excess")
def foo(a,b,c,**args): print "a=%s" % (a,) print "b=%s" % (b,) print "c=%s" % (c,) print "args=%s" % (args,) argdict = dict(a="testa", b="testb", c="testc", excessarg="string") foo(**argdict)
def foo(a,b,c,*args): print "a=%s" % (a,) print "b=%s" % (b,) print "c=%s" % (c,) print "args=%s" % (args,) argtuple = ("testa","testb","testc","excess") foo(*argtuple)
>>> def foo(*args): ... print(args) ... >>> l = [1,2,3,4,5]
>>> def foo(**argd): ... print(argd) ... >>> d = { >>> foo(**d) {
def f0(a) def f1(*a) def f2(**a) def f3(*a, **b) etc...
def some_function(parm1, parm2, callback, *callback_args): a = 1 b = 2 ... callback(a, b, *callback_args) ...
def my_callback_function(a, b, x, y, z): ... x = 5 y = 6 z = 7 some_function(
>>> class MyData: ... def __init__(self, data): ... "Initialize MyData from a sequence" ... self.data = data ... ... @classmethod ... def fromfilename(cls, filename): ... "Initialize MyData from a file" ... data = open(filename).readlines() ... return cls(data) ... ... @classmethod ... def fromdict(cls, datadict): ... "Initialize MyData from a dict ... return cls(datadict.items()) ... >>> MyData([1, 2, 3]).data [1, 2, 3] >>> MyData.fromfilename("/tmp/foobar").data [ >>> MyData.fromdict({"spam": "ham"}).data [(
def read(self, str=None, filename=None, addr=0): """ Read binary data and return a store object. The data store is also saved in the interal The data can either be taken from a string (str argument) or a file (provide a filename, which will be read in binary mode). If both are provided, the str will be used. If neither is provided, an ArgumentError is raised. """ if str is None: if filename is None: raise ArgumentError( file = open(filename, str = file.read() file.close() ... ...
class MyData: def __init__(string=None,list=None): if string is not None: elif list is not None: else:
def __init__ (self, filename): if isinstance (filename, basestring): else: self.path = list (filename)
import time class Date(metaclass=MultipleMeta): def __init__(self, year:int, month:int, day:int): self.year = year self.month = month self.day = day def __init__(self): t = time.localtime() self.__init__(t.tm_year, t.tm_mon, t.tm_mday)
>>> d = Date(2012, 12, 21) >>> d.year 2012 >>> e = Date() >>> e.year 2018
isinstance(...) isinstance(object, class-or-type-or-tuple) -> bool Return whether an object is an instance of a class or of a subclass thereof. With a type as second argument, return whether that is the object The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for isinstance(x, A) or isinstance(x, B) or ... (etc.).
self.data = data if isinstance(data, list) else self.parse(data)
class MyClass: _data = [] __init__(self,data=None): if not data: return self._data = list(data)
class MyData: def __init__(self, data): self.myList = [] if isinstance(data, tuple): for i in data: self.myList.append(i) else: self.myList = data def GetData(self): print self.myList
class AutoList: def __init__(self, inp): try: self.data = inp.read() except AttributeError: try: with open(inp, self.data = fd.read() except: self.data = inp
entries = [[ [-8522787127447073495, [ [ [ [-9092791511155847987, [ [-6480567542315338377,
indices = [None, 1, None, None, None, 0, None, 2] entries = [[-9092791511155847987, [-8522787127447073495, [-6480567542315338377,
with open("somefile.py") as f: code = compile(f.read(), "somefile.py", exec(code, global_vars, local_vars)
def execfile(filepath, globals=None, locals=None): if globals is None: globals = {} globals.update({ "__file__": filepath, "__name__": "__main__", }) with open(filepath, exec(compile(file.read(), filepath, execfile("/path/to/somefile.py")
import runpy file_globals = runpy.run_path("file.py")
def xfile(afile, globalz=None, localz=None): with open(afile, "r") as fh: exec(fh.read(), globalz, localz)
import sys def execfile(filename, globals=None, locals=None): if globals is None: globals = sys._getframe(1).f_globals if locals is None: locals = sys._getframe(1).f_locals with open(filename, "r") as fh: exec(fh.read()+"\n", globals, locals)
>>> import sys >>> sys.path = [ >>> __import__( <module >>> __import__(
class python3Execfile(object): def _get_file_encoding(self, filename): with open(filename, try: return tokenize.detect_encoding(fp.readline)[0] except SyntaxError: return "utf-8" def my_execfile(filename): globals[ with open(filename, contents = fp.read() if not contents.endswith("\n"): contents += "\n" exec(contents, globals, globals)
from time import mktime from datetime import datetime dt = datetime.fromtimestamp(mktime(struct))
>>> structTime = time.localtime() >>> datetime.datetime(*structTime[:6]) datetime.datetime(2009, 11, 8, 20, 32, 35)
time.struct_time(tm_year=2013, tm_mon=9, tm_mday=9, tm_hour=23, tm_min=57, tm_sec=42, tm_wday=0, tm_yday=252, tm_isdst=0)
from dateutil import parser dt = parser.parse(entry["published"]) print "published", entry["published"]) print "dt", dt print "utcoffset", dt.utcoffset() print "tzinfo", dt.tzinfo print "dst", dt.dst()
published Mon, 09 Sep 2013 19:57:42 -0400 dt 2013-09-09 19:57:42-04:00 utcoffset -1 day, 20:00:00 tzinfo tzoffset(None, -14400) dst 0:00:00
import datetime as dt import pandas as pd import scipy as s if __name__ == base = dt.datetime.today().date() dates = [ base - dt.timedelta(days=x) for x in range(0,10) ] dates.sort() valdict = {} symbols = [ for symb in symbols: valdict[symb] = pd.Series( s.zeros( len(dates)), dates ) for thedate in dates: if thedate > dates[0]: for symb in valdict: valdict[symb][thedate] = 1+valdict[symb][thedate - dt.timedelta(days=1)] print valdict
import datetime import pandas as pd import numpy as np todays_date = datetime.datetime.now().date() index = pd.date_range(todays_date-datetime.timedelta(10), periods=10, freq= columns = [
df_ = pd.DataFrame(index=index, columns=columns) df_ = df_.fillna(0)
In [10]: df = pd.DataFrame(data, index=index, columns=columns) In [11]: df Out[11]: A B C 2012-11-29 0 0 0 2012-11-30 1 1 1 2012-12-01 2 2 2 2012-12-02 3 3 3 2012-12-03 4 4 4 2012-12-04 5 5 5 2012-12-05 6 6 6 2012-12-06 7 7 7 2012-12-07 8 8 8 2012-12-08 9 9 9
newDF = pd.DataFrame() newDF = newDF.append(oldDF, ignore_index = True) print newDF.head()
import pandas as pd col_names = [ my_df = pd.DataFrame(columns = col_names) my_df
col_names = [ my_df2 = pd.DataFrame(columns = col_names) my_df = my_df.append(my_df2)
index=range(0,19) index columns=[ test = pd.DataFrame(index=index, columns=columns)
import re s = "The fox jumped over the log." re.sub("\s\s+" , " ", s)
import re def while_replace(string): while string = string.replace( return string def re_replace(string): return re.sub(r def proper_join(string): split_string = string.split( beg = end = return beg + original_string = assert while_replace(original_string) == re_replace(original_string) == proper_join(original_string)
new_string = original_string[:] new_string = while_replace(new_string) assert new_string != original_string
new_string = original_string[:] new_string = re_replace(new_string) assert new_string != original_string
new_string = original_string[:] new_string = proper_join(new_string) assert new_string != original_string
new_string = original_string[:] new_string = while_replace(new_string) assert new_string != original_string while original_string = original_string.replace(
Tests run on a laptop with an i5 processor running Windows 7 (64-bit). timeit.Timer(stmt = test, setup = setup).repeat(7, 1000) test_string = Python 2.7.3, 32-bit, Windows test | minum | maximum | average | median ---------------------+------------+------------+------------+----------- while_replace_test | 0.001066 | 0.001260 | 0.001128 | 0.001092 re_replace_test | 0.003074 | 0.003941 | 0.003357 | 0.003349 proper_join_test | 0.002783 | 0.004829 | 0.003554 | 0.003035 Python 2.7.3, 64-bit, Windows test | minum | maximum | average | median ---------------------+------------+------------+------------+----------- while_replace_test | 0.001025 | 0.001079 | 0.001052 | 0.001051 re_replace_test | 0.003213 | 0.004512 | 0.003656 | 0.003504 proper_join_test | 0.002760 | 0.006361 | 0.004626 | 0.004600 Python 3.2.3, 32-bit, Windows test | minum | maximum | average | median ---------------------+------------+------------+------------+----------- while_replace_test | 0.001350 | 0.002302 | 0.001639 | 0.001357 re_replace_test | 0.006797 | 0.008107 | 0.007319 | 0.007440 proper_join_test | 0.002863 | 0.003356 | 0.003026 | 0.002975 Python 3.3.3, 64-bit, Windows test | minum | maximum | average | median ---------------------+------------+------------+------------+----------- while_replace_test | 0.001444 | 0.001490 | 0.001460 | 0.001459 re_replace_test | 0.011771 | 0.012598 | 0.012082 | 0.011910 proper_join_test | 0.003741 | 0.005933 | 0.004341 | 0.004009
test_string = lorem_ipsum Python 2.7.3, 32-bit test | minum | maximum | average | median ---------------------+------------+------------+------------+----------- while_replace_test | 0.342602 | 0.387803 | 0.359319 | 0.356284 re_replace_test | 0.337571 | 0.359821 | 0.348876 | 0.348006 proper_join_test | 0.381654 | 0.395349 | 0.388304 | 0.388193 Python 2.7.3, 64-bit test | minum | maximum | average | median ---------------------+------------+------------+------------+----------- while_replace_test | 0.227471 | 0.268340 | 0.240884 | 0.236776 re_replace_test | 0.301516 | 0.325730 | 0.308626 | 0.307852 proper_join_test | 0.358766 | 0.383736 | 0.370958 | 0.371866 Python 3.2.3, 32-bit test | minum | maximum | average | median ---------------------+------------+------------+------------+----------- while_replace_test | 0.438480 | 0.463380 | 0.447953 | 0.446646 re_replace_test | 0.463729 | 0.490947 | 0.472496 | 0.468778 proper_join_test | 0.397022 | 0.427817 | 0.406612 | 0.402053 Python 3.3.3, 64-bit test | minum | maximum | average | median ---------------------+------------+------------+------------+----------- while_replace_test | 0.284495 | 0.294025 | 0.288735 | 0.289153 re_replace_test | 0.501351 | 0.525673 | 0.511347 | 0.508467 proper_join_test | 0.422011 | 0.448736 | 0.436196 | 0.440318
>>> import re >>> s = "The fox jumped over the log." >>> re.sub(
>>> import re >>> s="The fox jumped over the log." >>> print re.sub( The fox jumped over the log.
>>> import re >>> str = >>> str = re.sub( >>> print str this is a string with multiple spaces and tabs
sentence = " The fox jumped over the log. " sentence =
import re def normalize_whitespace(string): return re.sub(r
>>> normalize_whitespace( >>> normalize_whitespace(
string= string=string.split( while string.remove( string= print(string)
def spaceMatcher(command): iteration space_match = 0 space_char = "" for char in command: if char == " ": space_match += 1 space_char += " " elif (char != " ") & (space_match > 1): new_command = command.replace(space_char, " ") space_match = 0 space_char = "" elif char != " ": space_match = 0 space_char = "" return new_command command = None command = str(input("Please enter a command ->")) print(spaceMatcher(command)) print(list(spaceMatcher(command)))
i have tried the following method and it even works with the extreme case like str1= but if you prefer regular expression it can be done as:- re.sub( although some preprocessing has to be done in order to remove the trailing and ending space.
line = "I have a nice day." end = 1000 while end != 0: line.replace(" ", " ") end -= 1
class A: def __init__(self): print "world" class B(A): def __init__(self): print "hello" B() hello
class A(object): def __init__(self): print "world" class B(A): def __init__(self): print "hello" super(B, self).__init__() B()
class A(object): def __init__(self): print "world" class B(A): def __init__(self): print "hello" super(B, self).__init__()
class A(object): def __init__(self): print("world") class B(A): def __init__(self): print("hello") super().__init__()
class A: def __init__(self): print "world" class B(A): def __init__(self): print "hello" A.__init__(self)
class B(A): def __init__(self): A.__init__(self) print "hello"
class Base1: def __init__(): super(Base1, self).__init__() class Base2: def __init__(): super(Base2, self).__init__() class Derived(Base1, Base2): def __init__(): super(Derived, self).__init__()
class A(object): def __init__(self): print "world" class B(A): def __init__(self): print "hello" super(self.__class__, self).__init__() B()
3 + 5 map(lambda x: x*x, range(10)) [a.x for a in some_iterable] yield 7
>>> 23 23 >>> 23l 23L >>> range(4) [0, 1, 2, 3] >>> 2L*bin(2) >>> def func(a): ... return a*a ... >>> func(3)*4 36 >>> func(5) is func(a=5) True
fun printHello(name: String?): Unit { if (name != null) println("Hello ${name}") else println("Hi there!")
parser.add_argument( type=list, action= dest= help= required=True)
import argparse parser = argparse.ArgumentParser() parser.add_argument( parser.add_argument( parser.add_argument( parser.add_argument( parser.add_argument( parser.add_argument( for _, value in parser.parse_args()._get_kwargs(): if value is not None: print(value)
$ python arg.py --default 1234 2345 3456 4567 ... arg.py: error: unrecognized arguments: 2345 3456 4567 $ python arg.py --list-type 1234 2345 3456 4567 ... arg.py: error: unrecognized arguments: 2345 3456 4567 $ $ python arg.py --list-type "1234 2345 3456 4567" [ $ python arg.py --list-type-nargs 1234 2345 3456 4567 [[ $ python arg.py --nargs 1234 2345 3456 4567 [ $ python arg.py --nargs-int-type 1234 2345 3456 4567 [1234, 2345, 3456, 4567] $ $ python arg.py --nargs-int-type -1234 2345 -3456 4567 [-1234, 2345, -3456, 4567] $ python arg.py --append-action 1234 --append-action 2345 --append-action 3456 --append-action 4567 [
parser = ArgumentParser() parser.add_argument( args = parser.parse_args() my_list = [int(item) for item in args.list.split(
python test.py -l "265340,268738,270774,270817" [other arguments]
python test.py -l 265340,268738,270774,270817 [other arguments]
>>> parser = argparse.ArgumentParser(prog= >>> parser.add_argument( >>> parser.parse_args([ Namespace(move= >>> parser.parse_args([ usage: game.py [-h] {rock,paper,scissors} game.py: error: argument move: invalid choice:
a = argparse.ArgumentParser() a.add_argument( nargs= type=int, dest= default=[], ) print a.parse_args("-l 123 234 345 456".split( print a.parse_args("-l 123 -l=234 -l345 --list 456".split(
Namespace(list=[123, 234, 345, 456]) Namespace(list=[456])
a = argparse.ArgumentParser() a.add_argument( type=int, dest= default=[], action= ) print a.parse_args("-l 123 -l=234 -l345 --list 456".split(
import ast def arg_as_list(s): v = ast.literal_eval(s) if type(v) is not list: raise argparse.ArgumentTypeError("Argument \"%s\" is not a list" % (s)) return v def foo(): parser.add_argument("--list", type=arg_as_list, default=[], help="List of values")
from argparse import ArgumentParser description = parser = ArgumentParser(description=description) parser.add_argument( type=str, nargs= help="Examples: -i item1 item2, -i item3") opts = parser.parse_args() print("List of items: {}".format(opts.alist))
python3.6 temp_agrs1.py -i item5 item6 item7 List of items: [ python3.6 temp_agrs1.py -i item10 List of items: [ python3.6 temp_agrs1.py List of items: [
import argparse parser = argparse.ArgumentParser() parser.add_argument("-l", "--tolist", help="input to list", action="store_true") parser.add_argument("newlist", type=str, help="generate a list") args = parser.parse_args() if args.tolist: print(args.newlist.split(" "))
>>> NoneType = type(None) >>> x = None >>> type(x) == NoneType True >>> isinstance(x, NoneType) True
name = 12 if type(name) != type(None): print(name) else: print("Can
def fib(n, sum): if n < 1: return sum else: return fib(n-1, sum+n) c = 998 print(fib(c, 0))
def fibonacci(n): f = [0,1,1] for i in xrange(3,n): f.append(f[i-1] + f[i-2]) return
from math import floor, sqrt def fib(n): return int(floor(((1+sqrt(5))**n-(1-sqrt(5))**n)/(2**n*sqrt(5))+0.5))
import resource import sys print resource.getrlimit(resource.RLIMIT_STACK) print sys.getrecursionlimit() print resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY]) sys.setrecursionlimit(0x100000) def f(i): print i sys.stdout.flush() f(i + 1) f(0)
def fib(): a, b = 0, 1 while True: yield a a, b = b, a + b fibs = fib() f = [fibs.next() for x in xrange(1001)] for num in f: print num
from numpy import matrix def fib(n): return (matrix(
import sys class recursionlimit: def __init__(self, limit): self.limit = limit self.old_limit = sys.getrecursionlimit() def __enter__(self): sys.setrecursionlimit(self.limit) def __exit__(self, type, value, tb): sys.setrecursionlimit(self.old_limit)
def fib(n): a,b = 1,1 for i in range(n-1): a,b = b,a+b return a print fib(5)
def fib(n): def fibseq(n): a, b = 0, 1 for _ in xrange(n): yield a a, b = b, a + b return sum(v for v in fibseq(n)) print format(fib(100000),
class A(object): def __init__(self): print "Constructor A was called" class B(A): def __init__(self): super(B,self).__init__() print "Constructor B was called" class C(B): def __init__(self): super(C,self).__init__() print "Constructor C was called" c = C()
class A(object): def __init__(self): print "Constructor A was called" class B(A): def __init__(self): A.__init__(self) print "Constructor B was called" class C(B): def __init__(self): B.__init__(self) print "Constructor C was called"
class Celsius(object): def __init__(self, value=0.0): self.value = float(value) def __get__(self, instance, owner): return self.value def __set__(self, instance, value): self.value = float(value) class Temperature(object): celsius = Celsius()
class Celsius: def __get__(self, instance, owner): return 5 * (instance.fahrenheit - 32) / 9 def __set__(self, instance, value): instance.fahrenheit = 32 + 9 * value / 5 class Temperature: celsius = Celsius() def __init__(self, initial_f): self.fahrenheit = initial_f t = Temperature(212) print(t.celsius) t.celsius = 0 print(t.fahrenheit)
def has_descriptor_attrs(obj): return set([ def is_descriptor(obj): return bool(has_descriptor_attrs(obj))
def has_data_descriptor_attrs(obj): return set([ def is_data_descriptor(obj): return bool(has_data_descriptor_attrs(obj))
>>> is_descriptor(classmethod), is_data_descriptor(classmethod) (True, False) >>> is_descriptor(staticmethod), is_data_descriptor(staticmethod) (True, False)
>>> has_descriptor_attrs(classmethod), has_descriptor_attrs(staticmethod) (set([
>>> def foo(): pass ... >>> is_descriptor(foo), is_data_descriptor(foo) (True, False)
>>> is_data_descriptor(property) True >>> has_descriptor_attrs(property) set([
class Celsius(object): def __init__(self, value=0.0): self.value = float(value) def __get__(self, instance, owner): return self.value def __set__(self, instance, value): self.value = float(value) class Temperature(object): celsius = Celsius()
>>> t1 = Temperature() >>> del t1.celsius Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: __delete__
class Temperature(object): _celsius = 0.0 @property def celsius(self): return type(self)._celsius @celsius.setter def celsius(self, value): type(self)._celsius = float(value)
>>> t1 = Temperature() >>> t1.celsius 0.0 >>> t1.celsius = 1 >>> >>> t1.celsius 1.0 >>> t2 = Temperature() >>> t2.celsius 1.0
>>> del t2.celsius Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: __delete__
>>> t1.celsius = Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 7, in __set__ ValueError: invalid literal for float(): 0x02
class Temperature(object): _celsius = 0.0 @property def celsius(self): return type(self)._celsius @celsius.setter def celsius(self, value): type(self)._celsius = float(value)
>>> t1 = Temperature() >>> t2 = Temperature() >>> t1.celsius 0.0 >>> t1.celsius = 1.0 >>> t2.celsius 1.0 >>> del t1.celsius Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: can >>> t1.celsius = Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 8, in celsius ValueError: invalid literal for float(): 0x02
class LineItem: price = 10.9 weight = 2.1 def __init__(self, name, price, weight): self.name = name self.price = price self.weight = weight item = LineItem("apple", 2.9, 2.1) item.price = -0.9 item.weight = -0.8
class Quantity(object): __index = 0 def __init__(self): self.__index = self.__class__.__index self._storage_name = "quantity self.__class__.__index += 1 def __set__(self, instance, value): if value > 0: setattr(instance, self._storage_name, value) else: raise ValueError( def __get__(self, instance, owner): return getattr(instance, self._storage_name)
class LineItem(object): weight = Quantity() price = Quantity() def __init__(self, name, weight, price): self.name = name self.weight = weight self.price = price
class Celsius: def __get__(self, instance, owner): return 9 * (instance.fahrenheit + 32) / 5.0 def __set__(self, instance, value): instance.fahrenheit = 32 + 5 * value / 9.0 class Temperature: def __init__(self, initial_f): self.fahrenheit = initial_f celsius = Celsius() if __name__ == "__main__": t = Temperature(212) print(t.celsius) t.celsius = 0 print(t.fahrenheit)
C:\Users\gkuhn\Desktop>python test2.py <__main__.Celsius instance at 0x02E95A80> 212
pip3 --version pip 9.0.1 from /usr/local/lib/python3.6/site-packages (python 3.6)
ln -s /Library/Frameworks/Python.framework/Versions/2.6/bin/pip /usr/local/bin
pip3 install --upgrade pip sudo pip3 install -U numpy ::
sudo apt update sudo apt install python3-pip source ~/.bashrc
Downloading/unpacking PIL You are installing a potentially insecure and unverifiable file. Future versions of pip will default to disallowing insecure files. Downloading PIL-1.1.7.tar.gz (506kB): 506kB downloaded Running setup.py egg_info for package PIL WARNING: Installing collected packages: PIL Running setup.py install for PIL WARNING: --- using frameworks at /System/Library/Frameworks building clang -fno-strict-aliasing -fno-common -dynamic -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -mno-fused-madd -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE -arch i386 -arch x86_64 -pipe -IlibImaging -I/System/Library/Frameworks/Python.framework/Versions/2.7/include -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -c _imaging.c -o build/temp.macosx-10.8-intel-2.7/_imaging.o unable to execute clang: No such file or directory error: command Complete output from command /usr/bin/python -c "import setuptools;__file__= WARNING: running install running build . . . . copying PIL/XVThumbImagePlugin.py -> build/lib.macosx-10.8-intel-2.7 running build_ext --- using frameworks at /System/Library/Frameworks building creating build/temp.macosx-10.8-intel-2.7 creating build/temp.macosx-10.8-intel-2.7/libImaging clang -fno-strict-aliasing -fno-common -dynamic -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -mno-fused-madd -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE -arch i386 -arch x86_64 -pipe -IlibImaging -I/System/Library/Frameworks/Python.framework/Versions/2.7/include -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -c _imaging.c -o build/temp.macosx-10.8-intel-2.7/_imaging.o unable to execute clang: No such file or directory error: command ---------------------------------------- Cleaning up…
apt-get install python-dev apt-get install libjpeg-dev apt-get install libjpeg8-dev apt-get install libpng3 apt-get install libfreetype6-dev ln -s /usr/lib/i386-linux-gnu/libfreetype.so /usr/lib ln -s /usr/lib/i386-linux-gnu/libjpeg.so /usr/lib ln -s /usr/lib/i386-linux-gnu/libz.so /usr/lib pip install PIL --allow-unverified PIL --allow-all-external
$ sudo apt-get install python-imaging $ sudo -H pip install pillow
curl -O -L http: tar -xzf Imaging-1.1.7.tar.gz cd Imaging-1.1.7 python setup.py build sudo python setup.py install
File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/os.py", line 157, in makedirs mkdir(name, mode) OSError: [Errno 13] Permission denied: Storing debug log for failure in /Users/wzbozon/Library/Logs/pip.log
sudo pip install PIL --allow-external PIL --allow-unverified PIL
0 2 * * 7 /usr/bin/run-backup 0 9-17/2 * * 1-5 /usr/bin/purge-temps
import schedule import time def job(): print("I schedule.every(10).minutes.do(job) schedule.every().hour.do(job) schedule.every().day.at("10:30").do(job) while 1: schedule.run_pending() time.sleep(1)
from datetime import datetime, timedelta import time class AllMatch(set): def __contains__(self, item): return True allMatch = AllMatch() def conv_to_set(obj): if isinstance(obj, (int,long)): return set([obj]) if not isinstance(obj, set): obj = set(obj) return obj class Event(object): def __init__(self, action, min=allMatch, hour=allMatch, day=allMatch, month=allMatch, dow=allMatch, args=(), kwargs={}): self.mins = conv_to_set(min) self.hours= conv_to_set(hour) self.days = conv_to_set(day) self.months = conv_to_set(month) self.dow = conv_to_set(dow) self.action = action self.args = args self.kwargs = kwargs def matchtime(self, t): return ((t.minute in self.mins) and (t.hour in self.hours) and (t.day in self.days) and (t.month in self.months) and (t.weekday() in self.dow)) def check(self, t): if self.matchtime(t): self.action(*self.args, **self.kwargs)
c = CronTab( Event(perform_backup, 0, 2, dow=6 ), Event(purge_temps, 0, range(9,18,2), dow=range(0,5)) )
class CronTab(object): def __init__(self, *events): self.events = events def run(self): t=datetime(*datetime.now().timetuple()[:5]) while 1: for e in self.events: e.check(t) t += timedelta(minutes=1) while datetime.now() < t: time.sleep((t - datetime.now()).seconds)
from datetime import datetime, timedelta import gevent def conv_to_set(obj): if isinstance(obj, (int, long)): return set([obj]) if not isinstance(obj, set): obj = set(obj) return obj class AllMatch(set): def __contains__(self, item): return True allMatch = AllMatch() class Event(object): def __init__(self, action, minute=allMatch, hour=allMatch, day=allMatch, month=allMatch, daysofweek=allMatch, args=(), kwargs={}): self.mins = conv_to_set(minute) self.hours = conv_to_set(hour) self.days = conv_to_set(day) self.months = conv_to_set(month) self.daysofweek = conv_to_set(daysofweek) self.action = action self.args = args self.kwargs = kwargs def matchtime(self, t1): return ((t1.minute in self.mins) and (t1.hour in self.hours) and (t1.day in self.days) and (t1.month in self.months) and (t1.weekday() in self.daysofweek)) def check(self, t): if self.matchtime(t): self.action(*self.args, **self.kwargs) class CronTab(object): def __init__(self, *events): self.events = events def _check(self): t1 = datetime(*datetime.now().timetuple()[:5]) for event in self.events: gevent.spawn(event.check, t1) t1 += timedelta(minutes=1) s1 = (t1 - datetime.now()).seconds + 1 print "Checking again in %s seconds" % s1 job = gevent.spawn_later(s1, self._check) def run(self): self._check() while True: gevent.sleep(60) import os def test_task(): os.system( cron = CronTab( Event(test_task, 22, 1 ), Event(test_task, 0, range(9,18,2), daysofweek=range(0,5)), ) cron.run()
schedule = "*/5 * * * *" nextRunTime = getNextCronRunTime(schedule) while True: roundedDownTime = roundDownTime() if (roundedDownTime == nextRunTime): nextRunTime = getNextCronRunTime(schedule) elif (roundedDownTime > nextRunTime): nextRunTime = getNextCronRunTime(schedule) sleepTillTopOfNextMinute()
from croniter import croniter from datetime import datetime, timedelta def roundDownTime(dt=None, dateDelta=timedelta(minutes=1)): roundTo = dateDelta.total_seconds() if dt == None : dt = datetime.now() seconds = (dt - dt.min).seconds rounding = (seconds+roundTo/2) return dt + timedelta(0,rounding-seconds,-dt.microsecond) def getNextCronRunTime(schedule): return croniter(schedule, datetime.now()).get_next(datetime) def sleepTillTopOfNextMinute(): t = datetime.utcnow() sleeptime = 60 - (t.second + t.microsecond/1000000.0) time.sleep(sleeptime)
cron = Cron() cron.add( cron.add( cron.add( cron.run()
class CronTab(object): def __init__(self, *events): self.events = events def run(self): t=datetime(*datetime.now().timetuple()[:5]) while 1: for e in self.events: e.check(t) t += timedelta(minutes=1) n = datetime.now() while n < t: s = (t - n).seconds + 1 time.sleep(s) n = datetime.now()
def run(self): while 1: t = datetime.now() for e in self.events: e.check(t) time.sleep(60 - t.second - t.microsecond / 1000000.0)
from aqcron import At from time import sleep from datetime import datetime event_1 = At( second=5 ) event_2 = At( second=[0,20,40] ) while True: now = datetime.now() if now in event_1: print "event_1" if now in event_2: print "event_2" sleep(1)
class At(object): def __init__(self, year=None, month=None, day=None, weekday=None, hour=None, minute=None, second=None): loc = locals() loc.pop("self") self.at = dict((k, v) for k, v in loc.iteritems() if v != None) def __contains__(self, now): for k in self.at.keys(): try: if not getattr(now, k) in self.at[k]: return False except TypeError: if self.at[k] != getattr(now, k): return False return True
Traceback (most recent call last): File "C:/Users/Felipe/PycharmProjects/untitled/asdf.py", line 4, in <module> nx.write_shp(redVial, "shapefiles") File "C:\Python34\lib\site-packages\networkx\readwrite\nx_shp.py", line 192, in write_shp for key, data in e[2].iteritems(): AttributeError:
import timeit d = {i:i*2 for i in xrange(10000000)} start = timeit.default_timer() for key,value in d.items(): tmp = key + value t1 = timeit.default_timer() - start start = timeit.default_timer() for key,value in d.iteritems(): tmp = key + value t2 = timeit.default_timer() - start
Time with d.items(): 9.04773592949 Time with d.iteritems(): 2.17707300186
mydict2={ maxval=(max(mydict2.values())) print(maxval) mykey=[key for key,value in mydict2.items()if value==maxval][0] print(mykey) YEILDS; 85 Macon
>>> elements = ( >>> for elem in elements: ... print elem ... foo bar baz >>> for count, elem in enumerate(elements): ... print count, elem ... 0 foo 1 bar 2 baz
>>> for count, elem in enumerate(elements, 42): ... print count, elem ... 42 foo 43 bar 44 baz
from itertools import count def enumerate(it, start=0): return zip(count(start), it)
def enumerate(it, start=0): count = start for elem in it: yield (count, elem) count += 1
list_of_letters = [ for i in range(len(list_of_letters)): letter = list_of_letters[i] print (i, letter)
i = 0 for n in list_of_letters: print (i, n) i = i +1
list_of_letters = [ for i, letter in enumerate(list_of_letters): print (i, letter)
doc = doc1 = doc.split( for i in enumerate(doc1): print(i)
for index, value in enumerate(joint_values): if index == 3: continue
def enumerate(l, start=0): return zip(range(start, len(l) + start), l)
l = ["test_1", "test_2", "test_3"] enumerate(l) enumerate(l, 10)
try: r = requests.get(url, params={ except requests.ConnectionError, e: print e
try: r = requests.get(url, params={ except requests.exceptions.RequestException as e: print e sys.exit(1)
try: r = requests.get(url, params={ except requests.exceptions.Timeout: except requests.exceptions.TooManyRedirects: except requests.exceptions.RequestException as e: print e sys.exit(1)
try: r = requests.get( r.raise_for_status() except requests.exceptions.HTTPError as err: print err sys.exit(1)
url= try: r = requests.get(url,timeout=3) r.raise_for_status() except requests.exceptions.HTTPError as errh: print ("Http Error:",errh) except requests.exceptions.ConnectionError as errc: print ("Error Connecting:",errc) except requests.exceptions.Timeout as errt: print ("Timeout Error:",errt) except requests.exceptions.RequestException as err: print ("OOps: Something Else",err) Http Error: 404 Client Error: Not Found for url: http:
url= try: r = requests.get(url,timeout=3) r.raise_for_status() except requests.exceptions.RequestException as err: print ("OOps: Something Else",err) except requests.exceptions.HTTPError as errh: print ("Http Error:",errh) except requests.exceptions.ConnectionError as errc: print ("Error Connecting:",errc) except requests.exceptions.Timeout as errt: print ("Timeout Error:",errt) OOps: Something Else 404 Client Error: Not Found for url: http:
>>> class Foo: ... bar = ... baz = ... >>> f = Foo() >>> props(f) {
class Foo(dict): def __init__(self): pass def __getattr__(self, attr): return self[attr]
>>> class Foo(object): ... bar = ... baz = ... >>> f = Foo() >>> [name for name in dir(f) if not name.startswith( [ >>> dict((name, getattr(f, name)) for name in dir(f) if not name.startswith( {
import inspect def props(obj): pr = {} for name in dir(obj): value = getattr(obj, name) if not name.startswith( pr[name] = value return pr
dict((key, value) for key, value in f.__dict__.iteritems() if not callable(value) and not key.startswith(
class A(object): d = e = f = def __init__(self): self.a = self.b = self.c = def __iter__(self): iters = dict((x,y) for x,y in A.__dict__.items() if x[:2] != iters.update(self.__dict__) for x,y in iters.items(): yield x,y a = A() print(dict(a))
def iterable(cls): def iterfn(self): iters = dict((x,y) for x,y in cls.__dict__.items() if x[:2] != iters.update(self.__dict__) for x,y in iters.items(): yield x,y cls.__iter__ = iterfn return cls @iterable class B(object): d = e = f = def __init__(self): self.a = self.b = self.c = b = B() print(dict(b))
def props(x): return dict((key, getattr(x, key)) for key in dir(x) if key not in dir(x.__class__))
class A(object): def __init__(self): self.b = 1 self.c = 2 def __getitem__(self, item): return self.__dict__[item] a = A() a.__getitem__( a.__dict__ vars(a)
def __dict__(self): d = { ... } return d d = instance.__dict__()
class DateTimeDecoder(json.JSONDecoder): def __init__(self, *args, **kargs): JSONDecoder.__init__(self, object_hook=self.dict_to_object, *args, **kargs) def dict_to_object(self, d): if return d type = d.pop( try: dateobj = datetime(**d) return dateobj except: d[ return d def json_default_format(value): try: if isinstance(value, datetime): return { } if isinstance(value, decimal.Decimal): return float(value) if isinstance(value, Enum): return value.name else: return vars(value) except Exception as e: raise ValueError
class Foo(): def toJSON(self): return json.loads( json.dumps(self, sort_keys=True, indent=4, separators=( Foo().toJSON()
try: from local_settings import * except ImportError as e: pass
project/ app1/ app2/ project/ __init__.py settings/ __init__.py base.py local.py production.py manage.py
from project.settings.base import * DEBUG = True INSTALLED_APPS += ( )
from project.settings.base import * DEBUG = False INSTALLED_APPS += ( )
$ ./manage.py runserver 0:8000 --settings=project.settings.local $ ./manage.py shell --settings=project.settings.production
. └── settings/ ├── __init__.py <= not versioned ├── common.py ├── dev.py └── prod.py
from __future__ import absolute_import from .common import * DEBUG = False
from __future__ import absolute_import from .prod import * SECRET_KEY = DATABASES[ AWS_SECRET_ACCESS_KEY = "h50fH..."
PRODUCTION_SERVERS = [ if os.environ[ PRODUCTION = True else: PRODUCTION = False DEBUG = not PRODUCTION TEMPLATE_DEBUG = DEBUG if PRODUCTION: DATABASE_HOST = else: DATABASE_HOST =
from split_settings.tools import optional, include import os if os.environ[ include( optional( scope=globals() )
. │ manage.py ├───data └───website ├───settings │ │ __init__.py <-- imports local for compatybility │ │ base.py <-- almost all the settings, reads from proces environment │ │ local.py <-- a few modifications for local development │ │ production.py <-- ideally is empy and everything is in base │ │ testing.py <-- mimics production with a reasonable exeptions │ │ .env <-- for local use, not kept in repo │ __init__.py │ urls.py │ wsgi.py
import logging import environ logging.debug("Settings loading: %s" % __file__) environ.Env.read_env(DEBUG= from .base import * ALLOWED_HOSTS += [ ] EMAIL_BACKEND = LOGGING[ CELERY_ALWAYS_EAGER = True CELERY_EAGER_PROPAGATES_EXCEPTIONS = True
environ.Env.read_env(Path(__file__) / "production.env", DEBUG= from .base import *
import environ env = environ.Env() BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) ROOT_DIR = BASE_DIR SECRET_KEY = env( DEBUG = env( INTERNAL_IPS = [ ] ALLOWED_HOSTS = [] if hosts = os.environ[ BASE_URL = "https: for host in hosts: host = host.strip() if host: ALLOWED_HOSTS.append(host) SECURE_SSL_REDIRECT = env.bool(
if "DATABASE_URL" in os.environ: DATABASES = { } DATABASES[ DATABASES[ } else: DATABASES = { } } }
STATIC_ROOT = os.path.join(ROOT_DIR, ASSETS_LOAD_PATH = STATIC_ROOT ASSETS_ROOT = os.path.join(ROOT_DIR, ASSETS_DEBUG = env( if ASSETS_DEBUG: ASSETS_URL = STATIC_URL ASSETS_MANIFEST = "json:{}".format(os.path.join(ASSETS_ROOT, "manifest.json")) else: ASSETS_URL = STATIC_URL + "assets/compressed/" ASSETS_MANIFEST = "json:{}".format(os.path.join(STATIC_ROOT, ASSETS_AUTO_BUILD = ASSETS_DEBUG ASSETS_MODULES = (
if DEBUG: STATIC_PATH = /path/to/dev/files else: STATIC_PATH = /path/to/production/files
PRODUCTION_SERVERS = [ def check_env(): for item in PRODUCTION_SERVERS: match = re.match(r"(^." + item + "$)", socket.gethostname()) if match: return True if check_env(): PRODUCTION = True else: PRODUCTION = False DEBUG = not PRODUCTION
import platform from django.core.management import execute_manager computername = platform.node() try: settings = __import__(computername + except ImportError: import sys sys.stderr.write("Error: Can sys.exit(1) if __name__ == "__main__": execute_manager(settings)
import sys import socket from django.core.management import execute_manager ipaddress = socket.gethostbyname( socket.gethostname() ) if ipaddress == try: import local_settings settings = local_settings except ImportError: import sys sys.stderr.write("Error: Can sys.exit(1) else: try: import prod_settings settings = prod_settings except ImportError: import sys sys.stderr.write("Error: Can sys.exit(1) if __name__ == "__main__": execute_manager(settings)
from socket import gethostname, gethostbyname PROD_HOSTS = ["webserver1", "webserver2"] DEBUG = False ALLOWED_HOSTS = [gethostname(), gethostbyname(gethostname()),] if any(host in PROD_HOSTS for host in ALLOWED_HOSTS): SESSION_COOKIE_SECURE = True CSRF_COOKIE_SECURE = True
from .base import * try: from .local import * except: pass try: from .production import * except: pass
try: os.environ[ DEBUG = True TEMPLATE_DEBUG = True INSTALLED_APPS.extend([ ]) except KeyError: print
from dask import delayed def f(storage, index, chunk_size): return storage partial_result = delayed([]) chunk_size = 100 for index in range(0, len(file), chunk_size): partial_result = delayed(f)(partial_result, index, chunk_size) result = partial_result.compute()
class Map(db.Model): members = models.ManyToManyField(User, related_name= verbose_name=_(
@with_author class BOM(models.Model): name = models.CharField(max_length=200,null=True, blank=True) description = models.TextField(null=True, blank=True) tomaterial = models.ForeignKey(Material, related_name = frommaterial = models.ForeignKey(Material, related_name = creation_time = models.DateTimeField(auto_now_add=True, blank=True) quantity = models.DecimalField(max_digits=19, decimal_places=10)
class UserMapDataFrame(models.Model): user = models.ForeignKey(User)
class MyObj(object): def __init__(self): self.name = self.phone = obj = MyObj() print(obj.__dict__)
for att in dir(your_object): print (att, getattr(your_object,att))
import os, sys from stat import * def walktree(top, callback): calling the callback function for each regular file for f in os.listdir(top): pathname = os.path.join(top, f) mode = os.stat(pathname)[ST_MODE] if S_ISDIR(mode): walktree(pathname, callback) elif S_ISREG(mode): callback(pathname) else: print def visitfile(file): print if __name__ == walktree(sys.argv[1], visitfile)
>>> string = "blah, lots , of , spaces, here " >>> mylist = string.split( >>> print mylist [
my_string = "blah, lots , of , spaces, here " result = [x.strip() for x in my_string.split(
>>> import re >>> string = " blah, lots , of , spaces, here " >>> pattern = re.compile("^\s+|\s*,\s*|\s+$") >>> print([x for x in pattern.split(string) if x]) [
>>> string = "foo, bar " >>> print([x for x in pattern.split(string) if x]) [ >>>
>>> pattern = re.compile("\s*,\s*|\s+$") >>> print([x for x in pattern.split(string) if x]) [
[word.strip() for word in string.split( $ time ./list_comprehension.py real 0m22.876s map(lambda s: s.strip(), string.split( $ time ./map_with_lambda.py real 0m25.736s map(str.strip, string.split( $ time ./map_with_str.strip.py real 0m19.428s
$ string = "blah, lots , of , spaces, here " $ re.split( [
Traceback (most recent call last): File "run.py", line 7, in <module> from Normalization import Normalizer
1.5: 20121 1.5.1: 20121 1.5.2: 20121 1.6: 50428 2.0: 50823 2.0.1: 50823 2.1: 60202 2.1.1: 60202 2.1.2: 60202 2.2: 60717 2.3a0: 62011 2.3a0: 62021 2.3a0: 62011 2.4a0: 62041 2.4a3: 62051 2.4b1: 62061 2.5a0: 62071 2.5a0: 62081 2.5a0: 62091 2.5a0: 62092 2.5b3: 62101 2.5b3: 62111 2.5c1: 62121 2.5c2: 62131 2.6a0: 62151 2.6a1: 62161 2.7a0: 62171
find {directory-of-.pyc-files} -name "*.pyc" -print0 | xargs -0 rm -rf
f = lambda x: if x==2 print x else raise Exception() f(2) f(3)
def f(x): if x == 2: print(x) else: raise ValueError
f = lambda x: sys.stdout.write(["2\n",][2*(x==2)-2])
def Raise(exception): raise exception x = lambda y: 1 if y < 2 else Raise(ValueError("invalid value"))
from __future__ import print_function f = lambda x: print(x) if x%2 == 0 else False
def fun(): raise Exception() f = lambda x:print x if x==2 else fun()
func = lambda element: (expression and DoSomething) or DoSomethingIfExpressionIsFalse
plaintext = input("Please enter the text you want to compress") filename = input("Please enter the desired filename") with gzip.open(filename + ".gz", "wb") as outfile: outfile.write(bytes(plaintext,
plaintext = filename = with gzip.open(filename, outfile.write(bytes(plaintext, with gzip.open(filename, outfile_content = infile.read().decode( print(outfile_content)
py2>> plaintext= py2>> type(plaintext) str py2>> outfile.write(plaintext)
>>> s = bytes("s","utf-8") >>> print(s) b >>> s = s.decode("utf-8") >>> print(s) s
def test_view(self): response = self.client.get(reverse( self.assertIn(str(self.obj.id), response.content) ...
def test_view(self): response = self.client.get(reverse( self.assertIn(str(self.obj.id), response.content.decode( ...
nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]
import numpy as np data = np.random.random(2) print(data) data[0], data[1] = data[1], data[0] print(data) data = np.random.random((2, 2)) print(data) data[0], data[1] = data[1], data[0] print(data)
class Foo: def __call__(self): print foo_instance = Foo() foo_instance()
class Cached: def __init__(self, function): self.function = function self.cache = {} def __call__(self, *args): try: return self.cache[args] except KeyError: ret = self.cache[args] = self.function(*args) return ret
@Cached def ack(x, y): return ack(x-1, ack(x, y-1)) if x*y else (x + y + 1)
class Quitter(object): def __init__(self, name): self.name = name def __repr__(self): return def __call__(self, code=None): try: sys.stdin.close() except: pass raise SystemExit(code) __builtin__.quit = Quitter( __builtin__.exit = Quitter(
class a(object): def __call__(self, *args): print func = a() def func(*args): print
[nigel@k9 ~]$ python Python 2.5 (r25:51908, Nov 6 2007, 15:55:44) [GCC 4.1.2 20070925 (Red Hat 4.1.2-27)] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: >>>
class Adder(object): def __init__(self, val): self.val = val def __call__(self, val): return self.val + val func = Adder(5) print func(3)
>>> class Foo: ... pass ... >>> class Bar(object): ... pass ... >>> type(Foo).__call__(Foo) <__main__.Foo instance at 0x711440> >>> type(Bar).__call__(Bar) <__main__.Bar object at 0x712110> >>> def foo(bar): ... return bar ... >>> type(foo).__call__(foo, 42) 42
>>> class Foo(object): ... def __call__(self): ... return 42 ... >>> f = Foo() >>> f() 42
Class A: def __init__(self,val): self.val = val def bar(self): print "bar" obj = A() callable(obj.bar) True callable(obj.__init___) False def foo(): return "s" callable(foo) True callable(foo()) False
>>> type(print) <class >>> print.__call__(10) 10 >>> print(10) 10 >>>
class ContainerMethods: def __init__(self): self.list_methods_11 = { } self.tuple_methods_2 = { self.dict_methods_11 = { } self.set_methods_17 ={
>>> import os >>> clear = lambda: os.system( >>> clear()
>>> clear = "\n" * 100 >>> print clear >>> ...do some other stuff... >>> print clear
class Wipe(object): def __repr__(self): return wipe = Wipe()
>>> from wiper import wipe >>> wipe >>> wipe >>> wipe
class cls(object): def __repr__(self): import os os.system( return cls = cls()
class exit(object): exit = exit def __repr__(self): self.exit() return quit = exit = exit()
class Prompt: def __str__(self): import os return import sys sys.ps1 = Prompt() del sys del Prompt
import os import subprocess def clear(): if os.name in ( subprocess.call("cls") elif os.name in ( subprocess.call("clear") else: print("\n") * 120
import os class Cls(object): def __repr__(self): os.system( return
class clear: def __call__(self): import os if os.name==( elif os.name== else: print( def __neg__(self): self() def __repr__(self): self();return clear=clear()
import subprocess clear = lambda: subprocess.call( clear()
class exxxit(): """Shortcut for exit() function, use quit_now = exit def __repr__(self): self.quit_now() x = exxxit()
Py2.7.1>help(x) Help on instance of exxxit in module __main__: class exxxit | Shortcut for exit() function, use | | Methods defined here: | | __repr__(self) | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | quit_now = Use exit() or Ctrl-Z plus Return to exit
import os if (os.name in ( os.system( elif ( os.system(
import os def clear(): if os.name == os.system( elif os.name in ( os.system( clear()
from os import popen with popen( clear = f.read() print clear
while [ "0" == "0" ]; do clear $@ while [ "$input" == "" ]; do read -p "Do you want to quit? (y/n): " -n 1 -e input if [ "$input" == "y" ]; then exit 1 elif [ "$input" == "n" ]; then echo "Ok, keep working ;)" fi done input="" done
import subprocess import os if os.name == def clearscreen(): subprocess.call("cls", shell=True) return else: def clearscreen(): subprocess.call("clear", shell=True) return
indices = [i for i, x in enumerate(my_list) if x == "whatever"]
import numpy as np values = np.array([1,2,3,1,2,4,5,6,3,2,1]) searchval = 3 ii = np.where(values == searchval)[0]
def indices(lst, element): result = [] offset = -1 while True: try: offset = lst.index(element, offset+1) except ValueError: return result result.append(offset)
In [1]: l=[1,2,3,4,3,2,5,6,7] In [2]: [i for i,val in enumerate(l) if val==3] Out[2]: [2, 4]
occurrences = lambda s, lst: (i for i,e in enumerate(lst) if e == s) list(occurrences(1, [1,2,3,1]))
values = [1,2,3,1,2,4,5,6,3,2,1] map(lambda val: (val, [i for i in xrange(len(values)) if values[i] == val]), values)
from more_itertools import locate list(locate([0, 1, 1, 0, 1, 0, 0])) list(locate([
f = lambda my_list, value:filter(lambda x: my_list[x] == value, range(len(my_list)))
[i for i,x in enumerate([1,2,3,2]) if x==2 & 2<= i <=3]
from collections import defaultdict d1 = defaultdict(int) unq = set(lst1) for each in unq: d1[each] = lst1.count(each) else: print(d1)
def count(x, lst): ind = [] for i in lst: if i == x: ind.append(lst.index(x)) return ind
Downloading/unpacking git+git: Cloning Git repository git: Complete output from command /usr/local/bin/git clone git: fatal: The remote end hung up unexpectedly Cloning into /var/folders/cB/cB85g9P7HM4jcPn7nrvWRU+++TI/-Tmp-/pip-VRsIoo-build... ---------------------------------------- Command /usr/local/bin/git clone git:
Downloading/unpacking git+ssh: Cloning Git repository ssh: Complete output from command /usr/local/bin/git clone ssh: Cloning into /var/folders/cB/cB85g9P7HM4jcPn7nrvWRU+++TI/-Tmp-/pip-DQB8s4-build... Permission denied (publickey). fatal: The remote end hung up unexpectedly ---------------------------------------- Command /usr/local/bin/git clone ssh:
$ git remote -v origin git@github.com:echweb/echweb-utils.git (fetch) ^ change this to a
ssh: Could not resolve hostname github.com:echweb: nodename nor servname provided, or not known
from setuptools import setup import os github_token = os.environ[ setup( install_requires= dependency_links = [ .format(github_token=github_token, package=package, version=master) ]
Host GitLab HostName gitlab.mycorp.com IdentityFile ~/.ssh/GitLab_Robot_Deploy_Key
In [2]: df Out[2]: col1 col2 col3 col4 col5 col6 0 A B 0.20 -0.61 -0.49 1.49 1 A B -1.53 -1.01 -0.39 1.82 2 A B -0.44 0.27 0.72 0.11 3 A B 0.28 -1.32 0.38 0.18 4 C D 0.12 0.59 0.81 0.66 5 C D -0.13 -1.65 -1.64 0.50 6 C D -1.42 -0.11 -0.18 -0.44 7 E F -0.00 1.42 -0.26 1.17 8 E F 0.91 -0.47 1.35 -0.34 9 G H 1.48 -0.63 -1.14 0.17
In [3]: df.groupby([ Out[3]: col1 col2 A B 4 C D 3 E F 2 G H 1 dtype: int64
In [4]: df.groupby([ Out[4]: col1 col2 counts 0 A B 4 1 C D 3 2 E F 2 3 G H 1
In [5]: (df ...: .groupby([ ...: .agg({ ...: ...: ...: })) Out[5]: col4 col3 median min count mean count col1 col2 A B -0.810 -1.32 4 -0.372500 4 C D -0.110 -1.65 3 -0.476667 3 E F 0.475 -0.47 2 0.455000 2 G H -0.630 -0.63 1 1.480000 1
In [6]: gb = df.groupby([ ...: counts = gb.size().to_frame(name= ...: (counts ...: .join(gb.agg({ ...: .join(gb.agg({ ...: .join(gb.agg({ ...: .reset_index() ...: ) ...: Out[6]: col1 col2 counts col3_mean col4_median col4_min 0 A B 4 -0.372500 -0.810 -1.32 1 C D 3 -0.476667 -0.110 -1.65 2 E F 2 0.455000 0.475 -0.47 3 G H 1 1.480000 -0.630 -0.63
In [1]: import numpy as np ...: import pandas as pd ...: ...: keys = np.array([ ...: [ ...: [ ...: [ ...: [ ...: [ ...: [ ...: [ ...: [ ...: [ ...: [ ...: ]) ...: ...: df = pd.DataFrame( ...: np.hstack([keys,np.random.randn(10,4).round(2)]), ...: columns = [ ...: ) ...: ...: df[[ ...: df[[ ...:
>>> sub = [ >>> def getJoin(): ... return ... >>> getJoin()
def bob(): me = "locally defined" print me bob() print me
locally defined Traceback (most recent call last): File "file.py", line 9, in <module> print me NameError: name
def bob(): global me me = "locally defined" print me bob() print me
foo = 1 def test(): foo = 2 def blub(): global foo foo = 3
>>> a = 1 >>> def p(): print(a) >>> def q(): a = 3 print(a) >>> def r(): print(a) a = 4 >>> p() 1 >>> q() 3 >>> r() Traceback (most recent call last): File "<pyshell r() File "<pyshell print(a) UnboundLocalError: local variable >>>
value = 42 def doit(): print value value = 0 doit() print value
>>> x = 1 >>> def foo(): print x >>> foo() 1 >>> def foo(): x = 2 print x >>> x 1 >>> foo() 2
words = [...] def contains (word): global words return (word in words) def add (word): global words if word not in words: words += [word]
x = 1 def myfunc(): global x def localfunction(x): return x+1 import os.path as x for x in range(10): print x class x(object): def __init__(self): pass def x(): print "I
def out(): global x x = 1 print(x) return out() print (x)
myVar = 0 print (myVar ) def func(): myVar = "def" print (myVar ) func() print (myVar )
myVar = 0 print (myVar ) def func(): global myVar myVar = "def" print (myVar ) func() print (myVar )
In [1]: s = pd.Series([1,2,3, np.nan, np.nan]) In [4]: s.isna().sum() Out[4]: 2
In [5]: df = pd.DataFrame({ In [6]: df.isna().sum() Out[6]: a 1 b 2 dtype: int64
def missing_values_table(df): mis_val = df.isnull().sum() mis_val_percent = 100 * df.isnull().sum() / len(df) mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1) mis_val_table_ren_columns = mis_val_table.rename( columns = {0 : mis_val_table_ren_columns = mis_val_table_ren_columns[ mis_val_table_ren_columns.iloc[:,1] != 0].sort_values( print ("Your selected dataframe has " + str(df.shape[1]) + " columns.\n" "There are " + str(mis_val_table_ren_columns.shape[0]) + " columns that have missing values.") return mis_val_table_ren_columns
import pandas as pd df = pd.DataFrame({ for col in df: print df[col].value_counts(dropna=False) 2 1 1 1 NaN 1 dtype: int64 NaN 2 1 1 dtype: int64
def PercentageMissin(Dataset): if isinstance(Dataset,pd.DataFrame): adict={} for col in Dataset.columns: adict[col]=(np.count_nonzero(Dataset[col].isnull())*100)/len(Dataset[col]) return pd.DataFrame(adict,index=[ else: raise TypeError("can only be used with panda dataframe")
gdf = df.groupby([ def countna(x): return (x.isna()).sum() gdf.agg([
colNullCnt = [] for z in range(len(df1.cols)): colNullCnt.append([df1.cols[z], sum(pd.isnull(trainPd[df1.cols[z]]))])
import pandas as pd import numpy as np df = pd.DataFrame({ num_nan_a = df.loc[ (pd.isna(df[ num_nan_b = df.loc[ (pd.isna(df[ print(df) print( print(f"There are {num_nan_a} NaNs in column a") print(f"There are {num_nan_b} NaNs in column b")
a b 0 1.0 NaN 1 2.0 1.0 2 NaN NaN There are 1 NaNs in column a There are 2 NaNs in column b
>>> x = [] >>> x = x + [1] >>> x = x + [2] >>> x = x + [3] >>> x [1, 2, 3]
>>> a = [[1], [2], [3]] >>> a[0].append(7) >>> a [[1, 7], [2], [3]]
aList=[1,2,3] i=0 for item in aList: if i<2: aList[i]="del" i+=1 aList [ for i in range(2): del aList[0] aList [3]
a = a + b: 0.11338996887207031 a += b: 0.11040496826171875
a += b: 0.10780501365661621 a.append(b): 0.1123361587524414
a += b: 0.41823482513427734 a.append(b): 0.010656118392944336
a += b: 0.165287017822 a.append(b): 0.0132720470428 a.join(a): 0.114929914474
from cStringIO import StringIO buf = StringIO() buf.write( buf.write( buf.write( buf.getvalue()
chunks = [] for s in my_strings: chunks.append(s) result =
result = bytearray() for b in my_bytes_objects: result += b
try: from cStringIO import StringIO except: from io import StringIO source = [ %%timeit buf = StringIO() for i in source: buf.write(i) final = buf.getvalue() %%timeit out = [] for i in source: out.append(i) final = %%timeit out = bytearray() for i in source: out += i %%timeit out = "" for i in source: out += i source = [
def test_concat_chunk(seq, split_by): result = [ for item in seq: if len(result[-1]) + len(item) > split_by: result.append( result[-1] += item return result
import io def test_stringio_chunk(seq, split_by): def chunk(): buf = io.StringIO() size = 0 for item in seq: if size + len(item) <= split_by: size += buf.write(item) else: yield buf.getvalue() buf = io.StringIO() size = buf.write(item) if size: yield buf.getvalue() return list(chunk()) def test_join_chunk(seq, split_by): def chunk(): buf = [] size = 0 for item in seq: if size + len(item) <= split_by: buf.append(item) size += len(item) else: yield buf.clear() buf.append(item) size = len(item) if size: yield return list(chunk())
import timeit import random import string import matplotlib.pyplot as plt line = string.ascii_uppercase + string.digits, k=512)) + x = [] y_concat = [] y_stringio = [] y_join = [] n = 5 for i in range(1, 11): x.append(i) seq = [line] * (20 * 2 ** 20 chunk_size = i * 2 ** 20 y_concat.append( timeit.timeit(lambda: test_concat_chunk(seq, chunk_size), number=n) / n) y_stringio.append( timeit.timeit(lambda: test_stringio_chunk(seq, chunk_size), number=n) / n) y_join.append( timeit.timeit(lambda: test_join_chunk(seq, chunk_size), number=n) / n) plt.plot(x, y_concat) plt.plot(x, y_stringio) plt.plot(x, y_join) plt.legend([ plt.show()
query = "insert into {0}({1},{2},{3}) values({4}, {5}, {6})" query.format(
Downloading/unpacking linkchecker Getting page https: Could not fetch URL https: Will skip URL https: Getting page https: Could not fetch URL https: Will skip URL https: Cannot fetch index base URL https: URLs to search for versions for linkchecker: * https: Getting page https: Could not fetch URL https: Will skip URL https: Could not find any downloads that satisfy the requirement linkchecker Cleaning up... Removing temporary dir C:\Users\jcook\AppData\Local\Temp\pip_build_jcook... No distributions at all found for linkchecker Exception information: Traceback (most recent call last): File "C:\Python34\lib\site-packages\pip\basecommand.py", line 122, in main status = self.run(options, args) File "C:\Python34\lib\site-packages\pip\commands\install.py", line 278, in run requirement_set.prepare_files(finder, force_root_egg_info=self.bundle, bundle=self.bundle) File "C:\Python34\lib\site-packages\pip\req.py", line 1177, in prepare_files url = finder.find_requirement(req_to_install, upgrade=self.upgrade) File "C:\Python34\lib\site-packages\pip\index.py", line 277, in find_requirement raise DistributionNotFound( pip.exceptions.DistributionNotFound: No distributions at all found for linkchecker
$ pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org <package_name>
$ pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org pip setuptools
[global] trusted-host = pypi.python.org pypi.org files.pythonhosted.org
pip --cert /etc/ssl/certs/FOO_Root_CA.pem install linkchecker
pip install --trusted-host pypi.python.org linkchecker
pip install --trusted-host files.pythonhosted.org --trusted-host pypi.org --trusted-host pypi.python.org oauthlib -vvv
$ openssl s_client -connect pypi.python.org:443 CONNECTED(00000003) depth=1 /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert SHA2 Extended Validation Server CA verify error:num=20:unable to get local issuer certificate verify return:0 --- Certificate chain 0 s:/businessCategory=Private Organization/1.3.6.1.4.1.311.60.2.1.3=US/1.3.6.1.4.1.311.60.2.1.2=Delaware/serialNumber=3359300/street=16 Allen Rd/postalCode=03894-4801/C=US/ST=NH/L=Wolfeboro,/O=Python Software Foundation/CN=www.python.org i:/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert SHA2 Extended Validation Server CA 1 s:/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert SHA2 Extended Validation Server CA i:/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert High Assurance EV Root CA
curl -sO http: openssl x509 -inform DES -in DigiCertHighAssuranceEVRootCA.crt -out DigiCertHighAssuranceEVRootCA.pem -text export PIP_CERT=`pwd`/DigiCertHighAssuranceEVRootCA.pem
pip install --trusted-host pypi.python.org <package name>
pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org <package name>
sudo date -s "Wed Aug 23 11:12:00 GMT+1 2018" dpkg-reconfigure tzdata
pip install --trusted-host pypi.python.org <package>
pip install \ --trusted-host pypi.python.org \ --trusted-host pypi.org \ --trusted-host files.pythonhosted.org \ <package>
$ pip install --cert /path/to/mycertificate.crt linkchecker
$HOME/.pip/pip.conf (Linux) %HOME%\pip\pip.ini (Windows)
$ pip install --trusted-host pypi.python.org linkchecker
$HOME/.pip/pip.conf (Linux) %HOME%\pip\pip.ini (Windows)
[global] trusted-host = pypi.python.org pypi.org files.pythonhosted.org
pip install --trusted-host files.pythonhosted.org <package_name>
[list] format=columns [global] trusted-host = pypi.python.org pypi.org
[global] cert = C:/certs/python_root.pem proxy = http:
$ pip3 install --proxy http: --cert C:/certs/python_root.pem PyQt5
$ openssl x509 -inform der -in python_root.cer -out python_root.pem
Traceback (most recent call last): File "emailSend.py", line 14, in <module> server.login(username,password) File "/usr/lib/python2.5/smtplib.py", line 554, in login raise SMTPException("SMTP AUTH extension not supported by server.") smtplib.SMTPException: SMTP AUTH extension not supported by server.
import smtplib fromaddr = toaddrs = msg = username = password = server = smtplib.SMTP( server.starttls() server.login(username,password) server.sendmail(fromaddr, toaddrs, msg) server.quit()
server = smtplib.SMTP( server.ehlo() server.starttls()
msg = "\r\n".join([ "From: user_me@gmail.com", "To: user_you@gmail.com", "Subject: Just a message", "", "Why, oh why" ])
def send_email(user, pwd, recipient, subject, body): import smtplib FROM = user TO = recipient if isinstance(recipient, list) else [recipient] SUBJECT = subject TEXT = body message = % (FROM, ", ".join(TO), SUBJECT, TEXT) try: server = smtplib.SMTP("smtp.gmail.com", 587) server.ehlo() server.starttls() server.login(user, pwd) server.sendmail(FROM, TO, message) server.close() print except: print "failed to send mail"
server_ssl = smtplib.SMTP_SSL("smtp.gmail.com", 465) server_ssl.ehlo() server_ssl.login(gmail_user, gmail_pwd) server_ssl.sendmail(FROM, TO, message) server_ssl.close() print
smtpserver = smtplib.SMTP("smtp.gmail.com", 587) smtpserver.ehlo() smtpserver.starttls() smtpserver.ehlo() smtpserver.login(
smtp_host = smtp_port = 587 server = smtplib.SMTP() server.connect(smtp_host,smtp_port) server.ehlo() server.starttls() server.login(user,passw) fromaddr = raw_input( tolist = raw_input( sub = raw_input( msg = email.MIMEMultipart.MIMEMultipart() msg[ msg[ msg[ msg.attach(MIMEText(raw_input( msg.attach(MIMEText( server.sendmail(user,tolist,msg.as_string())
import smtplib class Gmail(object): def __init__(self, email, password): self.email = email self.password = password self.server = self.port = 587 session = smtplib.SMTP(self.server, self.port) session.ehlo() session.starttls() session.ehlo session.login(self.email, self.password) self.session = session def send_message(self, subject, body): headers = [ "From: " + self.email, "Subject: " + subject, "To: " + self.email, "MIME-Version: 1.0", "Content-Type: text/html"] headers = "\r\n".join(headers) self.session.sendmail( self.email, self.email, headers + "\r\n\r\n" + body) gm = Gmail( gm.send_message(
import smtplib gmail_user = gmail_app_password = sent_from = gmail_user sent_to = [ sent_subject = "Where are all my Robot Women at?" sent_body = ("Hey, what "I hope you have been well!\n" "\n" "Cheers,\n" "Jay\n") email_text = % (sent_from, ", ".join(sent_to), sent_subject, sent_body) try: server = smtplib.SMTP_SSL( server.ehlo() server.login(gmail_user, gmail_app_password) server.sendmail(sent_from, sent_to, email_text) server.close() print( except Exception as exception: print("Error: %s!\n\n" % exception)
def send_email(user, password, recipient, subject, body): gmail_user = user gmail_pwd = password FROM = user TO = recipient if type(recipient) is list else [recipient] SUBJECT = subject TEXT = body message = % (FROM, ", ".join(TO), SUBJECT, TEXT) server = smtplib.SMTP("smtp.gmail.com", 587) server.ehlo() server.starttls() server.login(gmail_user, gmail_pwd) server.sendmail(FROM, TO, message) server.close()
import smtplib fromadd= toadd= msg= username= passwd= try: server = smtplib.SMTP( server.ehlo() server.starttls() server.login(username,passwd) server.sendmail(fromadd,toadd,msg) print("Mail Send Successfully") server.quit() except: print("Error:unable to send mail") NOTE:https:
import smtplib server = smtplib.SMTP( server.ehlo() server.starttls() server.login("fromaddress", "password") msg = "HI!" server.sendmail("fromaddress", "receiveraddress", msg) server.quit()
from contextlib import redirect_stdout with open( with redirect_stdout(f): print(
import sys from contextlib import contextmanager @contextmanager def redirect_stdout(new_target): old_target, sys.stdout = sys.stdout, new_target try: yield new_target finally: sys.stdout = old_target
import os from contextlib import redirect_stdout stdout_fd = sys.stdout.fileno() with open( print( os.write(stdout_fd, b os.system(
import os import sys from contextlib import contextmanager def fileno(file_or_fd): fd = getattr(file_or_fd, if not isinstance(fd, int): raise ValueError("Expected a file (`.fileno()`) or a file descriptor") return fd @contextmanager def stdout_redirected(to=os.devnull, stdout=None): if stdout is None: stdout = sys.stdout stdout_fd = fileno(stdout) with os.fdopen(os.dup(stdout_fd), stdout.flush() try: os.dup2(fileno(to), stdout_fd) except ValueError: with open(to, os.dup2(to_file.fileno(), stdout_fd) try: yield stdout finally: stdout.flush() os.dup2(copied.fileno(), stdout_fd)
import os import sys stdout_fd = sys.stdout.fileno() with open( print( os.write(stdout_fd, b os.system( print(
try: import ctypes from ctypes.util import find_library except ImportError: libc = None else: try: libc = ctypes.cdll.msvcrt except OSError: libc = ctypes.cdll.LoadLibrary(find_library( def flush(stream): try: libc.fflush(None) stream.flush() except (AttributeError, ValueError, IOError): pass
def merged_stderr_stdout(): return stdout_redirected(to=sys.stdout, stdout=sys.stderr)
from __future__ import print_function import sys with merged_stderr_stdout(): print( print(
import sys class Logger(object): def __init__(self, filename="Default.log"): self.terminal = sys.stdout self.log = open(filename, "a") def write(self, message): self.terminal.write(message) self.log.write(message) sys.stdout = Logger("yourlogfilename.txt") print "Hello world !"
from os import open, close, dup, O_WRONLY old = dup(1) close(1) open("file", O_WRONLY) ..... do stuff and then restore close(1) dup(old) close(old)
import sys from contextlib import contextmanager @contextmanager def stdout_redirected(new_stdout): save_stdout = sys.stdout sys.stdout = new_stdout try: yield None finally: sys.stdout = save_stdout
with open(filename, "w") as f: with stdout_redirected(f): print "Hello world"
class FileToLogInterface(file): Interface to make sure that everytime anything is written to stderr, it is also forwarded to a file. def __init__(self, *args, **kwargs): if raise TypeError( else: if not isinstance(kwargs[ raise TypeError( self._cfg = kwargs[ kwargs.pop( self._logger = logging.getlogger( super(FileToLogInterface, self).__init__(*args, **kwargs) def write(self, msg): super(FileToLogInterface, self).write(msg) self._logger.info(msg)
import contextlib, sys @contextlib.contextmanager def log_print(file): class Logger: def __init__(self, file): self.terminal = sys.stdout self.log = file def write(self, message): self.terminal.write(message) self.log.write(message) def __getattr__(self, attr): return getattr(self.terminal, attr) logger = Logger(file) _stdout = sys.stdout _stderr = sys.stderr sys.stdout = logger sys.stderr = logger try: yield logger.log finally: sys.stdout = _stdout sys.stderr = _stderr with log_print(open( print( print(
$ python -m timeit -s \ "import string" \ " 10000 loops, best of 3: 57.6 usec per loop $ python -m timeit -s \ "import string" \ "filter(str.isalnum, string.printable)" 10000 loops, best of 3: 37.9 usec per loop $ python -m timeit -s \ "import re, string" \ "re.sub( 10000 loops, best of 3: 27.5 usec per loop $ python -m timeit -s \ "import re, string" \ "re.sub( 100000 loops, best of 3: 15 usec per loop $ python -m timeit -s \ "import re, string; pattern = re.compile( "pattern.sub( 100000 loops, best of 3: 11.2 usec per loop
C:\junk>\python26\python -mtimeit -s"import string;d= 100000 loops, best of 3: 2.04 usec per loop C:\junk>\python26\python -mtimeit -s"import re,string;s=string.printable;r=re.compile(r 100000 loops, best of 3: 7.34 usec per loop
C:\junk>\python26\python -c "import string; s = string.printable; print len(s),repr(s)" 100
C:\junk>\python26\python -mtimeit -s"d= 1000000 loops, best of 3: 1.97 usec per loop C:\junk>\python26\python -mtimeit -s"import re;s= 10000 loops, best of 3: 26.4 usec per loop
>>> import re >>> string = "Kl13@£$%[}; >>> pattern = re.compile( >>> string = re.sub(pattern, >>> print string Kl13
def ExtractAlphanumeric(InputString): from string import ascii_letters, digits return "".join([ch for ch in InputString if ch in (ascii_letters + digits)])
PERMITTED_CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-" someString = "".join(c for c in someString if c in PERMITTED_CHARS)
for char in my_string: if not char.isalnum(): my_string = my_string.replace(char,"")
from inspect import getsource from random import sample import re from string import printable from timeit import timeit pattern_single = re.compile(r pattern_repeat = re.compile(r translation_tb = str.maketrans( def generate_test_string(length): return def main(): for i in range(0, 60, 10): for test in [ lambda: lambda: lambda: re.sub(r lambda: re.sub(r lambda: pattern_single.sub( lambda: pattern_repeat.sub( lambda: generate_test_string(i).translate(translation_tb), ]: print(timeit(test), i, getsource(test).lstrip( if __name__ == main()
Time Length Code 6.3716264850008880 00 5.7285426190064750 00 8.1875841680011940 00 re.sub(r 8.0002205439959650 00 re.sub(r 5.5290945199958510 00 pattern_single.sub( 5.4417179649972240 00 pattern_repeat.sub( 4.6772285089973590 00 generate_test_string(i).translate(translation_tb) 23.574712151996210 10 22.829975890002970 10 27.210196289997840 10 re.sub(r 27.203713296003116 10 re.sub(r 24.008979928999906 10 pattern_single.sub( 23.945240008994006 10 pattern_repeat.sub( 21.830899796994345 10 generate_test_string(i).translate(translation_tb) 38.731336012999236 20 37.942474347000825 20 42.169366310001350 20 re.sub(r 41.933375883003464 20 re.sub(r 38.899814646996674 20 pattern_single.sub( 38.636144253003295 20 pattern_repeat.sub( 36.201238164998360 20 generate_test_string(i).translate(translation_tb) 49.377356811004574 30 48.408927293996385 30 53.901889764994850 30 re.sub(r 52.130339455994545 30 re.sub(r 50.061149017004940 30 pattern_single.sub( 49.366573111998150 30 pattern_repeat.sub( 46.649754120997386 30 generate_test_string(i).translate(translation_tb) 63.107938601999194 40 65.116287978999030 40 71.477421126997800 40 re.sub(r 66.027950693998720 40 re.sub(r 63.315361931003280 40 pattern_single.sub( 62.342320287003530 40 pattern_repeat.sub( 58.249303059004890 40 generate_test_string(i).translate(translation_tb) 73.810345625002810 50 72.593953348005020 50 76.048324580995540 50 re.sub(r 75.106637657001560 50 re.sub(r 74.681338128997600 50 pattern_single.sub( 72.430461594005460 50 pattern_repeat.sub( 69.394243567003290 50 generate_test_string(i).translate(translation_tb)
import argparse parser = argparse.ArgumentParser("simple_example") parser.add_argument("counter", help="An integer will be increased by 1 and printed.", type=int) args = parser.parse_args() print(args.counter + 1)
usage: simple_example [-h] counter positional arguments: counter counter will be increased by 1 and printed. optional arguments: -h, --help show this help message and exit
import sys param_1= sys.argv[1] param_2= sys.argv[2] param_3= sys.argv[3] print
import sys var1 = sys.argv[1] var2 = sys.argv[2] var3 = sys.argv[3]
SITEDIR=$(python -m site --user-site) mkdir -p "$SITEDIR" echo "$HOME/foo/bar" > "$SITEDIR/somelib.pth"
export PYTHONPATH="$PYTHONPATH:/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python"
export PYTHONPATH="/my/other/path1" export PYTHONPATH="${PYTHONPATH}:/my/other/path2"
export PYTHONPATH="${PYTHONPATH}:/User/johndoe/pythonModule"
import sys import os print(str(sys.path)) dir_path = os.path.dirname(os.path.realpath(__file__)) print(f"current working dir: {dir_path}") root_dir = dir_path.replace("/util", print(f"root dir: {root_dir}") sys.path.insert(0, root_dir) print(str(sys.path))
from pathlib import Path to_add=Path(path_of_directory_to_add) from sys import path if str(to_add) not in path: minLen=999999 for index,directory in enumerate(path): if minLen=len(directory) stpi=index pathSitePckgs=Path(path[stpi]) with open(str(pathSitePckgs/ pth_file.write(str(to_add))
>>> import json >>> original_list = [ >>> json_list = json.dumps(original_list) >>> json_list >>> new_list = json.loads(json_list) >>> new_list [u
import json def json_load_byteified(file_handle): return _byteify( json.load(file_handle, object_hook=_byteify), ignore_dicts=True ) def json_loads_byteified(json_text): return _byteify( json.loads(json_text, object_hook=_byteify), ignore_dicts=True ) def _byteify(data, ignore_dicts = False): if isinstance(data, unicode): return data.encode( if isinstance(data, list): return [ _byteify(item, ignore_dicts=True) for item in data ] if isinstance(data, dict) and not ignore_dicts: return { _byteify(key, ignore_dicts=True): _byteify(value, ignore_dicts=True) for key, value in data.iteritems() } return data
>>> json_loads_byteified( { >>> json_loads_byteified( >>> json_loads_byteified( 7 >>> json_loads_byteified( [ >>> json_loads_byteified( [[[[[[[[ >>> json_loads_byteified( { >>> json_load_byteified(open( {
>>> import json >>> import yaml >>> list_org = [ >>> list_dump = json.dumps(list_org) >>> list_dump >>> json.loads(list_dump) [u >>> yaml.safe_load(list_dump) [
def byteify(input): if isinstance(input, dict): return {byteify(key): byteify(value) for key, value in input.iteritems()} elif isinstance(input, list): return [byteify(element) for element in input] elif isinstance(input, unicode): return input.encode( else: return input
def _decode_list(data): rv = [] for item in data: if isinstance(item, unicode): item = item.encode( elif isinstance(item, list): item = _decode_list(item) elif isinstance(item, dict): item = _decode_dict(item) rv.append(item) return rv def _decode_dict(data): rv = {} for key, value in data.iteritems(): if isinstance(key, unicode): key = key.encode( if isinstance(value, unicode): value = value.encode( elif isinstance(value, list): value = _decode_list(value) elif isinstance(value, dict): value = _decode_dict(value) rv[key] = value return rv obj = json.loads(s, object_hook=_decode_dict)
>>> nl = json.loads(js) >>> nl [u >>> nl = [s.encode( >>> nl [
import json, ast d = { print "JSON Fail: ", json.loads(json.dumps(d)) print "AST Win:", ast.literal_eval(json.dumps(d))
def deunicodify_hook(pairs): new_pairs = [] for key, value in pairs: if isinstance(value, unicode): value = value.encode( if isinstance(key, unicode): key = key.encode( new_pairs.append((key, value)) return dict(new_pairs) In [52]: open( Out[52]: In [53]: json.load(open( Out[53]: {u u u u In [54]: json.load(open( Out[54]: {
def to_utf8(loader, node): return loader.construct_scalar(node).encode( yaml.add_constructor(u
dt[yaml.safe_load(json.dumps(m))] =~ 100 * dt[j] dt[byteify recursion(Mark Amery)] =~ 5 * dt[j]
def filter_data(obj): if type(obj) in (int, float, str, bool): return obj elif type(obj) == unicode: return str(obj) elif type(obj) in (list, tuple, set): obj = list(obj) for i,v in enumerate(obj): obj[i] = filter_data(v) elif type(obj) == dict: for i,v in obj.iteritems(): obj[i] = filter_data(v) else: print "invalid object in data, converting to string" obj = str(obj) return obj
import json import pickle d = { json.dump(d,open("testjson.txt","w")) print json.load(open("testjson.txt","r")) pickle.dump(d,open("testpickle.txt","w")) print pickle.load(open("testpickle.txt","r"))
import requests import six from six import iteritems requests.packages.urllib3.disable_warnings() r = requests.get("http: def _byteify(data): if isinstance(data, six.string_types): return str(data.encode( if isinstance(data, list): return [ _byteify(item) for item in data ] if isinstance(data, dict): return { _byteify(key): _byteify(value) for key, value in iteritems(data) } return data w = r.json(object_hook=_byteify) print(w)
def _parseJSON(self, obj): newobj = {} for key, value in obj.iteritems(): key = str(key) if isinstance(value, dict): newobj[key] = self._parseJSON(value) elif isinstance(value, list): if key not in newobj: newobj[key] = [] for i in value: newobj[key].append(self._parseJSON(i)) elif isinstance(value, unicode): val = str(value) if val.isdigit(): val = int(val) else: try: val = float(val) except ValueError: val = str(val) newobj[key] = val return newobj
obj = json.loads(content, parse_float=float, parse_int=int) obj = _parseJSON(obj)
def _parseJSON(self, obj): if isinstance(obj, dict): newobj = {} for key, value in obj.iteritems(): key = str(key) newobj[key] = self._parseJSON(value) elif isinstance(obj, list): newobj = [] for value in obj: newobj.append(self._parseJSON(value)) elif isinstance(obj, unicode): newobj = str(obj) else: newobj = obj return newobj
python speed.py json loads [0.16sec]: {u json loads + encoding [0.18sec]: { time overhead in percent: 9%
import json, nested_encode, time s = """ { "firstName": "Jos\\u0301", "lastName": "Smith", "isAlive": true, "age": 25, "address": { "streetAddress": "21 2nd Street", "city": "\\u00d6sterreich", "state": "NY", "postalCode": "10021-3100" }, "phoneNumbers": [ { "type": "home", "number": "212 555-1234" }, { "type": "office", "number": "646 555-4567" } ], "children": [], "spouse": null, "a": [{"b": [[1, 2, ["\\u00d6sterreich"]]]}] } """ t1 = time.time() for i in xrange(10000): u = json.loads(s) dt_json = time.time() - t1 t1 = time.time() for i in xrange(10000): b = nested_encode.encode_nested(json.loads(s)) dt_json_enc = time.time() - t1 print "json loads [%.2fsec]: %s..." % (dt_json, str(u)[:20]) print "json loads + encoding [%.2fsec]: %s..." % (dt_json_enc, str(b)[:20]) print "time overhead in percent: %i%%" % (100 * (dt_json_enc - dt_json)/dt_json)
response_message = json.loads(json.dumps(response.text)) print(response_message)
if NAME_CLASS_MAP.has_key(cls): kwargs = {} for i in obj.keys(): kwargs[str(i)] = obj[i] o = NAME_CLASS_MAP[cls](**kwargs) o.save()
import json def encode_items(input, encoding= u"""original from: https: adapted by SO/u/611007 (20150623) >>> >>> >>> >>> txt = u"Tüskéshátú kígyóbűvölő" >>> txt2 = u"T\\u00fcsk\\u00e9sh\\u00e1t\\u00fa k\\u00edgy\\u00f3b\\u0171v\\u00f6l\\u0151" >>> txt3 = u"uúuutifu" >>> txt4 = b >>> >>> assert u >>> txt4u = txt4.decode( >>> assert txt4u == u >>> txt5 = b"u\\xc3\\xbauutifu" >>> txt5u = txt5.decode( >>> txt6 = u"u\\u251c\\u2551uutifu" >>> there_and_back_again = lambda t: encode_items(t, encoding= >>> assert txt == there_and_back_again(txt) >>> assert txt == there_and_back_again(txt2) >>> assert txt3 == there_and_back_again(txt3) >>> assert txt3.encode( >>> assert txt3 == txt4u,(txt3,txt4u) >>> assert txt3 == there_and_back_again(txt5) >>> assert txt3 == there_and_back_again(txt5u) >>> assert txt3 == there_and_back_again(txt4u) >>> assert txt3.encode( >>> assert txt3.encode( >>> assert txt2.encode( >>> assert { >>> assert [txt2.encode( >>> assert [[txt2.encode( >>> assert [{ >>> assert { """ try: input.iteritems return {encode_items(k): encode_items(v) for (k,v) in input.iteritems()} except AttributeError: if isinstance(input, unicode): return input.encode(encoding) elif isinstance(input, str): return input try: iter(input) return [encode_items(e) for e in input] except TypeError: return input def alt_dumps(obj, **kwargs): """ >>> alt_dumps({ """ if del kwargs[ return json.dumps(encode_items(obj), ensure_ascii=False, **kwargs)
import contextlib @contextlib.contextmanager def redirect_argv(num): sys._argv = sys.argv[:] sys.argv=[str(num)] yield sys.argv = sys._argv with redirect_argv(1): print(sys.argv)
def main(arg1, arg2, etc): if __name__ == "__main__": main(sys.argv[1], sys.argv[2], sys.argv[3])
import subprocess subprocess.Popen("script2.py 1", shell=True)
import subprocess cmd = p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True) out, err = p.communicate() result = out.split( for lin in result: if not lin.startswith( print(lin)
import subprocess subprocess.call(" python script2.py 1", shell=True)
int[] myIntArray = {1,2,3}; String[] myStringArray = {"a","b","c"};
mylist = list() mylist.append(1) mylist.append(2) mylist.append(3) print(mylist) >>> [1,2,3]
Eric, Salesman, X-Shop Freddie, Manager, X2-Shop Teddy, Salesman, X2-Shop Sean, Manager, X2-Shop
from django.db.models import Count Members.objects.values(
SELECT designation, COUNT(designation) AS dcount FROM members GROUP BY designation
query = Members.objects.all().query query.group_by = [ results = QuerySet(query=query, model=Members)
cities = [ { { { { { ] ... {% regroup cities by country as country_list %} <ul> {% for country in country_list %} <li>{{ country.grouper }} <ul> {% for city in country.list %} <li>{{ city.name }}: {{ city.population }}</li> {% endfor %} </ul> </li> {% endfor %} </ul>
from django_group_by import GroupByMixin class BookQuerySet(QuerySet, GroupByMixin): pass class Book(Model): title = TextField(...) author = ForeignKey(User, ...) shop = ForeignKey(Shop, ...) price = DecimalField(...)
class GroupedBookListView(PaginationMixin, ListView): template_name = model = Book paginate_by = 100 def get_queryset(self): return Book.objects.group_by( shop_count=Count( def get_context_data(self, **kwargs): return super().get_context_data(total_count=self.get_queryset().count(), **kwargs)
<ul> {% for book in object_list %} <li> <h2>{{ book.title }}</td> <p>{{ book.author.last_name }}, {{ book.author.first_name }}</p> <p>{{ book.shop_count }}</p> <p>{{ book.price_avg }}</p> </li> {% endfor %} </ul>
class Travel(models.Model): interest = models.ForeignKey(Interest) user = models.ForeignKey(User) time = models.DateTimeField(auto_now_add=True) >>> Travel.objects.values( <QuerySet [{ >>> Travel.objects.values( <QuerySet [{
from django.db.models import Sum Members.objects.annotate(total=Sum(designation))
$ unzip -l /tmp/example.zip Archive: /tmp/example.zip Length Date Time Name -------- ---- ---- ---- 8467 11-26-02 22:30 jwzthreading.py -------- ------- 8467 1 file $ ./python Python 2.3 ( >>> import sys >>> sys.path.insert(0, >>> import jwzthreading >>> jwzthreading.__file__
>>> def kinetic_energy(m: ... return 1/2*m*v**2 ... >>> kinetic_energy.__annotations__ {
>>> rd={ >>> def f()->rd: ... pass >>> f.__annotations__[ <class >>> f.__annotations__[ >>> f.__annotations__[
def validate(func, locals): for var, test in func.__annotations__.items(): value = locals[var] try: pr=test.__name__+ except AttributeError: pr=test.__name__ msg = assert test(value), msg def between(lo, hi): def _between(x): return lo <= x <= hi _between.__docstring__= return _between def f(x: between(3,10), y:lambda _y: isinstance(_y,int)): validate(f, locals()) print(x,y)
>>> f(2,2) AssertionError: x==2; Test: _between: must be between 3 and 10 >>> f(3,2.1) AssertionError: y==2.1; Test: <lambda>
>>> import locale >>> print str( locale.getlocale() ) (None, None) >>> locale.setlocale(locale.LC_ALL, Traceback (most recent call last): File "<stdin>", line 1, in <module> File "/usr/lib/python2.7/locale.py", line 531, in setlocale return _setlocale(category, locale) locale.Error: unsupported locale setting
export LC_ALL="en_US.UTF-8" export LC_CTYPE="en_US.UTF-8" sudo dpkg-reconfigure locales
$ locale -a C C.UTF-8 en_AG en_AG.utf8 en_AU.utf8 en_BW.utf8 en_CA.utf8 en_DK.utf8 en_GB.utf8 en_HK.utf8 en_IE.utf8 en_IN en_IN.utf8 en_NG en_NG.utf8 en_NZ.utf8 en_PH.utf8 en_SG.utf8 en_US.utf8 en_ZA.utf8 en_ZM en_ZM.utf8 en_ZW.utf8 it_CH.utf8 it_IT.utf8 POSIX
>>> import locale >>> locale.setlocale(locale.LC_ALL, Traceback (most recent call last): File "<stdin>", line 1, in <module> File "/usr/lib/python2.7/locale.py", line 539, in setlocale return _setlocale(category, locale) locale.Error: unsupported locale setting >>> locale.setlocale(locale.LC_ALL,
export LC_ALL="en_US.UTF-8" export LC_CTYPE="en_US.UTF-8" sudo dpkg-reconfigure locales
$ locale LANG=en_US.utf8 LANGUAGE= LC_CTYPE="en_US.utf8" LC_NUMERIC=es_ES.utf8 LC_TIME=es_ES.utf8 LC_COLLATE="en_US.utf8" LC_MONETARY=es_ES.utf8 LC_MESSAGES="en_US.utf8" LC_PAPER=es_ES.utf8 LC_NAME="en_US.utf8" LC_ADDRESS="en_US.utf8" LC_TELEPHONE="en_US.utf8" LC_MEASUREMENT=es_ES.utf8 LC_IDENTIFICATION="en_US.utf8" LC_ALL=
export LANGUAGE="en_US.UTF-8" export LC_ALL="en_US.UTF-8"
$ locale LANG=en_US.utf8 LANGUAGE= LC_CTYPE="en_US.utf8" LC_NUMERIC=es_ES.utf8 LC_TIME=es_ES.utf8 LC_COLLATE="en_US.utf8" LC_MONETARY=es_ES.utf8 LC_MESSAGES="en_US.utf8" LC_PAPER=es_ES.utf8 LC_NAME="en_US.utf8" LC_ADDRESS="en_US.utf8" LC_TELEPHONE="en_US.utf8" LC_MEASUREMENT=es_ES.utf8 LC_IDENTIFICATION="en_US.utf8" LC_ALL=
RUN apt-get update && apt-get install -y locales && rm -rf /var/lib/apt/lists/* \ && localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8 ENV LANG en_US.UTF-8
import locale loc_list = [(a,b) for a,b in locale.locale_alias.items() ] loc_size = len(loc_list) print loc_size, for loc in loc_list: try: locale.setlocale(locale.LC_TIME, loc[1]) print except: pass
858 entries SUCCES set en_US.UTF-8 (univ) SUCCES set C (c.ascii) SUCCES set C (c.en) SUCCES set C (posix-utf2) SUCCES set C (c) SUCCES set C (c_c) SUCCES set C (c_c.c) SUCCES set en_IE.UTF-8 (en_ie.utf8@euro) SUCCES set en_US.UTF-8 (universal.utf8@ucs4) SUCCES set C (posix) SUCCES set C (english_united-states.437) SUCCES set en_US.UTF-8 (universal)
>>> import locale >>> locale.setlocale(locale.LC_ALL,
>>> import datetime as dt >>> print(dt.date.today().strftime("%A %d. %B %Y")) Sonntag 11. Dezember 2016
DESIRED_LOCALE=de DESIRED_LOCALE_COUNTRY=DE DESIRED_CODEPAGE_RE=\.[Uu][Tt][Ff].?8 if [ $(locale -a | grep -cE "${DESIRED_LOCALE}_${DESIRED_LOCALE_COUNTRY}${DESIRED_CODEPAGE_RE}") -eq 1 ] then export LC_ALL=$(locale -a | grep -m1 -E "${DESIRED_LOCALE}_${DESIRED_LOCALE_COUNTRY}${DESIRED_CODEPAGE_RE}") export LANG=$LC_ALL else echo "Not exactly one desired locale definition found: $(locale -a | grep -E "${DESIRED_LOCALE}_${DESIRED_LOCALE_COUNTRY}${DESIRED_CODEPAGE_RE}")" >&2 fi
def which(program): import os def is_exe(fpath): return os.path.isfile(fpath) and os.access(fpath, os.X_OK) fpath, fname = os.path.split(program) if fpath: if is_exe(program): return program else: for path in os.environ["PATH"].split(os.pathsep): exe_file = os.path.join(path, program) if is_exe(exe_file): return exe_file return None
import distutils.spawn distutils.spawn.find_executable("notepad.exe")
my_command = any(os.access(os.path.join(path, my_command), os.X_OK) for path in os.environ["PATH"].split(os.pathsep))
cmd_exists = lambda x: any(os.access(os.path.join(path, x), os.X_OK) for path in os.environ["PATH"].split(os.pathsep)) cmd_exists(
def cmd_exists(cmd): return any( os.access(os.path.join(path, cmd), os.X_OK) for path in os.environ["PATH"].split(os.pathsep) )
import shutil command = shutil.which(command) is not None
def cmd_exists(cmd): return shutil.which(cmd) is not None
def cmd_exists(cmd): return subprocess.call("type " + cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0
>>> cmd_exists("jsmin") True >>> cmd_exists("cssmin") False >>> cmd_exists("ls") True >>> cmd_exists("dir") False >>> cmd_exists("node") True >>> cmd_exists("steam") False
def which(program): def is_exe(fpath): return os.path.exists(fpath) and os.access(fpath, os.X_OK) and os.path.isfile(fpath) def ext_candidates(fpath): yield fpath for ext in os.environ.get("PATHEXT", "").split(os.pathsep): yield fpath + ext fpath, fname = os.path.split(program) if fpath: if is_exe(program): return program else: for path in os.environ["PATH"].split(os.pathsep): exe_file = os.path.join(path, program) for candidate in ext_candidates(exe_file): if is_exe(candidate): return candidate return None
import subprocess myexec = "python2.8" try: subprocess.call([myexec, except OSError: print "%s not found on path" % myexec
import os import sys import stat import tempfile def is_case_sensitive_filesystem(): tmphandle, tmppath = tempfile.mkstemp() is_insensitive = os.path.exists(tmppath.upper()) os.close(tmphandle) os.remove(tmppath) return not is_insensitive _IS_CASE_SENSITIVE_FILESYSTEM = is_case_sensitive_filesystem() def which(program, case_sensitive=_IS_CASE_SENSITIVE_FILESYSTEM): def is_exe(fpath): accessmode = os.F_OK | os.X_OK if os.path.exists(fpath) and os.access(fpath, accessmode) and not os.path.isdir(fpath): filemode = os.stat(fpath).st_mode ret = bool(filemode & stat.S_IXUSR or filemode & stat.S_IXGRP or filemode & stat.S_IXOTH) return ret def list_file_exts(directory, search_filename=None, ignore_case=True): """ Return list of (filename, extension) tuples which match the search_filename""" if ignore_case: search_filename = search_filename.lower() for root, dirs, files in os.walk(path): for f in files: filename, extension = os.path.splitext(f) if ignore_case: filename = filename.lower() if not search_filename or filename == search_filename: yield (filename, extension) break fpath, fname = os.path.split(program) if fpath: if is_exe(program): return program elif "win" in sys.platform: if is_exe(fname): return program paths = [path.strip( exe_exts = [ext for ext in os.environ.get("PATHEXT", "").split(os.pathsep)] if not case_sensitive: exe_exts = map(str.lower, exe_exts) for path in paths: exe_file = os.path.join(path, program) if is_exe(exe_file): return exe_file for path in paths: filepath = os.path.join(path, program) for extension in exe_exts: exe_file = filepath+extension if is_exe(exe_file): return exe_file if len(os.path.splitext(fname)[1]) == 0: for path in paths: file_exts = list_file_exts(path, fname, not case_sensitive) for file_ext in file_exts: filename = "".join(file_ext) exe_file = os.path.join(path, filename) if is_exe(exe_file): return exe_file return None
def which(program): path_ext = [""]; ext_list = None if sys.platform == "win32": ext_list = [ext.lower() for ext in os.environ["PATHEXT"].split(";")] def is_exe(fpath): exe = os.path.isfile(fpath) and os.access(fpath, os.X_OK) if not exe: if ext_list: for ext in ext_list: exe_path = "%s%s" % (fpath,ext) if os.path.isfile(exe_path) and os.access(exe_path, os.X_OK): path_ext[0] = ext return True return False return exe fpath, fname = os.path.split(program) if fpath: if is_exe(program): return "%s%s" % (program, path_ext[0]) else: for path in os.environ["PATH"].split(os.pathsep): path = path.strip( exe_file = os.path.join(path, program) if is_exe(exe_file): return "%s%s" % (exe_file, path_ext[0]) return None
for each element r in path: for each file f in directory p: if f is executable: return True
from fabric.api import * def test_cli_exists(): with settings(warn_only=True): which = local( if not which: print "command does not exist" assert which
result = [] [ result.extend(el) for el in x] for el in result: print el
import itertools a = [["a","b"], ["c"]] print list(itertools.chain.from_iterable(a))
>>> x = [["a","b"], ["c"]] >>> [inner ... for outer in x ... for inner in outer] [
>>> x = [["a","b"], ["c"]] >>> for el in sum(x, []): ... print el ... a b c
def flatten(l, ltypes=(list, tuple)): ltype = type(l) l = list(l) i = 0 while i < len(l): while isinstance(l[i], ltypes): if not l[i]: l.pop(i) i -= 1 break else: l[i:i + 1] = l[i] i += 1 return ltype(l)
def iterFlatten(root): if isinstance(root, (list, tuple)): for element in root: for e in iterFlatten(element): yield e else: yield root
import itertools import timeit big_list = [[0]*1000 for i in range(1000)] timeit.repeat(lambda: list(itertools.chain.from_iterable(big_list)), number=100) timeit.repeat(lambda: list(itertools.chain(*big_list)), number=100) timeit.repeat(lambda: (lambda b: map(b.extend, big_list))([]), number=100) timeit.repeat(lambda: [el for list_ in big_list for el in list_], number=100) [100*x for x in timeit.repeat(lambda: sum(big_list, []), number=1)]
>>> import itertools >>> import timeit >>> big_list = [[0]*1000 for i in range(1000)] >>> timeit.repeat(lambda: list(itertools.chain.from_iterable(big_list)), number=100) [3.016212113769325, 3.0148865239060227, 3.0126415732791028] >>> timeit.repeat(lambda: list(itertools.chain(*big_list)), number=100) [3.019953987082083, 3.528754223385439, 3.02181439266457] >>> timeit.repeat(lambda: (lambda b: map(b.extend, big_list))([]), number=100) [1.812084445152557, 1.7702404451095965, 1.7722977998725362] >>> timeit.repeat(lambda: [el for list_ in big_list for el in list_], number=100) [5.409658160700605, 5.477502077679354, 5.444318360412744] >>> [100*x for x in timeit.repeat(lambda: sum(big_list, []), number=1)] [399.27587954973444, 400.9240571138051, 403.7521153804846]
def flatten(lst): if lst: car,*cdr=lst if isinstance(car,(list,tuple)): if cdr: return flatten(car) + flatten(cdr) return flatten(car) if cdr: return [car] + flatten(cdr) return [car]
def flatten(x): flat = True ans = [] for i in x: if ( i.__class__ is list): ans = flatten(i) else: ans.append(i) return ans
from itertools import chain x = [["a","b"], ["c"]] y = list(chain(*x))
>>> x = [ [ >>> for el in reduce(lambda a,b: a+b, x, []): ... print el ... __main__:1: DeprecationWarning: reduce() not supported in 3.x; use functools.reduce() a b c >>> import functools >>> for el in functools.reduce(lambda a,b: a+b, x, []): ... print el ... a b c >>>
def flatten(input): ret = [] if not isinstance(input, (list, tuple)): return [input] for i in input: if isinstance(i, (list, tuple)): ret.extend(flatten(i)) else: ret.append(i) return ret
def flatten(some_list): for element in some_list: if type(element) in (tuple, list): for item in flatten(element): yield item else: yield element
result = [] [ result.extend(el) for el in x] for el in flatten(result): print el
{ "_id" : ObjectId("4fe3a90783157d765d000011"), "status" : [ "opencalais" ], "content_length" : 688, "open_calais_extract" : { "entities" : [ {"type" :"Person","name" : "Iman Samdura","rel_score" : 0.223 }, {"type" : "Company", "name" : "Associated Press", "rel_score" : 0.321 }, {"type" : "Country", "name" : "Indonesia", "rel_score" : 0.321 }, ... ]}, "title" : "Indonesia Police Arrest Bali Bomb Planner", "time" : "06:42 ET", "filename" : "021121bn.01", "month" : "November", "utctime" : 1037836800, "date" : "November 21, 2002", "news_type" : "bn", "day" : "21" }
def flatten_list(items): return sorted([entity[ [item[ for entities in sublist])
def join(a): """Joins a sequence of sequences into a single sequence. (One-level flattening.) E.g., join([(1,2,3), [4, 5], [6, (7, 8, 9), 10]]) = [1,2,3,4,5,6,(7,8,9),10] This is very efficient, especially when the subsequences are long. """ n = sum([len(b) for b in a]) l = [None]*n i = 0 for b in a: j = i+len(b) l[i:j] = b i = j return l
[(0.5391559600830078, (0.5400412082672119, (0.5419249534606934, (0.7351131439208984, (0.7472689151763916, (1.5468521118164062, (26.696547985076904,
def hello(): print "Hi :)" if __name__ == "__main__": hello()
import sys import inspect import importlib import os if __name__ == "__main__": cmd_folder = os.path.realpath(os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0])) if cmd_folder not in sys.path: sys.path.insert(0, cmd_folder) methodname = sys.argv[1] modulename, classname, funcname = methodname.split(".") themodule = importlib.import_module(modulename) theclass = getattr(themodule, classname) thefunc = getattr(theclass, funcname) args = inspect.getargspec(thefunc) z = len(args[0]) + 2 params=sys.argv[2:z] thefunc(*params)
class SomeClass: @staticmethod def First(): print "First" @staticmethod def Second(x): print(x) @staticmethod def Third(x, y): print x print y class OtherClass: @staticmethod def Uno(): print("Uno")
./PyRun PyTest.SomeClass.First ./PyRun PyTest.SomeClass.Second Hello ./PyRun PyTest.SomeClass.Third Hello World ./PyRun PyTest.OtherClass.Uno ./PyRun PyTest.SomeClass.Second "Hello" ./PyRun PyTest.SomeClass.Second \(Hello, World\)
import compago app = compago.Application() @app.command def hello(): print "hi there!" @app.command def goodbye(): print "see ya later." if __name__ == "__main__": app.run()
$ python test.py hello hi there! $ python test.py goodbye see ya later.
import fire class Calculator(object): def double(self, number): return 2 * number if __name__ == fire.Fire(Calculator)
python calculator.py double 10 python calculator.py double --number=15
$ pyfunc -m range -a 1 7 2 1 3 5 $ pyfunc -m string.upper -a test TEST $ pyfunc -m string.replace -a analyze this
def myfunction(): ... if __name__ == globals()[sys.argv[1]]()
$ ip= $ python -c "import ${fun_name} as cft; cft.test_term_fun(${ip})" hi
def OE(n): for a in range(n): if a % 2 == 0: print(a) else: print(a, "ODD")
Traceback (most recent call last): File "./test.py", line 24, in <module> response = requests.get(url1, headers=headers) File "build/bdist.linux-x86_64/egg/requests/api.py", line 52, in get File "build/bdist.linux-x86_64/egg/requests/api.py", line 40, in request File "build/bdist.linux-x86_64/egg/requests/sessions.py", line 209, in request File "build/bdist.linux-x86_64/egg/requests/models.py", line 624, in send File "build/bdist.linux-x86_64/egg/requests/models.py", line 300, in _build_response File "build/bdist.linux-x86_64/egg/requests/models.py", line 611, in send requests.exceptions.SSLError: [Errno 1] _ssl.c:503: error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed
from boto3.session import Session import os os.environ[
REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt export REQUESTS_CA_BUNDLE
C:\>python -c "import requests; print requests.certs.where()" c:\Python27\lib\site-packages\requests-2.8.1-py2.7.egg\requests\cacert.pem
root@host:~/ /usr/lib/python2.7/dist-packages/certifi/cacert.pem root@host:~/ /usr/local/lib/python2.7/dist-packages/requests/cacert.pem
REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-bundle.crt python -c "import requests; requests.get(
sudo pip uninstall -y certifi sudo pip install certifi==2015.04.28
import requests url = "Write your url here" returnResponse = requests.get(url, verify=False)
sudo apt-get install ntpdate sudo ntpdate -u ntp.ubuntu.com
import requests.api import warnings def requestspatch(method, url, **kwargs): kwargs[ return _origcall(method, url, **kwargs) _origcall = requests.api.request requests.api.request = requestspatch warnings.warn(
open /Applications/Python\ 3.6/Install\ Certificates.command
cat StartComClass1.pem >> .virtualenvs/caldav/lib/python2.7/site-packages/pip/_vendor/requests/cacert.pem cat temp/StartComClass1.pem >> .virtualenvs/caldav/lib/python2.7/site-packages/requests/cacert.pem
pyenv virtualenv 3.4.6 myvenv pyenv activate myvenv pip install -r requirements.txt
$ sudo pip install yaml Downloading/unpacking yaml Could not find any downloads that satisfy the requirement yaml No distributions at all found for yaml Storing complete log in /home/pa/.pip/pip.log
$ sudo apt-get install python-yaml $ sudo yum install python-yaml
brew install libyaml sudo python -m easy_install pyyaml
yum install libyaml-devel apt-get install libyaml-dev
. your/env/bin/activate tar xzf PyYAML-3.13.tar.gz cd PyYAML-3.13.tar.gz (env)$ python setup.py install (env)$ python setup.py test
import numpy as np def find_nearest(array, value): array = np.asarray(array) idx = (np.abs(array - value)).argmin() return array[idx] array = np.random.random(10) print(array) value = 0.5 print(find_nearest(array, value))
def find_nearest(array,value): idx = np.searchsorted(array, value, side="left") if idx > 0 and (idx == len(array) or math.fabs(value - array[idx-1]) < math.fabs(value - array[idx])): return array[idx-1] else: return array[idx]
def find_nearest(a, a0): "Element in nd array `a` closest to the scalar value `a0`" idx = np.abs(a - a0).argmin() return a.flat[idx]
import numpy as np def find_nearest_vector(array, value): idx = np.array([np.linalg.norm(x+y) for (x,y) in array-value]).argmin() return array[idx] A = np.random.random((10,2))*100 """ A = array([[ 34.19762933, 43.14534123], [ 48.79558706, 47.79243283], [ 38.42774411, 84.87155478], [ 63.64371943, 50.7722317 ], [ 73.56362857, 27.87895698], [ 96.67790593, 77.76150486], [ 68.86202147, 21.38735169], [ 5.21796467, 59.17051276], [ 82.92389467, 99.90387851], [ 6.76626539, 30.50661753]])""" pt = [6, 30] print find_nearest_vector(A,pt)
def bisection(array,value): and array[j+1]. ``array`` must be monotonic increasing. j=-1 or j=len(array) is returned to indicate that ``value`` is out of range below and above respectively. n = len(array) if (value < array[0]): return -1 elif (value > array[n-1]): return n jl = 0 ju = n-1 while (ju-jl > 1): jm=(ju+jl) >> 1 if (value >= array[jm]): jl=jm else: ju=jm if (value == array[0]): return 0 elif (value == array[n-1]): return n-1 else: return jl
import math import numpy as np def find_nearest1(array,value): idx,val = min(enumerate(array), key=lambda x: abs(x[1]-value)) return idx def find_nearest2(array, values): indices = np.abs(np.subtract.outer(array, values)).argmin(0) return indices def find_nearest3(array, values): values = np.atleast_1d(values) indices = np.abs(np.int64(np.subtract.outer(array, values))).argmin(0) out = array[indices] return indices def find_nearest4(array,value): idx = (np.abs(array-value)).argmin() return idx def find_nearest5(array, value): idx_sorted = np.argsort(array) sorted_array = np.array(array[idx_sorted]) idx = np.searchsorted(sorted_array, value, side="left") if idx >= len(array): idx_nearest = idx_sorted[len(array)-1] elif idx == 0: idx_nearest = idx_sorted[0] else: if abs(value - sorted_array[idx-1]) < abs(value - sorted_array[idx]): idx_nearest = idx_sorted[idx-1] else: idx_nearest = idx_sorted[idx] return idx_nearest def find_nearest6(array,value): xi = np.argmin(np.abs(np.ceil(array[None].T - value)),axis=0) return xi
array = np.arange(100000) val = array[50000]+0.55 print( bisection(array,val)) %timeit bisection(array,val) print( find_nearest1(array,val)) %timeit find_nearest1(array,val) print( find_nearest2(array,val)) %timeit find_nearest2(array,val) print( find_nearest3(array,val)) %timeit find_nearest3(array,val) print( find_nearest4(array,val)) %timeit find_nearest4(array,val) print( find_nearest5(array,val)) %timeit find_nearest5(array,val) print( find_nearest6(array,val)) %timeit find_nearest6(array,val) (50000, 50000) 100000 loops, best of 3: 4.4 µs per loop 50001 1 loop, best of 3: 180 ms per loop 50001 1000 loops, best of 3: 267 µs per loop [50000] 1000 loops, best of 3: 390 µs per loop 50001 1000 loops, best of 3: 259 µs per loop 50001 1000 loops, best of 3: 1.21 ms per loop [50000] 1000 loops, best of 3: 746 µs per loop
def find_nearest(array, value): n = [abs(i-value) for i in array] idx = n.index(min(n)) return array[idx]
In [1]: from scipy import spatial In [2]: import numpy as np In [3]: A = np.random.random((10,2))*100 In [4]: A Out[4]: array([[ 68.83402637, 38.07632221], [ 76.84704074, 24.9395109 ], [ 16.26715795, 98.52763827], [ 70.99411985, 67.31740151], [ 71.72452181, 24.13516764], [ 17.22707611, 20.65425362], [ 43.85122458, 21.50624882], [ 76.71987125, 44.95031274], [ 63.77341073, 78.87417774], [ 8.45828909, 30.18426696]]) In [5]: pt = [6, 30] In [6]: A[spatial.KDTree(A).query(pt)[1]] Out[6]: array([ 8.45828909, 30.18426696]) In [7]: distance,index = spatial.KDTree(A).query(pt) In [8]: distance Out[8]: 2.4651855048258393 In [9]: index Out[9]: 9 In [10]: A[index] Out[10]: array([ 8.45828909, 30.18426696])
import numpy as np def find_nearest(array, values): indices = np.abs(np.subtract.outer(array, values)).argmin(0) return array[indices]
def find_nearest(array, values): values = np.atleast_1d(values) indices = np.abs(np.subtract.outer(array, values)).argmin(0) out = array[indices] return out if len(out) > 1 else out[0]
def find_idx_nearest_val(array, value): idx_sorted = np.argsort(array) sorted_array = np.array(array[idx_sorted]) idx = np.searchsorted(sorted_array, value, side="left") if idx >= len(array): idx_nearest = idx_sorted[len(array)-1] elif idx == 0: idx_nearest = idx_sorted[0] else: if abs(value - sorted_array[idx-1]) < abs(value - sorted_array[idx]): idx_nearest = idx_sorted[idx-1] else: idx_nearest = idx_sorted[idx] return idx_nearest
def get_closest(array, values): array = np.array(array) idxs = np.searchsorted(array, values, side="left") prev_idx_is_less = ((idxs == len(array))|(np.fabs(values - array[np.maximum(idxs-1, 0)]) < np.fabs(values - array[np.minimum(idxs, len(array)-1)]))) idxs[prev_idx_is_less] -= 1 return array[idxs]
>>> %timeit ar=get_closest(np.linspace(1, 1000, 100), np.random.randint(0, 1050, (1000, 1000))) 139 ms ± 4.04 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) >>> %timeit ar=[find_nearest(np.linspace(1, 1000, 100), value) for value in np.random.randint(0, 1050, 1000*1000)] took 21.4 seconds
def find_nearest(array, values): array = np.asarray(array) values = np.expand_dims(values, axis=-1) indices = np.abs(array - values).argmin(axis=-1) return array[indices] image = plt.imread( print(image.shape) quantiles = np.linspace(0, 255, num=2 ** 2, dtype=np.uint8) quantiled_image = find_nearest(quantiles, image) print(quantiled_image.shape)
num = 65 array = n.random.random((10))*100 nearest_idx = n.where(abs(array-num)==abs(array-num).min())[0] nearest_val = array[abs(array-num)==abs(array-num).min()]
import numpy as np import bisect xarr = np.random.rand(int(1e7)) srt_ind = xarr.argsort() xar = xarr.copy()[srt_ind] xlist = xar.tolist() bisect.bisect_left(xlist, 0.3)
randpts = np.random.rand(1000) np.searchsorted(xar, randpts, side="left")
import numpy as np def find_nearest(array, value): array = np.array(array) z=np.abs(array-value) y= np.where(z == z.min()) m=np.array(y) x=m[0,0] y=m[1,0] near_value=array[x,y] return near_value array =np.array([[60,200,30],[3,30,50],[20,1,-50],[20,-500,11]]) print(array) value = 0 print(find_nearest(array, value))
def find_nearest(X, value): return X[np.unravel_index(np.argmin(np.abs(X - value)), X.shape)]
def foo(hello, *args): print hello for each in args: print each if __name__ == foo("LOVE", ["lol", "lololol"])
class Super( object ): def __init__( self, this, that ): self.this = this self.that = that class Sub( Super ): def __init__( self, myStuff, *args, **kw ): super( Sub, self ).__init__( *args, **kw ) self.myStuff= myStuff x= Super( 2.7, 3.1 ) y= Sub( "green", 7, 6 )
def foo(a, b, c, d): print a, b, c, d l = [0, 1] d = {"d":3, "c":2} foo(*l, **d)
import pickle, functools def cache(f): _cache = {} def wrapper(*args, **kwargs): key = pickle.dumps((args, kwargs)) if key not in _cache: _cache[key] = f(*args, **kwargs) return _cache[key] functools.update_wrapper(wrapper, f) return wrapper import time @cache def foo(n): time.sleep(2) return n*2 foo(10) foo(10)
def func(**keyword_args): print print keyword_args if keyword_args.has_key( if keyword_args.has_key( def func2(*positional_args): print print positional_args if len(positional_args) > 1: print positional_args[1] def func3(*positional_args, **keyword_args): print print positional_args print keyword_args func(a= func(c= func2( func3( func3(
my_calculator.button_0 = tkinter.Button(root, text=0) my_calculator.button_1 = tkinter.Button(root, text=1) my_calculator.button_2 = tkinter.Button(root, text=2) ...
my_calculator.buttons = [] for i in range(10): my_calculator.buttons.append(tkinter.Button(root, text=i))
my_calculator.buttons = [tkinter.Button(root, text=i) for i in range(10)]
keyword_1 = keyword_2 = if query == keyword_1 or query == keyword_2: print(
variables = {} variables["first"] = 34 variables["second"] = 45 print variables["first"], variables["second"] Variables = namedtuple( vars = Variables(34, 45) print vars.first, vars.second
import sys current_module = module = sys.modules[__name__] setattr(current_module, print(variable_name)
def var_of_var(k, v): globals()[k] = v print variable_name some_name = globals()[some_name] = 123 print variable_name some_name = var_of_var(some_name, 456) print variable_name2
from types import SimpleNamespace variables = {"b":"B","c":"C"} a = SimpleNamespace(**v) setattr(a,"g","G") a.g = "G+" something = a.a
class Variables(object): def __init__(self): self.foo = "initial_variable" def create_new_var(self,name,value): setattr(self,name,value) def get_var(self,name): if hasattr(self,name): return getattr(self,name) else: raise("Class does not have a variable named: "+name)
v.create_new_var(v.foo,"is actually not initial") v.initial_variable
from variableVariablesManager import VariableVariablesManager myVars = VariableVariablesManager() myVars[ print(myVars[ myVars.defineConstVariable( try: myVars[ print("not allowed") except AttributeError as e: pass myVars.renameVariable( def testLocalVar(): myVars = VariableVariablesManager() myVars[ print("inside function myVars[ testLocalVar() print("outside function myVars[ myVars.defineGlobalVariable( def testGlobalVar(): myVars = VariableVariablesManager() print("inside function myVars[ myVars[ print("inside function myVars[ testGlobalVar() print("outside function myVars[
myVars = VariableVariablesManager(enforceSameTypeOnOverride = True) myVars[ myVars[
L = [ class Variables: def __init__(self, L): for item in L: self.__dict__[item] = 100 v = Variables(L) print(v.a, v.b, v.c)
variable_0 [Output]:0 variable_1 [Output]:1 variable_2 [Output]:2
for i in range(3): globals() [ print( [Output]: Variable Value: 0 Variable Value: 1 Variable Value: 2
class Vars: def __init__(self, **kw): self.__dict__.update(kw) def __getitem__(self, key): return self.__dict__[key] def __setitem__(self, key, val): self.__dict__[key] = val def __contains__(self, name): return name in self.__dict__ def __nonzero__(self): return bool(self.__dict__) def __iter__(self): return iter(self.__dict__) def __len__(self): return len(self.__dict__) def __copy__(self): return self.__class__(**self.__dict__) def __repr__(self): return >>> vars = Vars() >>> vars.a = 1 >>> vars[ >>> print(vars) Vars(a=1, b=2) >>> print(vars[ 1 2 >>> print(tuple(vars)) (
with open(the_file, f.seek(-1, 2) if f.read(1) != f.write( f.flush() f.seek(0) lines = [line[:-1] for line in f]
def readlines(self): lines = [] for line in iter(self.readline, lines.append(line) return lines def readlines(self): lines = [] while True: line = self.readline() if not line: break lines.append(line) return lines
u=open("url.txt","r") url=u.read().replace( print(url)
with open(filename, for row in fileobj: print( row.rstrip(
my_file = open("first_file.txt", "r") for line in my_file.readlines(): if line[-1:] == "\n": print(line[:-1]) else: print(line) my_file.close()
def getText(): file=open("ex1.txt","r"); names=file.read().split("\n"); for x,word in enumerate(names): if(len(word)>=20): return 0; print "length of ",word,"is over 20" break; if(x==20): return 0; break; else: return names; def show(names): for word in names: len_set=len(set(word)) print word," ",len_set for i in range(1): names=getText(); if(names!=0): show(names); else: break;
class Foo: pass import inspect import foo for name, obj in inspect.getmembers(foo): if inspect.isclass(obj): print obj
import inspect class Foo: pass def print_classes(): for name, obj in inspect.getmembers(???): if inspect.isclass(obj): print obj import foo foo.print_classes()
import sys, inspect def print_classes(): for name, obj in inspect.getmembers(sys.modules[__name__]): if inspect.isclass(obj): print(obj)
clsmembers = inspect.getmembers(sys.modules[__name__], inspect.isclass)
g = globals().copy() for name, obj in g.iteritems():
print dir(myproject) print dir(myproject.mymodule) print dir(myproject.mymodule.myfile) print dir(myproject.mymodule.myfile.myclass)
def list_supported_platforms(): """ List supported platforms (to match sys.platform) @Retirms: list str: platform names """ return list(itertools.chain( *list( getattr( getattr( getattr(platforms, item), dir( getattr(platforms, item) )[0] ), ) for item in dir(platforms) if not item.startswith( ) ))
import pyclbr print(pyclbr.readmodule(__name__).keys())
import sys, inspect def print_classes(): is_class_member = lambda member: inspect.isclass(member) and member.__module__ == __name__ clsmembers = inspect.getmembers(sys.modules[__name__], is_class_member)
import sys class Foo(object): pass def print_classes(): current_module = sys.modules[__name__] for key in dir(current_module): if isinstance( getattr(current_module, key), type ): print(key) import foo foo.print_classes()
import sys import inspect classes = [name for name, obj in inspect.getmembers(sys.modules[__name__], inspect.isclass) if obj.__module__ is __name__]
classes = [obj for name, obj in inspect.getmembers(sys.modules[__name__], inspect.isclass) if obj.__module__ is __name__]
class custom(object): __custom__ = True class Alpha(custom): something = 3 def GetClasses(): return [x for x in globals() if hasattr(globals()[str(x)], print(GetClasses())`
sudo rm -rf /Library/Frameworks/Python.framework/Versions/2.7
org.python.Python.PythonApplications-2.7 org.python.Python.PythonDocumentation-2.7 org.python.Python.PythonFramework-2.7 org.python.Python.PythonProfileChanges-2.7 org.python.Python.PythonUnixTools-2.7
--unlink package-id Unlinks (removes) each file referenced by package-id. WARNING: This command makes no attempt to perform reference counting or dependency analy- sis. It can easily remove files required by your system. It may include unexpected files due to package tainting. Use the --files command first to double check.
pkgutil --unlink org.python.Python.PythonApplications-2.7 pkgutil --unlink org.python.Python.PythonDocumentation-2.7 pkgutil --unlink org.python.Python.PythonFramework-2.7 pkgutil --unlink org.python.Python.PythonProfileChanges-2.7 pkgutil --unlink org.python.Python.PythonUnixTools-2.7
pkgutil --pkgs | grep org.python.Python | xargs -L1 pkgutil -f --unlink
sudo -i which python ls -ltra /usr/local/bin/python rm -rf /usr/local/Cellar/python\@2/
config_root = "/etc/myapp.conf/" file_name = os.path.join(config_root, sys.argv[1])
root="/home" os.path.join(root,"build","test","sandboxes",todaystr,"new_sandbox")
import os home = todaystr = new = os.path.join(*home.split("/"), todaystr, *new.split("/"))
components = os.path.splitext(filename) prefix = components[0] extension = components[1] return os.path.join("avatars", instance.username, prefix, extension)
return os.path.join("avatars", instance.username, prefix) + extension
def function(a): if a == print ( else if a == print ( else print ( function(input(
def function(a): if a == print( elif a == print( else: print( function(input(
def function(a): if a == print ( elif a == print ( else: print (
d={"1":"1a","2":"2a"} if not a in d: print("3a") else: print (d[a])
def print_one(arg=None): print "one" def print_two(num): print "two %s" % num execfunctions = { 1 : (print_one, [ try: execfunctions[1][0]() except KeyError,e: print "Invalid option: ",e try: execfunctions[2][0]("test") except KeyError,e: print "Invalid option: ",e else: sys.exit()
def function(a): if a not in (1, 2): a = 3 print(str(a) + "a")
def function(a): if a == print ( elif a == print ( else: print (
def function(a): if a == print( elif a == print( else: print(
import os.path print os.path.abspath(os.path.join(yourpath, os.pardir))
>>> >>> p = Path( >>> q = p / >>> q PosixPath( >>> q.resolve() PosixPath(
import os os.path.dirname(os.path.normpath(yourpath))
import os os.path.normpath(os.path.join(yourpath, os.pardir))
os.path.dirname(os.path.normpath( os.path.normpath(os.path.join( os.path.dirname(os.path.normpath( os.path.normpath(os.path.join( os.path.dirname(os.path.normpath( os.path.normpath(os.path.join( os.path.dirname(os.path.normpath( os.path.normpath(os.path.join( os.path.dirname(os.path.normpath( os.path.normpath(os.path.join( os.path.dirname(os.path.normpath( os.path.normpath(os.path.join( os.path.dirname(os.path.normpath( os.path.normpath(os.path.join(
os.path.dirname(os.path.normpath( os.path.normpath(os.path.join( os.path.dirname(os.path.normpath( os.path.normpath(os.path.join( os.path.dirname(os.path.normpath( os.path.normpath(os.path.join(
import posixpath import ntpath print ntpath.abspath(ntpath.join( print ntpath.abspath(ntpath.join( print posixpath.abspath(posixpath.join( print posixpath.abspath(posixpath.join(
import os print"------------------------------------------------------------" SITE_ROOT = os.path.dirname(os.path.realpath(__file__)) print("example 1: "+SITE_ROOT) PARENT_ROOT=os.path.abspath(os.path.join(SITE_ROOT, os.pardir)) print("example 2: "+PARENT_ROOT) GRANDPAPA_ROOT=os.path.abspath(os.path.join(PARENT_ROOT, os.pardir)) print("example 3: "+GRANDPAPA_ROOT) print "------------------------------------------------------------"
>>> import os >>> os.path.basename(os.path.dirname(<your_path>))
>>> my_path = >>> os.path.basename(os.path.dirname(my_path))
>>> my_path = >>> os.path.basename(os.path.dirname(my_path))
>>> input = "../data/replies/" >>> os.path.dirname(input.rstrip( >>> input = "../data/replies" >>> os.path.dirname(input.rstrip(
print os.path.abspath(os.path.join(os.getcwd(), os.path.pardir))
import os dir_path = os.path.dirname(os.path.realpath(__file__)) parent_path = os.path.abspath(os.path.join(dir_path, os.pardir))
import os print os.makedirs(os.path.join(os.path.dirname(__file__), os.pardir,
import os print os.makedirs(os.path.join(os.path.dirname(__file__), os.path.abspath(
import os def parent_filedir(n): return parent_filedir_iter(n, os.path.dirname(__file__)) def parent_filedir_iter(n, path): n = int(n) if n <= 1: return path return parent_filedir_iter(n - 1, os.path.dirname(path)) test_dir = os.path.abspath(parent_filedir(2))
import os upup = [os.pardir]*5 go_upup = os.path.join(*upup) up_dir = os.path.abspath(os.path.join(__file__, go_upup))
(mysite)zjm1126@zjm1126-G41MT-S2:~/zjm_test/mysite$ pip install lxml Downloading/unpacking lxml Running setup.py egg_info for package lxml Building lxml version 2.3. Building without Cython. ERROR: /bin/sh: xslt-config: not found ** make sure the development packages of libxml2 and libxslt are installed ** Using build configuration of libxslt Installing collected packages: lxml Running setup.py install for lxml Building lxml version 2.3. Building without Cython. ERROR: /bin/sh: xslt-config: not found ** make sure the development packages of libxml2 and libxslt are installed ** Using build configuration of libxslt building gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/include/python2.6 -c src/lxml/lxml.etree.c -o build/temp.linux-i686-2.6/src/lxml/lxml.etree.o -w src/lxml/lxml.etree.c:4: fatal error: Python.h: 没有那个文件或目录 compilation terminated. error: command Complete output from command /home/zjm1126/zjm_test/mysite/bin/python -c "import setuptools;__file__= Building lxml version 2.3. Building without Cython. ERROR: /bin/sh: xslt-config: not found ** make sure the development packages of libxml2 and libxslt are installed ** Using build configuration of libxslt running install running build running build_py running build_ext building gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/include/python2.6 -c src/lxml/lxml.etree.c -o build/temp.linux-i686-2.6/src/lxml/lxml.etree.o -w src/lxml/lxml.etree.c:4: fatal error: Python.h: 没有那个文件或目录 compilation terminated. error: command ---------------------------------------- Command /home/zjm1126/zjm_test/mysite/bin/python -c "import setuptools;__file__= Storing complete log in /home/zjm1126/.pip/pip.log
(mysite)zjm1126@zjm1126-G41MT-S2:~/zjm_test/mysite$ pip install lxml Downloading/unpacking lxml Running setup.py egg_info for package lxml Building lxml version 2.3. Building without Cython. Using build configuration of libxslt 1.1.26 Building against libxml2/libxslt in the following directory: /usr/lib Installing collected packages: lxml Running setup.py install for lxml Building lxml version 2.3. Building without Cython. Using build configuration of libxslt 1.1.26 Building against libxml2/libxslt in the following directory: /usr/lib building gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/include/libxml2 -I/usr/include/python2.6 -c src/lxml/lxml.etree.c -o build/temp.linux-i686-2.6/src/lxml/lxml.etree.o -w src/lxml/lxml.etree.c:4: fatal error: Python.h: 没有那个文件或目录 compilation terminated. error: command Complete output from command /home/zjm1126/zjm_test/mysite/bin/python -c "import setuptools;__file__= Building lxml version 2.3. Building without Cython. Using build configuration of libxslt 1.1.26 Building against libxml2/libxslt in the following directory: /usr/lib running install running build running build_py running build_ext building gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/include/libxml2 -I/usr/include/python2.6 -c src/lxml/lxml.etree.c -o build/temp.linux-i686-2.6/src/lxml/lxml.etree.o -w src/lxml/lxml.etree.c:4: fatal error: Python.h: 没有那个文件或目录 compilation terminated. error: command ---------------------------------------- Command /home/zjm1126/zjm_test/mysite/bin/python -c "import setuptools;__file__= Storing complete log in /home/zjm1126/.pip/pip.log
------------------------------------------------------------ /home/zjm1126/zjm_test/mysite/bin/pip run on Thu Mar 3 17:07:27 2011 Downloading/unpacking mysql-python Running setup.py egg_info for package mysql-python running egg_info creating pip-egg-info/MySQL_python.egg-info writing pip-egg-info/MySQL_python.egg-info/PKG-INFO writing top-level names to pip-egg-info/MySQL_python.egg-info/top_level.txt writing dependency_links to pip-egg-info/MySQL_python.egg-info/dependency_links.txt writing pip-egg-info/MySQL_python.egg-info/PKG-INFO writing top-level names to pip-egg-info/MySQL_python.egg-info/top_level.txt writing dependency_links to pip-egg-info/MySQL_python.egg-info/dependency_links.txt writing manifest file warning: manifest_maker: standard file reading manifest file reading manifest template warning: no files found matching warning: no files found matching warning: no files found matching writing manifest file Installing collected packages: mysql-python Running setup.py install for mysql-python Running command /home/zjm1126/zjm_test/mysite/bin/python -c "import setuptools;__file__= running install running build running build_py creating build creating build/lib.linux-i686-2.6 copying _mysql_exceptions.py -> build/lib.linux-i686-2.6 creating build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/__init__.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/converters.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/connections.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/cursors.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/release.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/times.py -> build/lib.linux-i686-2.6/MySQLdb creating build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/__init__.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/CR.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/FIELD_TYPE.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/ER.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/FLAG.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/REFRESH.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/CLIENT.py -> build/lib.linux-i686-2.6/MySQLdb/constants running build_ext building creating build/temp.linux-i686-2.6 gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -Dversion_info=(1,2,3, In file included from _mysql.c:29: pymemcompat.h:10: fatal error: Python.h: 没有那个文件或目录 compilation terminated. error: command Complete output from command /home/zjm1126/zjm_test/mysite/bin/python -c "import setuptools;__file__= running install running build running build_py creating build creating build/lib.linux-i686-2.6 copying _mysql_exceptions.py -> build/lib.linux-i686-2.6 creating build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/__init__.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/converters.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/connections.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/cursors.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/release.py -> build/lib.linux-i686-2.6/MySQLdb copying MySQLdb/times.py -> build/lib.linux-i686-2.6/MySQLdb creating build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/__init__.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/CR.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/FIELD_TYPE.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/ER.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/FLAG.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/REFRESH.py -> build/lib.linux-i686-2.6/MySQLdb/constants copying MySQLdb/constants/CLIENT.py -> build/lib.linux-i686-2.6/MySQLdb/constants running build_ext building creating build/temp.linux-i686-2.6 gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -Dversion_info=(1,2,3, In file included from _mysql.c:29: pymemcompat.h:10: fatal error: Python.h: 没有那个文件或目录 compilation terminated. error: command ---------------------------------------- Command /home/zjm1126/zjm_test/mysite/bin/python -c "import setuptools;__file__= Exception information: Traceback (most recent call last): File "/home/zjm1126/zjm_test/mysite/lib/python2.6/site-packages/pip-0.8.1-py2.6.egg/pip/basecommand.py", line 130, in main self.run(options, args) File "/home/zjm1126/zjm_test/mysite/lib/python2.6/site-packages/pip-0.8.1-py2.6.egg/pip/commands/install.py", line 228, in run requirement_set.install(install_options, global_options) File "/home/zjm1126/zjm_test/mysite/lib/python2.6/site-packages/pip-0.8.1-py2.6.egg/pip/req.py", line 1043, in install requirement.install(install_options, global_options) File "/home/zjm1126/zjm_test/mysite/lib/python2.6/site-packages/pip-0.8.1-py2.6.egg/pip/req.py", line 559, in install cwd=self.source_dir, filter_stdout=self._filter_install, show_stdout=False) File "/home/zjm1126/zjm_test/mysite/lib/python2.6/site-packages/pip-0.8.1-py2.6.egg/pip/__init__.py", line 249, in call_subprocess % (command_desc, proc.returncode)) InstallationError: Command /home/zjm1126/zjm_test/mysite/bin/python -c "import setuptools;__file__=
sudo apt-get install python-dev libxml2-dev libxslt1-dev zlib1g-dev
sudo apt-get install -y libxml2-dev libxslt1-dev zlib1g-dev python3-pip sudo pip3 install lxml
sudo apt-get install libxml2-dev libxslt-dev python-dev
error: command yum remove audit yum install gcc yum install libxslt-devel libxml2-devel cd lxml-x.x.x python setup.py build python setup.py install
sudo apt-get build-dep python3-lxml sudo apt-get install libxml2-dev libxslt-dev python-dev
sudo apt-get install libxml2 libxml2-dev libxslt1-dev sudo pip install lxml
mkdir ~/tmp export TMPDIR=~/tmp STATIC_DEPS=true easy_install-2.7 lxml
gcc -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -ggdb -O2 -pipe -Wimplicit-function-declaration -fdebug-prefix-map=/usr/src/ports/python3/python3-3.2.5-4.x86_64/build=/usr/src/debug/python3-3.2.5-4 -fdebug-prefix-map=/usr/src/ports/python3/python3-3.2.5-4.x86_64/src/Python-3.2.5=/usr/src/debug/python3-3.2.5-4 -I/usr/include/libxml2 -I/tmp/pip-build-b8ybku/lxml/src/lxml/includes -I/usr/include/python3.2m -c src/lxml/lxml.etree.c -o build/temp.cygwin-1.7.34-x86_64-3.2/src/lxml/lxml.etree.o -w src/lxml/lxml.etree.c:8:22: fatal error: pyconfig.h: No such file or directory compilation terminated. /usr/lib/python3.2/distutils/dist.py:257: UserWarning: Unknown distribution option: warnings.warn(msg) error: command ---------------------------------------- Command "/usr/bin/python3.2m -c "import setuptools, tokenize;__file__=
sudo apt-get install libxml2-dev sudo apt-get install libxslt1-dev sudo apt-get install python-dev sudo apt-get install lxml
sudo C_INCLUDE_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include/libxml2:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include/libxml2/libxml:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include pip install -r lxml
Compile failed: command cc -I/usr/include/libxml2 -I/usr/include/libxml2 -c /tmp/xmlXPathInitZsgdMQ.c -o tmp/xmlXPathInitZsgdMQ.o ********************************************************************************* Could not find function xmlCheckVersion in library libxml2. Is libxml2 installed? ********************************************************************************* error: command
>>> import datetime >>> datetime.date(2010, 6, 16).isocalendar()[1] 24
>>> dt = datetime.date(2010, 6, 16) >>> wk = dt.isocalendar()[1] 24
>>> import datetime >>> datetime.date(2010, 6, 16).strftime("%V")
import time from time import gmtime, strftime d = time.strptime("16 Jun 2010", "%d %b %Y") print(strftime("%U", d))
>>> testdate=datetime.datetime(2010,6,16) >>> print(((testdate - datetime.datetime(testdate.year,1,1)).days 24
from datetime import * today = datetime.today() print today.strftime("%U")
import datetime datetime.datetime.utcnow().isocalendar()[1]
import datetime week = date(year=2014, month=1, day=1).isocalendar()[1]
import datetime date = datetime.datetime.strptime("2014-1-1", "%Y-%W-%w") week = date.isocalendar()[1]
import datetime def gregorian_week(date): iso_week = date.isocalendar()[1] base_greg = datetime.datetime.strptime( return iso_week if base_greg.isocalendar()[1] == 1 else iso_week - 1
d = datetime.datetime.strptime( print(datetime.datetime.strftime(d,
Python 2.7.3 (default, Feb 27 2014, 19:58:35) [GCC 4.6.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> import datetime as dt >>> myDateTime = dt.datetime.strptime("20141229T000000.000Z", >>> yr,weekNumber,weekDay = myDateTime.isocalendar() >>> print "Year is " + str(yr) + ", weekNumber is " + str(weekNumber) Year is 2015, weekNumber is 1
>>> yr = myDateTime.year >>> weekNumber = ((myDateTime - dt.datetime(yr,1,1)).days/7) + 1 >>> print "Year is " + str(yr) + ", weekNumber is " + str(weekNumber) Year is 2014, weekNumber is 52
from datetime import datetime, date, time d = date(2005, 7, 14) t = time(12, 30) dt = datetime.combine(d, t) print(dt)
dt = datetime.strptime( print(dt.strftime("%W")) print(dt.strftime("%U")) print(dt.strftime("%V"))
dt = datetime.strptime( d = dt.date() year, week, weekday = d.isocalendar() print(year, week, weekday)
userInput = input ("Please enter project deadline date (dd/mm/yyyy/): ") import datetime currentDate = datetime.datetime.today() testVar = datetime.datetime.strptime(userInput ,"%d/%b/%Y").date() remainDays = testVar - currentDate.date() remainWeeks = (remainDays.days / 7.0) + 1 print ("Please pay attention for deadline of project X in days and weeks are : " ,(remainDays) , "and" ,(remainWeeks) , "Weeks ,\nSo hurryup.............!!!")
>>> from collections import defaultdict >>> d = defaultdict(lambda : defaultdict(int)) >>> print d[0] defaultdict(<type >>> print d[0]["x"] 0
>>> from collections import Counter >>> c = Counter() >>> c["goodbye"]+=1 >>> c["and thank you"]=42 >>> c["for the fish"]-=5 >>> c Counter({
import functools dd_int = functools.partial(defaultdict, int) defaultdict(dd_int)
d = defaultdict(int) for x in stuff: d[x.a,x.b] += x.c_int
>>> print "hello World" File "<stdin>", line 1 print "hello World" ^ SyntaxError: invalid syntax
Old: print "The answer is", 2*2 New: print("The answer is", 2*2) Old: print x, New: print(x, end=" ") Old: print New: print() Old: print >>sys.stderr, "fatal error" New: print("fatal error", file=sys.stderr) Old: print (x, y) New: print((x, y))
n = 5 while n != 0: print n n -= 1 else: print "what the..."
while condition: handle_true() else: handle_false()
while value < threshold: if not process_acceptable_value(value): break value = update(value) else: handle_threshold_reached()
for value in values: if value == 5: print "Found it!" break else: print "Nowhere to be found. :-("
for k in [2, 3, 5, 7, 11, 13, 17, 25]: for m in range(2, 10): if k == m: continue print if k % m == 0: print break else: continue print break else: print
while_stmt ::= "while" expression ":" suite ["else" ":" suite]
In [17]: i = 0 In [18]: while i < 5: print i if i == 2: break i = i +1 else: print print ....: 0 1 2 The next statement
In [19]: i = 0 In [20]: while i < 5: print i if i == 2: break i = i +1 print print ....: 0 1 2 ELSE The next statement
while (Date != "January 1st"): time.sleep(1) else: print("Happy new year!")
n = 5 while n != 0: print n n -= 1 print "what the..."
>>> def f(x): return x % 2 != 0 and x % 3 != 0 >>> filter(f, range(2, 25)) [5, 7, 11, 13, 17, 19, 23] >>> def cube(x): return x*x*x >>> map(cube, range(1, 11)) [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] >>> def add(x,y): return x+y >>> reduce(add, range(1, 11)) 55
>>> filter(f, range(2, 25)) <filter object at 0x0000000002C14908> >>> map(cube, range(1, 11)) <map object at 0x0000000002C82B70> >>> reduce(add, range(1, 11)) Traceback (most recent call last): File "<pyshell reduce(add, range(1, 11)) NameError: name
>>> def f(x): return x % 2 != 0 and x % 3 != 0 ... >>> list(filter(f, range(2, 25))) [5, 7, 11, 13, 17, 19, 23] >>> def cube(x): return x*x*x ... >>> list(map(cube, range(1, 11))) [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] >>> import functools >>> def add(x,y): return x+y ... >>> functools.reduce(add, range(1, 11)) 55 >>>
>>> def f(x): return x % 2 != 0 and x % 3 != 0 ... >>> [i for i in range(2, 25) if f(i)] [5, 7, 11, 13, 17, 19, 23] >>> def cube(x): return x*x*x ... >>> [cube(i) for i in range(1, 11)] [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] >>>
from contextlib import contextmanager @contextmanager def noiters(*funcs): if not funcs: funcs = [map, filter, zip] from functools import reduce globals()[reduce.__name__] = reduce for func in funcs: globals()[func.__name__] = lambda *ar, func = func, **kwar: list(func(*ar, **kwar)) try: yield finally: del globals()[reduce.__name__] for func in funcs: globals()[func.__name__] = func
with noiters(map): from operator import add print(reduce(add, range(1, 20))) print(map(int, [
import functools my_list = [10,15,20,25,35] sum_numbers = functools.reduce(lambda x ,y : x+y , my_list) print(sum_numbers)
if config_dbms_name == import psycopg self.database_interface = psycopg elif config_dbms_name == ...
def polite(name_str): return "dear " + name_str def rude(name_str): return name_str + ", you, moron" def greet(name_str, call=polite): print "Hello, " + call(name_str) + "!"
>>greet("Peter") Hello, dear Peter! >>greet("Jack", rude) Hello, Jack, you, moron!
class Container: def __init__(self, system_data): for component_name, component_class, component_args in system_data: if type(component_class) == types.ClassType: args = [self.__dict__[arg] for arg in component_args] self.__dict__[component_name] = component_class(*args) else: self.__dict__[component_name] = component_class
class Application(object): def __init__(self): pass Application.postgres_connection = PostgresConnection() postgres_connection = Application.postgres_connection db_data = postgres_connection.fetchone()
from libs.service_locator import ServiceLocator ServiceLocator.register(PostgresConnection) postgres_connection = ServiceLocator.resolve(PostgresConnection) db_data = postgres_connection.fetchone()
class FooView(APIView): permission_classes = (IsAuthenticated, ) throttle_classes = (ScopedRateThrottle, ) parser_classes = (parsers.FormParser, parsers.JSONParser, parsers.MultiPartParser) renderer_classes = (renderers.JSONRenderer,) def get(self, request, *args, **kwargs): pass def post(self, request, *args, **kwargs): pass
from sys import stdout from time import sleep for i in range(1,20): stdout.write("\r%d" % i) stdout.flush() sleep(1) stdout.write("\n")
to = 20 digits = len(str(to - 1)) delete = "\b" * (digits + 1) for i in range(to): print "{0}{1:{2}}".format(delete, i, digits),
import sys to = 20 digits = len(str(to - 1)) delete = "\b" * (digits) for i in range(to): print("{0}{1:{2}}".format(delete, i, digits), end="") sys.stdout.flush()
import sys class Printer(): def __init__(self,data): sys.stdout.write("\r\x1b[K"+data.__str__()) sys.stdout.flush()
x = 1 for f in fileList: ProcessFile(f) output = "File number %d completed." % x Printer(output) x += 1
from __future__ import print_function ... print(item, end="")
from sys import stdout ... stdout.write( str(item) )
nl = [] for x in range(1,10):nl.append(str(x)) print
import win32console, time output_handle = win32console.GetStdHandle( win32console.STD_OUTPUT_HANDLE ) info = output_handle.GetConsoleScreenBufferInfo() pos = info["CursorPosition"] for i in "\\|/-\\|/-": output_handle.WriteConsoleOutputCharacter( i, pos ) time.sleep( 1 )
import win32console, time output_handle = win32console.GetStdHandle( win32console.STD_OUTPUT_HANDLE ) info = output_handle.GetConsoleScreenBufferInfo() pos = info["CursorPosition"] for i in "\\|/-\\|/-": print i output_handle.SetConsoleCursorPosition( pos ) time.sleep( 1 )
prev_digits = -1 for i in range(0,1000): print("%s%d" % ("\b"*(prev_digits + 1), i)), prev_digits = len(str(i))
In [9]: print? Type: builtin_function_or_method Base Class: <type String Form: <built-in function print> Namespace: Python builtin Docstring: print(value, ..., sep= Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline.
import time startnumber = 1 endnumber = 100 start_time = time.clock() m = map(str, range(startnumber, endnumber + 1)) print( end_time = time.clock() timetaken = (end_time - start_time) * 1000 print( start_time = time.clock() for i in range(startnumber, endnumber + 1): print(i, end= end_time = time.clock() timetaken = (end_time - start_time) * 1000 print(
import time for n in range(500): print(n, end= time.sleep(0.01) print()
tup = (1,2,3,4,5) for n in tup: print(n, end = " - ")
list_of_tuples = [(1,2),( for item in list_of_tuples: print(item)
list_of_tuples = [(1,2),( for (item1, item2) in list_of_tuples: print(item1, item2)
list_of_tuples = [(1,2),( for (item1, item2) in list_of_tuples: print(item1) print(item2) print(
l="" for item in range(1,100): item=str(item) l=l+" "+item l.lstrip() print l
l="" for item in range(1,100): item=str(item) l=l+" "+item l.lstrip() print(l)
def md5(fname): hash_md5 = hashlib.md5() with open(fname, "rb") as f: for chunk in iter(lambda: f.read(4096), b""): hash_md5.update(chunk) return hash_md5.hexdigest()
import hashlib def file_as_bytes(file): with file: return file.read() print hashlib.md5(file_as_bytes(open(full_path,
import hashlib def hash_bytestr_iter(bytesiter, hasher, ashexstr=False): for block in bytesiter: hasher.update(block) return hasher.hexdigest() if ashexstr else hasher.digest() def file_as_blockiter(afile, blocksize=65536): with afile: block = afile.read(blocksize) while len(block) > 0: yield block block = afile.read(blocksize) [(fname, hash_bytestr_iter(file_as_blockiter(open(fname, for fname in fnamelst]
[(fname, hash_bytestr_iter(file_as_blockiter(open(fname, for fname in fnamelst]
$ ./sum_methods.py crc32_mmap(filename) 0.0241742134094 crc32_read(filename) 0.0219960212708 subprocess.check_output([ md5sum_mmap(filename) 0.0286180973053 md5sum_read(filename) 0.0311000347137 subprocess.check_output([ $ time md5sum /tmp/test.data.300k d3fe3d5d4c2460b5daacc30c6efbc77f /tmp/test.data.300k real 0m0.043s user 0m0.032s sys 0m0.010s $ stat -c 11890400
import hashlib def md5sum(filename, blocksize=65536): hash = hashlib.md5() with open(filename, "rb") as f: for block in iter(lambda: f.read(blocksize), b""): hash.update(block) return hash.hexdigest()
import zlib def adler32sum(filename, blocksize=65536): checksum = zlib.adler32("") with open(filename, "rb") as f: for block in iter(lambda: f.read(blocksize), b""): checksum = zlib.adler32(block, checksum) return checksum & 0xffffffff
p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
p = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
import os import signal import subprocess pro = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid) os.killpg(os.getpgid(pro.pid), signal.SIGTERM)
p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True) p.kill()
p = subprocess.Popen("exec " + cmd, stdout=subprocess.PIPE, shell=True)
import subprocess import psutil def kill(proc_pid): process = psutil.Process(proc_pid) for proc in process.children(recursive=True): proc.kill() process.kill() proc = subprocess.Popen(["infinite_app", "param"], shell=True) try: proc.wait(timeout=3) except subprocess.TimeoutExpired: kill(proc.pid)
from subprocess import Popen process = Popen(command, shell=True) Popen("TASKKILL /F /PID {pid} /T".format(pid=process.pid))
proc = subprocess.Popen(...) try: outs, errs = proc.communicate(timeout=15) except TimeoutExpired: proc.kill() outs, errs = proc.communicate()
if isinstance(command, unicode): cmd = command.encode( args = shlex.split(cmd) p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
si = subprocess.STARTUPINFO() si.dwFlags |= subprocess.STARTF_USESHOWWINDOW subprocess.call(["taskkill", "/IM", "robocopy.exe", "/T", "/F"], startupinfo=si)
self.proc = Popen(commands, stdout=PIPE, stderr=STDOUT, universal_newlines=True, preexec_fn=os.setsid) os.killpg(os.getpgid(self.proc.pid), signal.SIGHUP) os.killpg(os.getpgid(self.proc.pid), signal.SIGTERM)
import os import signal import subprocess p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True) os.killpg(os.getpgid(pro.pid), signal.SIGINT)
truck: color: blue brand: ford city: new york cabriolet: color: black engine: cylinders: 8 placement: mid doors: 2
truck = dict( color = brand = ) city = cabriolet = dict( color = engine = dict( cylinders = 8, placement = ), doors = 2, )
import yaml config = yaml.safe_load(open("path/to/config.yml"))
[SectionOne] Status: Single Name: Derek Value: Yes Age: 30 Single: True [SectionTwo] FavoriteColor=Green [SectionThree] FamilyName: Johnson [Others] Route: 66
>>> import ConfigParser >>> Config = ConfigParser.ConfigParser() >>> Config <ConfigParser.ConfigParser instance at 0x00BA9B20> >>> Config.read("myfile.ini") [ >>> Config.sections() [ >>> Config.options( [ >>> Config.get(
>>> import json >>> config = { >>> json.dump(config, open( >>> json.load(open( {u
string: "foobar"[3] == "b" tuple: (1,2,3,4)[3] == 4 list: [1,2,3,4][3] == 4 dict: {"a":1, "b":2, "c":3}["c"] == 3
>>> var = "myString" >>> def foo(): return 0 ... >>> var[3] >>> foo[3] Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError:
import warnings def fxn(): warnings.warn("deprecated", DeprecationWarning) with warnings.catch_warnings(): warnings.simplefilter("ignore") fxn()
>>> import warnings >>> def f(): ... print( ... warnings.warn( ... print( >>> f() before __main__:3: UserWarning: you are warned! after >>> warnings.filterwarnings("ignore") >>> f() before after
$ export PYTHONWARNINGS="default" $ python >>> import warnings >>> warnings.warn( __main__:1: UserWarning: my warning >>>
$ export PYTHONWARNINGS="ignore" $ python >>> import warnings >>> warnings.warn( >>>
import sys import warnings if not sys.warnoptions: warnings.simplefilter("ignore")
def warn(*args, **kwargs): pass import warnings warnings.warn = warn
def __enter__(self): return self def __exit__(self, type, value, tb): self.stream.close()
from __future__ import with_statement class a(object): def __enter__(self): print return def __exit__(self ,type, value, traceback): print return False with a() as s: print s print s
class DatabaseConnection(object): def __enter__(self): ... return self.dbconn def __exit__(self, exc_type, exc_val, exc_tb): self.dbconn.close() ...
fp=open(r"C:\Users\SharpEl\Desktop\myfile.txt") try: for line in fp: print(line) finally: fp.close()
with open(r"C:\Users\SharpEl\Desktop\myfile.txt") as fp: for line in fp: print(line)
class Log: def __init__(self,filename): self.filename=filename self.fp=None def logging(self,text): self.fp.write(text+ def __enter__(self): print("__enter__") self.fp=open(self.filename,"a+") return self def __exit__(self, exc_type, exc_val, exc_tb): print("__exit__") self.fp.close() with Log(r"C:\Users\SharpEl\Desktop\myfile.txt") as logfile: print("Main") logfile.logging("Test1") logfile.logging("Test2")
def __exit__(self, type, value, traceback): return isinstance(value, TypeError)
class myclass: def __init__(self): print("__init__") def __enter__(self): print("__enter__") def __exit__(self, type, value, traceback): print("__exit__") def __del__(self): print("__del__") with myclass(): print("body")
mgr = (EXPR) exit = type(mgr).__exit__ value = type(mgr).__enter__(mgr) exc = True try: try: VAR = value BLOCK except: exc = False if not exit(mgr, *sys.exc_info()): raise finally: if exc: exit(mgr, None, None, None)
>>> import logging >>> import socket >>> import sys >>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) >>> s.listen(5) >>> s.bind((socket.gethostname(), 999)) >>> while True: >>> (clientsocket, addr) = s.accept() >>> print( >>> msg = clientsocket.recv(1024) >>> print( >>> clientsocket.send(b >>> continue >>> class MyConnectionManager: >>> def __init__(self, sock, addrs): >>> logging.basicConfig(level=logging.DEBUG, format= >>> : %(levelname)s --> %(message)s >>> logging.info( >>> self.sock = sock >>> self.addrs = addrs >>> def __enter__(self): >>> try: >>> self.sock.connect(addrs) >>> logging.info( >>> return self.sock >>> except: >>> logging.warning( >>> raise >>> def __exit__(self, type, value, tb): >>> logging.info( >>> return False >>> addrs = (socket.gethostname()) >>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) >>> with MyConnectionManager(s, addrs) as CM: >>> try: >>> CM.send(b >>> msg = CM.recv(1024) >>> print(msg) >>> except: >>> raise 2018-12-18 14:44:05,863 : INFO --> Initiating My connection 2018-12-18 14:44:05,863 : INFO --> connection success b 2018-12-18 14:44:05,864 : INFO --> CM suppress exception get connection from received b
>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) >>> mgr = MyConnection(s, addrs) 2018-12-18 14:53:19,331 : INFO --> Initiating My connection >>> ext = mgr.__exit__ >>> value = mgr.__enter__() 2018-12-18 14:55:55,491 : INFO --> connection success >>> exc = True >>> try: >>> try: >>> VAR = value >>> VAR.send(b >>> msg = VAR.recv(1024) >>> print(msg) >>> except: >>> exc = False >>> if not ext(*sys.exc_info()): >>> raise >>> finally: >>> if exc: >>> ext(None, None, None) b 2018-12-18 15:01:54,208 : INFO --> CM suppress exception
from django.contrib.gis.utils import GeoIP from django.template import RequestContext from django.shortcuts import render_to_response def home(request): g = GeoIP() client_ip = request.META[ lat,long = g.lat_lon(client_ip) return render_to_response(
KeyError at /mypage/ Request Method: GET Request URL: http: Django Version: 1.2.4 Exception Type: KeyError Exception Value: Exception Location: /mysite/homepage/views.py in home, line 9 Python Executable: /usr/bin/python Python Version: 2.6.6 Python Path: [ Server time: Sun, 2 Jan 2011 20:42:50 -0600
def get_client_ip(request): x_forwarded_for = request.META.get( if x_forwarded_for: ip = x_forwarded_for.split( else: ip = request.META.get( return ip
from ipware import get_client_ip ip, is_routable = get_client_ip(request) if ip is None: else: if is_routable: else:
i, r = get_client_ip(request, request_header_order=[ i, r = get_client_ip(request, request_header_order=[
i, r = get_client_ip(request, proxy_trusted_ips=( i, r = get_client_ip(request, proxy_trusted_ips=( i, r = get_client_ip(request, proxy_trusted_ips=(
def get_client_ip(request): x_forwarded_for = request.META.get( if x_forwarded_for: ip = x_forwarded_for.split( else: ip = request.META.get( return ip
PRIVATE_IPS_PREFIX = ( def get_client_ip(request): remote_address = request.META.get( ip = remote_address x_forwarded_for = request.META.get( if x_forwarded_for: proxies = x_forwarded_for.split( while (len(proxies) > 0 and proxies[0].startswith(PRIVATE_IPS_PREFIX)): proxies.pop(0) if len(proxies) > 0: ip = proxies[0] return ip
uwsgi_param X-Real-IP $remote_addr; uwsgi_param X-Forwarded-For "10.10.10.10"; uwsgi_param HTTP_X_FORWARDED_FOR "20.20.20.20";
X-Forwarded-For : 10.10.10.10 HTTP_X_FORWARDED_FOR : 20.20.20.20
add_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header X-Real-Ip $remote_addr;
from easy_timezones.utils import get_ip_address_from_request, is_valid_ip, is_local_ip ip = get_ip_address_from_request(request) try: if is_valid_ip(ip): geoip_record = IpRange.objects.by_ip(ip) except IpRange.DoesNotExist: return None
def get_ip_address_from_request(request): PRIVATE_IPS_PREFIX = ( ip_address = x_forwarded_for = request.META.get( if x_forwarded_for and if not x_forwarded_for.startswith(PRIVATE_IPS_PREFIX) and is_valid_ip(x_forwarded_for): ip_address = x_forwarded_for.strip() else: ips = [ip.strip() for ip in x_forwarded_for.split( for ip in ips: if ip.startswith(PRIVATE_IPS_PREFIX): continue elif not is_valid_ip(ip): continue else: ip_address = ip break if not ip_address: x_real_ip = request.META.get( if x_real_ip: if not x_real_ip.startswith(PRIVATE_IPS_PREFIX) and is_valid_ip(x_real_ip): ip_address = x_real_ip.strip() if not ip_address: remote_addr = request.META.get( if remote_addr: if not remote_addr.startswith(PRIVATE_IPS_PREFIX) and is_valid_ip(remote_addr): ip_address = remote_addr.strip() if not ip_address: ip_address = return ip_address
"strings": [{"-name": "city", " {"-name": "address", "
import json from pprint import pprint with open( d = json.load(json_data) json_data.close() pprint(d)
import json with open( d = json.load(json_data) print(d)
import json with open("test.json") as json_file: json_data = json.load(json_file) print(json_data)
{ "a": [1,3,"asdf",true], "b": { "Hello": "world" } }
X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"] Y = [ 0, 1, 1, 0, 1, 2, 2, 0, 1]
X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"] Y = [ 0, 1, 1, 0, 1, 2, 2, 0, 1] Z = [x for _,x in sorted(zip(Y,X))] print(Z)
[x for _, x in sorted(zip(Y,X), key=lambda pair: pair[0])]
>>> yx = zip(Y, X) >>> yx [(0, >>> yx.sort() >>> yx [(0, >>> x_sorted = [x for y, x in yx] >>> x_sorted [
people = [ ages = [27, 25, 4, 9] import numpy people = numpy.array(people) ages = numpy.array(ages) inds = ages.argsort() sortedPeople = people[inds]
>>> X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"] >>> Y = [ 0, 1, 1, 0, 1, 2, 2, 0, 1] >>> keydict = dict(zip(X, Y)) >>> X.sort(key=keydict.get) >>> X [
X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"] Y = [ 0, 1, 1, 0, 1, 2, 2, 0, 1] sorted_y_idx_list = sorted(range(len(Y)),key=lambda x:Y[x]) Xs = [X[i] for i in sorted_y_idx_list ] print( "Xs:", Xs )
zip(*sorted(zip(X,Y), key=operator.itemgetter(1)))[0]
from more_itertools import sort_together sort_together([Y, X])[1]
list_a = [5,4,3,2,1] list_b = [1,1.5,1.75,2,3,3.5,3.75,4,5]
orderedList = sorted(list_a, key=lambda x: list_b.index(x))
list_a = [ list_b = [ sorted(list_b, key=lambda x: list_a.index(x))
def parallel_sort(*lists): sorted_lists = tuple([] for _ in range(len(lists))) for t in sorted(zip(*lists)): for i, item in enumerate(t): sorted_lists[i].append(item) return sorted_lists
import pandas as pd pd.Series(data=X,index=Y).sort_index().tolist()
X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"] Y = [ 0, 1, 1, 0, 1, 2, 2, 0, 1] Zx, Zy = zip(*[(x, y) for x, y in sorted(zip(Y, X))]) print(list(Zx)) print(list(Zy))
list1 = [ list2 = [0,1,1,0,1,2,2,0,1] output=[] cur_loclist = []
for i in list_set: cur_loc = list_str.find(str(i)) while cur_loc >= 0: cur_loclist.append(cur_loc) cur_loc = list_str.find(str(i),cur_loc+1) print(cur_loclist) for i in range(0,len(cur_loclist)): output.append(list1[cur_loclist[i]]) print(output)
>>> d1 = {1: 1, 2: 2} >>> d2 = {2: >>> d1.update(d2) >>> d1 {1: 1, 2:
from itertools import chain dest = dict(chain(orig.items(), extra.items()))
dest = dict(list(orig.items()) + list(extra.items()))
from itertools import chain dest = dict(chain.from_iterable(map(dict.items, list_of_dicts)))
>>> dest = orig.copy() >>> dest.update(extra) >>> orig { >>> dest {
from ssReader import Reader from theCalcs import ACalc, AnotherCalc from theDB import Loader def main( sourceFileName ): rdr= Reader( sourceFileName ) c1= ACalc( options ) c2= AnotherCalc( options ) ldr= Loader( parameters ) for myObj in rdr.readAll(): c1.thisOp( myObj ) c2.thatOp( myObj ) ldr.laod( myObj )
if number >= 10000 and number >= 30000: print ("you have to pay 5% taxes")
r=range(1,4) >>> 1 in r True >>> 2 in r True >>> 3 in r True >>> 4 in r False >>> 5 in r False >>> 0 in r False
if number >= 10000 and number >= 30000: print ("you have to pay 5% taxes")
if 10000 <= number <= 30000: print ("you have to pay 5% taxes")
if number >= 10000 and number <= 30000: print ("you have to pay 5% taxes")
if number >= 10000 and number >= 30000: print ("you have to pay 5% taxes")
$ python3.5 -m timeit "5 in range(10000, 30000)" 1000000 loops, best of 3: 0.266 usec per loop $ python3.5 -m timeit "10000 <= 5 < 30000" 10000000 loops, best of 3: 0.0327 usec per loop
$ python3.5 -m timeit -s "R=range(10000, 30000)" "5 in R" 10000000 loops, best of 3: 0.0551 usec per loop
import pytz, datetime local = pytz.timezone ("America/Los_Angeles") naive = datetime.datetime.strptime ("2001-2-3 10:11:12", "%Y-%m-%d %H:%M:%S") local_dt = local.localize(naive, is_dst=None) utc_dt = local_dt.astimezone(pytz.utc)
>>> import datetime >>> utc_datetime = datetime.datetime.utcnow() >>> utc_datetime.strftime("%Y-%m-%d %H:%M:%S")
>>> >>> UTC_OFFSET_TIMEDELTA = datetime.datetime.utcnow() - datetime.datetime.now() >>> local_datetime = datetime.datetime.strptime("2008-09-17 14:04:00", "%Y-%m-%d %H:%M:%S") >>> result_utc_datetime = local_datetime + UTC_OFFSET_TIMEDELTA >>> result_utc_datetime.strftime("%Y-%m-%d %H:%M:%S")
>>> UTC_OFFSET = 10 >>> result_utc_datetime = local_datetime - datetime.timedelta(hours=UTC_OFFSET) >>> result_utc_datetime.strftime("%Y-%m-%d %H:%M:%S")
time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(time.mktime(time.strptime("2008-09-17 14:04:00", "%Y-%m-%d %H:%M:%S"))))
def local_to_utc(t): secs = time.mktime(t) return time.gmtime(secs) def utc_to_local(t): secs = calendar.timegm(t) return time.localtime(secs)
from datetime import * from dateutil import * from dateutil.tz import * utc_zone = tz.gettz( local_zone = tz.gettz( utc_zone = tz.tzutc() local_zone = tz.tzlocal() local_time = datetime.strptime("2008-09-17 14:02:00", local_time = local_time.replace(tzinfo=local_zone) utc_time = local_time.astimezone(utc_zone) utc_string = utc_time.strftime(
import pytz, datetime utc = pytz.utc fmt = amsterdam = pytz.timezone( dt = datetime.datetime.strptime("2012-04-06 10:00:00", fmt) am_dt = amsterdam.localize(dt) print am_dt.astimezone(utc).strftime(fmt)
from dateutil import tz def datetime_to_utc(date): return date.astimezone(tz.gettz(
import time import datetime def Local2UTC(LocalTime): EpochSecond = time.mktime(LocalTime.timetuple()) utcTime = datetime.datetime.utcfromtimestamp(EpochSecond) return utcTime >>> LocalTime = datetime.datetime.now() >>> UTCTime = Local2UTC(LocalTime) >>> LocalTime.ctime() >>> UTCTime.ctime()
dt = datetime.strptime("2008-09-17 14:04:00","%Y-%m-%d %H:%M:%S") utc_struct_time = time.gmtime(time.mktime(dt.timetuple())) utc_dt = datetime.fromtimestamp(time.mktime(utc_struct_time)) print dt.strftime("%Y-%m-%d %H:%M:%S")
>>> from time import strftime, gmtime, localtime >>> strftime( >>> strftime(
time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(seconds))
def get_utc_from_local(date_time, local_tz=None): assert date_time.__class__.__name__ == if local_tz is None: local_tz = pytz.timezone(settings.TIME_ZONE) local_time = local_tz.normalize(local_tz.localize(date_time)) return local_time.astimezone(pytz.utc) import pytz from datetime import datetime summer_11_am = datetime(2011, 7, 1, 11) get_utc_from_local(summer_11_am) >>>datetime.datetime(2011, 7, 1, 10, 0, tzinfo=<UTC>) winter_11_am = datetime(2011, 11, 11, 11) get_utc_from_local(winter_11_am) >>>datetime.datetime(2011, 11, 11, 11, 0, tzinfo=<UTC>)
>>> utc_delta = datetime.utcnow()-datetime.now() >>> utc_time = datetime(2008, 9, 17, 14, 2, 0) + utc_delta >>> print(utc_time) 2008-09-17 19:01:59.999996
class to_utc(): utc_delta = datetime.utcnow() - datetime.now() def __call__(cls, t): return t + cls.utc_delta
>>> utc_converter = to_utc() >>> print(utc_converter(datetime(2008, 9, 17, 14, 2, 0))) 2008-09-17 19:01:59.999996
from dateutil.parser import tz mydt.astimezone(tz.gettz(
import pytz utc = pytz.utc yourdate = datetime.datetime.now() yourdateutc = yourdate.astimezone(utc).replace(tzinfo=None)
import time import calendar local_time = time.strptime("2018-12-13T09:32:00.000", "%Y-%m-%dT%H:%M:%S.%f") local_seconds = time.mktime(local_time) utc_time = time.gmtime(local_seconds)
import subprocess from cStringIO import StringIO subprocess.Popen([
Traceback (most recent call last): File "<stdin>", line 1, in ? File "/build/toolchain/mac32/python-2.4.3/lib/python2.4/subprocess.py", line 533, in __init__ (p2cread, p2cwrite, File "/build/toolchain/mac32/python-2.4.3/lib/python2.4/subprocess.py", line 830, in _get_handles p2cread = stdin.fileno() AttributeError:
pipe = os.popen(cmd, pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin
from subprocess import Popen, PIPE, STDOUT p = Popen([ grep_stdout = p.communicate(input=b print(grep_stdout.decode())
from subprocess import run, PIPE p = run([ input= print(p.returncode) print(p.stdout)
>>> p = subprocess.Popen([ >>> p.stdin.write(b >>> p.communicate()[0] >>> p.stdin.close()
read, write = os.pipe() os.write(write, "stdin input here") os.close(write) subprocess.check_call([
p = Popen([ out, err = p.communicate(input= print(out)
output = subprocess.check_output( ["sed", "s/foo/bar/"], input=b"foo", )
from subprocess import Popen, PIPE from tempfile import SpooledTemporaryFile as tempfile f = tempfile() f.write( f.seek(0) print Popen([ f.close()
""" Ex: Dialog (2-way) with a Popen() """ p = subprocess.Popen( stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=PIPE, shell=True, bufsize=0) p.stdin.write( out = p.stdout.readline() while out: line = out line = line.rstrip("\n") if "WHATEVER1" in line: pr = 1 p.stdin.write( out = p.stdout.readline() continue if "WHATEVER2" in line: pr = 2 p.stdin.write( out = p.stdout.readline() continue out = p.stdout.readline() p.wait()
p = Popen([ p.stdin.write( time.sleep(0.5) p.stdin.write( time.sleep(0.5) p.stdin.write( time.sleep(0.5) testresult = p.communicate()[0] time.sleep(0.5) print(testresult)
dictionary[new_key] = dictionary[old_key] del dictionary[old_key]
>>> dictionary = { 1: >>> dictionary[ >>> dictionary {2: >>> dictionary[ Traceback (most recent call last): File "<input>", line 1, in <module> KeyError: 1
d = { d1 = { In [10]: dict((d1[key], value) for (key, value) in d.items()) Out[10]: {
>>>a = {1:2, 3:4} >>>a[5] = a.pop(1) >>>a {3: 4, 5: 2} >>>
myDict = {1:"one",2:{3:"three",4:"four"}} myDict[2][5] = myDict[2].pop(4) print myDict Output {1:
a = { b = {ps.stem(w) : a[w] for w in a.keys()} print(b) >>> {
def isEmpty(self, dictionary): for element in dictionary: if element: return True return False def onMessage(self, socket, message): if self.isEmpty(self.users) == False: socket.send("Nobody is online, please use REGISTER command" \ " in order to register into the server") else: socket.send("ONLINE " +
>>> dct = {} >>> bool(dct) False >>> not dct True >>>
def onMessage(self, socket, message): if not self.users: socket.send("Nobody is online, please use REGISTER command" \ " in order to register into the server") else: socket.send("ONLINE " +
test_dict = {} if not test_dict: print "Dict is Empty" if not bool(test_dict): print "Dict is Empty" if len(test_dict) == 0: print "Dict is Empty"
def is_empty(dict): if not bool(dict): return True return False test_dict = {} if is_empty(test_dict): print("1") test_dict = {"a":123} if not is_empty(test_dict): print("1")
if myDictionary: non_empty_clause() else: empty_clause()
>>> d = { >>> bool(d.get( False >>> d[ >>> bool(d.get( True
def is_empty(my_dict): if my_dict == {}: print("Dict is empty !")
import numpy as np x=np.random.random(10) print(x) np.set_printoptions(precision=3) print(x)
y=np.array([1.5e-10,1.5,1500]) print(y) np.set_printoptions(suppress=True) print(y)
x = np.random.random(10) with np.printoptions(precision=3, suppress=True): print(x)
import numpy as np import contextlib @contextlib.contextmanager def printoptions(*args, **kwargs): original = np.get_printoptions() np.set_printoptions(*args, **kwargs) try: yield finally: np.set_printoptions(**original) x = np.random.random(10) with printoptions(precision=3, suppress=True): print(x)
[ 0.078 0.480 0.413 0.830 0.776 0.102 0.513 0.462 0.335 0.712]
[ 0.078 0.48 0.413 0.83 0.776 0.102 0.513 0.462 0.335 0.712]
>>> x=np.random.randn(5) >>> x array([ 0.25276524, 2.28334499, -1.88221637, 0.69949927, 1.0285625 ]) >>> [ [
def ndprint(a, format_string = print [format_string.format(v,i) for i,v in enumerate(a)]
In [27]: x = np.array([[1.1, 0.9, 1e-6]]*3) In [28]: print x [[ 1.10000000e+00 9.00000000e-01 1.00000000e-06] [ 1.10000000e+00 9.00000000e-01 1.00000000e-06] [ 1.10000000e+00 9.00000000e-01 1.00000000e-06]] In [29]: print np.array_str(x, precision=2) [[ 1.10e+00 9.00e-01 1.00e-06] [ 1.10e+00 9.00e-01 1.00e-06] [ 1.10e+00 9.00e-01 1.00e-06]] In [30]: print np.array_str(x, precision=2, suppress_small=True) [[ 1.1 0.9 0. ] [ 1.1 0.9 0. ] [ 1.1 0.9 0. ]]
>>> import numpy as np >>> x=np.random.random(10) >>> np.array2string(x, formatter={
np.set_printoptions( threshold=20, edgeitems=10, linewidth=140, formatter = dict( float = lambda x: "%.3g" % x ))
Example: printf( """ x: %.3g A: %.1f s: %s B: %s """, x, A, "str", B ) If `x` and `A` are numbers, this is like `"format" % (x, A, "str", B)` in python. If they `x`: e.g. [ 1.23 1.23e-6 ... ] 3 digits `A`: [ [ 1 digit after the decimal point ... ] ... ] with the current `np.set_printoptions()`. For example, with np.set_printoptions( threshold=100, edgeitems=3, suppress=True ) only the edges of big `x` and `A` are printed. `B` is printed as `str(B)`, for any `B` -- a number, a list, a numpy object ... `printf()` tries to handle too few or too many arguments sensibly, but this is iffy and subject to change. How it works: numpy has a function `np.array2string( A, "%.3g" )` (simplifying a bit). `printf()` splits the format string, and for format / arg pairs format: % d e f g arg: try `np.asanyarray()` --> %s np.array2string( arg, format ) Other formats and non-ndarray args are left alone, formatted as usual. Notes: `printf( ... end= file= )` are passed on to the python `print()` function. Only formats `% [optional width . precision] d e f g` are implemented, not `%(varname)format` . %d truncates floats, e.g. 0.9 and -0.9 to 0; %.0f rounds, 0.9 to 1 . %g is the same as %.6g, 6 digits. %% is a single "%" character. The function `sprintf()` returns a long string. For example, title = sprintf( "%s m %g n %g X %.3g", __file__, m, n, X ) print( title ) ... pl.title( title ) Module globals: _fmt = "%.3g" _squeeze = np.squeeze See also: http: http: from __future__ import division, print_function import re import numpy as np __version__ = "2014-02-03 feb denis" _splitformat = re.compile( r % (?<! %% ) -? [ \d . ]* \w ) _fmt = "%.3g" _squeeze = np.squeeze def printf( format, *args, **kwargs ): print( sprintf( format, *args ), **kwargs ) printf.__doc__ = __doc__ def sprintf( format, *args ): """ sprintf( "text %.3g text %4.1f ... %s ... ", numpy arrays or ... ) %[defg] array -> np.array2string( formatter= ) """ args = list(args) if not isinstance( format, basestring ): args = [format] + args format = "" tf = _splitformat.split( format ) nfmt = len(tf) nargs = len(args) if nargs < nfmt: args += (nfmt - nargs) * ["?arg?"] elif nargs > nfmt: tf += (nargs - nfmt) * [_fmt, " "] for j, arg in enumerate( args ): fmt = tf[ 2*j + 1 ] if arg is None \ or isinstance( arg, basestring ) \ or (hasattr( arg, "__iter__" ) and len(arg) == 0): tf[ 2*j + 1 ] = "%s" continue args[j], isarray = _tonumpyarray(arg) if isarray and fmt[-1] in "defgEFG": tf[ 2*j + 1 ] = "%s" fmtfunc = (lambda x: fmt % x) formatter = dict( float_kind=fmtfunc, int=fmtfunc ) args[j] = np.array2string( args[j], formatter=formatter ) try: return "".join(tf) % tuple(args) except TypeError: print( "error: tf %s types %s" % (tf, map( type, args ))) raise def _tonumpyarray( a ): """ a, isarray = _tonumpyarray( a ) -> scalar, False np.asanyarray(a), float or int a, False """ a = getattr( a, "value", a ) if np.isscalar(a): return a, False if hasattr( a, "__iter__" ) and len(a) == 0: return a, False try: a = np.asanyarray( a ) except ValueError: return a, False if hasattr( a, "dtype" ) and a.dtype.kind in "fi": if callable( _squeeze ): a = _squeeze( a ) return a, True else: return a, False if __name__ == "__main__": import sys n = 5 seed = 0 for arg in sys.argv[1:]: exec( arg ) np.set_printoptions( 1, threshold=4, edgeitems=2, linewidth=80, suppress=True ) np.random.seed(seed) A = np.random.exponential( size=(n,n) ) ** 10 x = A[0] printf( "x: %.3g \nA: %.1f \ns: %s \nB: %s ", x, A, "str", A ) printf( "x %%d: %d", x ) printf( "x %%.0f: %.0f", x ) printf( "x %%.1e: %.1e", x ) printf( "x %%g: %g", x ) printf( "x %%s uses np printoptions: %s", x ) printf( "x with default _fmt: ", x ) printf( "no args" ) printf( "too few args: %g %g", x ) printf( x ) printf( x, x ) printf( None ) printf( "[]:", [] ) printf( "[3]:", [3] ) printf( np.array( [] )) printf( [[]] )
x = np.random.random(10) with np.printoptions(precision=3, suppress=True): print(x)
import numpy as np dat = np.random.random((10,11))*100 print(dat) for i in range(10): print((4*"%6.2f"+7*"%9.4f") % tuple(dat[i,:]))
import numpy as np np.set_printoptions(suppress=True) a3 = 4E-3 a4 = 4E-4 a5 = 4E-5 a6 = 4E-6 a7 = 4E-7 a8 = 4E-8 print( print( print( print( myList = [a3,a4,a5,a6,a7,a8] print( for x in myList: print( print() myArray = np.array(myList) print( for x in myArray: print( print()
Case 3: a3, a4, a5: 0.00400 0.00040 0.00004 Case 4: a3, a4, a5, a6: 0.00400 0.00040 0.00004 4e-06 Case 5: a3, a4, a5, a6, a7: 0.00400 0.00040 0.00004 4e-06 0.00000 Case 6: a3, a4, a5, a6, a7, a8: 0.00400 0.00040 0.00004 0.00000 4e-07 0.00000 List 6: a3, a4, a5, a6, a7, a8: 0.00400 0.00040 0.00004 0.00000 0.00000 0.00000 Array 6: a3, a4, a5, a6, a7, a8: 0.00400 0.00040 0.00004 0.00000 0.00000 0.00000
def np_print(array,fmt="10.5f"): print (array.size*("{:"+fmt+"}")).format(*array)
import numpy as np from decimal import * arr = np.array([ 56.83, 385.3 , 6.65, 126.63, 85.76, 192.72, 112.81, 10.55]) arr2 = [str(Decimal(i).quantize(Decimal(
import numpy as np x = np.random.random([5,5]) print(np.around(x,decimals=3)) Output: [[0.475 0.239 0.183 0.991 0.171] [0.231 0.188 0.235 0.335 0.049] [0.87 0.212 0.219 0.9 0.3 ] [0.628 0.791 0.409 0.5 0.319] [0.614 0.84 0.812 0.4 0.307]]
import numpy as np x = np.random.random([5,5]) print(x.round(3))
In [96]: df Out[96]: A B C D a 1 4 9 1 b 4 5 0 2 c 5 5 1 0 d 1 3 9 6 In [99]: df[(df.A == 1) & (df.D == 6)] Out[99]: A B C D d 1 3 9 6
In [90]: def mask(df, key, value): ....: return df[df[key] == value] ....: In [92]: pandas.DataFrame.mask = mask In [93]: df = pandas.DataFrame(np.random.randint(0, 10, (4,4)), index=list( In [95]: df.ix[ In [96]: df Out[96]: A B C D a 1 4 9 1 b 4 5 0 2 c 5 5 1 0 d 1 3 9 6 In [97]: df.mask( Out[97]: A B C D a 1 4 9 1 d 1 3 9 6 In [98]: df.mask( Out[98]: A B C D d 1 3 9 6
df = pd.DataFrame( np.random.randn(30,3), columns = [ df_filtered = df.query(
df.mask(lambda x: x[0] < 0).mask(lambda x: x[1] > 0)
import pandas as pd import numpy as np np.random.seed([3,1415]) df = pd.DataFrame( np.random.randint(10, size=(10, 5)), columns=list( ) df A B C D E 0 0 2 7 3 8 1 7 0 6 8 6 2 0 2 0 4 9 3 7 3 2 4 3 4 3 6 7 7 4 5 5 3 7 5 9 6 8 7 6 4 7 7 6 2 6 6 5 8 2 8 7 5 8 9 4 7 6 1 5
df.query( A B C D E 0 0 2 7 3 8 1 7 0 6 8 6 2 0 2 0 4 9 3 7 3 2 4 3 4 3 6 7 7 4 5 5 3 7 5 9 7 6 2 6 6 5
df.query( A B C D E 0 0 2 7 3 8 1 7 0 6 8 6 4 3 6 7 7 4 5 5 3 7 5 9 7 6 2 6 6 5
import numpy as np import pandas as pd df = pd.DataFrame(np.random.randint(0,100,size=(100, 4)), columns=list( df.loc[lambda df: df.A == 80] df.sort_values(
In [96]: df Out[96]: A B C D a 1 4 9 1 b 4 5 0 2 c 5 5 1 0 d 1 3 9 6 In [99]: df[(df.A == 1) & (df.D == 6)] Out[99]: A B C D d 1 3 9 6
A = pd.DataFrame(np.random.randn(4, 4), columns=["A", "B", "C", "D"]) A.le_mask("A", 0.7).ge_mask("B", 0.2)... (May be repeated as necessary
import pandas as pd def eq_mask(df, key, value): return df[df[key] == value] def ge_mask(df, key, value): return df[df[key] >= value] def gt_mask(df, key, value): return df[df[key] > value] def le_mask(df, key, value): return df[df[key] <= value] def lt_mask(df, key, value): return df[df[key] < value] def ne_mask(df, key, value): return df[df[key] != value] def gen_mask(df, f): return df[f(df)] def apply_masks(): pd.DataFrame.eq_mask = eq_mask pd.DataFrame.ge_mask = ge_mask pd.DataFrame.gt_mask = gt_mask pd.DataFrame.le_mask = le_mask pd.DataFrame.lt_mask = lt_mask pd.DataFrame.ne_mask = ne_mask pd.DataFrame.gen_mask = gen_mask return pd.DataFrame if __name__ == pass
df = pd.DataFrame([[1, 2, True], [3, 4, False], [5, 7, True]], index=range(3), columns=[ print(df.loc[W[ print(df.loc[-W[ print(df.loc[~W[ print(df.loc[W.sum(axis=1) > 3]) print(df.loc[W[[
df[df["column_name"] != 5].groupby("other_column_name")
import pandas as pd import numpy as np np.random.seed([3,1415]) df = pd.DataFrame( np.random.randint(3, size=(10, 5)), columns=list( ) df df.set_index([
import os def touch(fname, times=None): with open(fname, os.utime(fname, times)
import os def touch(fname, times=None): fhandle = open(fname, try: os.utime(fname, times) finally: fhandle.close()
import os def touch(fname, mode=0o666, dir_fd=None, **kwargs): flags = os.O_CREAT | os.O_APPEND with os.fdopen(os.open(fname, flags=flags, mode=mode, dir_fd=dir_fd)) as f: os.utime(f.fileno() if os.utime in os.supports_fd else fname, dir_fd=None if os.supports_fd else dir_fd, **kwargs)
def touch(fname): if os.path.exists(fname): os.utime(fname, None) else: open(fname,
import os def touch(fname): try: os.utime(fname, None) except OSError: open(fname,
from ctypes import * libc = CDLL("libc.so.6") class c_timespec(Structure): _fields_ = [( class c_utimbuf(Structure): _fields_ = [( utimens = CFUNCTYPE(c_int, c_char_p, POINTER(c_utimbuf)) futimens = CFUNCTYPE(c_int, c_char_p, POINTER(c_utimbuf)) UTIME_NOW = ((1l << 30) - 1l) UTIME_OMIT = ((1l << 30) - 2l) now = c_timespec(0,UTIME_NOW) omit = c_timespec(0,UTIME_OMIT) def update_atime(fileno): assert(isinstance(fileno, int)) libc.futimens(fileno, byref(c_utimbuf(now, omit))) def update_mtime(fileno): assert(isinstance(fileno, int)) libc.futimens(fileno, byref(c_utimbuf(omit, now))) #
def touch(fname): open(fname, os.utime(fname, None)
import os fname = with open(fname, os.utime(fname, None)
import os with open(fname, try: os.utime(fname, None) except OSError: pass
import os try: os.utime(fname, None) except OSError: pass
from __future__ import (absolute_import, division, print_function) import os if os.path.exists(fname): try: os.utime(fname, None) except OSError: pass
from __future__ import (absolute_import, division, print_function) import os number_of_files = 0 for root, _, filenames in os.walk( for fname in filenames: pathname = os.path.join(root, fname) try: os.utime(pathname, None) number_of_files += 1 except OSError as why: print( print(
def utime(fname, atime=None, mtime=None) if type(atime) is tuple: atime, mtime = atime if atime is None or mtime is None: statinfo = os.stat(fname) if atime is None: atime = statinfo.st_atime if mtime is None: mtime = statinfo.st_mtime os.utime(fname, (atime, mtime)) def touch(fname, atime=None, mtime=None): if type(atime) is tuple: atime, mtime = atime open(fname, utime(fname, atime, mtime)
def touch(file_name): if not os.path.exists(file_name): return try: os.utime(file_name, None) except Exception: open(file_name, def midas_touch(root_path, older_than=dt.now(), pattern= midas_touch updates the modified timestamp of a file or files in a directory (folder) Arguements: root_path (str): file name or folder name of file-like object to touch older_than (datetime): only touch files with datetime older than this datetime pattern (str): filter files with this pattern (ignored if root_path is a single file) recursive (boolean): search sub-diretories (ignored if root_path is a single file) if not os.path.exists(root_path): return else: if os.path.isdir(root_path): dir_list=find_files(root_path, pattern= for f in dir_list: if dt.fromtimestamp(os.path.getmtime(f)) < older_than: touch(f) print "Touched ", f else: if dt.fromtimestamp(os.path.getmtime(f)) < older_than: touch(root_path)
[i for i in xrange(100000) if i == 1000][0] next(i for i in xrange(100000) if i == 1000)
a=[100,200,300,400,500] def search(b): try: k=a.index(b) return a[k] except ValueError: return print(search(500))
curl -O http: sudo python ez_setup.py sudo easy_install pip sudo pip install virtualenv
sudo pip install virtualenvwrapper curl -O http: sudo python distribute_setup.py
curl -O http: sudo python distribute_setup.py sudo easy_install pip sudo pip install virtualenv sudo pip install virtualenvwrapper
VERSION=12.0.7 INITIAL_ENV=bootstrap PYTHON=$(which python) URL_BASE=https: curl -O $URL_BASE/virtualenv-$VERSION.tar.gz tar xzf virtualenv-$VERSION.tar.gz $PYTHON virtualenv-$VERSION/virtualenv.py $INITIAL_ENV rm -rf virtualenv-$VERSION $INITIAL_ENV/bin/pip install virtualenv-$VERSION.tar.gz
$INITIAL_ENV/bin/virtualenv py-env1 $INITIAL_ENV/bin/virtualenv py-env2
export WORKON_HOME source ~/.local/bin/virtualenvwrapper.sh
export WORKON_HOME source /usr/local/bin/virtualenvwrapper.sh
kermit@hocus-pocus:~$ sudo apt-get install python-pandas kermit@hocus-pocus:~$ mkvirtualenv --system-site-packages s (s)kermit@hocus-pocus:~$ pip install --upgrade pandas (s)kermit@hocus-pocus:~$ python -c "import pandas; print(pandas.__version__)" 0.10.1 (s)kermit@hocus-pocus:~$ deactivate kermit@hocus-pocus:~$ python -c "import pandas; print(pandas.__version__)" 0.8.0
pythonbrew venv init pythonbrew venv create mycoolbundle pythonbrew venv use mycoolbundle
import os, sys, shutil, tempfile, subprocess, tarfile, hashlib try: from urllib2 import urlopen except ImportError: from urllib.request import urlopen tmp_dir = tempfile.mkdtemp(prefix= try: f = urlopen("https: tar_found = False url = None sha256 = None for line in f.read().splitlines(): if isinstance(line, bytes): line = line.decode( if tar_found: if sha256 = line.split( break continue if not tar_found and continue tar_found = True for url in line.split( if url.startswith( break else: print( sys.exit(1) file_name = url.rsplit( print(file_name) os.chdir(tmp_dir) data = urlopen(url).read() data_sha256 = hashlib.sha256(data).hexdigest() if sha256 != data_sha256: print( print(sha256) print(data_sha256) sys.exit(1) with open(file_name, fp.write(data) tar = tarfile.open(file_name) tar.extractall() tar.close() os.chdir(file_name.replace( print(subprocess.check_output([sys.executable, [sys.argv[1]]).decode( if len(sys.argv) > 2: print(subprocess.check_output([ os.path.join(sys.argv[1], sys.argv[2:]).decode( except: raise finally: shutil.rmtree(tmp_dir)
python_binary_to_use_in_venv /tmp/initvenv.py your_venv_name [optional packages]
% /opt/python/2.7.10/bin/python /tmp/initvenv.py venv virtualenvwrapper
% mktmpenv New python executable in tmp-17bdc3054a46b2b/bin/python Installing setuptools, pip, wheel...done. This is a temporary environment. It will be deleted when you run (tmp-17bdc3054a46b2b)%
$ cd ~ $ python <path to unzipped folder>/virtualenv.py bootstrapenv $ source bootstrapenv/bin/activate $ pip install virtualenvwrapper $ mkdir -p ~/bootstrapenv/Envs $ vi ~/.bashrc source ~/bootstrapenv/bin/activate export WORKON_HOME=~/bootstrapenv/Envs source ~/bootstrapenv/bin/virtualenvwrapper.sh $ source ~/.bashrc
pyvenv project_dir source project_dir/bin/activate python --version python 3.4.*
my_dict = {} if (my_dict[key] != None): my_dict[key] = 1 else: my_dict[key] += 1
from collections import defaultdict my_dict = defaultdict(int) my_dict[key] += 1
if key in my_dict: my_dict[key] += 1 else: my_dict[key] = 1
if key in my_dict and not (my_dict[key] is None): else:
my_dict = {} my_dict.setdefault(some_key, 0) my_dict[some_key] += 1
try: nonNone = my_dict[key] is not None except KeyError: nonNone = False
my_dict = {} def add (key): if my_dict.has_key(key): my_dict[key] += 1 else: my_dict[key] = 1 if __name__ == add("foo") add("bar") add("foo") print my_dict
my_dict = {} my_dict[key] = my_dict[key] + 1 if key in my_dict else 1
from collections import Counter to_count = ["foo", "foo", "bar", "baz", "foo", "bar"] count = Counter(to_count) print(count) print("acts just like the desired dictionary:") print("bar occurs {} times".format(count["bar"])) print("any item that does not occur in the list is set to 0:") print("dog occurs {} times".format(count["dog"])) print("can iterate over items from most frequent to least:") for item, times in count.most_common(): print("{} occurs {} times".format(item, times))
Counter({ acts just like the desired dictionary: bar occurs 2 times any item that does not occur in the list is set to 0: dog occurs 0 times can iterate over items from most frequent to least: foo occurs 3 times bar occurs 2 times baz occurs 1 times
my_dict = {} my_dict[key] = my_dict.setdefault(key, 0) + 1
my_dict = {} if my_dict.__contains__(some_key): my_dict[some_key] += 1 else: my_dict[some_key] = 1
>>> query = urllib.quote(u"Müller".encode( >>> print urllib.unquote(query).decode( Müller
>>> from urllib.parse import quote >>> quote( >>> quote( >>> quote(
>>> from requests.utils import quote >>> quote( >>> quote(
>>> from django.utils.http import urlquote >>> urlquote(u"Müller") u
A legacy compatibility wrapper to Python (was used for unicode handling on Python 2)
In [21]: query= In [22]: val=34 In [23]: from urllib.parse import urlencode In [24]: encoded = urlencode(dict(p=query,val=val)) In [25]: print(f"http: http:
from subprocess import check_output out = check_output(["ntpq", "-p"])
import subprocess p = subprocess.Popen(["ntpq", "-p"], stdout=subprocess.PIPE) out, err = p.communicate()
from subprocess import Popen, PIPE pipe = Popen(path, stdout=PIPE) text = pipe.communicate()[0]
import subprocess p = subprocess.Popen("pwd", stdout=subprocess.PIPE) result = p.communicate()[0] print result
import subprocess command = "ntpq -p" process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=None, shell=True) output = process.communicate() print output[0]
command = ["ntpq", "-p"] process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=None)
import subprocess command = "ntpq -p" process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True) output, error = process.communicate()
import subprocess try: result = subprocess.check_output("echo %USERNAME%", stderr=subprocess.STDOUT, shell=True) print result result = subprocess.check_output("copy testfds", stderr=subprocess.STDOUT, shell=True) except subprocess.CalledProcessError, ex: print "--------error------" print ex.cmd print ex.message print ex.returncode print ex.output
from subprocess import check_call import shlex check_call(shlex.split(
from subprocess import Popen, PIPE def console(cmd): p = Popen(cmd, shell=True, stdout=PIPE) out, err = p.communicate() return (p.returncode, out, err)
def pexec(*args): return subprocess.Popen(args, stdout=subprocess.PIPE).communicate()[0].rstrip()
changeset = pexec( branch = pexec( revnum = pexec( print(
import sys, traceback def main(): try: do main program stuff here .... except KeyboardInterrupt: print "Shutdown requested...exiting" except Exception: traceback.print_exc(file=sys.stdout) sys.exit(0) if __name__ == "__main__": main()
import sys try: sys.exit(1) except SystemExit as e: sys.exit(e) except: raise
import sys from subprocess import * try: check_call([ except CalledProcessError: sys.tracebacklimit=0 print "Process failed" raise print "This message should never follow an error."
[me@test01 dev]$ ./foo.py usage: uptime [-V] -V display version Process failed subprocess.CalledProcessError: Command
import sys def do_my_stuff(): pass if __name__ == "__main__": try: do_my_stuff() except SystemExit, e: print(e)
import sys .... .... .... sys.exit("I am getting the heck out of here!")
import pygame, sys from pygame.locals import * pygame.init() DISPLAYSURF = pygame.display.set_mode((400, 300)) pygame.display.set_caption( BLACK = (0, 0, 0) GREEN = (0, 255, 0) fontObj = pygame.font.Font( textSurfaceObj = fontObj.render( textRectObj = textSurfaceObj.get_rect() textRectObj = (10, 10) try: while True: DISPLAYSURF.fill(BLACK) DISPLAYSURF.blit(textSurfaceObj, textRectObj) for event in pygame.event.get(): if event.type == QUIT: pygame.quit() sys.exit() pygame.display.update() except SystemExit: pass
import numpy, scipy, pylab, random xs = [] rawsignal = [] with open("test.dat", for line in f: if line[0] != xs.append( int( line.split()[0] ) ) rawsignal.append( int( line.split()[1] ) ) h, w = 3, 1 pylab.figure(figsize=(12,9)) pylab.subplots_adjust(hspace=.7) pylab.subplot(h,w,1) pylab.title("Signal") pylab.plot(xs,rawsignal) pylab.subplot(h,w,2) pylab.title("FFT") fft = scipy.fft(rawsignal) pylab.ylim([0,1000]) pylab.plot(abs(fft)) pylab.savefig("SIG.png",dpi=200) pylab.show()
import matplotlib.pyplot as plt fig = plt.figure(figsize=(12,9)) signal_axes = fig.add_subplot(211) signal_axes.plot(xs,rawsignal) fft_axes = fig.add_subplot(212) fft_axes.set_title("FFT") fft_axes.set_autoscaley_on(False) fft_axes.set_ylim([0,1000]) fft = scipy.fft(rawsignal) fft_axes.plot(abs(fft)) plt.show()
fft_axes = pylab.subplot(h,w,2) pylab.title("FFT") fft = scipy.fft(rawsignal) pylab.ylim([0,1000]) fft_axes.set_autoscaley_on(False) pylab.plot(abs(fft))
pushButtonShowDialog.clicked.connect( lambda: ( field1.clear(), spinBox1.setValue(0), diag.show())
def function(n): x = 4 x = x+n return x-2 function(0)
import types def _obj(): return lambda: None def LET(bindings, body, env=None): ex: LET(( lambda o: [o.a, o.b]) gives: [1, 2] Bindings down the chain can depend on the ones above them through a lambda. ex: LET(( lambda o: o.b) gives: 2 if len(bindings) == 0: return body(env) env = env or _obj() k, v = bindings[:2] if isinstance(v, types.FunctionType): v = v(env) setattr(env, k, v) return LET(bindings[2:], body, env)
map(lambda x: LET(( lambda o: o.y * o.z), [1, 2, 3])
>>> def foo(arg): ... result = arg * 2; ... print "foo(" + str(arg) + ") called: " + str(result); ... return result; ... >>> f = lambda a, b, state=[]: [ ... state.append(foo(a)), ... state.append(foo(b)), ... state.append(foo(state[0] + state[1])), ... state[-1] ... ][-1]; >>> f(1, 2); foo(1) called: 2 foo(2) called: 4 foo(6) called: 12 12
f = exec( def mlambda(x, y): d = y - x return d * d
def mlambda(signature, *lines): exec_vars = {} exec( return exec_vars[ f = mlambda(
def my_function(**kwargs): print str(kwargs) my_function(a=12, b="abc") {
def foo(*positional, **keywords): print "Positional:", positional print "Keywords:", keywords
def foo(bar, baz): pass foo(1, 2) foo(baz=2, bar=1)
func(foo="bar", baz=5, hello=123) func(baz=5, foo="bar", hello=123)
def func(foo=1, baz=2, hello=3): ... func("bar", 5, 123)
>>> def func(a= ... print ... >>> func() a:a, b:b, c:c >>> func(**{ a:z, b:q, c:v >>>
def func2(a, *, b): ... func2(value_for_a, b=21) func2(value_for_a)
def test_var_kwargs(farg, **kwargs): print "formal arg:", farg for key in kwargs: print "another keyword arg: %s: %s" % (key, kwargs[key])
>>> print(test_var_kwarg( A B okay {} >>> d = { >>> print(test_var_kwarg( a b c { >>> print(test_var_kwarg( a b c {}
import itertools for element in itertools.product(*somelists): print(element)
import itertools >>> for i in itertools.product([1,2,3],[ ... print i ... (1, (1, (1, (1, (2, (2, (2, (2, (3, (3, (3, (3, >>>
>>> [(a, b, c) for a in [1,2,3] for b in [ [(1, (2, (3,
def product(*args): if not args: return iter(((),)) return (items + (item,) for items in product(*args[:-1]) for item in args[-1])
>>> list(product([1,2,3], [ [(1, (2, (3, >>> list(product([1,2,3])) [(1,), (2,), (3,)] >>> list(product([])) [] >>> list(product()) [()]
import itertools result = list(itertools.product(*somelists))
def product(*args, **kwds): pools = map(tuple, args) * kwds.get( result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] for prod in result: yield tuple(prod)
somelists = [ [1, 2, 3], [ [4, 5] ] cart_prod = [(a,b,c) for a in somelists[0] for b in somelists[1] for c in somelists[2]]
def product(ar_list): if not ar_list: yield () else: for a in ar_list[0]: for prod in product(ar_list[1:]): yield (a,)+prod print list(product([[1,2],[3,4],[5,6]]))
[(1, 3, 5), (1, 3, 6), (1, 4, 5), (1, 4, 6), (2, 3, 5), (2, 3, 6), (2, 4, 5), (2, 4, 6)]
def cartesian_iterative(pools): result = [[]] for pool in pools: result = [x+[y] for x in result for y in pool] return result
def cartesian_recursive(pools): if len(pools) > 2: pools[0] = product(pools[0], pools[1]) del pools[1] return cartesian_recursive(pools) else: pools[0] = product(pools[0], pools[1]) del pools[1] return pools def product(x, y): return [xx + [yy] if isinstance(xx, list) else [xx] + [yy] for xx in x for yy in y]
def cartesian_reduct(pools): return reduce(lambda x,y: product(x,y) , pools)
import itertools import sympy x, y = sympy.symbols( somelist = [[x,y], [1,2,3], [4,5]] somelist2 = [[1,2], [1,2,3], [4,5]] for element in itertools.product(*somelist): print element
def product_args(*args): if args: for a in args[0]: for prod in product_args(*args[1:]) if args[1:] else ((),): yield (a,) + prod
def product2(ar_list): """ >>> list(product(())) [()] >>> list(product2(())) [] """ return product_args(*ar_list)
def rec_cart(start, array, partial, results): if len(partial) == len(array): results.append(partial) return for element in array[start]: rec_cart(start+1, array, partial+[element], results) rec_res = [] some_lists = [[1, 2, 3], [ rec_cart(0, some_lists, [], rec_res) print(rec_res)
def itr_cart(array): results = [[]] for i in range(len(array)): temp = [] for res in results: for element in array[i]: temp.append(res+[element]) results = temp return results some_lists = [[1, 2, 3], [ itr_res = itr_cart(some_lists) print(itr_res)
>>> d = { >>> k, v = d.keys(), d.values() >>> for i in range(len(k)): print d[k[i]] == v[i] True True True
for key, value in myDictionary.iteritems(): print key, value
keys = dict1.keys() ordered_keys1 = [dict1[cur_key] for cur_key in keys] ordered_keys2 = [dict2[cur_key] for cur_key in keys]
import psutil psutil.cpu_percent() psutil.virtual_memory()` dict(psutil.virtual_memory()._asdict())
from __future__ import print_function import psutil print(psutil.__versi‌​on__)
from __future__ import print_function import psutil print(psutil.cpu_percent()) print(psutil.virtual_memory())
import os import psutil pid = os.getpid() py = psutil.Process(pid) memoryUse = py.memory_info()[0]/2.**30 print(
tar -xvzf psutil-0.5.0.tar.gz‌​ cd psutil-0.5.0 sudo python setup.py install
import os CPU_Pct=str(round(float(os.popen( print("CPU Usage = " + CPU_Pct)
import os mem=str(os.popen( """ Get a whole line of memory output, it will be something like below [ So, we need total memory, usage and free memory. We should find the index of capital T which is unique at this string """ T_ind=mem.index( """ Than, we can recreate the string with this information. After T we have, "Total: " which has 14 characters, so we can start from index of T +14 and last 4 characters are also not necessary. We can create a new sub-string using this information The result will be like 1025 603 422 we need to find first index of the first space, and we can start our substring from from 0 to this index number, this will give us the string of total memory """ S1_ind=mem_G.index( mem_T=mem_G[0:S1_ind] """ Similarly we will create a new sub-string, which will start at the second value. The resulting string will be like 603 422 Again, we should find the index of first space and than the take the Used Memory and Free memory. """ mem_G1=mem_G[S1_ind+8:] S2_ind=mem_G1.index( mem_U=mem_G1[0:S2_ind] mem_F=mem_G1[S2_ind+8:] print print print print
import os tot_m, used_m, free_m = map(int, os.popen(
Monitor window processes derived from: >for sys available mem http: > individual process information and python script examples http: NOTE: the WMI interface/process is also available for performing similar tasks I to extend or improve this module, then may want to investigate the WMI tools available. WMI for python: http: __revision__ = 3 import win32com.client from ctypes import * from ctypes.wintypes import * import pythoncom import pywintypes import datetime class MEMORYSTATUS(Structure): _fields_ = [ ( ( ( ( ( ( ( ( ] def winmem(): x = MEMORYSTATUS() windll.kernel32.GlobalMemoryStatus(byref(x)) return x class process_stats: Refer to the self.supported_types keys for the currently supported To add logging support for other data you can derive the necessary data from perfmon: --------- perfmon can be run from windows Clicking on the From the --> Where spaces are removed and symbols are entered as text (Ex. For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary, keyed by the --------- NOTE: The Initially the python implementation was derived from: http: def __init__(self,process_name_list=[],perf_object_list=[],filter_list=[]): perf_object_list == list of process counters to log filter_list == list of text to filter print_results == boolean, output to stdout pythoncom.CoInitialize() self.process_name_list = process_name_list self.perf_object_list = perf_object_list self.filter_list = filter_list self.win32_perf_base = self.supported_types = { ], ] } def get_pid_stats(self, pid): this_proc_dict = {} pythoncom.CoInitialize() if not self.perf_object_list: perf_object_list = self.supported_types.keys() for counter_type in perf_object_list: strComputer = "." objWMIService = win32com.client.Dispatch("WbemScripting.SWbemLocator") objSWbemServices = objWMIService.ConnectServer(strComputer,"root\cimv2") query_str = colItems = objSWbemServices.ExecQuery(query_str) if len(colItems) > 0: for objItem in colItems: if hasattr(objItem, for attribute in self.supported_types[counter_type]: eval_str = this_proc_dict[attribute] = eval(eval_str) this_proc_dict[ break return this_proc_dict def get_stats(self): Show process stats for all processes in given list, if none given return all processes If filter list is defined return only the items that match or contained in the list Returns a list of result dictionaries pythoncom.CoInitialize() proc_results_list = [] if not self.perf_object_list: perf_object_list = self.supported_types.keys() for counter_type in perf_object_list: strComputer = "." objWMIService = win32com.client.Dispatch("WbemScripting.SWbemLocator") objSWbemServices = objWMIService.ConnectServer(strComputer,"root\cimv2") query_str = colItems = objSWbemServices.ExecQuery(query_str) try: if len(colItems) > 0: for objItem in colItems: found_flag = False this_proc_dict = {} if not self.process_name_list: found_flag = True else: for proc_name in self.process_name_list: obj_name = objItem.Name if proc_name.lower() in obj_name.lower(): found_flag = True break if found_flag: for attribute in self.supported_types[counter_type]: eval_str = this_proc_dict[attribute] = eval(eval_str) this_proc_dict[ proc_results_list.append(this_proc_dict) except pywintypes.com_error, err_msg: continue return proc_results_list def get_sys_stats(): pythoncom.CoInitialize() x = winmem() sys_dict = { } return sys_dict if __name__ == sys_dict = get_sys_stats() stats_processor = process_stats(process_name_list=[ proc_results = stats_processor.get_stats() for result_dict in proc_results: print result_dict import os this_pid = os.getpid() this_proc_results = stats_processor.get_pid_stats(this_pid) print print this_proc_results
import os def get_cpu_load(): result = [] cmd = "WMIC CPU GET LoadPercentage " response = os.popen(cmd + for load in response[1:]: result.append(int(load)) return result if __name__ == print get_cpu_load()
import subprocess cmd = subprocess.Popen([ out,error = cmd.communicate() memory = out.splitlines()
import os .... memory_usage = os.popen("cat /proc/meminfo").read()
from subprocess import Popen, PIPE def get_cpu_usage(): sub = Popen(( top_vals = [int(val) for val in sub.communicate()[0].split( return (top_vals[0] + top_vals[2]) * 100. /(top_vals[0] + top_vals[2] + top_vals[3])
urlpatterns = patterns( url(r ) urlpatterns = patterns(
return combine_sample_generators(sample_generators[ combine_sample_generators(sample_generators[ combine_sample_generators(sample_generators[
return \ combine_sample_generators(sample_generators[ combine_sample_generators(sample_generators[ combine_sample_generators(sample_generators[
"cannot index with vector containing NA / NaN values"
>>> df = pd.DataFrame([[ >>> df a b 0 hello hello world 1 abcd defg
>>> df.apply(lambda x: x[ 0 True 1 False dtype: bool
def stringSearchColumn_DataFrame(df, colName, regex): newdf = DataFrame() for idx, record in df[colName].iteritems(): if re.search(regex, record): newdf = concat([df[df[colName] == record], newdf], ignore_index=True) return newdf
import pandas as pd k=pd.DataFrame([ k.columns=[ t=k[k[ d=k.replace(t,
k Out[95]: some_thing 0 hello 1 doubt 2 hero 3 help t Out[99]: some_thing 0 hello 3 help d Out[96]: some_thing 0 CS 1 doubt 2 hero 3 CS
df_Fixed[~df_Fixed["Busler Group"].map(lambda x: x.startswith(
Jans-MacBook-Pro:~ jan$ /Library/Frameworks/Python.framework/Versions/3.3/bin/pip-3.3 install MySQL-python Downloading/unpacking MySQL-python Running setup.py egg_info for package MySQL-python Traceback (most recent call last): File "<string>", line 16, in <module> File "/var/folders/lf/myf7bjr57_jg7_5c4014bh640000gn/T/pip-build/MySQL-python/setup.py", line 14, in <module> from setup_posix import get_config File "./setup_posix.py", line 2, in <module> from ConfigParser import SafeConfigParser ImportError: No module named Complete output from command python setup.py egg_info: Traceback (most recent call last): File "<string>", line 16, in <module> File "/var/folders/lf/myf7bjr57_jg7_5c4014bh640000gn/T/pip-build/MySQL-python/setup.py", line 14, in <module> from setup_posix import get_config File "./setup_posix.py", line 2, in <module> from ConfigParser import SafeConfigParser ImportError: No module named ---------------------------------------- Command python setup.py egg_info failed with error code 1 in /var/folders/lf/myf7bjr57_jg7_5c4014bh640000gn/T/pip-build/MySQL-python Storing complete log in /Users/jan/.pip/pip.log Jans-MacBook-Pro:~ jan$
sudo apt-get install python3-dev libmysqlclient-dev
try: import configparser except: from six.moves import configparser
pip install configparser sudo cp /usr/lib/python3.6/configparser.py /usr/lib/python3.6/ConfigParser.py
import six if six.PY2: import ConfigParser as configparser else: import configparser
cp /usr/local/lib/python3.5/configparser.py /usr/local/lib/python3.5/ConfigParser.py
f = open(file) for line in f: if line.contains( newline = line.replace(
from tempfile import mkstemp from shutil import move from os import fdopen, remove def replace(file_path, pattern, subst): fh, abs_path = mkstemp() with fdopen(fh, with open(file_path) as old_file: for line in old_file: new_file.write(line.replace(pattern, subst)) remove(file_path) move(abs_path, file_path)
import fileinput for line in fileinput.input("test.txt", inplace=True): print "%d: %s" % (fileinput.filelineno(), line),
import fileinput import sys def replaceAll(file,searchExp,replaceExp): for line in fileinput.input(file, inplace=1): if searchExp in line: line = line.replace(searchExp,replaceExp) sys.stdout.write(line)
replaceAll("/fooBar.txt","Hello\sWorld!$","Goodbye\sWorld.")
import fileinput for line in fileinput.input(files, inplace = 1): print line.replace("foo", "bar"),
import re def replace(file, pattern, subst): file_handle = open(file, file_string = file_handle.read() file_handle.close() file_string = (re.sub(pattern, subst, file_string)) file_handle = open(file, file_handle.write(file_string) file_handle.close()
fin = open("a.txt") fout = open("b.txt", "wt") for line in fin: fout.write( line.replace( fin.close() fout.close()
import re def replace( filePath, text, subs, flags=0 ): with open( filePath, "r+" ) as file: fileContents = file.read() textPattern = re.compile( re.escape( text ), flags ) fileContents = textPattern.sub( subs, fileContents ) file.seek( 0 ) file.truncate() file.write( fileContents )
from tempfile import mkstemp from shutil import move from os import remove def replace(source_file_path, pattern, substring): fh, target_file_path = mkstemp() with open(target_file_path, with open(source_file_path, for line in source_file: target_file.write(line.replace(pattern, substring)) remove(source_file_path) move(target_file_path, source_file_path)
import codecs from tempfile import mkstemp from shutil import move from os import remove def replace(source_file_path, pattern, substring): fh, target_file_path = mkstemp() with codecs.open(target_file_path, with codecs.open(source_file_path, for line in source_file: target_file.write(line.replace(pattern, substring)) remove(source_file_path) move(target_file_path, source_file_path)
import re fin = open("in.txt", fout = open("out.txt", for line in fin: p = re.compile( newline = p.sub( print newline fout.write(newline) fin.close() fout.close()
def replace(file, pattern, subst): fh, abs_path = mkstemp() print fh, abs_path new_file = open(abs_path, old_file = open(file) for line in old_file: new_file.write(line.replace(pattern, subst)) new_file.close() close(fh) old_file.close() remove(file) move(abs_path, file)
result = [] for a in iterable_a: for b in iterable_b: result.append((a, b))
def map(func, iterable): for i in iterable: yield func(i)
>>> a = "hello, world" >>> list(a) [ >>> tuple(a) (
>>> a = ["foo", "bar", "baz"] >>> list(map(list, a)) [[
xs = [1, 2, 3] ys = map(lambda x: x * 2, xs) ys = [x * 2 for x in xs] ys = [] for x in xs: ys.append(x * 2)
xs = [1, 2, 3] ys = [2, 4, 6] def f(x, y): return (x * 2, y zs = map(f, xs, ys) zs = [f(x, y) for x, y in zip(xs, ys)] zs = [] for x, y in zip(xs, ys): zs.append(f(x, y))
def mymap(func, lst): result = [] for e in lst: result.append(func(e)) return result
lst = [1, 2, 3, 4, 5] from operator import add reduce(add, map(lambda i: map(lambda j: (i, j), lst), lst))
from itertools import product list(product(lst, lst))
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5)]
list_one = [1, 2, 3, 4, 5] list_two = [11, 12, 13, 14, 15] list_three = [21, 22, 23, 24, 25]
>>> map(sum, list_one, list_two, list_three) [33, 36, 39, 42, 45]
import time def test1(iterable): a = time.clock() map(str, iterable) a = time.clock() - a b = time.clock() [ str(x) for x in iterable ] b = time.clock() - b print(a,b) def test2(iterable): a = time.clock() [ x for x in map(str, iterable)] a = time.clock() - a b = time.clock() [ str(x) for x in iterable ] b = time.clock() - b print(a,b) test1(range(2000000)) test2(range(2000000))
from collections import OrderedDict OrderedDict((word, True) for word in words)
>>> from collections import OrderedDict >>> my_dictionary=OrderedDict() >>> my_dictionary[ >>> my_dictionary[ >>> my_dictionary OrderedDict([( >>> dict(my_dictionary) {
test_dict = dict( val1 = "hi", val2 = "bye", val3 = "huh?", val4 = "what....") test_tuple = ( for key in test_tuple: print(test_dict[key])
>>> list =[[1,2],[2,3]] >>> for i in list: ... print i[0] ... print i[1] 1 2 2 3
Usage [-w W] error: argument -w: expected one argument
import argparse parser = argparse.ArgumentParser(description="Flip a switch by setting a flag") parser.add_argument( args = parser.parse_args() print args.w
>>> from optparse import OptionParser >>> import inspect >>> inspect.getmembers(OptionParser, predicate=inspect.ismethod) [([( ... ( ( ( ( ( ( <unbound method OptionParser.disable_interspersed_args>), ( <unbound method OptionParser.enable_interspersed_args>), ( ( ( ... ]
>>> parser = OptionParser() >>> inspect.getmembers(parser, predicate=inspect.ismethod) ...
method_list = [func for func in dir(Foo) if callable(getattr(Foo, func))]
method_list = [func for func in dir(Foo) if callable(getattr(Foo, func)) and not func.startswith("__")]
from types import FunctionType class Foo: def bar(self): pass def baz(self): pass def methods(cls): return [x for x, y in cls.__dict__.items() if type(y) == FunctionType] methods(Foo)
def find_defining_class(obj, meth_name): for ty in type(obj).mro(): if meth_name in ty.__dict__: return ty
def classMethods(the_class,class_only=False,instance_only=False,exclude_internal=True): def acceptMethod(tup): is_method = inspect.ismethod(tup[1]) if is_method: bound_to = tup[1].im_self internal = tup[1].im_func.func_name[:2] == if internal and exclude_internal: include = False else: include = (bound_to == the_class and not instance_only) or (bound_to == None and not class_only) else: include = False return include return filter(acceptMethod,inspect.getmembers(the_class))
>>> d = datetime.date(2011,01,01) >>> datetime.datetime.utcfromtimestamp(time.mktime(d.timetuple())) datetime.datetime(2010, 12, 31, 23, 0)
from pytz import utc, timezone from datetime import datetime from time import mktime input_date = datetime(year=2011, month=1, day=15)
>>> from datetime import datetime, date >>> import calendar >>> timestamp1 = calendar.timegm(d.timetuple()) >>> datetime.utcfromtimestamp(timestamp1) datetime.datetime(2011, 1, 1, 0, 0)
>>> import time >>> timestamp2 = time.mktime(d.timetuple()) >>> datetime.fromtimestamp(timestamp2) datetime.datetime(2011, 1, 1, 0, 0)
DAY = 24*60*60 timestamp = (utc_date.toordinal() - date(1970, 1, 1).toordinal()) * DAY timestamp = (utc_date - date(1970, 1, 1)).days * DAY
from datetime import timezone timestamp = dt.replace(tzinfo=timezone.utc).timestamp()
timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)
timestamp = (dt - datetime(1970,1,1, tzinfo=timezone.utc)) / timedelta(seconds=1)
timestamp = (dt - datetime(1970, 1, 1)).total_seconds()
from __future__ import division from datetime import datetime, timedelta def totimestamp(dt, epoch=datetime(1970,1,1)): td = dt - epoch return (td.microseconds + (td.seconds + td.days * 86400) * 10**6) / 10**6 now = datetime.utcnow() print now print totimestamp(now)
assert dt.tzinfo is not None and dt.utcoffset() is not None timestamp = dt.timestamp()
from datetime import datetime, timedelta, timezone epoch = datetime(1970, 1, 1, tzinfo=timezone.utc) timestamp = (dt - epoch) / timedelta(seconds=1) integer_timestamp = (dt - epoch)
utc_naive = dt.replace(tzinfo=None) - dt.utcoffset() timestamp = (utc_naive - datetime(1970, 1, 1)).total_seconds()
>>> import datetime >>> d = datetime.date(2011,01,01) >>> d.strftime("%s")
d = datetime.date(1970,1,1) dtt = d.timetuple() ts = time.mktime(dtt)
>>> d = datetime.date(2011,01,01) >>> datetime.datetime.utcfromtimestamp(calendar.timegm(d.timetuple())) datetime.datetime(2011, 1, 1, 0, 0)
>>> SimpleDate(1293858000, tz= datetime.date(2011, 1, 1)
>>> import arrow >>> arrow.get(2010, 12, 31).timestamp 1293753600 >>> time.gmtime(1293753600) time.struct_time(tm_year=2010, tm_mon=12, tm_mday=31, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=365, tm_isdst=0)
import time import datetime from pytz import timezone import calendar import pytz def utc_time2datetime(utc_time, tz=None): utc_datetime = datetime.datetime.fromtimestamp(utc_time) if tz is None: tz_datetime = utc_datetime.astimezone(timezone( else: tz_datetime = utc_datetime.astimezone(tz) return tz_datetime def datetime2utc_time(datetime): if datetime.tzinfo is None: datetime = datetime.replace(tzinfo=timezone( utc_datetime = datetime.astimezone(timezone( utc_timetuple = utc_datetime.timetuple() utc_time = calendar.timegm(utc_timetuple) + datetime.microsecond / 1E6 return utc_time
$ python3 >>> from datetime import datetime >>> from calendar import timegm >>> tm = >>> fmt = >>> timegm(datetime.strptime(tm, fmt).utctimetuple()) 3600
$ python3 >>> from datetime import datetime, timezone, timedelta >>> from calendar import timegm >>> dt = datetime(1970, 1, 1, 6, 0) >>> tz = timezone(timedelta(hours=5)) >>> timegm(dt.replace(tzinfo=tz).utctimetuple()) 3600
import logging import logging.handlers logger = logging.getLogger("") logger.setLevel(logging.DEBUG) handler = logging.handlers.RotatingFileHandler( LOGFILE, maxBytes=(1048576*5), backupCount=7 ) formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s") handler.setFormatter(formatter) logger.addHandler(handler)
import logging logging.getLogger().addHandler(logging.StreamHandler())
import logging logFormatter = logging.Formatter("%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s] %(message)s") rootLogger = logging.getLogger() fileHandler = logging.FileHandler("{0}/{1}.log".format(logPath, fileName)) fileHandler.setFormatter(logFormatter) rootLogger.addHandler(fileHandler) consoleHandler = logging.StreamHandler() consoleHandler.setFormatter(logFormatter) rootLogger.addHandler(consoleHandler)
2012-12-05 16:58:26,618 [MainThread ] [INFO ] my message
import logging logging.basicConfig( level=logging.INFO, format="%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s] %(message)s", handlers=[ logging.FileHandler("{0}/{1}.log".format(logPath, fileName)), logging.StreamHandler() ])
import logging from logging.handlers import RotatingFileHandler from logging import handlers import sys log = logging.getLogger( log.setLevel(logging.DEBUG) format = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s") ch = logging.StreamHandler(sys.stdout) ch.setFormatter(format) log.addHandler(ch) fh = handlers.RotatingFileHandler(LOGFILE, maxBytes=(1048576*5), backupCount=7) fh.setFormatter(format) log.addHandler(fh)
fh = logging.handlers.RotatingFileHandler(LOGFILE, maxBytes=(1048576*5), backupCount=7)
In [1]: import numpy as np In [2]: a = np.array([[1,2,3],[4,5,6],[0,0,1]]) In [3]: np.sort(a.view( Out[3]: array([[0, 0, 1], [1, 2, 3], [4, 5, 6]])
In [6]: a.view( In [7]: a Out[7]: array([[0, 0, 1], [1, 2, 3], [4, 5, 6]])
a = a[a[:,2].argsort()] a = a[a[:,1].argsort(kind= a = a[a[:,0].argsort(kind=
a = ([[1, 2, 3], [4, 5, 6], [0, 0, 1]]); a = sorted(a, key=lambda a_entry: a_entry[1]) print a
import numpy as np table = np.random.rand(5000, 10) %timeit table.view( 1000 loops, best of 3: 1.88 ms per loop %timeit table[table[:,9].argsort()] 10000 loops, best of 3: 180 µs per loop import pandas as pd df = pd.DataFrame(table) %timeit df.sort_values(9, ascending=True) 1000 loops, best of 3: 400 µs per loop
>>> a array([[1, 2], [0, 0], [1, 0], [0, 2], [2, 1], [1, 0], [1, 0], [0, 0], [1, 0], [2, 2]]) >>> a[np.lexsort(np.fliplr(a).T)] array([[0, 0], [0, 0], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 2], [2, 1], [2, 2]])
In [120]: b=np.array([[1,2,1],[3,1,2],[1,1,3],[2,3,4],[3,2,5],[2,1,6]]) In [121]: b Out[121]: array([[1, 2, 1], [3, 1, 2], [1, 1, 3], [2, 3, 4], [3, 2, 5], [2, 1, 6]]) In [122]: b[np.lexsort(([1,-1]*b[:,[1,0]]).T)] Out[122]: array([[3, 1, 2], [3, 2, 5], [2, 1, 6], [2, 3, 4], [1, 1, 3], [1, 2, 1]])
ar=np.array([[0, 0, 0, 1], [1, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 0], [1, 1, 0, 0]])
ar[np.lexsort(([ar[:, i] for i in range(ar.shape[1]-1, -1, -1)]))]
array([[0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0]])
def mean(numbers): return float(sum(numbers)) / max(len(numbers), 1) >>> mean([1,2,3,4]) 2.5 >>> mean([]) 0.0
>>> import numpy >>> a = [1, 2, 4] >>> numpy.mean(a) 2.3333333333333335
>>> a = [1, 2, 3, 4, 5, 6] >>> print(sum(a) / len(a)) 3
l1 = [3,5,14,2,5,36,4,3] l2 = [0,0,0] print(avg(l1)) print(avg(l2))
def list_mean(nums): sumof = 0 num_of = len(nums) mean = 0 for i in nums: sumof += i mean = sumof / num_of return float(mean)
if not L: raise WhateverYouWantError("foo") avg = float(sum(L))/len(L)
from functools import reduce from operator import truediv def ave(seq): return truediv(*reduce(lambda a, b: (a[0] + b[1], b[0]), enumerate(seq, start=1), (0, 0)))
from statistics import mean avarage=mean(your_list)
from statistics import mean my_list=[5,2,3,2] avarage=mean(my_list) print(avarage)
def meanmanual(listt): mean = 0 lsum = 0 lenoflist = len(listt) for i in listt: lsum += i mean = lsum / lenoflist return float(mean) a = [1, 2, 3, 4, 5, 6] meanmanual(a) Answer: 3.5
def filter_list(full_list, excludes): s = set(excludes) return (x for x in full_list if x not in s)
filtered_list = list(filter_list(full_list, excludes))
>>> l1 = [1,2,6,8] >>> l2 = set([2,3,5,8]) >>> list(filter(lambda x: x not in l2, l1)) [1, 6]
mquadri$ python -m timeit -s "l1 = set([1,2,6,8]); l2 = set([2,3,5,8]);" "l1 - l2" 10000000 loops, best of 3: 0.124 usec per loop
mquadri$ python -m timeit -s "l1 = [1,2,6,8]; l2 = set([2,3,5,8]);" "[x for x in l1 if x not in l2]" 1000000 loops, best of 3: 0.302 usec per loop
mquadri$ python -m timeit -s "l1 = [1,2,6,8]; l2 = [2,3,5,8];" "[x for x in l1 if x not in l2]" 1000000 loops, best of 3: 0.552 usec per loop
mquadri$ python -m timeit -s "l1 = [1,2,6,8]; l2 = set([2,3,5,8]);" "filter(lambda x: x not in l2, l1)" 1000000 loops, best of 3: 0.972 usec per loop
mquadri$ python -m timeit "l1 = [1,2,6,8]; l2 = [2,3,5,8];" "reduce(lambda x,y : filter(lambda z: z!=y,x) ,l1,l2)" 100000 loops, best of 3: 3.97 usec per loop
reduce(lambda x,y : filter(lambda z: z!=y,x) ,[2,3,5,8],[1,2,6,8])
first_names = [ last_names = [ fields = { } for field, possible_values in fields:
for field, possible_values in fields.iteritems(): print field, possible_values
for field, possible_values in fields.items(): print(field, possible_values)
for field, possible_values in fields.items(): print(field, possible_values)
>>> for field, values in fields.iteritems(): ... print field, values ... first_names [ last_name [
>>> for field in fields: ... print field ... first_names last_name
for field, possible_values in enumerate(fields): print(field, possible_values)
first_names = [ last_names = [ fields = { } tup_field=tuple(fields.items()) for names in fields.items(): field,possible_values = names tup_possible_values=tuple(possible_values) for pvalue in tup_possible_values: print (field + "is" + pvalue)
data = ([ corpus = [] for(doc,tags) in data: doc_tag = [] for word,tag in zip(doc,tags): doc_tag.append((word,tag)) corpus.append(doc_tag) print(corpus)
for field, possible_values in fields.items(): print(field, possible_values)
for field, possible_values in enumerate(fields): print(field, possible_values)
def filter_by(self, **kwargs): return self.filter(sql.and_(**kwargs))
pip install autopep8 autopep8 script.py autopep8 -i script.py
import os; os.system("C:\\Temp\\a b c\\Notepad.exe"); raw_input();
import win32api try: win32api.WinExec( except: pass
import os; os.system("\"C:\\Temp\\a b c\\Notepad.exe\" C:\\test.txt");
import subprocess args = [ res = subprocess.Popen(args, stdout=subprocess.PIPE) output, error_ = res.communicate() if not error_: print(output) else: print(error_)
def set_property(property,value): def get_property(property):
class C(object): def __init__(self): self._x = None @property def x(self): print("getter of x called") return self._x @x.setter def x(self, value): print("setter of x called") self._x = value @x.deleter def x(self): print("deleter of x called") del self._x c = C() c.x = foo = c.x del c.x
value = obj.attribute = value value = obj.attribute del obj.attribute
class Obj: # @property def attribute(self): return self._attribute # @attribute.setter def attribute(self, value): self._attribute = value # @attribute.deleter def attribute(self): del self._attribute
obj = Obj() obj.attribute = value the_value = obj.attribute del obj.attribute
def set_property(property,value): def get_property(property):
class Obj: def set_property(self, property, value): ... def get_property(self, property): ...
class Protective(object): @property def protected_value(self): return self._protected_value @protected_value.setter def protected_value(self, value): if acceptable(value): self._protected_value = value
class Protective(object): def __init__(self, start_protected_value=0): self.protected_value = start_protected_value @property def protected_value(self): return self._protected_value @protected_value.setter def protected_value(self, value): if value != int(value): raise TypeError("protected_value must be an integer") if 0 <= value <= 100: self._protected_value = int(value) else: raise ValueError("protected_value must be " + "between 0 and 100 inclusive") @protected_value.deleter def protected_value(self): raise AttributeError("do not delete, protected_value can be set to 0")
>>> p1 = Protective(3) >>> p1.protected_value 3 >>> p1 = Protective(5.0) >>> p1.protected_value 5 >>> p2 = Protective(-5) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 3, in __init__ File "<stdin>", line 15, in protected_value ValueError: protectected_value must be between 0 and 100 inclusive >>> p1.protected_value = 7.3 Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 17, in protected_value TypeError: protected_value must be an integer >>> p1.protected_value = 101 Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 15, in protected_value ValueError: protectected_value must be between 0 and 100 inclusive >>> del p1.protected_value Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 18, in protected_value AttributeError: do not delete, protected_value can be set to 0
class Obj: # @property def get_only(self): return self._attribute # @get_only.setter def get_or_set(self, value): self._attribute = value # @get_or_set.deleter def get_set_or_delete(self): del self._attribute
obj = Obj() obj.get_or_set = obj.get_set_or_delete = the_value = obj.get_only del obj.get_set_or_delete
In [1]: class test(object): def __init__(self): self.pants = @property def p(self): return self.pants @p.setter def p(self, value): self.pants = value * 2 ....: In [2]: t = test() In [3]: t.p Out[3]: In [4]: t.p = 10 In [5]: t.p Out[5]: 20
class Person(object): def __init__(self, p_name=None): self.name = p_name @property def name(self): return self._name @name.setter def name(self, new_name): if type(new_name) == str: self._name = new_name else: raise Exception("Invalid value for name")
>>>p = person( >>>print(p.name) Mike >>>p.name = >>>print(p.name) George >>>p.name = 2.3
class MyClass: def __init__(self, attrvalue): self.myattr = attrvalue def __getattribute__(self, attr): if attr == "myattr": def __setattr__(self, attr): if attr == "myattr":
params = [ obj = someobject obj.a = object() for p in params: obj.a.p
obj = someobject obj.a = lambda: None setattr(obj.a,
class Object(object): pass a = Object() a.somefield = somevalue
params = [ for p in params: setattr(obj.a, p, value)
obj = someobject obj.a = SimpleNamespace() for p in params: setattr(obj.a, p, value)
obj.a = type( obj.a.b = obj.b = lambda:None class Test: pass obj.c = Test()
$ python >>> class Container(object): ... pass ... >>> x = Container() >>> x.a = 10 >>> x.b = 20 >>> x.banana = 100 >>> x.a, x.b, x.banana (10, 20, 100) >>> dir(x) [
In [11]: auth = type( In [12]: auth.func = staticmethod(lambda i: i * 2) In [13]: auth.func(2) Out[13]: 4
class MyClass: i = 123456 def f(self): return "hello world" b = MyClass() b.c = MyClass() setattr(b.c, b.c.test
import os def x_path(path_name): return getattr(x_path, path_name) x_path.root = for name in [ setattr(x_path, name, os.path.join(x_path.root, name))
In [1]: x_path.projects Out[1]: In [2]: x_path( Out[2]:
class NestedObject(): def __init__(self, initial_attrs): for key in initial_attrs: setattr(self, key, initial_attrs[key]) obj = someobject attributes = { obj.a = NestedObject(attributes) >>> obj.a.attr1 >>> obj.a.attr2 >>> obj.a.attr3
class NestedObject(object): def __init__(self, *initial_attrs, **kwargs): for dictionary in initial_attrs: for key in dictionary: setattr(self, key, dictionary[key]) for key in kwargs: setattr(self, key, kwargs[key]) obj.a = NestedObject(attr1=
di = {} for x in range(20): name = di[name] = type(name, (object), {}) setattr(di[name], "attr", "value")
import maya.cmds def getData(objets=None, attrs=None): di = {} for obj in objets: name = str(obj) di[name]=[] for at in attrs: di[name].append(cmds.getAttr(name+ return di acns=cmds.ls( attrs=[ getData(acns,attrs)
pip install --help ... -e, --editable <path/url> Install a project in editable mode (i.e. setuptools "develop mode") from a local project path or a VCS url.
Install a particular source archive file. $ pip install ./downloads/SomePackage-1.0.4.tar.gz $ pip install http:
import pip def install(package): pip.main(["install", "--upgrade", "--no-index", "--find-links=.", package]) if __name__ == "__main__": install("mypackagename") raw_input("Press Enter to Exit...\n")
import pip def uninstall(package): response = raw_input("Uninstall if "y" in response.lower(): pip.main(["uninstall", package]) pass if __name__ == "__main__": uninstall("mypackagename") raw_input("Press Enter to Exit...\n")
. └───requirements.txt └───requirements ├───foo_bar-0.1.5-py2.py3-none-any.whl ├───foo_bar-0.1.6-py2.py3-none-any.whl ├───wiz_bang-0.7-py2.py3-none-any.whl ├───wiz_bang-0.8-py2.py3-none-any.whl ├───base.txt ├───local.txt └───production.txt
PyJWT==1.6.4 email_validator==1.0.3 git+https: git+file:
print("Total score for {} is {}".format(name, score))
print("Total score for {0} is {1}".format(name, score))
print("Total score for {n} is {s}".format(n=name, s=score))
print("Total score for " + str(name) + " is " + str(score))
print("Total score for ", name, " is ", score, sep=
a = 10 b = 20 c = a + b print("sum of", a , "and" , b , "is" , c) print("sum of " + str(a) + " and " + str(b) + " is " + str(c)) print("Sum of %s and %s is %s: " %(a,b,c)) print("sum of {} and {} is {}".format(a,b,c)) print("sum of " + repr(a) + " and " + repr(b) + " is " + repr(c)) EDIT : print(f
print("Total score for %s is %s. " % (name, score))
print("Total score for " + name + " is " + str(score))
print("Total score for {0} is {1}".format(name, score))
print("Total score for {n} is {s}".format(n=name, s=score))
idiot_type = "the biggest idiot" year = 22 print("I have been {} for {} years ".format(idiot_type, years))
idiot_type = "the biggest idiot" year = 22 print("I have been %s for %s years."% (idiot_type, year))
print("Total score for {} is {}".format(name, score))
def slugify(value): import unicodedata value = unicodedata.normalize( value = unicode(re.sub( value = unicode(re.sub(
>>> import string >>> valid_chars = "-_.() %s%s" % (string.ascii_letters, string.digits) >>> valid_chars >>> filename = "This Is a (valid) - filename%$&$ .txt" >>>
import base64 file_name_string = base64.urlsafe_b64encode(your_string)
>>> from slugify import slugify >>> txt = "This\ is/ a% >>> slugify(txt)
import unicodedata validFilenameChars = "-_.() %s%s" % (string.ascii_letters, string.digits) def removeDisallowedFilenameChars(filename): cleanedFilename = unicodedata.normalize( return
def get_valid_filename(s): s = str(s).strip().replace( return re.sub(r
import re str = "File!name?.txt" f = open(os.path.join("/tmp", re.sub(
>>> import string >>> safechars = bytearray(( >>> allchars = bytearray(range(0x100)) >>> deletechars = bytearray(set(allchars) - set(safechars)) >>> filename = u >>> safe_filename = filename.encode( >>> safe_filename
import re badchars= re.compile(r badnames= re.compile(r def makeName(s): name= badchars.sub( if badnames.match(name): name= return name
s = clean_basename = slugify(os.path.splitext(s)[0]) clean_extension = slugify(os.path.splitext(s)[1][1:]) if clean_extension: clean_filename = elif clean_basename: clean_filename = clean_basename else: clean_filename =
def safePath (url): return safePath.chars = set(map(lambda x: ord(x),
import string for chr in your_string: if chr == your_string = your_string.replace( elif chr not in string.ascii_letters or chr not in string.digits: your_string = your_string.replace(chr,
import re t = re.compile("[a-zA-Z0-9.,_-]") unsafe = "abc∂éåß®∆˚˙©¬ñ√ƒµ©∆∫ø" safe = [ch for ch in unsafe if t.match(ch)]
from random import choice from string import ascii_lowercase, ascii_uppercase, digits allowed_chr = ascii_lowercase + ascii_uppercase + digits safe =
from mechanize import Browser br = Browser() br.open( html = br.response().readlines() for line in html: print line
from HTMLParser import HTMLParser class MLStripper(HTMLParser): def __init__(self): self.reset() self.fed = [] def handle_data(self, d): self.fed.append(d) def get_data(self): return def strip_tags(html): s = MLStripper() s.feed(html) return s.get_data()
from html.parser import HTMLParser class MLStripper(HTMLParser): def __init__(self): self.reset() self.strict = False self.convert_charrefs= True self.fed = [] def handle_data(self, d): self.fed.append(d) def get_data(self): return def strip_tags(html): s = MLStripper() s.feed(html) return s.get_data()
from bs4 import BeautifulSoup html_str = <td><a href="http: <br/><a href="http: </td> soup = BeautifulSoup(html_str) print(soup.get_text())
import re, cgi tag_re = re.compile(r no_tags = tag_re.sub( ready_for_web = cgi.escape(no_tags)
def strip_tags(value): while new_value = _strip_once(value) if len(new_value) >= len(value): break value = new_value return value
from HTMLParser import HTMLParser import htmlentitydefs class HTMLTextExtractor(HTMLParser): def __init__(self): HTMLParser.__init__(self) self.result = [ ] def handle_data(self, d): self.result.append(d) def handle_charref(self, number): codepoint = int(number[1:], 16) if number[0] in (u self.result.append(unichr(codepoint)) def handle_entityref(self, name): codepoint = htmlentitydefs.name2codepoint[name] self.result.append(unichr(codepoint)) def get_text(self): return u def html_to_text(html): s = HTMLTextExtractor() s.feed(html) return s.get_text()
import html.parser class HTMLTextExtractor(html.parser.HTMLParser): def __init__(self): super(HTMLTextExtractor, self).__init__() self.result = [ ] def handle_data(self, d): self.result.append(d) def get_text(self): return def html_to_text(html): """Converts HTML to plain text (stripping tags and converting entities). >>> html_to_text( "Plain text" doesn >>> html_to_text( Always use html.escape to sanitize text before using in an HTML context! HTMLParser will do its best to make sense of invalid HTML. >>> html_to_text( Unrecognized named entities are included as-is. despite being XML only. >>> html_to_text( "&nosuchentity; """ s = HTMLTextExtractor() s.feed(html) return s.get_text()
def remove_html_markup(s): tag = False quote = False out = "" for c in s: if c == tag = True elif c == tag = False elif (c == quote = not quote elif not tag: out = out + c return out
from HTMLParser import HTMLParser class MLStripper(HTMLParser): def __init__(self): self.reset() self.fed = [] def handle_data(self, d): self.fed.append(d) def handle_entityref(self, name): self.fed.append( def get_data(self): return def html_to_text(html): s = MLStripper() s.feed(html) return s.get_data()
from bs4 import BeautifulSoup def stripHtmlTags(htmlTxt): if htmlTxt is None: return None else: return
from bs4 import BeautifulSoup soup = BeautifulSoup(html) text = soup.get_text() print(text)
def __init__(self): super().__init__() self.reset() self.fed = []
from HTMLParser import HTMLParser class MLStripper(HTMLParser): def __init__(self): self.reset() self.fed = [] self.containstags = False def handle_starttag(self, tag, attrs): self.containstags = True def handle_data(self, d): self.fed.append(d) def has_tags(self): return self.containstags def get_data(self): return def strip_tags(html): must_filtered = True while ( must_filtered ): s = MLStripper() s.feed(html) html = s.get_data() must_filtered = s.has_tags() return html
import sys def replace(strng,replaceText): rpl = 0 while rpl > -1: rpl = strng.find(replaceText) if rpl != -1: strng = strng[0:rpl] + strng[rpl + len(replaceText):] return strng lessThanPos = -1 count = 0 listOf = [] try: writeto = open(sys.argv[2], f = open(sys.argv[1], for readLine in f.readlines(): listOf.append(readLine) f.close() for line in listOf: count = 0; lessThanPos = -1 lineTemp = line for char in lineTemp: if char == "<": lessThanPos = count if char == ">": if lessThanPos > -1: if line[lessThanPos:count + 1] != lineTemp = replace(lineTemp,line[lessThanPos:count + 1]) lessThanPos = -1 count = count + 1 lineTemp = lineTemp.replace("&lt","<") lineTemp = lineTemp.replace("&gt",">") writeto.write(lineTemp) writeto.close() print "Write To --- >" , sys.argv[2] except: print "Help: invalid arguments or exception" print "Usage : ",sys.argv[0]," inputfile outputfile"
from html.parser import HTMLParser from html.entities import html5 class HTMLTextExtractor(HTMLParser): """ Adaption of http: def __init__(self): super().__init__() self.result = [] def handle_data(self, d): self.result.append(d) def handle_charref(self, number): codepoint = int(number[1:], 16) if number[0] in (u self.result.append(unichr(codepoint)) def handle_entityref(self, name): if name in html5: self.result.append(unichr(html5[name])) def get_text(self): return u def html_to_text(html): s = HTMLTextExtractor() s.feed(html) return s.get_text()
class MLStripper(HTMLParser): def __init__(self): self.reset() self.strict = False self.convert_charrefs= True self.fed = [] self.css = False def handle_starttag(self, tag, attrs): if tag == "style" or tag=="script": self.css = True def handle_endtag(self, tag): if tag=="style" or tag=="script": self.css=False def handle_data(self, d): if not self.css: self.fed.append(d) def get_data(self): return def strip_tags(html): s = MLStripper() s.feed(html) return s.get_data()
def StripTags(text): finished = 0 while not finished: finished = 1 start = text.find("<") if start >= 0: stop = text[start:].find(">") if stop >= 0: text = text[:start] + text[start+stop+1:] finished = 0 return text
import re import lxml.html def strip_markdown(x): links_sub = re.sub(r bold_sub = re.sub(r emph_sub = re.sub(r return emph_sub def strip_html(x): return lxml.html.fromstring(x).text_content() if x else
readme = """<img src="https: sky is a web scraping framework, implemented with the latest python versions in mind (3.4+). It uses the asynchronous `asyncio` framework, as well as many popular modules and extensions. Most importantly, it aims for **next generation** web crawling where machine intelligence is used to speed up the development/maintainance/reliability of crawling. It mainly does this by considering the user to be interested in content from *domains*, not just a collection of *single pages* ([templating approach]( strip_markdown(strip_html(readme))
import re import html2text from bs4 import BeautifulSoup def html2Text(html): def removeMarkdown(text): for current in ["^[ markdown = re.compile(current, flags=re.MULTILINE) text = markdown.sub(" ", text) return text def removeAngular(text): angular = re.compile("[{][|].{2,40}[|][}]|[{][*].{2,40}[*][}]|[{][{].{2,40}[}][}]|\[\[.{2,40}\]\]") text = angular.sub(" ", text) return text h = html2text.HTML2Text() h.images_to_alt = True h.ignore_links = True h.ignore_emphasis = False h.skip_internal_links = True text = h.handle(html) soup = BeautifulSoup(text, "html.parser") text = soup.text text = removeAngular(text) text = removeMarkdown(text) return text
import re import htmlentitydefs def convertentity(m): if m.group(1)== try: return unichr(int(m.group(2))) except ValueError: return try: return htmlentitydefs.entitydefs[m.group(2)] except KeyError: return def converthtml(s): return re.sub(r html = converthtml(html) html.replace("&nbsp;", " ")
>>> my_dict = { >>> my_copy = my_dict.deepcopy() Traceback (most recent calll last): File "<stdin>", line 1, in <module> AttributeError: >>> my_copy = my_dict.copy() >>> my_dict[ >>> my_copy[ 7
Python 3.2 (r32:88445, Feb 20 2011, 21:30:00) [MSC v.1500 64 bit (AMD64)] on win32 Type "help", "copyright", "credits" or "license" for more information. >>> import copy >>> my_dict = { >>> my_copy = copy.deepcopy(my_dict) >>> my_dict[ >>> my_copy[ 3 >>>
In [1]: my_dict = { In [2]: my_copy = my_dict.copy() In [3]: id(my_dict) Out[3]: 140190444167808 In [4]: id(my_copy) Out[4]: 140190444170328 In [5]: id(my_copy[ Out[5]: 140190444024104 In [6]: id(my_dict[ Out[6]: 140190444024104
In [7]: my_copy = {key: value[:] for key, value in my_dict.items()} In [8]: id(my_copy[ Out[8]: 140190444024176
"RuntimeError: dictionary changed size during iteration"
import socket import xml.etree.ElementTree as ET from copy import deepcopy
def remove_hostname(domain, hostname): domain_copy = deepcopy(domain) for domains, hosts in domain_copy.items(): for host, port in hosts.items(): if host == hostname: del domain[domains][host] return domain
my_dict={ my_copy = {} my_copy.update( my_dict ) my_dict[ my_dict[ Out[34]: 2 my_copy[ Out[35]: 1
my_dict1={ my_dict2={ my_dict3={ my_copy = {} my_copy.update( my_dict3 ) my_dict1[ my_copy Out[42]: {
import copy my_copy2 = copy.deepcopy( my_dict3 ) my_dict1[ my_copy2 Out[46]: {
for line in StringIO.StringIO(inputString): doStuff()
try: import cStringIO StringIO = cStringIO except ImportError: import StringIO for line in StringIO.StringIO(variable_with_multiline_string): pass print line.strip()
text = text = text.splitlines() rows_to_print = {} for line in range(len(text)): if text[line][0] == rows_to_print = rows_to_print | {line, line + 1} rows_to_print = sorted(list(rows_to_print)) for i in rows_to_print: print(text[i])
>>> class Obj: ... def __str__(self): ... return ... >>> list = [Obj(), Obj(), Obj()] >>> Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: sequence item 0: expected string, instance found
class my_string(str): def join(self, l): l_tmp = [str(x) for x in l] return super(my_string, self).join(l_tmp)
class Obj: def __str__(self): return list = [Obj(), Obj(), Obj()] comma = my_string( print comma.join(list)
for k, v in mydict.iteritems(): if k == val: del mydict[k]
>>> mydict = { >>> for k, v in mydict.iteritems(): ... if k == ... del mydict[k] ... ------------------------------------------------------------ Traceback (most recent call last): File "<ipython console>", line 1, in <module> RuntimeError: dictionary changed size during iteration
>>> for k in mydict.keys(): ... if k == ... del mydict[k] ... >>> mydict {
>>> for k, v in mydict.items(): ... if v == 3: ... del mydict[k] ... >>> mydict {
remove = [k for k in mydict if k == val] for k in remove: del mydict[k]
mydict = { k:v for k,v in mydict.items() if k!=val } mydict = dict((k,v) for k,v in mydict.iteritems() if k!=val)
my_dic = { 1:10, 2:20, 3:30 } key_list = list( my_dic.keys() ) for k in key_list: print(key_list) print(my_dic) del( my_dic[k] ) print( my_dic )
dict = { delete = [] for k,v in dict.items(): if v%2 == 1: delete.append(k) for i in delete: del dict[i]
>>> mydict = { >>> for k in list(mydict): ... if k == ... del mydict[k] ... >>> mydict {
>>> mylist = [ >>> for k in list(mylist): ... if k == ... mylist.remove(k) ... >>> mylist [
tmpDict = realDict.copy() for key, value in tmpDict.items(): if value: del(realDict[key])
play = True while play: x = input("Enter a number: ") y = input("Enter a number: ") print(x + y) print(x - y) print(x * y) print(x / y) print(x % y) if input("Play again? ") == "no": play = False
>>> import sys >>> sys.version >>> data = input("Enter a number: ") Enter a number: 5 + 17 >>> data, type(data) (22, <type
>>> data = eval(raw_input("Enter a number: ")) Enter a number: 5 + 17 >>> data, type(data) (22, <type
>>> import sys >>> sys.version >>> data = raw_input("Enter a number: ") Enter a number: 5 + 17 >>> data, type(data) (
>>> import sys >>> sys.version >>> data = input("Enter a number: ") Enter a number: 5 + 17 >>> data, type(data) (
x = int(input("Enter a number: ")) y = int(input("Enter a number: "))
>>> data = int(input("Enter a number: "), 8) Enter a number: 777 >>> data 511 >>> data = int(input("Enter a number: "), 16) Enter a number: FFFF >>> data 65535 >>> data = int(input("Enter a number: "), 2) Enter a number: 10101010101 >>> data 1365
>>> data = int(input("Enter a number: "), 2) Enter a number: 1234 Traceback (most recent call last): File "<input>", line 1, in <module> ValueError: invalid literal for int() with base 2:
while True: ... ... if input("Play again? ") == "no": break
x = int(input("Enter a number: ")) y = int(input("Enter a number: "))
x = int(input("Enter a number: ")) y = int(input("Enter a number: "))
p=raw_input() p=p.split() for i in p: a.append(int(i))
my_decimalnumber = float(input("enter the number"))
x = int(input("Enter a number: ")) y = int(input("Enter a number: "))
x = int(raw_input("Enter a number: ")) y = int(input("Enter a number: "))
num = input() num1 = 0 num2 = 0 for i in range(len(num)): if num[i] == break num1 = int(num[:i]) num2 = int(num[i+1:])
def dbz(): try: r = raw_input("Enter number:") if r.isdigit(): i = int(raw_input("Enter divident:")) d = int(r)/i print "O/p is -:",d else: print "Not a number" except Exception ,e: print "Program halted incorrect data entered",type(e) dbz() Or num = input("Enter Number:")
n=int(input()) for i in range(n): n=input() n=int(n) arr1=list(map(int,input().split()))
play = True while play: x = int(input("Enter a number: ")) y = int(input("Enter a number: ")) print(x + y) print(x - y) print(x * y) print(x / y) print(x % y) if input("Play again? ") == "no": play = False
play = True while play: x = input("Enter a number: ") y = input("Enter a number: ") print(int(x) + int(y)) print(int(x) - int(y)) print(int(x) * int(y)) print(int(x) / int(y)) print(int(x) % int(y)) if input("Play again? ") == "no": play = False
x = int(input("Enter a number: ")) y = int(input("Enter a number: ")
import tkinter tk = tkinter.Tk() tk.geometry("400x300+500+300") l = Label(tk,text="") l.pack() e = Entry(tk) e.pack() def click(): e[ b = Button(tk,text="Click me",command=click) b.pack() tk.mainloop()
from distutils.core import setup import py2exe setup(console=[
import sys if sys.version_info[0] >= 3: import PySimpleGUI as sg else: import PySimpleGUI27 as sg layout = [[ sg.Text( [ sg.Button( window = sg.Window( button, value = window.Read()
from appJar import gui num=1 def myfcn(btnName): global num num +=1 win.setLabel("mylabel", num) win = gui( win.addButtons(["Set"], [myfcn]) win.addLabel("mylabel", "Press the Button") win.go()
In file included from src/lxml/lxml.etree.c:314: /private/tmp/pip_build_root/lxml/src/lxml/includes/etree_defs.h:9:10: fatal error: ^ 1 error generated. error: command
brew install libxml2 brew install libxslt brew link libxml2 --force brew link libxslt --force
sudo CPATH=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2 CFLAGS=-Qunused-arguments CPPFLAGS=-Qunused-arguments pip install lxml
sudo ln -s /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2/libxml/ /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml
xcode-select --install sudo easy_install pip sudo CPATH=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2 CFLAGS=-Qunused-arguments CPPFLAGS=-Qunused-arguments pip install lxml
export CFLAGS=-Qunused-arguments export CPPFLAGS=-Qunused-arguments pip install lxml
xcode-select --install sudo easy_install pip sudo pip install lxml
LDFLAGS=-L`brew --prefix libxml2`/lib CPPFLAGS=-I`brew --prefix libxml2`/include/libxml2 pip install --user lxml
env LDFLAGS=-L(brew --prefix libxml2)/lib CPPFLAGS=-I(brew --prefix libxml2)/include/libxml2 pip install --user lxml
sudo env ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future STATIC_DEPS=true pip install lxml
$ STATIC_DEPS=true sudo easy_install-2.7 "lxml==2.3.5"
$ CPATH=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2 pip install lxml
$ set INCLUDE=$INCLUDE:/private/tmp/pip_build_root/lxml/src/lxml/
D:\Anaconda\Scripts\pip-script.py run on 02/27/14 16:13:17 Downloading/unpacking cryptography Getting page https: URLs to search for versions for cryptography: * https: Analyzing links from page https: Skipping https: Skipping https: Skipping https: Skipping https: Skipping https: Skipping https: Skipping https: Skipping https: Found link https: Found link https: Found link https: Using version 0.2.1 (newest of versions: 0.2.1, 0.2, 0.1) Downloading from URL https: Running setup.py (path:c:\users\paco\appdata\local\temp\pip_build_Paco\cryptography\setup.py) egg_info for package cryptography In file included from c/_cffi_backend.c:7:0: c/misc_win32.h:225:23: error: two or more data types in declaration specifiers c/misc_win32.h:225:1: warning: useless type name in empty declaration [enabled by default] c/_cffi_backend.c: In function c/_cffi_backend.c:1105:26: warning: unknown conversion type character c/_cffi_backend.c:1105:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1130:30: warning: unknown conversion type character c/_cffi_backend.c:1130:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1150:30: warning: unknown conversion type character c/_cffi_backend.c:1150:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1183:26: warning: unknown conversion type character c/_cffi_backend.c:1183:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1196:30: warning: unknown conversion type character c/_cffi_backend.c:1196:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1583:13: warning: unknown conversion type character c/_cffi_backend.c:1583:13: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1595:9: warning: unknown conversion type character c/_cffi_backend.c:1595:9: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1647:30: warning: unknown conversion type character c/_cffi_backend.c:1647:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1820:26: warning: unknown conversion type character c/_cffi_backend.c:1820:26: warning: unknown conversion type character c/_cffi_backend.c:1820:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1872:26: warning: unknown conversion type character c/_cffi_backend.c:1872:26: warning: unknown conversion type character c/_cffi_backend.c:1872:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1951:26: warning: unknown conversion type character c/_cffi_backend.c:1951:26: warning: unknown conversion type character c/_cffi_backend.c:1951:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1969:30: warning: unknown conversion type character c/_cffi_backend.c:1969:30: warning: unknown conversion type character c/_cffi_backend.c:1969:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1983:22: warning: unknown conversion type character c/_cffi_backend.c:1983:22: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:2367:30: warning: unknown conversion type character c/_cffi_backend.c:2367:30: warning: format c/_cffi_backend.c:2367:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:2916:26: warning: unknown conversion type character c/_cffi_backend.c:2916:26: warning: format c/_cffi_backend.c:2916:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:2928:26: warning: unknown conversion type character c/_cffi_backend.c:2928:26: warning: format c/_cffi_backend.c:2928:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:3480:9: warning: unknown conversion type character c/_cffi_backend.c:3480:9: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:3878:22: warning: unknown conversion type character c/_cffi_backend.c:3878:22: warning: unknown conversion type character c/_cffi_backend.c:3878:22: warning: too many arguments for format [-Wformat-extra-args] Traceback (most recent call last): File "<string>", line 17, in <module> File "c:\users\paco\appdata\local\temp\pip_build_Paco\cryptography\setup.py", line 113, in <module> "build": cffi_build, File "D:\Anaconda\lib\distutils\core.py", line 112, in setup _setup_distribution = dist = klass(attrs) File "build\bdist.win-amd64\egg\setuptools\dist.py", line 239, in __init__ File "build\bdist.win-amd64\egg\setuptools\dist.py", line 264, in fetch_build_eggs File "build\bdist.win-amd64\egg\pkg_resources.py", line 580, in resolve dist = best[req.key] = env.best_match(req, ws, installer) File "build\bdist.win-amd64\egg\pkg_resources.py", line 818, in best_match return self.obtain(req, installer) File "build\bdist.win-amd64\egg\pkg_resources.py", line 830, in obtain return installer(requirement) File "build\bdist.win-amd64\egg\setuptools\dist.py", line 314, in fetch_build_egg File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 593, in easy_install File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 623, in install_item File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 809, in install_eggs File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 1015, in build_and_install File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 1003, in run_setup distutils.errors.DistutilsError: Setup script exited with error: command Complete output from command python setup.py egg_info: In file included from c/_cffi_backend.c:7:0: c/misc_win32.h:225:23: error: two or more data types in declaration specifiers c/misc_win32.h:225:1: warning: useless type name in empty declaration [enabled by default] c/_cffi_backend.c: In function c/_cffi_backend.c:1105:26: warning: unknown conversion type character c/_cffi_backend.c:1105:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1130:30: warning: unknown conversion type character c/_cffi_backend.c:1130:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1150:30: warning: unknown conversion type character c/_cffi_backend.c:1150:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1183:26: warning: unknown conversion type character c/_cffi_backend.c:1183:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1196:30: warning: unknown conversion type character c/_cffi_backend.c:1196:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1583:13: warning: unknown conversion type character c/_cffi_backend.c:1583:13: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1595:9: warning: unknown conversion type character c/_cffi_backend.c:1595:9: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1647:30: warning: unknown conversion type character c/_cffi_backend.c:1647:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1820:26: warning: unknown conversion type character c/_cffi_backend.c:1820:26: warning: unknown conversion type character c/_cffi_backend.c:1820:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1872:26: warning: unknown conversion type character c/_cffi_backend.c:1872:26: warning: unknown conversion type character c/_cffi_backend.c:1872:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:1951:26: warning: unknown conversion type character c/_cffi_backend.c:1951:26: warning: unknown conversion type character c/_cffi_backend.c:1951:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1969:30: warning: unknown conversion type character c/_cffi_backend.c:1969:30: warning: unknown conversion type character c/_cffi_backend.c:1969:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:1983:22: warning: unknown conversion type character c/_cffi_backend.c:1983:22: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:2367:30: warning: unknown conversion type character c/_cffi_backend.c:2367:30: warning: format c/_cffi_backend.c:2367:30: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:2916:26: warning: unknown conversion type character c/_cffi_backend.c:2916:26: warning: format c/_cffi_backend.c:2916:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c:2928:26: warning: unknown conversion type character c/_cffi_backend.c:2928:26: warning: format c/_cffi_backend.c:2928:26: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:3480:9: warning: unknown conversion type character c/_cffi_backend.c:3480:9: warning: too many arguments for format [-Wformat-extra-args] c/_cffi_backend.c: In function c/_cffi_backend.c:3878:22: warning: unknown conversion type character c/_cffi_backend.c:3878:22: warning: unknown conversion type character c/_cffi_backend.c:3878:22: warning: too many arguments for format [-Wformat-extra-args] Traceback (most recent call last): File "<string>", line 17, in <module> File "c:\users\paco\appdata\local\temp\pip_build_Paco\cryptography\setup.py", line 113, in <module> "build": cffi_build, File "D:\Anaconda\lib\distutils\core.py", line 112, in setup _setup_distribution = dist = klass(attrs) File "build\bdist.win-amd64\egg\setuptools\dist.py", line 239, in __init__ File "build\bdist.win-amd64\egg\setuptools\dist.py", line 264, in fetch_build_eggs File "build\bdist.win-amd64\egg\pkg_resources.py", line 580, in resolve dist = best[req.key] = env.best_match(req, ws, installer) File "build\bdist.win-amd64\egg\pkg_resources.py", line 818, in best_match return self.obtain(req, installer) File "build\bdist.win-amd64\egg\pkg_resources.py", line 830, in obtain return installer(requirement) File "build\bdist.win-amd64\egg\setuptools\dist.py", line 314, in fetch_build_egg File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 593, in easy_install File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 623, in install_item File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 809, in install_eggs File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 1015, in build_and_install File "build\bdist.win-amd64\egg\setuptools\command\easy_install.py", line 1003, in run_setup distutils.errors.DistutilsError: Setup script exited with error: command ---------------------------------------- Cleaning up... Removing temporary dir c:\users\paco\appdata\local\temp\pip_build_Paco... Command python setup.py egg_info failed with error code 1 in c:\users\paco\appdata\local\temp\pip_build_Paco\cryptography Exception information: Traceback (most recent call last): File "D:\Anaconda\lib\site-packages\pip-1.5.4-py2.7.egg\pip\basecommand.py", line 122, in main status = self.run(options, args) File "D:\Anaconda\lib\site-packages\pip-1.5.4-py2.7.egg\pip\commands\install.py", line 278, in run requirement_set.prepare_files(finder, force_root_egg_info=self.bundle, bundle=self.bundle) File "D:\Anaconda\lib\site-packages\pip-1.5.4-py2.7.egg\pip\req.py", line 1229, in prepare_files req_to_install.run_egg_info() File "D:\Anaconda\lib\site-packages\pip-1.5.4-py2.7.egg\pip\req.py", line 325, in run_egg_info command_desc= File "D:\Anaconda\lib\site-packages\pip-1.5.4-py2.7.egg\pip\util.py", line 697, in call_subprocess % (command_desc, proc.returncode, cwd)) InstallationError: Command python setup.py egg_info failed with error code 1 in c:\users\paco\appdata\local\temp\pip_build_Paco\cryptography
C:\> \path\to\vcvarsall.bat x86_amd64 C:\> set LIB=C:\OpenSSL-1.0.1f-64bit\lib;%LIB% C:\> set INCLUDE=C:\OpenSSL-1.0.1f-64bit\include;%INCLUDE% C:\> pip install cryptography
sudo apt-get install build-essential libssl-dev libffi-dev python-dev
sudo yum install gcc libffi-devel python-devel openssl-devel
brew install openssl env ARCHFLAGS="-arch x86_64" LDFLAGS="-L/usr/local/opt/openssl/lib" CFLAGS="-I/usr/local/opt/openssl/include" pip install cryptography
brew install openssl env ARCHFLAGS="-arch x86_64" LDFLAGS="-L/usr/local/opt/openssl/lib" CFLAGS="-I/usr/local/opt/openssl/include" pip install cryptography
brew install pkg-config libffi openssl env LDFLAGS="-L$(brew --prefix openssl)/lib" CFLAGS="-I$(brew --prefix openssl)/include" pip install cryptography
sudo apt-get install build-essential libssl-dev libffi-dev python-dev python3-dev
pip install cryptography pip install pyopenssl ndg-httpsclient pyasn1
pip install --upgrade --force-reinstall pip virtualenv
(...) ---------------------------------------- Failed cleaning build dir for cryptography Failed to build cryptography (...) ---------------------------------------- Command "/home/myuser/pyenvs/testo/bin/python -u -c "import setuptools, tokenize;__file__=
Reading package lists... Done Building dependency tree Reading state information... Done Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming. The following information may help to resolve the situation: The following packages have unmet dependencies: build-essential : Depends: libc6-dev but it is not going to be installed > or libc-dev Depends: gcc (>= 4:4.4.3) but it is not going to be installed Depends: g++ (>= 4:4.4.3) but it is not going to be installed E: Unable to correct problems, you have held broken packages.
sudo apt-get install libffi-dev libssl-dev libpython2.7-dev
pip install cryptography pip install pyopenssl ndg-httpsclient pyasn1
brew install openssl CFLAGS="-I/usr/local/opt/openssl/include" pip install cryptography==0.8
$ brew install pkg-config libffi $ export PKG_CONFIG_PATH=/usr/local/Cellar/libffi/3.0.13/lib/pkgconfig/ $ pip install cryptography
$ sudo port install openssl $ env LDFLAGS="-L/opt/local/lib" CFLAGS="-I/opt/local/include" pip install cryptography
cd C:\Python27\Scripts pip install cryptography (or pycrypto, fabric, etc)
C:\> "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\vcvarsall.bat" x86_amd64 C:\> set LIB=C:\OpenSSL-Win64\lib;%LIB% C:\> set INCLUDE=C:\OpenSSL-Win64\include;%INCLUDE% C:\> pip install cryptography
pip install cryptography . . . Installing collected packages: cffi, cryptography Running setup.py install for cffi ... error
def read_in_chunks(file_object, chunk_size=1024): """Lazy function (generator) to read a file piece by piece. Default chunk size: 1k.""" while True: data = file_object.read(chunk_size) if not data: break yield data f = open( for piece in read_in_chunks(f): process_data(piece)
f = open( def read1k(): return f.read(1024) for piece in iter(read1k, process_data(piece)
import mmap with open("hello.txt", "r+") as f: map = mmap.mmap(f.fileno(), 0) print map.readline() print map[:5] map[6:] = " world!\n" map.seek(0) print map.readline() map.close()
bigfile = open( tmp_lines = bigfile.readlines(BUF_SIZE) while tmp_lines: process([line for line in tmp_lines]) tmp_lines = bigfile.readlines(BUF_SIZE)
def rows(f, chunksize=1024, sep= """ Read a file where the row separator is Usage: >>> with open( >>> for r in rows(f): >>> process(row) """ incomplete_row = None while True: chunk = f.read(chunksize) if not chunk: if incomplete_row is not None: yield incomplete_row break while True: i = chunk.find(sep) if i == -1: break if incomplete_row is not None: yield incomplete_row + chunk[:i] incomplete_row = None else: yield chunk[:i] chunk = chunk[i+1:] if incomplete_row is not None: incomplete_row += chunk else: incomplete_row = chunk
f = ... def chunked(file, chunk_size): return iter(lambda: file.read(chunk_size), for data in chunked(f, 65536):
def read_file(path, block_size=1024): with open(path, while True: piece = f.read(block_size) if piece: yield piece else: return for piece in read_file(path): process_piece(piece)
def get_line(): with open( for i in file: yield i lines_required = 100 gen = get_line() chunk = [i for i, j in zip(gen, range(lines_required))]
def stream_lines(file_name): file = open(file_name) while True: line = file.readline() if not line: file.close() break yield line
file_size = os.stat( for i in range( file_size/1024): print file_obj.read(1024)
$ python my_program_dir $ python my_program.zip $ python -m my_program
$ mkdir demo $ cat > demo/__init__.py << EOF print( def main(): print( EOF $ cat > demo/__main__.py << EOF print( from __init__ import main main() EOF
$ python demo demo/__main__.py executed demo/__init__.py executed main executed
$ python -m zipfile -c demo.zip demo/* $ python demo.zip demo/__main__.py executed demo/__init__.py executed main() executed
import sys if sys.version_info < (2, 4): raise "must use python 2.5 or greater" else: x = 1 if True else 2 print x
$ ~/bin/python2.4 tern.py must use python 2.5 or greater
$ ~/bin/python2.4 tern.py File "tern.py", line 5 x = 1 if True else 2 ^ SyntaxError: invalid syntax
try: eval("1 if True else 2") except SyntaxError: raise ImportError("requires ternary support") from impl import *
import sys req_version = (2,5) cur_version = sys.version_info if cur_version >= req_version: import myApp myApp.run() else: print "Your Python interpreter is too old. Please consider upgrading."
import sys if sys.hexversion < 0x02060000: print "yep!" else: print "oops!"
import sys python_version = sys.version_info.major if python_version == 3: print("is python 3") else: print("not python 3")
import platform print(platform.python_version()) print(platform.python_version_tuple())
try: eval("1 if True else 2") except SyntaxError: raise ImportError("requires ternary support")
if sys.version_info < (2, 4): from sets import Set as set
@ECHO OFF REM see http: FOR /F "tokens=1,2" %%G IN ( IF NOT ErrorLevel 1 GOTO Python27 ECHO must use python2.7 or greater GOTO EOF :Python27 python.exe tern.py GOTO EOF :EOF
import sys if sys.hexversion < 0x02060000: from my_module_2_5 import thisFunc, thatFunc, theOtherFunc else: from my_module import thisFunc, thatFunc, theOtherFunc
import sys if float(sys.version.split()[0][:3]) < 2.7: print "Python 2.7 or higher required to run this code, " + sys.version.split()[0] + " detected, exiting." exit(1)
import sys, subprocess args = [sys.executable,"--version"] output, error = subprocess.Popen(args ,stdout = subprocess.PIPE, stderr = subprocess.PIPE).communicate() print("The version is:
import sys, time if sys.hexversion < 0x30600F0: print("You need Python 3.6 or greater.") for _ in range(1, 5): time.sleep(1) exit()
import sys, time if sys.version_info[0] < 3 and sys.version_info[1] < 6: print("You need Python 3.6 or greater.") for _ in range(1, 5): time.sleep(1) exit()
import sys def testPyVer(reqver): if float(sys.version[:3]) >= reqver: return 1 else: return 0 if testPyVer(3.0) == 1: else:
import datetime a = datetime.datetime.today() numdays = 100 dateList = [] for x in range (0, numdays): dateList.append(a - datetime.timedelta(days = x)) print dateList
base = datetime.datetime.today() date_list = [base - datetime.timedelta(days=x) for x in range(0, numdays)]
import pandas as pd datelist = pd.date_range(pd.datetime.today(), periods=100).tolist()
import datetime start = datetime.datetime.strptime("21-06-2014", "%d-%m-%Y") end = datetime.datetime.strptime("07-07-2014", "%d-%m-%Y") date_generated = [start + datetime.timedelta(days=x) for x in range(0, (end-start).days)] for date in date_generated: print date.strftime("%d-%m-%Y")
import datetime def date_generator(): from_date = datetime.datetime.today() while True: yield from_date from_date = from_date - datetime.timedelta(days=1)
>>> import itertools >>> dates = itertools.islice(date_generator(), 3) >>> list(dates) [datetime.datetime(2009, 6, 14, 19, 12, 21, 703890), datetime.datetime(2009, 6, 13, 19, 12, 21, 703890), datetime.datetime(2009, 6, 12, 19, 12, 21, 703890)]
date_generator = (datetime.datetime.today() - datetime.timedelta(days=i) for i in itertools.count())
>>> dates = itertools.islice(date_generator, 3) >>> list(dates) [datetime.datetime(2009, 6, 15, 1, 32, 37, 286765), datetime.datetime(2009, 6, 14, 1, 32, 37, 286836), datetime.datetime(2009, 6, 13, 1, 32, 37, 286859)]
def date_range(start_date, end_date): for ordinal in range(start_date.toordinal(), end_date.toordinal()): yield datetime.date.fromordinal(ordinal)
date_range = [ datetime.date.fromordinal(ordinal) for ordinal in range( start_date.toordinal(), end_date.toordinal(), ) ]
from dateutil import rrule from datetime import datetime list(rrule.rrule(rrule.DAILY,count=100,dtstart=datetime.now()))
import datetime start_date = datetime.date(2011, 01, 01) end_date = datetime.date(2014, 01, 01) dates_2011_2013 = [ start_date + datetime.timedelta(n) for n in range(int ((end_date - start_date).days))]
from __builtin__ import range as _range from datetime import datetime, timedelta def range(*args): if len(args) != 3: return _range(*args) start, stop, step = args if start < stop: cmp = lambda a, b: a < b inc = lambda a: a + step else: cmp = lambda a, b: a > b inc = lambda a: a - step output = [start] while cmp(start, stop): start = inc(start) output.append(start) return output print range(datetime(2011, 5, 1), datetime(2011, 10, 1), timedelta(days=30))
import datetime from time import mktime def convert_date_to_datetime(date_object): date_tuple = date_object.timetuple() date_timestamp = mktime(date_tuple) return datetime.datetime.fromtimestamp(date_timestamp) def date_range(how_many=7): for x in range(0, how_many): some_date = datetime.datetime.today() - datetime.timedelta(days=x) some_datetime = convert_date_to_datetime(some_date.date()) yield some_datetime def pick_two_dates(how_many=7): a = b = convert_date_to_datetime(datetime.datetime.now().date()) for each_date in date_range(how_many): b = a a = each_date if a == b: continue yield b, a
start = datetime.datetime(2017,1,1) end = datetime.datetime.today() daterange = [start + datetime.timedelta(days=x) for x in range(0, (end-start).days)]
from matplotlib.dates import drange import datetime base = datetime.date.today() end = base + datetime.timedelta(days=100) delta = datetime.timedelta(days=1) l = drange(base, end, delta)
from dateutil import rrule, parser date1 = date2 = datesx = list(rrule.rrule(rrule.DAILY, dtstart=parser.parse(date1), until=parser.parse(date2)))
import datetime; print [(datetime.date.today() - datetime.timedelta(days=x)).strftime(
import numpy as np import datetime as dt listOfDates=[date for date in np.arange(firstDate,lastDate,dt.timedelta(days=x))]
from datetime import datetime, timedelta from dateutil import parser def getDateRange(begin, end): beginDate = parser.parse(begin) endDate = parser.parse(end) delta = endDate-beginDate numdays = delta.days + 1 dayList = [datetime.strftime(beginDate + timedelta(days=x), return dayList
import datetime as dt from dateutil.relativedelta import relativedelta def month_range(start_date, n_months): for m in range(n_months): yield start_date + relativedelta(months=+m)
import datetime def date_generator(): cur = base = datetime.date.today() end = base + datetime.timedelta(days=100) delta = datetime.timedelta(days=1) while(end>base): base = base+delta print base date_generator()
pip install --proxy DOMAIN\user:password@proxyaddress:port package
pip install --proxy BR\neo:p4ssw0rd@myproxyrocks.com.br:8080 virtualenv
pip install --proxy="user:password@proxy_ip:port" package_name
chris@green:~$ sudo http_proxy=http: Downloading/unpacking django==1.8.8 Cannot fetch index base URL http: Could not find any downloads that satisfy the requirement django==1.8.8 No distributions at all found for django==1.8.8 Storing complete log in /home/chris/.pip/pip.log
chris@green:~$ sudo http_proxy=http: Downloading/unpacking django==1.8.8 Downloading Django-1.8.8.tar.gz (7.3Mb): 7.3Mb downloaded Running setup.py egg_info for package django warning: no previously-included files matching warning: no previously-included files matching Installing collected packages: django Running setup.py install for django warning: no previously-included files matching warning: no previously-included files matching changing mode of build/scripts-2.7/django-admin.py from 644 to 755 changing mode of /usr/local/bin/django-admin.py to 755 Installing django-admin script to /usr/local/bin Successfully installed django Cleaning up...
C:\mysql-connector-python-2.0.3>python.exe setup.py install
import numpy as np def strange(S, T, U, V): d = 0 print min(np.abs(S[d]), np.abs(T[d]), U[d], V[d])
>>> s = >>> casesensitive = re.compile( >>> ignorecase = re.compile( >>> >>> print casesensitive.match(s) None >>> print ignorecase.match(s) <_sre.SRE_Match object at 0x02F0B608>
>>> s = r >>> print (re.match(s, r <_sre.SRE_Match object; span=(0, 4), match= >>> pattern = re.compile(s, re.I) >>> print(pattern.match(r <_sre.SRE_Match object; span=(0, 4), match=
x = 0 def outer(): x = 1 def inner(): x = 2 print("inner:", x) inner() print("outer:", x) outer() print("global:", x)
x = 0 def outer(): x = 1 def inner(): nonlocal x x = 2 print("inner:", x) inner() print("outer:", x) outer() print("global:", x)
x = 0 def outer(): x = 1 def inner(): global x x = 2 print("inner:", x) inner() print("outer:", x) outer() print("global:", x)
def make_counter(): count = 0 def counter(): nonlocal count count += 1 return count return counter
def counter_generator(): count = 0 while True: count += 1 yield count
nonlocal_stmt ::= "nonlocal" identifier ("," identifier)*
a = 0 def f(): a = 0 def g(): nonlocal a a=a+1 print("The value of def h(): global a a=a+5 print("The value of a using global is ", a) def i(): a = 0 print("The value of g() h() i() print("The value of f() print("The value of
a = 10 def Outer(msg): a = 20 b = 30 def Inner(): c = 50 d = 60 print("MU LCL =",locals()) nonlocal a a = 100 ans = a+c print("Hello from Inner",ans) print("value of a Inner : ",a) Inner() print("value of a Outer : ",a) res = Outer("Hello World") print(res) print("value of a Global : ",a)
def outer(): def inner(): def innermost(): nonlocal x x = 3 x = 2 innermost() if x == 3: print( x = 1 inner() if x == 3: print( x = 0 outer() if x == 3: print(
def outer(): def inner(): def innermost(): nonlocal x x = 3 innermost() x = 1 inner() if x == 3: print( x = 0 outer() if x == 3: print(
def outer(): def inner(): def innermost(): nonlocal x x = 3 innermost() inner() x = 0 outer() if x == 3: print(
>>> class StackList(list): ... def push(self, item): ... self.append(item) ... >>> x = StackList([1,2,3]) >>> x [1, 2, 3] >>> x.push(4) >>> x [1, 2, 3, 4]
function add_nulls($int, $cnt=2) { $int = intval($int); for($i=0; $i<($cnt-strlen($int)); $i++) $nulls .= return $nulls.$int; }
add_nulls = lambda number, zero_count : "{0:0{1}d}".format(number, zero_count) >>>add_nulls(2,3)
str_output = print(str_output) str_output = print(str_output) int_inputArg = 22 int_desiredLength = 5 str_output = print(str_output)
def add_nulls2(int, cnt): nulls = str(int) for i in range(cnt - len(str(int))): nulls = return nulls
def add_nulls(num, cnt=2): cnt = cnt - len(str(num)) nulls = return
import datetime t = datetime.datetime(2012, 2, 23, 0, 0) t.strftime(
import datetime now=datetime.datetime.now() now.isoformat()
>>> dt = datetime.datetime(2012, 2, 23, 0, 0) >>> >>>
t = datetime.datetime(2012, 2, 23, 0, 0) "{:%m/%d/%Y}".format(t)
from datetime import date myDate = date.today() dateStr = str(myDate.month)+ "/" + str(myDate.day) + "/" + str(myDate.year) print(dateStr)
import subprocess text = print text subprocess.call([
import os import subprocess FNULL = open(os.devnull, retcode = subprocess.call([
from subprocess import Popen, PIPE, STDOUT try: from subprocess import DEVNULL except ImportError: import os DEVNULL = open(os.devnull, text = u"René Descartes" p = Popen([ p.communicate(text.encode( assert p.returncode == 0
import subprocess try: subprocess.check_output([ except subprocess.CalledProcessError:
subprocess.check_output(["espeak", text], stderr=subprocess.STDOUT)
import os import subprocess with open(os.devnull, try: subprocess._check_call([ except subprocess.CalledProcessError:
import subprocess text = print text subprocess.call([
import commands text = "Mario Balotelli" output = print text a = commands.getoutput(output)
>>> def f(x=2): ... print(str(x)) ... >>> new_x = { >>> f() 2 >>> f(x=3) 3 >>> f(**new_x) 4
>>> def range1(start, end): ... return range(start, end+1) ... >>> range1(1, 10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
class PersonAdmin(admin.ModelAdmin): list_display = [
class UserAdmin(admin.ModelAdmin): list_display = (..., def get_author(self, obj): return obj.book.author get_author.short_description = get_author.admin_order_field =
class Author(models.Model): name = models.CharField(max_length=255) class Book(models.Model): author = models.ForeignKey(Author) title = models.CharField(max_length=255)
class BookAdmin(admin.ModelAdmin): model = Book list_display = [ admin.site.register(Book, BookAdmin)
class BookAdmin(admin.ModelAdmin): model = Book list_display = [ def get_name(self, obj): return obj.author.name get_name.admin_order_field = get_name.short_description = admin.site.register(Book, BookAdmin)
def author(self): return self.book.author author.admin_order_field =
def get_queryset(self, request): return super(PersonAdmin,self).get_queryset(request).select_related(
class PersonAdmin(RelatedFieldAdmin): list_display = [
class Category(models.Model): name = models.CharField(max_length=50) def __unicode__(self): return self.name
class AddInline(admin.TabularInline): readonly_fields = [ model = MyModel fields = (
class MyModel(models.Model): localization = models.ForeignKey(Localizations) def localname(self): return self.localization.name
class DynamicLookupMixin(object): a mixin to add dynamic callable attributes like return a function that return the instance.book.author value def __getattr__(self, attr): if ( and not attr.startswith( and not attr.endswith( and not attr.endswith( def dyn_lookup(instance): return reduce(lambda parent, child: getattr(parent, child), attr.split( instance) dyn_lookup.admin_order_field = attr dyn_lookup.boolean = getattr(self, dyn_lookup.short_description = getattr( self, attr.replace( return dyn_lookup return self.__getattribute__(attr) @admin.register(models.Person) class PersonAdmin(admin.ModelAdmin, DynamicLookupMixin): list_display = [ book__publisher__country_short_description = @admin.register(models.Product) class ProductAdmin(admin.ModelAdmin, DynamicLookupMixin): list_display = ( category__is_new_boolean = True
class PersonAdmin(RelatedFieldAdmin): list_display = [
class CoolAdmin(admin.ModelAdmin): list_display = ( @staticmethod def submodel__field(obj): return obj.submodel.field
/usr/local/lib/python2.7/dist-packages/requests/packages/urllib3 /util/ssl_.py:79: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. For more information, see https: /security.html
import requests.packages.urllib3 requests.packages.urllib3.disable_warnings()
import requests.packages.urllib3 requests.packages.urllib3.disable_warnings()
class Session(SessionRedirectMixin): ...... def request(self, method, url, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, allow_redirects=True, proxies=None, hooks=None, stream=None, verify=None, cert=None): """ ... :param verify: (optional) if True, the SSL cert will be verified. A CA_BUNDLE path can also be provided. ... """
$ sudo pip install --trusted-host pypi.python.org <module_name>
sudo apt-get install libpython-dev libssl-dev libffi-dev
sudo pip install -U pip sudo pip install -U pyopenssl ndg-httpsclient pyasn1
sudo apt-get remove --purge libpython-dev libssl-dev libffi-dev sudo apt-get autoremove
import requests import urllib3 urllib3.disable_warnings()
import requests requests.packages.urllib3.disable_warnings()
5 7 * * * /usr/local/bin/certbot-auto renew --quiet --no-self-upgrade
import smtplib from os.path import basename from email.mime.application import MIMEApplication from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.utils import COMMASPACE, formatdate def send_mail(send_from, send_to, subject, text, files=None, server="127.0.0.1"): assert isinstance(send_to, list) msg = MIMEMultipart() msg[ msg[ msg[ msg[ msg.attach(MIMEText(text)) for f in files or []: with open(f, "rb") as fil: part = MIMEApplication( fil.read(), Name=basename(f) ) part[ msg.attach(part) smtp = smtplib.SMTP(server) smtp.sendmail(send_from, send_to, msg.as_string()) smtp.close()
import smtplib from email.MIMEMultipart import MIMEMultipart from email.MIMEBase import MIMEBase from email import Encoders SUBJECT = "Email Data" msg = MIMEMultipart() msg[ msg[ msg[ part = MIMEBase( part.set_payload(open("text.txt", "rb").read()) Encoders.encode_base64(part) part.add_header( msg.attach(part) server = smtplib.SMTP(self.EMAIL_SERVER) server.sendmail(self.EMAIL_FROM, self.EMAIL_TO, msg.as_string())
import smtplib import os.path as op from email.mime.multipart import MIMEMultipart from email.mime.base import MIMEBase from email.mime.text import MIMEText from email.utils import COMMASPACE, formatdate from email import encoders def send_mail(send_from, send_to, subject, message, files=[], server="localhost", port=587, username= use_tls=True): """Compose and send email with provided info and attachments. Args: send_from (str): from name send_to (str): to name subject (str): message title message (str): message body files (list[str]): list of file paths to be attached to email server (str): mail server host name port (int): port number username (str): server auth username password (str): server auth password use_tls (bool): use TLS mode """ msg = MIMEMultipart() msg[ msg[ msg[ msg[ msg.attach(MIMEText(message)) for path in files: part = MIMEBase( with open(path, part.set_payload(file.read()) encoders.encode_base64(part) part.add_header( msg.attach(part) smtp = smtplib.SMTP(server, port) if use_tls: smtp.starttls() smtp.login(username, password) smtp.sendmail(send_from, send_to, msg.as_string()) smtp.quit()
from email.MIMEMultipart import MIMEMultipart from email.MIMEText import MIMEText from email.MIMEImage import MIMEImage import smtplib msg = MIMEMultipart() msg.attach(MIMEText(file("text.txt").read())) msg.attach(MIMEImage(file("image.png").read())) mailer = smtplib.SMTP() mailer.connect() mailer.sendmail(from_, to, msg.as_string()) mailer.close()
import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.mime.application import MIMEApplication from os.path import basename def send_mail(send_from: str, subject: str, text: str, send_to: list, files= None): send_to= default_address if not send_to else send_to msg = MIMEMultipart() msg[ msg[ msg[ msg.attach(MIMEText(text)) for f in files or []: with open(f, "rb") as fil: ext = f.split( attachedfile = MIMEApplication(fil.read(), _subtype = ext) attachedfile.add_header( msg.attach(attachedfile) smtp = smtplib.SMTP(host="smtp.gmail.com", port= 587) smtp.starttls() smtp.login(username,password) smtp.sendmail(send_from, send_to, msg.as_string()) smtp.close()
username = password = default_address = [ send_mail(send_from= username, subject="test", text="text", send_to= None, files= )
from django.core.mail import EmailMessage def attachment_email(request): email = EmailMessage( [ [ reply_to=[ headers={ ) email.attach_file( email.send()
import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.mime.base import MIMEBase from email import encoders fromaddr = "sender mail address" toaddr = "receiver mail address" msg = MIMEMultipart() msg[ msg[ msg[ body = "TEXT YOU WANT TO SEND" msg.attach(MIMEText(body, filename = "fileName" attachment = open("path of file", "rb") part = MIMEBase( part.set_payload((attachment).read()) encoders.encode_base64(part) part.add_header( msg.attach(part) server = smtplib.SMTP( server.starttls() server.login(fromaddr, "sender mail password") text = msg.as_string() server.sendmail(fromaddr, toaddr, text) server.quit()
import os.path import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.mime.application import MIMEApplication def send_email(subject, message, from_email, to_email=[], attachment=[]): """ :param subject: email subject :param message: Body content of the email (string), can be HTML/CSS or plain text :param from_email: Email address from where the email is sent :param to_email: List of email recipients, example: ["a@a.com", "b@b.com"] :param attachment: List of attachments, exmaple: ["file1.txt", "file2.txt"] """ msg = MIMEMultipart() msg[ msg[ msg[ msg.attach(MIMEText(message, for f in attachment: with open(f, basename = os.path.basename(f) part = MIMEApplication(a_file.read(), Name=basename) part[ msg.attach(part) email = smtplib.SMTP( email.sendmail(from_email, to_email, msg.as_string())
file = username= password= send_from = send_to = Cc = msg = MIMEMultipart() msg[ msg[ msg[ msg[ msg[ server = smtplib.SMTP( port = fp = open(file, part = MIMEBase( part.set_payload(fp.read()) fp.close() encoders.encode_base64(part) part.add_header( msg.attach(part) smtp = smtplib.SMTP( smtp.ehlo() smtp.starttls() smtp.login(username,password) smtp.sendmail(send_from, send_to.split( smtp.quit()
from email.mime.multipart import MIMEMultipart from email.mime.image import MIMEImage from email.mime.text import MIMEText import smtplib msg = MIMEMultipart() password = "password" msg[ msg[ msg[ msg.attach(MIMEImage(file("abc.jpg").read())) file = "file path" fp = open(file, img = MIMEImage(fp.read()) fp.close() msg.attach(img) server = smtplib.SMTP( server.starttls() server.login(msg[ server.sendmail(msg[ server.quit()
from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart import smtplib import mimetypes import email.mime.application smtp_ssl_host = smtp_ssl_port = 465 s = smtplib.SMTP_SSL(smtp_ssl_host, smtp_ssl_port) s.login(email_user, email_pass) msg = MIMEMultipart() msg[ msg[ msg[ txt = MIMEText( msg.attach(txt) filename = fo=open(filename, attach = email.mime.application.MIMEApplication(fo.read(),_subtype="pdf") fo.close() attach.add_header( msg.attach(attach) s.send_message(msg) s.quit()
mat = None for col in columns: if mat is None: mat = col else: mat = hstack((mat, col))
>>> import numpy >>> a = numpy.zeros(shape=(5,2)) >>> a array([[ 0., 0.], [ 0., 0.], [ 0., 0.], [ 0., 0.], [ 0., 0.]]) >>> a[0] = [1,2] >>> a[1] = [2,3] >>> a array([[ 1., 2.], [ 2., 3.], [ 0., 0.], [ 0., 0.], [ 0., 0.]])
mylist = [] for item in data: mylist.append(item) mat = numpy.array(mylist)
import numpy as np n = 2 X = np.empty(shape=[0, n]) for i in range(5): for j in range(2): X = np.append(X, [[i, j]], axis=0) print X
[[ 0. 0.] [ 0. 1.] [ 1. 0.] [ 1. 1.] [ 2. 0.] [ 2. 1.] [ 3. 0.] [ 3. 1.] [ 4. 0.] [ 4. 1.]]
>>> from numpy import * >>> a = array([10,20,30]) >>> append(a, [[1,2,3]], axis=0) array([[10, 20, 30], [1, 2, 3]])
>>> append(a, [[15],[15]], axis=1) array([[10, 20, 30, 15], [1, 2, 3, 15]])
my_arr = numpy.zeros((0,5)) for i in range(3): my_arr=numpy.concatenate( ( my_arr, numpy.ones((1,5)) ) ) print(my_arr) [[ 1. 1. 1. 1. 1.] [ 1. 1. 1. 1. 1.] [ 1. 1. 1. 1. 1.]]
a = range(5) a = [i*0 for i in a] print a [0, 0, 0, 0, 0]
ur_list = [] for col in columns: ur_list.append(list(col)) mat = np.matrix(ur_list)
{% for i in range(0,(nums[ <li> {{ nums[ {% endfor %}
x = 10 y = 100 plot(x, y, "k*", label="Global Optimum") legend()
>>> variables= {} >>> execfile( "someFile.py", variables ) >>> print variables
exec(open("./path/to/script.py").read(), globals())
| foo.py | ---------- testvar = 10 def bar(bing): return bing*3 -------- $ python -i foo.py >>> testvar 10 >>> bar(6) 18
with open ("C:\\Users\\UserName\\SomeFolder\\helloworld.py", "r") as file: exec(file.read())
>>> numpy.arange(11, 17, 0.5) array([ 11. , 11.5, 12. , 12.5, 13. , 13.5, 14. , 14.5, 15. , 15.5, 16. , 16.5])
>>> x1=11 >>> x2=16 >>> range(x1, x2+1) [11, 12, 13, 14, 15, 16] >>> list1 = range(x1, x2+1) >>> list1 [11, 12, 13, 14, 15, 16]
>>> list2 = [x*0.5 for x in range(2*x1, 2*x2+1)] >>> list2 [11.0, 11.5, 12.0, 12.5, 13.0, 13.5, 14.0, 14.5, 15.0, 15.5, 16.0]
def frange(start, stop, step=1.0): i = start while i < stop: yield i i += step for i in frange(1.0, 2.0, 0.5): print i print list(frange(1.0, 10.0, 0.5))
1.0 1.5 [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5]
range(x,y+1) >>> range(11,17) [11, 12, 13, 14, 15, 16] >>>
def any_number_range(a,b,s=1): """ Generate consecutive values list between two numbers with optional step (default=1).""" if (a == b): return a else: mx = max(a,b) mn = min(a,b) result = [] while(mn < mx + 1): if s > 0: result.append(mn) mn += s if s < 0: result.append(mx) mx += s return result
def custom_range(*args): s = slice(*args) start, stop, step = s.start, s.stop, s.step if 0 == step: raise ValueError("range() arg 3 must not be zero") i = start while i < stop if step > 0 else i > stop: yield i i += step >>> [x for x in custom_range(10, 3, -1)]
from time import time as t def count(): st = t() [x for x in xrange(10000000) if x%4 == 0] et = t() print et-st count()
from time import time as t def xrange(x): return iter(range(x)) def count(): st = t() [x for x in xrange(10000000) if x%4 == 0] et = t() print (et-st) count()
In [37]: %timeit collections.deque((x for x in xrange(10000000) if x%4 == 0), maxlen=0) 1 loops, best of 3: 1.05 s per loop
In [83]: %timeit collections.deque((x for x in range(10000000) if x%4 == 0), maxlen=0) 1 loops, best of 3: 1.32 s per loop In [84]: %timeit collections.deque((x for x in xrange(10000000) if x%4 == 0), maxlen=0) 1 loops, best of 3: 1.31 s per loop In [85]: %timeit collections.deque((x for x in iter(range(10000000)) if x%4 == 0), maxlen=0) 1 loops, best of 3: 1.33 s per loop
In [86]: %timeit [x for x in range(10000000) if x%4 == 0] 1 loops, best of 3: 3.65 s per loop
In [87]: def consume(x): ....: for i in x: ....: pass In [88]: %timeit consume(x for x in range(10000000) if x%4 == 0) 1 loops, best of 3: 1.85 s per loop
Python 2.7.3 (default, Apr 10 2012, 23:24:47) [MSC v.1500 64 bit (AMD64)] on win32 Type "copyright", "credits" or "license()" for more information. >>> import timeit >>> timeit.timeit("[x for x in xrange(1000000) if x%4]",number=100) 18.631936646865853
Python 3.3.0 (v3.3.0:bd8afb90ebf2, Sep 29 2012, 10:57:17) [MSC v.1600 64 bit (AMD64)] on win32 Type "copyright", "credits" or "license()" for more information. >>> import timeit >>> timeit.timeit("[x for x in range(1000000) if x%4]",number=100) 17.31399508687869
import sys if sys.version_info >= (3, 0): def xrange(*args, **kwargs): return iter(range(*args, **kwargs))
>>> import timeit >>> timeit.timeit("[x for x in xrange(1000000) if x%4]",number=100)
>>> timeit.timeit("[x for x in xrange(1000000) if x%4]",number=100)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=100)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=100)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=1)
>>> timeit.timeit("[x for x in xrange(1000000) if x%4]",number=1)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=100)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=100)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=1)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=2)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=3)
>>> timeit.timeit("[x for x in range(1000000) if x%4]",number=4)
import numpy as _num from numpy import oldnumeric from numpy import * from numpy.random import rand, randn from numpy.fft import fft, ifft from numpy.lib.scimath import *
""" Wrapper functions to more user-friendly calling of certain math functions whose output data-type is different than the input data-type in certain domains of the input. For example, for functions like log() with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane: >>> import math >>> from numpy.lib import scimath >>> scimath.log(-math.exp(1)) == (1+1j*math.pi) True Similarly, sqrt(), other base logarithms, power() and trig functions are correctly handled. See their respective docstrings for specific examples. """
Python 2.4.3 ( [GCC 4.1.2 20080704 (Red Hat 4.1.2-50)] on linux2 >>> import scipy >>> import scipy.linalg >>> import numpy >>> scipy.source(scipy.linalg.solve) In file: /usr/lib64/python2.4/site-packages/scipy/linalg/basic.py def solve(a, b, sym_pos=0, lower=0, overwrite_a=0, overwrite_b=0, debug = 0): """ solve(a, b, sym_pos=0, lower=0, overwrite_a=0, overwrite_b=0) -> x Solve a linear system of equations a * x = b for x. Inputs: a -- An N x N matrix. b -- An N x nrhs matrix or N vector. sym_pos -- Assume a is symmetric and positive definite. lower -- Assume a is lower triangular, otherwise upper one. Only used if sym_pos is true. overwrite_y - Discard data in y, where y is a or b. Outputs: x -- The solution to the system a * x = b """ a1, b1 = map(asarray_chkfinite,(a,b)) if len(a1.shape) != 2 or a1.shape[0] != a1.shape[1]: raise ValueError, if a1.shape[0] != b1.shape[0]: raise ValueError, overwrite_a = overwrite_a or (a1 is not a and not hasattr(a, overwrite_b = overwrite_b or (b1 is not b and not hasattr(b, if debug: print print if sym_pos: posv, = get_lapack_funcs(( c,x,info = posv(a1,b1, lower = lower, overwrite_a=overwrite_a, overwrite_b=overwrite_b) else: gesv, = get_lapack_funcs(( lu,piv,x,info = gesv(a1,b1, overwrite_a=overwrite_a, overwrite_b=overwrite_b) if info==0: return x if info>0: raise LinAlgError, "singular matrix" raise ValueError,\ >>> scipy.source(numpy.linalg.solve) In file: /usr/lib64/python2.4/site-packages/numpy/linalg/linalg.py def solve(a, b): """ Solve the equation ``a x = b`` for ``x``. Parameters ---------- a : array_like, shape (M, M) Input equation coefficients. b : array_like, shape (M,) Equation target values. Returns ------- x : array, shape (M,) Raises ------ LinAlgError If `a` is singular or not square. Examples -------- Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``: >>> a = np.array([[3,1], [1,2]]) >>> b = np.array([9,8]) >>> x = np.linalg.solve(a, b) >>> x array([ 2., 3.]) Check that the solution is correct: >>> (np.dot(a, x) == b).all() True """ a, _ = _makearray(a) b, wrap = _makearray(b) one_eq = len(b.shape) == 1 if one_eq: b = b[:, newaxis] _assertRank2(a, b) _assertSquareness(a) n_eq = a.shape[0] n_rhs = b.shape[1] if n_eq != b.shape[0]: raise LinAlgError, t, result_t = _commonType(a, b) if isComplexType(t): lapack_routine = lapack_lite.zgesv else: lapack_routine = lapack_lite.dgesv a, b = _fastCopyAndTranspose(t, a, b) pivots = zeros(n_eq, fortran_int) results = lapack_routine(n_eq, n_rhs, a, n_eq, pivots, b, n_eq, 0) if results[ raise LinAlgError, if one_eq: return wrap(b.ravel().astype(result_t)) else: return wrap(b.transpose().astype(result_t))
import numpy as _num linalg = None from numpy import * from numpy.random import rand, randn from numpy.fft import fft, ifft from numpy.lib.scimath import * __all__ = [] __all__ += _num.__all__ __all__ += [ del _num del linalg __all__.remove(
teams_list = ["Man Utd", "Man City", "T Hotspur"] data = np.array([[1, 2, 1], [0, 1, 0], [2, 4, 2]])
Man Utd Man City T Hotspur Man Utd 1 0 0 Man City 1 1 0 T Hotspur 0 1 2
row_format ="{:>15}" * (len(teams_list) + 1) print row_format.format("", *teams_list) for team, row in zip(teams_list, data): print row_format.format(team, *row)
>>> from tabulate import tabulate >>> print tabulate([[ Name Age ------ ----- Alice 24 Bob 19
>>> print tabulate([[ | Name | Age | |--------+-------| | Alice | 24 | | Bob | 19 |
>>> from prettytable import PrettyTable >>> t = PrettyTable([ >>> t.add_row([ >>> t.add_row([ >>> print t +-------+-----+ | Name | Age | +-------+-----+ | Alice | 24 | | Bob | 19 | +-------+-----+
>>> from texttable import Texttable >>> t = Texttable() >>> t.add_rows([[ >>> print t.draw() +-------+-----+ | Name | Age | +=======+=====+ | Alice | 24 | +-------+-----+ | Bob | 19 | +-------+-----+
>>> import pandas >>> pandas.DataFrame(data, teams_list, teams_list) Man Utd Man City T Hotspur Man Utd 1 2 1 Man City 0 1 0 T Hotspur 2 4 2
1 1 10 20 100 400 1000 8000 10000 160000 100000 3200000 1000000 64000000 10000000 1280000000 100000000 25600000000 1000000000 512000000000
>>> from beautifultable import BeautifulTable >>> table = BeautifulTable() >>> table.column_headers = ["name", "rank", "gender"] >>> table.append_row(["Jacob", 1, "boy"]) >>> table.append_row(["Isabella", 1, "girl"]) >>> table.append_row(["Ethan", 2, "boy"]) >>> table.append_row(["Sophia", 2, "girl"]) >>> table.append_row(["Michael", 3, "boy"]) >>> print(table) +----------+------+--------+ | name | rank | gender | +----------+------+--------+ | Jacob | 1 | boy | +----------+------+--------+ | Isabella | 1 | girl | +----------+------+--------+ | Ethan | 2 | boy | +----------+------+--------+ | Sophia | 2 | girl | +----------+------+--------+ | Michael | 3 | boy | +----------+------+--------+
row_format ="{:>15}" * (len(teams_list) + 1) print(row_format.format("", *teams_list)) for team, row in zip(teams_list, data): print(row_format.format(team, *row))
def format_matrix(header, matrix, top_format, left_format, cell_format, row_delim, col_delim): table = [[ table_format = [[ + len(matrix) * [[left_format] + len(header) * [cell_format]] col_widths = [max( len(format.format(cell, 0)) for format, cell in zip(col_format, col)) for col_format, col in zip(zip(*table_format), zip(*table))] return row_delim.join( col_delim.join( format.format(cell, width) for format, cell, width in zip(row_format, row, col_widths)) for row_format, row in zip(table_format, table)) print format_matrix([ [[1, 2, 1, -1], [0, 1, 0, 5], [2, 4, 2, 2], [0, 1, 0, 6]],
| Man Utd | Man City | T Hotspur | Really Long Column Man Utd | 1.000 | 2.000 | 1.000 | -1.000 Man City | 0.000 | 1.000 | 0.000 | 5.000 T Hotspur | 2.000 | 4.000 | 2.000 | 2.000 Really Long Column | 0.000 | 1.000 | 0.000 | 6.000
def print_table(data, cols, wide): n, r = divmod(len(data), cols) pat = line = last_line = pat * r print(line.format(*data)) print(last_line.format(*data[n*cols:])) data = [str(i) for i in range(27)] print_table(data, 6, 12)
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
table = [ ["", "Man Utd", "Man City", "T Hotspur"], ["Man Utd", 1, 0, 0], ["Man City", 1, 1, 0], ["T Hotspur", 0, 1, 2], ] def print_table(table): longest_cols = [ (max([len(str(row[i])) for row in table]) + 3) for i in range(len(table[0])) ] row_format = "".join(["{:>" + str(longest_col) + "}" for longest_col in longest_cols]) for row in table: print(row_format.format(*row))
>>> print_table(table) Man Utd Man City T Hotspur Man Utd 1 0 0 Man City 1 1 0 T Hotspur 0 1 2
def print_results_table(data, teams_list): str_l = max(len(t) for t in teams_list) print(" ".join([ for t, row in zip(teams_list, data): print(" ".join([ teams_list = ["Man Utd", "Man City", "T Hotspur"] data = [[1, 2, 1], [0, 1, 0], [2, 4, 2]] print_results_table(data, teams_list)
Man Utd Man City T Hotspur Man Utd 1 2 1 Man City 0 1 0 T Hotspur 2 4 2
class AttributeDict(dict): def __getattr__(self, attr): return self[attr] def __setattr__(self, attr, value): self[attr] = value
class AttrDict(dict): def __init__(self, *args, **kwargs): super(AttrDict, self).__init__(*args, **kwargs) self.__dict__ = self
d = AttrDict() d.update({ for k, v in d.items(): print "Never reached!"
class AttributeDict(dict): __getattr__ = dict.__getitem__ __setattr__ = dict.__setitem__
>>> KEY = >>> d[KEY] = 1 >>> ... assert d.spam == 1
>>> KEY = >>> d[KEY] = 1 >>> ... assert d.spam == 1 Traceback (most recent call last): File "<stdin>", line 2, in <module> AttributeError:
>>> d = {(2, 3): True,} >>> assert d[(2, 3)] is True >>>
>>> C = type( >>> d = C() >>> assert d.(2, 3) is True File "<stdin>", line 1 d.(2, 3) ^ SyntaxError: invalid syntax >>> getattr(d, (2, 3)) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: getattr(): attribute name must be string >>>
>>> KEYS = >>> VALS = [1, 2, 3] >>> d = {k: v for k, v in zip(KEYS.split( >>> assert d == { >>>
>>> C = type( >>> d = C() >>> d.spam = 1 >>> d.eggs = 2 >>> d.ham = 3 >>> assert d.__dict__ == {
>>> C = type( >>> d = C() >>> for x in ... setattr(d, x, C()) ... i = 1 ... for y in ... setattr(getattr(d, x), y, i) ... i += 1 ... >>> assert d.spam.__dict__ == {
class Namespace(_AttributeHolder): def __init__(self, **kwargs): for name in kwargs: setattr(self, name, kwargs[name]) __hash__ = None def __eq__(self, other): return vars(self) == vars(other) def __ne__(self, other): return not (self == other) def __contains__(self, key): return key in self.__dict__
from addict import Dict body = Dict() body.query.filtered.query.match.description = body.query.filtered.filter.term.created_by =
def record(name, d): return namedtuple(name, d.keys())(**d)
>>> od = OrderedAttrDict() >>> od["a"] = 1 >>> od["b"] = 2 >>> od OrderedAttrDict([( >>> od.a 1 >>> od.b = 20 >>> od OrderedAttrDict([( >>> od.c = 8 >>> od OrderedAttrDict([( >>> od.c 8
class OrderedAttrDict(odict.OrderedDict): def __getattr__(self, attr): if self.has_key(attr): return super(OrderedAttrDict, self).__getitem__(attr) else: return super(OrderedAttrDict, self).__getattr__(attr) def __setattr__(self, attr, value): if self.has_key(attr): super(OrderedAttrDict, self).__setitem__(attr, value) else: super(OrderedAttrDict, self).__setattr__(attr, value)
class ObjectFromDict(object): def __init__(self, d): self.__dict__ = d
class AttrDict(dict): """ A class to convert a nested Dictionary into an object with key-values that are accessible using attribute notation (AttrDict.attribute) instead of key notation (Dict["key"]). This class recursively sets Dicts to objects, allowing you to recurse down nested dicts (like: AttrDict.attr.attr) """ def __init__(self, iterable, **kwargs): super(AttrDict, self).__init__(iterable, **kwargs) for key, value in iterable.items(): if isinstance(value, dict): self.__dict__[key] = AttrDict(value) else: self.__dict__[key] = value
class Bunch(dict): """ Scikit Learn Dictionary-like object that exposes its keys as attributes. >>> b = Bunch(a=1, b=2) >>> b[ 2 >>> b.b 2 >>> b.c = 6 >>> b[ 6 """ def __init__(self, **kwargs): super(Bunch, self).__init__(kwargs) def __setattr__(self, key, value): self[key] = value def __dir__(self): return self.keys() def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(key) def __setstate__(self, state): pass
class Country(Prodict): name: str population: int turkey = Country() turkey.name = turkey.population = 79814871
germany = Country(name= print(germany.population) print(type(germany.population)) print(germany.flag_colors) print(type(germany.flag_colors))
class Map(dict): """ Example: m = Map({ """ def __init__(self, *args, **kwargs): super(Map, self).__init__(*args, **kwargs) for arg in args: if isinstance(arg, dict): for k, v in arg.iteritems(): self[k] = v if kwargs: for k, v in kwargs.iteritems(): self[k] = v def __getattr__(self, attr): return self.get(attr) def __setattr__(self, key, value): self.__setitem__(key, value) def __setitem__(self, key, value): super(Map, self).__setitem__(key, value) self.__dict__.update({key: value}) def __delattr__(self, item): self.__delitem__(item) def __delitem__(self, key): super(Map, self).__delitem__(key) del self.__dict__[key]
m = Map({ m.new_key = print m.new_key print m[ m.new_key = m[ del m.new_key del m[
class AttrDict(dict): def __init__(self): self.__dict__ = self if __name__ == d = AttrDict() d[ d.sun = print d[ print d.sun
from mako.template import Template from neobunch import neobunchify mako_template = Template(filename= data = { with open( out_file.write(mako_template.render(**neobunchify(data)))
% for d in tmpl_data: Column1 Column2 ${d.key1} ${d.key2} % endfor
DICT_RESERVED_KEYS = vars(dict).keys() class SmartDict(dict): def __init__(self, *args, **kwargs): """ :param args: multiple dicts ({}, {}, ..) :param kwargs: arbitrary keys= If ``keyerror=False`` is passed then not found attributes will always return None. """ super(SmartDict, self).__init__() self[ [self.update(arg) for arg in args if isinstance(arg, dict)] self.update(kwargs) def __getattr__(self, attr): if attr not in DICT_RESERVED_KEYS: if self[ return self[attr] else: return self.get(attr) return getattr(self, attr) def __setattr__(self, key, value): if key in DICT_RESERVED_KEYS: raise AttributeError("You cannot set a reserved name as attribute") self.__setitem__(key, value) def __copy__(self): return self.__class__(self) def copy(self): return self.__copy__()
def make_funcdict(d={}, **kwargs) def funcdict(d={}, **kwargs): funcdict.__dict__.update(d) funcdict.__dict__.update(kwargs) return funcdict.__dict__ funcdict(d, **kwargs) return funcdict
d = { d = make_funcdict(d) >>> for key in d(): ... print key ... age name >>> print d.name ... Henry >>> print d.age ... 31 >>> d({ ... {
d.1_foo d./bar d.21.7, d.12:30 d."" d.john doe, d.denny d.3 * x
print "I am a test" print "see! I do nothing productive."
import test1 def service_func(): print if __name__ == service_func() test1.some_func()
import subprocess subprocess.call("test1.py", shell=True)
def main(): print "I am a test" print "see! I do nothing productive." if __name__ == "__main__": main()
def print_test(): print "I am a test" print "see! I do nothing productive."
import sys if sys.modules.has_key[ reload(sys.modules[ else: __import__(
import os os.system("python myOtherScript.py arg1 arg2 arg3")
% formatter something like numbers = [23.23, 0.123334987, 1, 4.223, 9887.2] for number in numbers: print formatter.format(number)
>>> v=10.4 >>> print( 10.40 >>> print( 10.4 >>> print( 0000000010.4
numbers = [23.23, 0.123334987, 1, 4.223, 9887.2] for number in numbers: print(f
IDLE 3.5.1 numbers = [ for x in numbers: print( 23.2300 0.1233 1.0000 4.2230 9887.2000
Logger.debug( "this is some annoying message I only want to see while debugging" )
Logger.error( "Wow, something really awful happened." )
class Logger : DEBUG = 5 INFO = 4 WARN = 3 ERROR = 2 FATAL = 1 _level = DEBUG def __init__( self ) : Logger._level = Logger.DEBUG @classmethod def isLevel( cls, level ) : return cls._level >= level @classmethod def debug( cls, message ) : if cls.isLevel( Logger.DEBUG ) : print "DEBUG: " + message @classmethod def info( cls, message ) : if cls.isLevel( Logger.INFO ) : print "INFO : " + message @classmethod def warn( cls, message ) : if cls.isLevel( Logger.WARN ) : print "WARN : " + message @classmethod def error( cls, message ) : if cls.isLevel( Logger.ERROR ) : print "ERROR: " + message @classmethod def fatal( cls, message ) : if cls.isLevel( Logger.FATAL ) : print "FATAL: " + message
def logAll() : Logger.debug( "This is a Debug message." ) Logger.info ( "This is a Info message." ) Logger.warn ( "This is a Warn message." ) Logger.error( "This is a Error message." ) Logger.fatal( "This is a Fatal message." ) if __name__ == print "Should see all DEBUG and higher" Logger._level = Logger.DEBUG logAll() print "Should see all ERROR and higher" Logger._level = Logger.ERROR logAll()
module.py (file 1) --------- def f1() : pass def f2() : pass def f3() : pass usage.py (file 2) -------- from module import * f1() f2() f3() def f4():pass def f5():pass usage1.py (file 3) ------------------- from usage import f4,f5 f4() f5()
class FileUtil (): def copy(source,dest):pass def move(source,dest):pass def copyDir(source,dest):pass def moveDir(source,dest):pass FileUtil.copy("1.txt","2.txt") FileUtil.moveDir("dir1","dir2")
class User(): @classmethod def get_by_username(cls, username): return cls.query(cls.username == username).get() @classmethod def get_by_auth_id(cls, auth_id): return cls.query(cls.auth_id == auth_id).get()
class A { static protected $inner_var = null; static public function echoInnerVar() { echo self::$inner_var."\n"; } static public function setInnerVar($v) { self::$inner_var = $v; } } class B extends A { } A::setInnerVar(10); B::setInnerVar(20); A::echoInnerVar(); B::echoInnerVar();
class A(object): inner_var = 0 @classmethod def setInnerVar(cls, value): cls.inner_var = value @classmethod def echoInnerVar(cls): print cls.inner_var class B(A): pass A.setInnerVar(10) B.setInnerVar(20) A.echoInnerVar() B.echoInnerVar()
Foo().foo() <__main__.Foo instance at 0x7f4dd3e3bc20>
Foo.foo() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unbound method foo() must be called with Foo instance as first argument (got nothing instead)
class Foo def foo() puts "instance method end def self.foo() puts "class method end end Foo.foo() class method Foo Foo.new.foo() instance method
class M(): @classmethod def m(cls, arg): print "arg was", getattr(cls, "arg" , None), cls.arg = arg print "arg is" , cls.arg M.m(1) M.m(2) m1 = M() m2 = M() m1.m(3) m2.m(4) M.m(5)
class Foo: def __eq__(self,other): return True foo=Foo() print(foo==None) print(foo is None)
conda create -n py27 python=2.7 ipykernel conda create -n py36 python=3.6 ipykernel
conda create -n py27 python=2.7 conda activate py27 conda install notebook ipykernel ipython kernel install --user
conda create -n py36 python=3.6 conda activate py36 conda install notebook ipykernel ipython kernel install --user
python2 -m pip install ipykernel python2 -m ipykernel install --user
{ "display_name": "IPython (Python 3)", "language": "python", "argv": [ "python3", "-c", "from IPython.kernel.zmq.kernelapp import main; main()", "-f", "{connection_file}" ], "codemirror_mode": { "version": 2, "name": "ipython" } }
sudo apt-get install python-dev python3-dev python-pip python3-pip
python -m pip install virtualenv --user python -m virtualenv -p python2 ~/py2_kernel source ~/py2_kernel/bin/activate python -m pip install ipykernel ipython kernel install --name py2 --user deactivate python -m virtualenv -p python3 ~/py3_kernel source ~/py3_kernel/bin/activate python -m pip install ipykernel ipython kernel install --name py3 --user deactivate
kernel2 python -m pip install <pkg-name> deactivate
kernel3 python -m pip install <pkg-name> deactivate
$ cd /opt/local/Library/Frameworks/Python.framework/Versions/2.7/bin $ sudo ./ipython kernelspec install-self
$ cd /opt/local/Library/Frameworks/Python.framework/Versions/3.4/bin $ sudo ./ipython kernelspec install-self
def downloadFile(URL=None): import httplib2 h = httplib2.Http(".cache") resp, content = h.request(URL, "GET") return content downloadFile(URL_from_file)
import urllib.request ... url = response = urllib.request.urlopen(url) data = response.read() text = data.decode(
import urllib.request ... urllib.request.urlretrieve(url, file_name)
import urllib.request ... file_name, headers = urllib.request.urlretrieve(url)
import urllib.request import shutil ... with urllib.request.urlopen(url) as response, open(file_name, shutil.copyfileobj(response, out_file)
import urllib.request ... with urllib.request.urlopen(url) as response, open(file_name, data = response.read() out_file.write(data)
import urllib.request import gzip ... url = with urllib.request.urlopen(url) as response: with gzip.GzipFile(fileobj=response) as uncompressed: file_header = uncompressed.read(64)
from requests import get def download(url, file_name): with open(file_name, "wb") as file: response = get(url) file.write(response.content)
import requests url = fileName = req = requests.get(url) file = open(fileName, for chunk in req.iter_content(100000): file.write(chunk) file.close()
import urllib.request url = urllib.request.urlretrieve(url, "logo.png")
from urllib import request def get(url): with request.urlopen(url) as r: return r.read() def download(url, file=None): if not file: file = url.split( with open(file, f.write(get(url))
plot.figure() plot.scatter(k, sum_cf, color= plot.scatter(k, data[:, 0], color= plot.scatter(k, data[:, 1], color= plot.scatter(k, data[:, 2], color= plot.legend(loc=2)
prop: [ None | FontProperties | dict ] A matplotlib.font_manager.FontProperties instance. If prop is a dictionary, a new instance will be created with prop. If None, use rc settings.
import pylab as plot params = { plot.rcParams.update(params)
xx-small x-small small medium large x-large xx-large
plt.legend(fontsize=20) plt.legend(fontsize="x-large")
>>> import datetime >>> a = datetime.datetime.now() >>> b = datetime.datetime.now() >>> c = b - a datetime.timedelta(0, 8, 562000) >>> divmod(c.days * 86400 + c.seconds, 60) (0, 8)
>>> import datetime >>> time1 = datetime.datetime.now() >>> time2 = datetime.datetime.now() >>> elapsedTime = time2 - time1 >>> elapsedTime datetime.timedelta(0, 125, 749430) >>> divmod(elapsedTime.total_seconds(), 60) (2.0, 5.749430000000004)
>>> import datetime >>> d1 = datetime.datetime.now() >>> d2 = datetime.datetime.now() >>> d2 - d1 datetime.timedelta(0, 5, 203000)
from datetime import timedelta time_difference = a - b time_difference_in_minutes = time_difference / timedelta(minutes=1)
time_difference_in_minutes = time_difference.total_seconds() / 60
>>> from datetime import datetime >>> then = datetime(2012, 3, 5, 23, 8, 15) >>> now = datetime.now() >>> duration = now - then >>> duration_in_s = duration.total_seconds()
>>> days = duration.days >>> days = divmod(duration_in_s, 86400)[0]
>>> seconds = duration.seconds >>> seconds = duration_in_s
>>> days = divmod(duration_in_s, 86400) >>> hours = divmod(days[1], 3600) >>> minutes = divmod(hours[1], 60) >>> seconds = divmod(minutes[1], 1) >>> print("Time between dates: %d days, %d hours, %d minutes and %d seconds" % (days[0], hours[0], minutes[0], seconds[0]))
now = int(time.time()) then = now - 90000 d = divmod(now-then,86400) h = divmod(d[1],3600) m = divmod(h[1],60) s = m[1] print
before = datetime.datetime.now() after = datetime.datetime.now() hours = math.floor(((after - before).seconds) / 3600)
>>>from datetime import datetime, timedelta >>>d1 = datetime(2015, 9, 12, 13, 9, 45) >>>d2 = datetime(2015, 8, 29, 21, 10, 12) >>>d3 = d1- d2 >>>print d3 13 days, 15:59:33 >>>print d3.days 13
import datetime from datetime import timedelta datetimeFormat = time1 = time2 = timedelta = datetime.datetime.strptime(time1, datetimeFormat) - datetime.datetime.strptime(time2,datetimeFormat)
from datetime import datetime def check_time_difference(t1: datetime, t2: datetime): t1_date = datetime( t1.year, t1.month, t1.day, t1.hour, t1.minute, t1.second) t2_date = datetime( t2.year, t2.month, t2.day, t2.hour, t2.minute, t2.second) t_elapsed = t1_date - t2_date return t_elapsed f = "%Y-%m-%d %H:%M:%S+01:00" t1 = datetime.strptime("2018-03-07 22:56:57+01:00", f) t2 = datetime.strptime("2018-03-07 22:48:05+01:00", f) elapsed_time = check_time_difference(t1, t2) print(elapsed_time)
t=datetime.now()-datetime.now().replace(hour=9,minute=30)
from datetime import datetime, timedelta from time import mktime yesterday = datetime.now() - timedelta(days=1) today = datetime.now() difference_in_seconds = abs(mktime(yesterday.timetuple()) - mktime(today.timetuple())) difference_in_minutes = difference_in_seconds / 60
import dateutil.parser import datetime last_sent_date = "" timeDifference = current_date - dateutil.parser.parse(last_sent_date) time_difference_in_minutes = (int(timeDifference.days) * 24 * 60) + int((timeDifference.seconds) / 60)
>>> s = "123mango abcd mango kiwi peach" >>> s.split("mango", 1) [ >>> s.split("mango", 1)[1]
import zipfile zip_ref = zipfile.ZipFile(path_to_zip_file, zip_ref.extractall(directory_to_extract_to) zip_ref.close()
import zipfile with zipfile.ZipFile("file.zip","r") as zip_ref: zip_ref.extractall("targetdir")
rarfile.UNRAR_TOOL = C:\Program Files (x86)\GnuWin32\bin\unrar.exe
import zipfile import rarfile import os.path import shutil def check_archrive_file(loc): check the file is an archive file or not. if the file is an archive file just extract it using the proper extracting method. if (loc.endswith( if os.path.isfile(loc): output_directory_location = loc.split( if not os.path.exists(output_directory_location): os.mkdir(output_directory_location) print(" Otput Directory " , output_directory_location) if loc.endswith( extractzip(loc,output_directory_location) else: extractrar(loc,output_directory_location) else: print("Otput Directory " , output_directory_location) print("Deleting old Otput Directory ") try: shutil.rmtree(output_directory_location) print("Delete success now extracting") if loc.endswith( extractzip(loc,output_directory_location) else: extractrar(loc,output_directory_location) except OSError as e: print ("Error: %s - %s." % (e.filename, e.strerror)) else: print("File not located to this path") else: print("File do not have any archrive structure.") def extractzip(loc,outloc): using the zipfile tool extract here . This function is valid if the file type is zip only with zipfile.ZipFile(loc,"r") as zip_ref: for item in zip_ref.infolist(): zip_ref.extract(item,outloc) zip_files = [files for files in zip_ref.filelist if files.filename.endswith( for file in zip_files: new_loc = os.path.join(outloc,file.filename) check_archrive_file(new_loc) zip_ref.close() def extractrar(loc,outloc): using the rarfile tool extract here . this function is valid if the file type is rar only if(rarfile.is_rarfile(loc)): with rarfile.RarFile(loc,"r") as rar_ref: for item in rar_ref.infolist(): rar_ref.extract(item,outloc) rar_files = [file for file in rar_ref.infolist() if file.filename.endswith( for file in rar_files: new_loc = os.path.join(outloc,file.filename) check_archrive_file(new_loc) rar_ref.close() else: print("File "+loc+" is not a rar file") def checkpathVariables(): check path variables. if unrar.exe nor present then install unrar and set unrar.exe in path variable. try: user_paths = os.environ[ except KeyError: user_paths = [] for item in user_paths: print("User path python variables :"+user_paths) for item in user_paths: if("unrar.exe" in item): print("Unrar tool setup found PYTHONPATH") return print("Unrar tool setup not found in PYTHONPATH") os_paths_list = os.environ[ for item in os_paths_list: if("unrar.exe" in item): print("Unrar tool setup found in PATH") rarfile.UNRAR_TOOL = item print("Unrar tool path set up complete ."+item) return print("Unrar tool setup not found in PATH") print("RAR TOOL WILL NOT WORK FOR YOU.") downloadlocation = "https: print("install unrar form the link"+downloadlocation) if __name__ == before you run this function make sure you have installed two packages unrar and rarfile. if not installed then pip install unrar pip install rarfile. This is not only the case unrar tool should be set up. zip is included in standard library so do not worry about the zip file. checkpathVariables() location = input( check_archrive_file(location)
def checkpathVariables(): check path variables. if unrar.exe nor present then install unrar and set unrar.exe in path variable. try: user_paths = os.environ[ except KeyError: user_paths = [] for item in user_paths: print("User path python variables :"+user_paths) for item in user_paths: if("unrar.exe" in item): print("Unrar tool setup found PYTHONPATH") return print("Unrar tool setup not found in PYTHONPATH") os_paths_list = os.environ[ for item in os_paths_list: if("unrar.exe" in item): print("Unrar tool setup found in PATH") rarfile.UNRAR_TOOL = item print("Unrar tool path set up complete ."+item) return print("Unrar tool setup not found in PATH") print("RAR TOOL WILL NOT WORK FOR YOU.") downloadlocation = "https: print("install unrar form the link"+downloadlocation)
def extractzip(loc,outloc): using the zipfile tool extract here . This function is valid if the file type is zip only with zipfile.ZipFile(loc,"r") as zip_ref: for item in zip_ref.infolist(): zip_ref.extract(item,outloc) zip_files = [files for files in zip_ref.filelist if files.filename.endswith( for file in zip_files: new_loc = os.path.join(outloc,file.filename) check_archrive_file(new_loc) zip_ref.close()
def extractrar(loc,outloc): using the rarfile tool extract here . this function is valid if the file type is rar only if(rarfile.is_rarfile(loc)): with rarfile.RarFile(loc,"r") as rar_ref: for item in rar_ref.infolist(): rar_ref.extract(item,outloc) rar_files = [file for file in rar_ref.infolist() if file.filename.endswith( for file in rar_files: new_loc = os.path.join(outloc,file.filename) check_archrive_file(new_loc) rar_ref.close() else: print("File "+loc+" is not a rar file")
if __name__ == before you run this function make sure you have installed two packages unrar and rarfile. if not installed then pip install unrar pip install rarfile. This is not only the case unrar tool should be set up. zip is included in standard library so do not worry about the zip file. checkpathVariables() location = input( check_archrive_file(location)
import os zip_file_path = "C:\AA\BB" file_list = os.listdir(path) abs_path = [] for a in file_list: x = zip_file_path+ print x abs_path.append(x) for f in abs_path: zip=zipfile.ZipFile(f) zip.extractall(zip_file_path)
from zipfile import ZipFile zf = ZipFile( zf.extractall( zf.close()
start_time = time.time() elapsed_time = time.time() - start_time
import time from functools import wraps PROF_DATA = {} def profile(fn): @wraps(fn) def with_profiling(*args, **kwargs): start_time = time.time() ret = fn(*args, **kwargs) elapsed_time = time.time() - start_time if fn.__name__ not in PROF_DATA: PROF_DATA[fn.__name__] = [0, []] PROF_DATA[fn.__name__][0] += 1 PROF_DATA[fn.__name__][1].append(elapsed_time) return ret return with_profiling def print_prof_data(): for fname, data in PROF_DATA.items(): max_time = max(data[1]) avg_time = sum(data[1]) / len(data[1]) print "Function %s called %d times. " % (fname, data[0]), print def clear_prof_data(): global PROF_DATA PROF_DATA = {}
import time start = time.time() end = time.time() elapsed = end - start
import time start_time = time.time() elapsed_time = time.time() - start_time time.strftime("%H:%M:%S", time.gmtime(elapsed_time))
import datetime start = datetime.datetime.now() end = datetime.datetime.now() elapsed = end - start print(elapsed) print(elapsed.seconds,":",elapsed.microseconds)
import time start_time=time.time() elapsed_time=time.time()-start_time
import time start_time = time.time() ... e = int(time.time() - start_time) print(
import datetime def calc_timing(original_function): def new_function(*args,**kwargs): start = datetime.datetime.now() x = original_function(*args,**kwargs) elapsed = datetime.datetime.now() print("Elapsed Time = {0}".format(elapsed-start)) return x return new_function() @calc_timing def a_func(*variables): print("do something big!")
filename = "/foo/bar/baz.txt" with open(filename, "w") as f: f.write("FOOBAR")
import os import errno filename = "/foo/bar/baz.txt" if not os.path.exists(os.path.dirname(filename)): try: os.makedirs(os.path.dirname(filename)) except OSError as exc: if exc.errno != errno.EEXIST: raise with open(filename, "w") as f: f.write("FOOBAR")
filename = "/foo/bar/baz.txt"¨ os.makedirs(os.path.dirname(filename), exist_ok=True) with open(filename, "w") as f: f.write("FOOBAR")
a = numpy.matrix([[1, 2, 3, 4], [5, 6, 7, 8]]) b = numpy.reshape(a, -1)
z = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) z.shape (3, 4)
z.reshape(-1) array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
z.reshape(-1,1) array([[ 1], [ 2], [ 3], [ 4], [ 5], [ 6], [ 7], [ 8], [ 9], [10], [11], [12]])
z.reshape(-1, 2) array([[ 1, 2], [ 3, 4], [ 5, 6], [ 7, 8], [ 9, 10], [11, 12]])
z.reshape(1,-1) array([[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]])
z.reshape(2, -1) array([[ 1, 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11, 12]])
z.reshape(3, -1) array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]])
z.reshape(-1, -1) ValueError: can only specify one unknown dimension
a = numpy.matrix([[1, 2, 3, 4], [5, 6, 7, 8]]) b = numpy.reshape(a, -1)
(userDim1, userDim2, ..., -1) -->> (userDim1, userDim1, ..., TOTAL_DIMENSION - (userDim1 + userDim2 + ...))
import win32serviceutil import win32service import win32event import servicemanager import socket class AppServerSvc (win32serviceutil.ServiceFramework): _svc_name_ = "TestService" _svc_display_name_ = "Test Service" def __init__(self,args): win32serviceutil.ServiceFramework.__init__(self,args) self.hWaitStop = win32event.CreateEvent(None,0,0,None) socket.setdefaulttimeout(60) def SvcStop(self): self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) win32event.SetEvent(self.hWaitStop) def SvcDoRun(self): servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE, servicemanager.PYS_SERVICE_STARTED, (self._svc_name_, self.main() def main(self): pass if __name__ == win32serviceutil.HandleCommandLine(AppServerSvc)
Service Name : PythonTest Display Name : PythonTest Startup : Manual (or whatever you like) Dependencies : (Leave blank or fill to fit your needs) Executable : c:\python25\python.exe Arguments : c:\path_to_your_python_script\test.py Working Directory : c:\path_to_your_python_script
sc create PythonApp binPath= "C:\Python34\Python.exe --C:\tmp\pythonscript.py"
import win32serviceutil import win32service import win32event import servicemanager import socket class AppServerSvc (win32serviceutil.ServiceFramework): _svc_name_ = "TestService" _svc_display_name_ = "Test Service" def __init__(self,args): win32serviceutil.ServiceFramework.__init__(self,args) self.hWaitStop = win32event.CreateEvent(None,0,0,None) socket.setdefaulttimeout(60) def SvcStop(self): self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) win32event.SetEvent(self.hWaitStop) def SvcDoRun(self): servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE, servicemanager.PYS_SERVICE_STARTED, (self._svc_name_, self.main() def main(self): f = open( rc = None while rc != win32event.WAIT_OBJECT_0: f.write( f.flush() rc = win32event.WaitForSingleObject(self.hWaitStop, 24 * 60 * 60 * 1000) f.write( f.close() if __name__ == win32serviceutil.HandleCommandLine(AppServerSvc)
from xmlrpc.server import SimpleXMLRPCServer from pysc import event_stop class TestServer: def echo(self, msg): return msg if __name__ == server = SimpleXMLRPCServer(( @event_stop def stop(): server.server_close() server.register_instance(TestServer()) server.serve_forever()
import os import sys from xmlrpc.client import ServerProxy import pysc if __name__ == service_name = script_path = os.path.join( os.path.dirname(__file__), ) pysc.create( service_name=service_name, cmd=[sys.executable, script_path] ) pysc.start(service_name) client = ServerProxy( print(client.echo(
import pysc service_name = pysc.stop(service_name) pysc.delete(service_name)
class Test(object): def method_one(self): print "Called method_one" def method_two(): print "Called method_two" a_test = Test() a_test.method_one() a_test.method_two()
>>> a_test = Test() >>> a_test.method_two() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: method_two() takes no arguments (1 given)
class Test(object): def method_one(self): print "Called method_one" @staticmethod def method_two(): print "Called method two"
>>> a_test = Test() >>> a_test.method_one() Called method_one >>> a_test.method_two() Called method_two >>> Test.method_two() Called method_two
>>> C.foo <unbound method C.foo> >>> C.__dict__[ <function foo at 0x17d05b0>
>>> c = C() >>> C.__dict__[ <bound method C.foo of <__main__.C object at 0x17bd4d0>>
>>> class Class(object): ... def __init__(self): ... self.i = 0 ... def instance_method(self): ... self.i += 1 ... print self.i ... c = 0 ... @classmethod ... def class_method(cls): ... cls.c += 1 ... print cls.c ... @staticmethod ... def static_method(s): ... s += 1 ... print s ... >>> a = Class() >>> a.class_method() 1 >>> Class.class_method() 2 >>> a.instance_method() 1 >>> Class.instance_method() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unbound method instance_method() must be called with Class instance as first argument (got nothing instead) >>> Class.instance_method(a) 2 >>> b = 0 >>> a.static_method(b) 1 >>> a.static_method(a.c) >>> 3 >>> Class.c 2 >>> a.c 2 >>> a.c = 5 >>> Class.c 2 >>> Class.class_method() 3 >>> a.c 5
>>> a_test.method_two() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: method_two() takes no arguments (1 given)
class C: a = [] def foo(self): pass C C.a C.foo c = C() c
def __get__(self, instance, owner) def __set__(self, instance, value) def __delete__(self, instance)
>>> C.__dict__[ <function C.foo at 0x10a72f510> >>> C.__dict__[ Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError:
>>> a.method_two() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: method_two() takes no arguments (1 given)
Class Test(Object): @staticmethod def method_two(): print "Called method_two" Test.method_two()
>>> from bitstring import BitArray >>> b = BitArray(bin= >>> b.uint 255
add = lambda x,y : x + y reduce(add, [int(x) * 2 ** y for x, y in zip(list(binstr), range(len(binstr) - 1, -1, -1))])
class Binary(): def __init__(self, binNumber): self._binNumber = binNumber self._binNumber = self._binNumber[::-1] self._binNumber = list(self._binNumber) self._x = [1] self._count = 1 self._change = 2 self._amount = 0 print(self._ToNumber(self._binNumber)) def _ToNumber(self, number): self._number = number for i in range (1, len (self._number)): self._total = self._count * self._change self._count = self._total self._x.append(self._count) self._deep = zip(self._number, self._x) for self._k, self._v in self._deep: if self._k == self._amount += self._v return self._amount mo = Binary(
def int2bin(n): return int2bin(n >> 1) + [n & 1] if n > 1 else [1]
import time from daemon import runner class App(): def __init__(self): self.stdin_path = self.stdout_path = self.stderr_path = self.pidfile_path = self.pidfile_timeout = 5 def run(self): while True: print("Howdy! Gig time.sleep(10) app = App() daemon_runner = runner.DaemonRunner(app) daemon_runner.do_action()
[Unit] Description=Python daemon After=syslog.target After=network.target [Service] Type=simple User=<run as user> Group=<run as group group> ExecStart=/usr/bin/python <python script home>/script.py TimeoutSec=300 [Install] WantedBy=multi-user.target
import sys import os def daemonize(): try: pid = os.fork() if pid > 0: sys.exit(0) except OSError as err: sys.stderr.write( sys.exit(1) os.chdir( os.setsid() os.umask(0) try: pid = os.fork() if pid > 0: sys.exit(0) except OSError as err: sys.stderr.write( sys.exit(1) sys.stdout.flush() sys.stderr.flush() si = open(os.devnull, so = open(os.devnull, se = open(os.devnull, os.dup2(si.fileno(), sys.stdin.fileno()) os.dup2(so.fileno(), sys.stdout.fileno()) os.dup2(se.fileno(), sys.stderr.fileno())
import sys import daemon sys.path.append( from samplemodule import moduleclass with daemon.DaemonContext(): moduleclass.do_running()
>ls samplemodule __init__.py __init__.pyc moduleclass.py
class moduleclass(): ... def do_running(): m = moduleclass()
screen -S myapp python myapp.py CTRL+A, D to detach
wanted_keys = [ dict((k, bigdict[k]) for k in wanted_keys if k in bigdict)
interesting_keys = ( subdict = {x: bigdict[x] for x in interesting_keys if x in bigdict}
Python 2.7.11 |Anaconda 2.4.1 (64-bit)| (default, Jan 29 2016, 14:26:21) [MSC v.1500 64 bit (AMD64)] on win32 In[2]: import numpy.random as nprnd keys = nprnd.randint(1000, size=10000) bigdict = dict([(_, nprnd.rand()) for _ in range(1000)]) %timeit {key:bigdict[key] for key in keys} %timeit dict((key, bigdict[key]) for key in keys) %timeit dict(map(lambda k: (k, bigdict[k]), keys)) %timeit dict(filter(lambda i:i[0] in keys, bigdict.items())) %timeit {key:value for key, value in bigdict.items() if key in keys} 100 loops, best of 3: 3.09 ms per loop 100 loops, best of 3: 3.72 ms per loop 100 loops, best of 3: 6.63 ms per loop 10 loops, best of 3: 20.3 ms per loop 100 loops, best of 3: 20.6 ms per loop
class my_dict(dict): def subdict(self, keywords, fragile=False): d = {} for k in keywords: try: d[k] = self[k] except KeyError: if fragile: raise return d
# keywords = # d = my_dict([(k,i) for i,k in enumerate(keywords)]) print( # oddkeywords = keywords[::2] subd = d.subdict(oddkeywords) print( # somebadkeywords = keywords[1::2] + try: subd2 = d.subdict(somebadkeywords) print("We shouldn except KeyError: print("subd2 construction fails:") print("\toriginal dictionary doesn # try: subd3 = d.subdict(somebadkeywords, fragile=False) print( except KeyError: print("We shouldn
di = { req = [ dict([i for i in di.iteritems() if i[0] in di and i[0] in req])
void someFunction() { /* Something Something more*/ }
x = This is my super-long mega-comment. Wow there are a lot of lines going on here!
import multiprocessing as mp import time def foo_pool(x): time.sleep(2) return x*x result_list = [] def log_result(result): result_list.append(result) def apply_async_with_callback(): pool = mp.Pool() for i in range(10): pool.apply_async(foo_pool, args = (i, ), callback = log_result) pool.close() pool.join() print(result_list) if __name__ == apply_async_with_callback()
def isclose(a, b, rel_tol=1e-09, abs_tol=0.0): return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)
numpy.isclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)
from nose.tools import assert_almost_equals assert_almost_equals(x, y, places=7)
def isclose(a, b, rel_tol=1e-09, abs_tol=0.0): Python 2 implementation of Python 3.5 math.isclose() https: if rel_tol < 0 or abs_tol < 0: raise ValueError("tolerances must be non-negative") if a == b: return True if math.isinf(a) or math.isinf(b): return False diff = math.fabs(b - a) result = (((diff <= math.fabs(rel_tol * b)) or (diff <= math.fabs(rel_tol * a))) or (diff <= abs_tol)) return result
if f1 ==0 and f2 == 0: return True else: return abs(f1-f2) < tol*max(abs(f1),abs(f2))
def round_to(float_num, decimal_precision): return eval(" def is_close(float_a, float_b, decimal_precision): if round_to(float_a, decimal_precision) == round_to(float_b, decimal_precision): return True return False a = 10.0 / 3 b = 10.0001 / 3 print is_close(a, b, decimal_precision=4) print is_close(a, b, decimal_precision=3)
arr = np.array(some_sequence) reversed_arr = arr[::-1] do_something(arr) look_at(reversed_arr) do_something_else(arr) look_at(reversed_arr)
arr1d = np.array(some_sequence) reversed_arr = np.fliplr([arr1d])[0]
import numpy import perfplot perfplot.show( setup=lambda n: numpy.random.randint(0, 1000, n), kernels=[ lambda a: a[::-1], lambda a: numpy.ascontiguousarray(a[::-1]), lambda a: numpy.fliplr([a])[0] ], labels=[ n_range=[2**k for k in range(25)], xlabel= logx=True, logy=True, )
import time import numpy as np start = time.clock() x = np.array(range(3)) x = np.atleast_2d(x) x = np.fliplr(x) x = x[0] end = time.clock() print end-start
>>> import numpy as np >>> x = np.arange(4) >>> x[::-1] Out[1]: array([3, 2, 1, 0])
>>> x = np.arange(10).reshape(2, 5) >>> x Out[2]: array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) >>> x[::-1] Out[3]: array([[5, 6, 7, 8, 9], [0, 1, 2, 3, 4]])
>>> np.flip(x) Out[4]: array([[9, 8, 7, 6, 5], [4, 3, 2, 1, 0]])
>>> for el in np.flip(x).flat: >>> print(el, end = 9 8 7 6 5 4 3 2 1 0
from datetime import datetime class TermPayment(models.Model): date = models.DateTimeField(default=datetime.now(), blank=True)
date = models.DateTimeField(auto_now_add=True, blank=True)
date = models.DateTimeField(default=datetime.now, blank=True)
from django.utils.timezone import now created_date = models.DateTimeField(default=now, editable=False)
date = models.DateTimeField(default=datetime.now,blank=True)
date = models.DateTimeField(default=datetime.now, editable=False,)
import itertools top5 = itertools.islice(my_list, 5)
[x for _, x in zip(xrange(n), generator)] [next(generator) for _ in xrange(n)] (x for _, x in zip(xrange(n), generator)) def top_n(n, generator): for _ in xrange(n): yield next(generator)
>>> generator = (i for i in xrange(10)) >>> list(next(generator) for _ in range(4)) [0, 1, 2, 3] >>> list(next(generator) for _ in range(4)) [4, 5, 6, 7] >>> list(next(generator) for _ in range(4)) [8, 9]
l = list(sequence) l.sort(reverse=True) top5 = l[:5]
first_N_element=[generator.next() for i in range(N)]
list_a = [1, 2, 3, 4] list_b = [5, 6, 7, 8] list_c = [(1,5), (2,6), (3,7), (4,8)]
>>> list_a = [1, 2, 3, 4] >>> list_b = [5, 6, 7, 8] >>> zip(list_a, list_b) [(1, 5), (2, 6), (3, 7), (4, 8)]
a = [2,3,4] b = [5,6,7] c = map(lambda x,y:(x,y),a,b)
>>> list_1 = [ >>> list_2 = [ >>> deck = [] >>> for i in range(max((len(list_1),len(list_2)))): while True: try: card = (list_1[i],list_2[i]) except IndexError: if len(list_1)>len(list_2): list_2.append( card = (list_1[i],list_2[i]) elif len(list_1)<len(list_2): list_1.append( card = (list_1[i], list_2[i]) continue deck.append(card) break >>> >>> >>> print deck >>> [(
list_c = [(p1, p2) for idx1, p1 in enumerate(list_a) for idx2, p2 in enumerate(list_b) if idx1==idx2]
list_d = [(p1, p2) for p1 in list_a for p2 in list_b]
list_a = [1, 2, 3, 4] list_b = [5, 6, 7, 8] list_c=[(list_a[i],list_b[i]) for i in range(0,len(list_a))]
def whatisthis(s): if isinstance(s, str): print "ordinary string" elif isinstance(s, unicode): print "unicode string" else: print "not a string"
if isinstance(s, str): print elif isinstance(s, unicode): print
if str(type(s)) == "<class s = s.decode( elif str(type(s)) == "<type s = str(s)
if sys.version_info >= (3,0,0): if isinstance(s, bytes): s = s.decode( else: if isinstance(s, unicode): s = str(s)
if PY3: string_types = str, else: string_types = basestring,
"Hello there!".encode("ascii") "Hello there... ☃!".encode("ascii")
"Hello there!".encode("utf8") "\udcc3".encode("utf8")
def return_utf(s): if isinstance(s, str): return s.encode( if isinstance(s, (int, float, complex)): return str(s).encode( try: return s.encode( except TypeError: try: return str(s).encode( except AttributeError: return s except AttributeError: return s return s
http: @app.route( def login(): username = request.form[ print(username) password = request.form[ print(password)
from flask import request @app.route(...) def login(): username = request.args.get( password = request.args.get(
from flask import request @app.route( def my_route(): page = request.args.get( filter = request.args.get(
/my-route?page=34 -> page: 34 filter: /my-route -> page: 1 filter: /my-route?page=10&filter=test -> page: 10 filter: /my-route?page=10&filter=10 -> page: 10 filter: /my-route?page=*&filter=* -> page: 1 filter:
from flask import request http: from flask import request @app.route( def login(username): print(username)
http: from flask import request @app.route( def login(): username = request.args.get( print(username) password= request.args.get( print(password)
<form action="http: Username : <input type="text" name="username"><br> Password : <input type="password" name="password"><br> <input type="submit" value="submit"> </form>
from flask import request @app.route( def login(): username = request.form.get( print(username) password= request.form.get( print(password)
>>>from os import cpu_count >>>exposed_methods = { >>>eval( 8 >>>eval( TypeError:
running_params = {"Greeting":"Hello "} fout = open("params.dat", fout.write(repr(running_params)) fout.close()
fin = open("params.dat", diction=eval(fin.read()) diction["Greeting"]+="world" fin.close() print diction
>>> input( Enter a number: 3 >>> >>> input( Enter a number: 1+1
>>> eval(input( Enter a number: 1+1 2 >>> >>> eval(input( Enter a number: 3.14 3.14
CommandError: You must set settings.ALLOWED_HOSTS if DEBUG is False.
def comment_edit(request, object_id, template_name= comment = get_object_or_404(Comment, pk=object_id, user=request.user) return render(request, template_name, { })
return render_to_response(template_name, my_data_dictionary, context_instance=RequestContext(request))
return direct_to_template(request, template_name, my_data_dictionary)
render(request, template[, dictionary][, context_instance][, content_type][, status][, current_app])
render_to_response(template[, dictionary][, context_instance][, mimetype])¶
def render(request, *args, **kwargs): kwargs[ return render_to_response(*args, **kwargs)
context_instance = RequestContext(request) return render_to_response(template_name, user_context, context_instance)
minitwit |-- minitwit.py |-- static |-- css, js, images, etc... `-- templates |-- html files and base layout
angular-phonecat |-- app `-- css `-- img `-- js `-- lib `-- partials `-- index.html |-- scripts `-- node.js server and test server files
app |-- app.py |-- static |-- css |-- img |-- js |-- templates
app |-- app.py |-- static |-- css |-- img |-- js |-- app.js, controllers.js, etc. |-- lib |-- angular |-- angular.js, etc. |-- partials |-- templates |-- index.html
<script src="static/lib/angular/angular.js"></script>
app |-- server |-- controllers |-- app.py |-- models |-- model.py |-- templates |-- index.html |-- static |-- img |-- client |-- app.js |-- main_style.css |-- foo_feature |-- controller.js |-- directive.js |-- service.js |-- style.css |-- html_file.tpl.html |-- bar_feature |-- controller.js |-- directive.js |-- service.js |-- style.css |-- html_file.tpl.html |-- lib |-- jquery.js |-- angular.js |-- ...
df.index = pd.RangeIndex(len(df.index)) df.index = range(len(df.index))
df = pd.DataFrame({ df = pd.concat([df]*10000) print (df.head()) In [298]: %timeit df1 = df.reset_index(drop=True) The slowest run took 7.26 times longer than the fastest. This could mean that an intermediate result is being cached. 10000 loops, best of 3: 105 µs per loop In [299]: %timeit df.index = pd.RangeIndex(len(df.index)) The slowest run took 15.05 times longer than the fastest. This could mean that an intermediate result is being cached. 100000 loops, best of 3: 7.84 µs per loop In [300]: %timeit df.index = range(len(df.index)) The slowest run took 7.10 times longer than the fastest. This could mean that an intermediate result is being cached. 100000 loops, best of 3: 14.2 µs per loop
test = pieces = [p for p in re.split("( |\\\".*?\\\"|
[\\\" .* = anything ( |X) = space or X .strip() = remove space and empty-string separators
import csv lines = [ for row in csv.reader(lines, delimiter=" "): print row
import re def line_split(line): return re.findall(r
import re s = def splitter(s): def replacer(m): return m.group(0).replace(" ", "\x00") parts = re.sub( parts = [p.replace("\x00", " ") for p in parts] return parts def splitter2(s): return [p.replace("\x00", " ") for p in re.sub( print splitter2(s)
def getArgs(s): args = [] cur = inQuotes = 0 for char in s.strip(): if char == args.append(cur) cur = elif char == inQuotes = 1 cur += char elif char == inQuotes = 0 cur += char else: cur += char args.append(cur) return args
from shlex import split as _split split = lambda a: [b.decode(
import re import shlex import csv line = %timeit [p for p in re.split("( |\\\".*?\\\"| 100000 loops, best of 3: 5.17 µs per loop %timeit re.findall(r 100000 loops, best of 3: 2.88 µs per loop %timeit list(csv.reader([line], delimiter=" ")) The slowest run took 9.62 times longer than the fastest. This could mean that an intermediate result is being cached. 100000 loops, best of 3: 2.4 µs per loop %timeit shlex.split(line) 10000 loops, best of 3: 50.2 µs per loop
import re def quoted_split(s): def strip_quotes(s): if s and (s[0] == return s[1:-1] return s return [strip_quotes(p).replace( for p in re.findall(r
import csv import re import shlex from timeit import timeit def test_case(fn, s, expected): try: if fn(s) == expected: print else: print except Exception as e: print def test_case_no_output(fn, s, expected): try: fn(s) except: pass def test_split(fn, test_case_fn=test_case): test_case_fn(fn, test_case_fn(fn, "abc \\s def", [ test_case_fn(fn, test_case_fn(fn, " test_case_fn(fn, test_case_fn(fn, " test_case_fn(fn, " test_case_fn(fn, test_case_fn(fn, test_case_fn(fn, " test_case_fn(fn, "abc test_case_fn(fn, "abc test_case_fn(fn, "abc test_case_fn(fn, "abc test_case_fn(fn, test_case_fn(fn, test_case_fn(fn, test_case_fn(fn, test_case_fn(fn, "r def csv_split(s): return list(csv.reader([s], delimiter= def re_split(s): def strip_quotes(s): if s and (s[0] == return s[1:-1] return s return [strip_quotes(p).replace( if __name__ == print test_split(shlex.split) print print test_split(csv_split) print print test_split(re_split) print iterations = 100 setup = def benchmark(method, code): print benchmark( benchmark( benchmark(
>>> a = "She said \"He said, \\\"My name is Mark.\\\"\"" >>> a >>> for i in re.findall("(?:\".*?[^\\\\]\"|\S)+", a): print(i) ... She said "He said, \"My name is Mark.\""
>>> s = " ( >>> t = timeit.Timer(stmt=s) >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000) 171.39 usec/pass
>>> from string import split as stringsplit; >>> stringsplit(
>>> s = "stringsplit( >>> t = timeit.Timer(s, "from string import split as stringsplit") >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000) 154.88 usec/pass
>>> from re import split as resplit >>> regex = >>> medstring = >>> resplit(regex, medstring)
>>> s = "resplit(regex, medstring)" >>> t = timeit.Timer(s, "from re import split as resplit; regex= >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000) 540.21 usec/pass
def adamsplit(s): result = [] inquotes = False for substring in s.split( if not inquotes: result.extend(substring.split()) else: result.append(substring) inquotes = not inquotes return result
In [1]: df = pd.DataFrame([[1, 2], [1, 3], [4, 6]], columns=[
In [12]: df = pd.DataFrame([[1, 2, 3], [1, 2, 6]], columns=[ In [13]: df Out[13]: C A B 1 2 3 2 6
import numpy as np import pandas as pd np.random.seed(123)
a b c d e f g 0 -1.085631 NaN panda 0 0 2011-01-01 2011-08-12 1 0.997345 7 shark 0 1 2011-01-02 2011-11-10 2 0.282978 5 panda 1 0 2011-01-03 2011-10-30 3 -1.506295 7 python 1 1 2011-01-04 2011-09-07 4 -0.578600 NaN shark 2 0 2011-01-05 2011-02-27 5 1.651437 7 python 2 1 2011-01-06 2011-02-03
>>> stocks.head(5) date price ticker 0 2011-01-01 9.497412 aapl 1 2011-01-02 10.261908 aapl 2 2011-01-03 9.438538 aapl 3 2011-01-04 9.515958 aapl 4 2011-01-05 7.554070 aapl >>> stocks.groupby( date price ticker 0 2011-01-01 9.497412 aapl 1 2011-01-02 10.261908 aapl 25 2011-01-01 8.277772 goog 26 2011-01-02 7.714916 goog 50 2011-01-01 5.613023 yhoo 51 2011-01-02 6.397686 yhoo 75 2011-01-01 11.736584 msft 76 2011-01-02 11.944519 msft
>>> stocks.head(5).to_dict() { 1: Timestamp( 2: Timestamp( 3: Timestamp( 4: Timestamp( 1: 11.930300761831457, 2: 10.93741046217319, 3: 10.884574289565609, 4: 11.78005850418319}, >>> pd.concat([stocks.head(), stocks.tail()], ignore_index=True).to_dict() { 1: Timestamp( 2: Timestamp( 3: Timestamp( 4: Timestamp( 5: Timestamp( 6: Timestamp( 7: Timestamp( 8: Timestamp( 9: Timestamp( 1: 11.930300761831457, 2: 10.93741046217319, 3: 10.884574289565609, 4: 11.78005850418319, 5: 10.017209045035006, 6: 10.57090128181566, 7: 11.442792747870204, 8: 11.592953372130493, 9: 12.864146419530938}, 1: 2: 3: 4: 5: 6: 7: 8: 9:
stocks.info() <class Int64Index: 100 entries, 0 to 99 Data columns (total 3 columns): date 100 non-null datetime64[ns] price 100 non-null float64 ticker 100 non-null object dtypes: datetime64[ns](1), float64(1), object(1)
df = stocks.set_index([ >>> df price date ticker 2011-01-01 aapl 10.284260 aapl 11.930301 aapl 10.937410 aapl 10.884574 2011-01-02 aapl 11.780059 ... d = df.reset_index().to_dict() df_new = pd.DataFrame(d).set_index([ >>> df_new.head() price date ticker 2011-01-01 aapl 10.284260 aapl 11.930301 aapl 10.937410 aapl 10.884574 2011-01-02 aapl 11.780059
import pandas as pd def dput (x): if isinstance(x,pd.Series): return "pd.Series(%s,dtype= if isinstance(x,pd.DataFrame): return "pd.DataFrame({" + ", ".join([ " "}, index=pd.%s)" % (x.index)) raise NotImplementedError("dput",type(x),x)
df = pd.DataFrame({ assert df.equals(eval(dput(df))) du = pd.get_dummies(df.a,"foo") assert du.equals(eval(dput(du))) di = df di.index = list( assert di.equals(eval(dput(di)))
with open("a.txt") as f: print f.readlines() except: print
with open("a.txt") as f: print f.readlines() else: print
from __future__ import with_statement try: with open( "a.txt" ) as f : print f.readlines() except EnvironmentError: print
try: f = open( except IOError: print( else: with f: print f.readlines()
@contextmanager def opened_w_error(filename, mode="r"): try: f = open(filename, mode) except IOError, err: yield None, err else: try: yield f, None finally: f.close()
with opened_w_error("/etc/passwd", "a") as (f, err): if err: print "IOError:", err else: f.write("guido::0:0::/:/bin/sh\n")
with open("a.txt") as f: print(f.readlines()) except: print(
try: with open("a.txt") as f: print(f.readlines()) except Exception as error: print(
>>> try: ... with open("a.txt") as f: ... print(f.readlines()) ... except IOError as error: ... print( ... oops
import os if os.path.exists(file_path): with open("a.txt") as f: print f.readlines() elif not os.path.exists(file_path): print("file not found")
try: with open("a.txt") as f: except Exception as e: print "oops, handle exception: ", e
import subprocess subprocess.Popen(["rm","-r","some.file"])
import subprocess ls_output=subprocess.Popen(["ls", "-a"], stdout=subprocess.PIPE)
DETACHED_PROCESS = 0x00000008 pid = subprocess.Popen([sys.executable, "longtask.py"], creationflags=DETACHED_PROCESS).pid
import os, time, sys, subprocess if len(sys.argv) == 2: time.sleep(5) print if sys.platform == subprocess.Popen([ else: print subprocess.Popen([ print
try: pid = os.fork() except OSError, e: sys.exit(1) if pid == 0: os.execv(args[0], args)
import os import subprocess import sys import threading def output_reader(proc, file): while True: byte = proc.stdout.read(1) if byte: sys.stdout.buffer.write(byte) sys.stdout.flush() file.buffer.write(byte) else: break with subprocess.Popen([ subprocess.Popen([ open( open( t1 = threading.Thread(target=output_reader, args=(proc1, file1)) t2 = threading.Thread(target=output_reader, args=(proc2, file2)) t1.start() t2.start() t1.join() t2.join()
import sys import time for i in range(4): print(i + int(sys.argv[1])) sys.stdout.flush() time.sleep(0.5)
import pytz from datetime import datetime datetime.utcnow().replace(tzinfo=pytz.utc)
import datetime import pytz my_date = datetime.datetime.now(pytz.timezone(
>>> import datetime >>> datetime.datetime.now(datetime.timezone.utc) datetime.datetime(2016, 8, 26, 14, 34, 34, 74823, tzinfo=datetime.timezone.utc)
from datetime import datetime now = datetime.now(utc) today = datetime(now.year, now.month, now.day, tzinfo=utc)
from datetime import tzinfo, timedelta ZERO = timedelta(0) class UTC(tzinfo): def utcoffset(self, dt): return ZERO def tzname(self, dt): return "UTC" def dst(self, dt): return ZERO utc = UTC()
import datetime import pytz pytz.utc.localize( datetime.datetime.utcnow() )
import time from datetime import datetime FORMAT= date=datetime.strptime(time.strftime(FORMAT, time.localtime()),FORMAT)
date datetime.datetime(2017, 8, 1, 12, 15, 44, tzinfo=datetime.timezone(datetime.timedelta(0, 7200))) date.tzname()
date=datetime.strptime(time.strftime(FORMAT, time.gmtime()),FORMAT) date datetime.datetime(2017, 8, 1, 10, 23, 51, tzinfo=datetime.timezone.utc) date.tzname()
from dateutil.tz import tzlocal now = datetime.datetime.now(tzlocal())
from tzlocal import get_localzone from datetime import datetime datetime.now(get_localzone())
import time from datetime import datetime aware_local_now = datetime.now( tz=datetime.strptime(time.strftime("%z", time.localtime()), "%z").tzinfo) print(aware_local_now) 2018-03-01 13:41:26.753644-08:00
from datetime import datetime import pytz import time str(datetime.strftime(datetime.now(pytz.utc),"%Y-%m-%d %H:%M:%S%t"))
from django.utils import timezone today = timezone.now()
>>> import pendulum >>> dt = pendulum.now().to_iso8601_string() >>> print (dt) 2018-03-27T13:59:49+03:00 >>>
>>> a = numpy.arange(12) >>> a array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10 │ 11 │ └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
>>> a.flags C_CONTIGUOUS : True F_CONTIGUOUS : True OWNDATA : True WRITEABLE : True ALIGNED : True UPDATEIFCOPY : False >>> a.dtype dtype( >>> a.itemsize 8 >>> a.strides (8,) >>> a.shape (12,)
i= 0 1 2 3 4 5 6 7 8 9 10 11 ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10 │ 11 │ └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
i= 0 0 0 0 1 1 1 1 2 2 2 2 j= 0 1 2 3 0 1 2 3 0 1 2 3 ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10 │ 11 │ └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
i= 0 1 2 0 1 2 0 1 2 0 1 2 j= 0 0 0 1 1 1 2 2 2 3 3 3 ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10 │ 11 │ └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
i= 0 1 2 3 4 5 6 7 8 9 10 11 j= 0 0 0 0 0 0 0 0 0 0 0 0 ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10 │ 11 │ └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
i= 0 0 0 0 0 0 0 0 0 0 0 0 j= 0 0 0 0 0 0 1 1 1 1 1 1 k= 0 0 0 0 0 0 0 0 0 0 0 0 l= 0 1 2 3 4 5 0 1 2 3 4 5 m= 0 0 0 0 0 0 0 0 0 0 0 0 ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10 │ 11 │ └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
M=np.arange(9).reshape(3,3) M[:,0].shape M[0,:].shape M[:,[0]].shape M[:,[0,1]].shape In [20]: np.dot(M[:,0].reshape(3,1),np.ones((1,3))) Out[20]: array([[ 0., 0., 0.], [ 3., 3., 3.], [ 6., 6., 6.]]) In [21]: np.dot(M[:,[0]],np.ones((1,3))) Out[21]: array([[ 0., 0., 0.], [ 3., 3., 3.], [ 6., 6., 6.]])
np.dot(M[:,0][:,np.newaxis],np.ones((1,3))) np.dot(np.atleast_2d(M[:,0]).T,np.ones((1,3))) np.einsum( M1=M[:,0]; R=np.ones((3)); np.dot(M1[:,None], R[None,:])
import subprocess, os my_env = os.environ my_env["PATH"] = "/usr/sbin:/sbin:" + my_env["PATH"] subprocess.Popen(my_command, env=my_env)
import subprocess, os my_env = os.environ.copy() my_env["PATH"] = "/usr/sbin:/sbin:" + my_env["PATH"] subprocess.Popen(my_command, env=my_env)
subprocess.Popen(my_command, env=dict(os.environ, PATH="path"))
subprocess.Popen(my_command, env=dict(os.environ, **{"Not valid python name":"value"}))
import os import subprocess my_env = {**os.environ, subprocess.Popen(my_command, env=my_env)
def hello(request): return HttpResponse( def home(request): return render_to_response(
import json from django.http import HttpResponse from django.views.generic.edit import CreateView from myapp.models import Author class AjaxableResponseMixin(object): """ Mixin to add AJAX support to a form. Must be used with an object-based FormView (e.g. CreateView) """ def render_to_json_response(self, context, **response_kwargs): data = json.dumps(context) response_kwargs[ return HttpResponse(data, **response_kwargs) def form_invalid(self, form): response = super(AjaxableResponseMixin, self).form_invalid(form) if self.request.is_ajax(): return self.render_to_json_response(form.errors, status=400) else: return response def form_valid(self, form): response = super(AjaxableResponseMixin, self).form_valid(form) if self.request.is_ajax(): data = { } return self.render_to_json_response(data) else: return response class AuthorCreate(AjaxableResponseMixin, CreateView): model = Author fields = [
<script src="bjax.min.js" type="text/javascript"></script> <link href="bjax.min.css" rel="stylesheet" type="text/css" />
from django.http import JsonResponse from django import forms from django.db import models class AjaxableResponseMixin(object): success_return_code = 1 error_return_code = 0 """ Mixin to add AJAX support to a form. Must be used with an object-based FormView (e.g. CreateView) """ def form_invalid(self, form): response = super(AjaxableResponseMixin, self).form_invalid(form) if self.request.is_ajax(): form.errors.update({ return JsonResponse(form.errors, status=400) else: return response def form_valid(self, form): if self.request.is_ajax(): self.object = form.save() data = { } return JsonResponse(data) else: response = super(AjaxableResponseMixin, self).form_valid(form) return response class Product(models.Model): name = models.CharField( class ProductAddForm(forms.ModelForm): Product add form class Meta: model = Product exclude = [ class PriceUnitAddView(AjaxableResponseMixin, CreateView): Product add view model = Product form_class = ProductAddForm
-+-----------------+ 0| <hash|key|value>| -+-----------------+ 1| ... | -+-----------------+ .| ... | -+-----------------+ i| ... | -+-----------------+ .| ... | -+-----------------+ n| ... | -+-----------------+
hash key value null null null ...010001 ffeb678c 633241c4 null null null ... ... ...
hash key value ...010001 ffeb678c 633241c4 ... ... ...
hash key dict_0 dict_1 dict_2... ...010001 ffeb678c 633241c4 fffad420 ... ... ... ... ... ...
try: [] + 3 except Exception as x: print "woo hoo" >>> woo hoo
try: a = 1/ except (ZeroDivisionError, TypeError): e = sys.exc_info()[1] print(e.args[0])
Python 2.5.2 (r252:60911, Sep 27 2008, 07:03:14) [GCC 4.3.1] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> import sys >>> print "hello",; print "there" hello there >>> print "hello",; sys.stdout.softspace=False; print "there" hellothere
import sys print "hello", sys.stdout.softspace=0 print "world", print "!"
import sys def printf(fmt, *varargs): sys.stdout.write(fmt % varargs)
>>> printf("Hello, world!\n") Hello, world! >>> printf("%d %d %d\n", 0, 1, 42) 0 1 42 >>> printf( abc >>>
import sys Print = sys.stdout.write Print("Hello") Print("World")
>>> print h m h >>> from __future__ import print_function >>> print( h>>> print( hmh>>> >>> print( hmh >>>
import sys a=raw_input() for i in range(0,len(a)): sys.stdout.write(a[i])
